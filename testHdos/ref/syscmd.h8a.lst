0000                    	TITLE	'SYSCMD/plus - SYSTEM COMMAND PROCESSOR'
0000                    	STL	'INTRODUCTION'

0000                    	LON	LCI

                        ***	SYSCMD/plus - System Command Processor.
                        *
                        *	J.G. Letwin,	77/12
                        *
                        *	FOR HEATH COMPANY
                        *
                        *	G.A. Chandler,	78/09	Maintenance Release
                        *			79/05	HDOS Version:	1.5
                        *
                        *	\wgp\	80/11	CUSTOM VERSION 1.6
                        *	\wgp\	81/06	Enhanced and Adapted for HDOS 2.0
                        *	\dtc\		Original programs for TIME and DEV.
                        *	\wgp\	81/10	Inclusion of PRn command.
                        *	\wgp\	82/01	2, 4, or 6MHz status display
                        *	\wgp\	82/01	Added additional processing for H19 terminal
                        *	\wgp\	82/04	Updated time routines for FPM/80, v1.5, & Super-89.
                        *	\wgp\	82/10	Updated PRINT command to copy as seperate files.
                        *	\wgp\	82/10	Added CLR command.
                        *
                        *	W.G. Parrott,	85-86	Major Revision for HDOS 3.0
                        *	R.L. Musgrave,	85-86	Major Revision for HDOS 3.0
                        *
                        *		86/08	Released into Public Domain
                        *			 by Heath Company,
                        *			 August 16, 1986.

      = 0000            CUSTOM	EQU	0			; Distribution Revision Number

      = 0000            TRUE	EQU	0
      = 0001            FALSE	EQU	1

      = 0001            Z80	EQU	FALSE			; Assemble for Z80 CPU
      = 0001            USER	EQU	FALSE			; USER Areas NOT implemented
      = 0000            $BATCH	EQU	TRUE			; Allow BATCH processing in $RTL
      = 0000            $MULTI	EQU	TRUE			; Allow multiple commands in $RTL
      = 0000            H17TBLS EQU	TRUE			; Don't replace ROM code

      = 0021            MI.LXIH EQU	041Q

0000                    	STL	'SYSTEM DEFINITIONS & EQUIVALANCES'
0000                    	EJECT
0000                    	XTEXT	HOSBASE
0000                    	SPACE	4,10
                        **	HDOS BASE PAGE DEFINITION
                        *

0000                    	ORG	0

      = 0000            HOSBASE EQU	*

                        	ERRNZ	*-000000A
0000   (0003)           B.INT0	DS	3

0003   (0002)           S.LABEL DS	2			; address of label buffer

0005   (0001)           S.FMASK DS	1			; feature mask

      = 0003            F.CLK	EQU	00000011B		; system clock speed
      = 0000            F.2MHZ	EQU	00000000B		;  2 MHz
      = 0001            F.4MHZ	EQU	00000001B		;  4 MHz
      = 0002            F.6MHZ	EQU	00000010B		;  6 MHz

      = 000C            F.MACH	EQU	00001100B		; System type
      = 0000            F.H8	EQU	00000000B		;  H8
      = 0004            F.H89	EQU	00000100B		;  H89
      = 0008            F.Z100	EQU	00001000B		;  Z-100
      = 000C            F.OMACH EQU	00001100B		;  PC, ETC.

      = 0030            F.TERM	EQU	00110000B		; Terminal type
      = 0000            F.TTY	EQU	00000000B		;  Dumb TTY
      = 0010            F.H19	EQU	00010000B		;  H19

      = 00C0            F.CPU	EQU	11000000B		; CPU type
      = 0000            F.8080	EQU	00000000B		;  8080
      = 0040            F.8085	EQU	01000000B		;  8085
      = 0080            F.Z80	EQU	10000000B		;  Z-80
      = 00C0            F.OCPU	EQU	11000000B		;  HD64180, V20, ETC.

0006   (0002)           S.LWA	DS	2			; lwa of HDOS

                        	ERRNZ	*-000010A
0008   (0003)           B.INT1	DS	3			; clock interrupt

000B   (0005)           S.REV	DS	5			; rev, date, time of HDOS

                        	ERRNZ	*-000020A
0010   (0003)           B.INT2	DS	3			; available

0013   (0005)           	DS	5

                        	ERRNZ	*-000030A
0018   (0003)           B.INT3	DS	3			; available

001B   (0005)           	DS	5

                        	ERRNZ	*-000040A
0020   (0003)           B.INT4	DS	3			; available

0023   (0005)           	DS	5

                        	ERRNZ	*-000050A
0028   (0003)           B.INT5	DS	3			; available

                        	ERRNZ	*-000053A		; same as .DLY
002B   (0003)           S.DLY	DS	3

002E   (0002)           	DS	2

                        	ERRNZ	*-000060A
0030   (0003)           B.INT6	DS	3			; available

0033   (0005)           	DS	5

                        	ERRNZ	*-000070A
0038   (0003)           B.INT7	DS	3			; SCALL interrupt

003B   (0003)           B.SCALL DS	3			; JMP directly to SCALL processor

003E   (0002)           CSLIBUF DS	2			; FWA of console type-ahead buffer

0040   (0011)           BATNAME DS	17			; complete batch file name
0051   (0001)           BATSEC	DS	1			; current sector index in batch file
0052   (0002)           BATGNS	DS	2			; batch file group numbers

0054   (0002)           BATBUF	DS	2			; address of batch buffer
0056   (0002)           BATPTR	DS	2			; address of next char. in BATBUF

0058   (0002)           SUBBUF	DS	2			; address of substitution buffer

005A   (0002)           S.PATH	DS	2			; address of path buffer
005C   (0002)           S.PRMT	DS	2			; address of prompt buffer
005E   (0002)           S.EDLIN DS	2			; adderss of line buffer

0060   (0001)           S.COUNT DS	1			; counter
0061   (0001)           S.SHIFT DS	1			; shift count
0062   (0001)           S.BITS	DS	1			; bit flags

0063   (0003)           	DS	3

                        	ERRNZ	*-66H
0066   (0003)           B.NMI	DS	3			; NMI handler vector
0069   (0001)           B.NMIFL DS	1			; NMI flag (0=no NMI's occured)

006A   (0006)           S.DFBLK DS	6			; system wide default block

0070   (000F)           S.CVEC	DS	5*3			; console SCALL vectors

007F   (0001)           S.FLAG	DS	1			; system flags

      = 0001            S.SYSCM equ	00000001b		; SYSCMD.SYS in memory
      = 0002            S.VFLG	equ	00000010b		; Verify is on
      = 0004            S.ECHO	equ	00000100b		; Echo is off
      = 0008            S.BATCH equ	00001000b		; Batch is active
      = 0010            S.EXITC equ	00010000b		; SYSCMD prints exit code
      = 0020            S.BREAK equ	00100000b		; used by PIP
      = 0040            S.TABUF equ	01000000b		; type-ahead is stuffed
      = 0080            S.INIT	equ	10000000b		; set 1st time SYSCMD.SYS runs

                        	ERRNZ	*-80H			; MAKE SURE GOT EM' ALL
      = 0080            B.END	EQU	*
0080                    	XTEXT	ASCII
0080                    	SPACE	3,10
                        **	ASCII CHARACTER EQUIVALENCES.

      = 0000            NUL	EQU	000Q			; null
      = 0007            BELL	EQU	007Q			; bell
      = 0008            BKSP	EQU	010Q			; backspace
      = 0008            BS	EQU	BKSP
      = 0009            TAB	EQU	011Q			; horizontal tab
      = 000A            LF	EQU	012Q			; line feed
      = 000A            NL	EQU	012Q			; new line (HDOS)
      = 000C            FF	EQU	014Q			; form feed
      = 000D            CR	EQU	015Q			; carriage return
      = 001B            ESC	EQU	033Q			; escape
      = 007F            DEL	EQU	177Q			; delete

                        *	Specials

      = 0080            EOL	EQU	200Q			; end of line flag
      = 0080            NULL	EQU	200Q			; pad character
      = 0000            NUL2	EQU	0			; ditto
      = 007F            RUBOUT	EQU	DEL			; rubout/delete
      = 0016            C.SYN	EQU	026Q			; SYNC
      = 0002            C.STX	EQU	002Q			; STX
      = 0027            QUOTE	EQU	047Q			; quote character (")
      = 008A            ENL	EQU	NL+EOL			; NL + end-of-line flag

                        *	Control keys

      = 0001            CTLA	EQU	'A'-'@' 		; CTRL/A
      = 0002            CTLB	EQU	'B'-'@' 		; CTRL/B
      = 0003            CTLC	EQU	'C'-'@' 		; CTRL/C
      = 0004            CTLD	EQU	'D'-'@' 		; CTRL/D
      = 0005            CTLE	EQU	'E'-'@' 		; CTRL/E
      = 000F            CTLO	EQU	'O'-'@' 		; CTRL/O
      = 0010            CTLP	EQU	'P'-'@' 		; CTRL/P
      = 0011            CTLQ	EQU	'Q'-'@' 		; CTRL/Q
      = 0012            CTLR	EQU	'R'-'@' 		; CTRL/R
      = 0013            CTLS	EQU	'S'-'@' 		; CTRL/S
      = 0018            CTLX	EQU	'X'-'@' 		; CTRL/X
      = 001A            CTLZ	EQU	'Z'-'@' 		; CTRL/Z
0080                    	XTEXT	MTR
0080                    MTR	SPACE	4,10
                        **	MTR - PAM/8 EQUIVALENCES.
                        *
                        *	THIS DECK CONTAINS SYMBOLIC DEFINITIONS USED TO
                        *	MAKE USE OF THE PAM/8 CODE.
0080                    	SPACE	3,10
                        **	IO PORTS

      = 00F0            IP.PAD	EQU	360Q			; PAD INPUT PORT
      = 00F0            OP.CTL	EQU	360Q			; CONTROL OUTPUT PORT
      = 00F0            OP.DIG	EQU	360Q			; DIGIT SELECT OUTPUT PORT
      = 00F1            OP.SEG	EQU	361Q			; SEGMENT SELECT OUTPUT PORT
      = 00F2            IP.CON	EQU	362Q			; H-88/H-89/HA-8-8 Configuration
      = 00F2            OP2.CTL EQU	362Q			; H-88/H-89/HA-8-8 Control Port
0080                    	SPACE	3,10
                        **	MONITOR IDENTIFICATION FLAGS
                        *
                        *	THESE BYTES IDENTIFY THE ROM MONITOR.
                        *	THEY ARE THE VARIOUS VALUES OF LOCATION .IDENT

      = 0011            M.PAM8	EQU	021Q			; 'LXI' INSTRUCTION AT 0 IN PAM-8
      = 00C3            M.FOX	EQU	303Q			; 'JMP' INSTRUCTION AT 0 IN FOX ROM
0080                    	SPACE	4,10
                        **	Configuration Flags
                        *
                        *	These bits are read in IP.CON.
                        *

      = 0003            CN.174M EQU	00000011B		; Port 174Q Device-Type Mask
      = 000C            CN.170M EQU	00001100B		; Port 170Q Device-Type Mask
      = 0010            CN.PRI	EQU	00010000B		; Primary/Secondary:  1=>primary == 170Q
      = 0020            CN.MEM	EQU	00100000B		; Memory Test/Normal Switch:  0=>Test; 1=>Normal
      = 0040            CN.BAU	EQU	01000000B		; Baud Rate:  0=>9600; 1=>19,200
      = 0080            CN.ABO	EQU	10000000B		; Auto-Boot:  1=>Auto-Boot

      = 0000            CND.H17 EQU	00B			; H-17 Disk, Valid only in CN.174M
      = 0000            CND.NDI EQU	00B			; No Device Installed
      = 0001            CND.H47 EQU	01B			; H-47 Disk
0080                    	SPACE	4,10
                        **	ROUTINE ENTRY POINTS.
                        *

      = 002B            .DLY	EQU	000053A 		; DELAY

                        *	All following entry points are unavailable under HDOS 3.0

                        *.IDENT EQU	000000A 		; IDENTIFICATION LOCATION
                        *.LOAD	EQU	001267A 		; TAPE LOAD
                        *.DUMP	EQU	001374A 		; TAPE DUMP
                        *.ALARM	EQU	002136A 		; ALARM ROUTINE
                        *.HORN	EQU	002140A 		; HORN
                        *.CTC	EQU	002172A 		; CHECK TAPE CHECKSUM
                        *.TPERR	EQU	002205A 		; TAPE ERROR ROUTINE
                        *.PCHL	EQU	002264A 		; PCHL INSTRUCTION
                        *.SRS	EQU	002265A 		; SCAN RECORD START
                        *.RNP	EQU	002325A 		; READ NEXT PAIR
                        *.RNB	EQU	002331A 		; READ NEXT BYTE
                        *.CRC	EQU	002347A 		; CRC-16 CALCULATOR
                        *.WNP	EQU	003017A 		; WRITE NEXT PAIR
                        *.WNB	EQU	003024A 		; WRITE NEXT BYTE
                        *.DOD	EQU	003122A 		; DECODE FOR OCTAL DISPLAY
                        *.RCK	EQU	003260A 		; READ CONSOLE KEYSET
                        *.DODA	EQU	003356A 		; SEGMENT CODE TABLE
0080                    	XTEXT	MTRRAM
0080                    MTRRAM	SPACE	4,10
                        **	MTR - PAM/8 EQUIVALENCES.
                        *
                        *	THIS DECK CONTAINS SYMBOLIC DEFINITIONS USED TO
                        *	MAKE USE OF THE PAM-8 CONTROL BYTES.
0080                    	SPACE	3,10
                        **	FRONT PANEL CONTROL BITS.
                        *
                        *	CB.*  set in OP.CTL
                        *	CB2.* set in OP2.CTL
                        *

      = 0010            CB.SSI	EQU	00010000B		; SINGLE STEP INTERRUPT
      = 0020            CB.MTL	EQU	00100000B		; MONITOR LIGHT
      = 0040            CB.CLI	EQU	01000000B		; CLOCK INTERRUPT ENABLE
      = 0080            CB.SPK	EQU	10000000B		; SPEAKER ENABLE

      = 0001            CB2.SSI EQU	00000001B		; Single Step Interrupt
      = 0002            CB2.CLI EQU	00000010B		; Clock Interrupt Enable
      = 0020            CB2.ORG EQU	00100000B		; ORG 0 Select
      = 0040            CB2.SID EQU	01000000B		; Side 1 Select
0080                    	SPACE	3,10
                        **	Secondary Control Bits
                        *

                        **	MONITOR MODE FLAGS.

      = 0000            DM.MR	EQU	0			; MEMORY READ
      = 0001            DM.MW	EQU	1			; MEMORY WRITE
      = 0002            DM.RR	EQU	2			; REGISTER READ
      = 0003            DM.RW	EQU	3			; REGISTER WRITE
0080                    	SPACE	3,10
                        **	USER OPTION BITS.
                        *
                        *	THESE BITS ARE SET IN CELL .MFLAG.

      = 0080            UO.HLT	EQU	10000000B		; DISABLE HALT PROCESSING
      = 0040            UO.NFR	EQU	CB.CLI			; NO REFRESH OF FRONT PANEL
      = 0002            UO.DDU	EQU	00000010B		; DISABLE DISPLAY UPDATE
      = 0001            UO.CLK	EQU	00000001B		; ALLOW PRIVATE INTERRUPT PROCESSING
0080                    	SPACE	3,10
                        **	RAM CELLS USED BY H8MTR.
                        *

      = 2000            .START	EQU	040000A 		; START DUMP ADDRESS
      = 2002            .IOWRK	EQU	040002A 		; IN OR OUT INSTRUCTION
      = 2005            .REGI	EQU	040005A 		; DISPLAYED REGISTER INDEX
      = 2006            .DSPROT EQU	040006A 		; PERIOD FLAG BYTE
      = 2007            .DSPMOD EQU	040007A 		; DISPLAY MODE
      = 2008            .MFLAG	EQU	040010A 		; USER OPTION BYTE
      = 2009            .CTLFLG EQU	040011A 		; PANEL CONTROL BYTE
      = 200B            .ALEDS	EQU	040013A 		; ABUSS LEDS
      = 2011            .DLEDS	EQU	040021A 		; DBUSS LEDS
      = 2014            .ABUSS	EQU	040024A 		; ABUSS REGISTER
      = 2017            .CRCSUM EQU	040027A 		; CRCSUM WORD
      = 2019            .TPERRX EQU	040031A 		; TAPE ERROR EXIT VECTOR
      = 201B            .TICCNT EQU	040033A 		; CLOCK TICK COUNTER
      = 201D            .REGPTR EQU	040035A 		; REGISTER POINTER
      = 201F            .UIVEC	EQU	040037A 		; USER INTERRUPT VECTORS
      = 2034            .NMIRET EQU	040064A 		; H88/H89 NMI Return Address
      = 2036            .CTL2FL EQU	040066A 		; OP2.CTL Control Byte
0080                    	XTEXT	HOSDEF
0080                    	SPACE	3,10
                        **	HOSDEF - Define HOS Parameters.
                        *

      = 0030            VERS	equ	3*16+0			; VERSION 3.0			/3.0a/

      = 00FF            SYSCALL equ	377Q			; SYSCALL INSTRUCTION

0000                    	org	0

                        *	Resident Functions

0000   (0001)           .EXIT	ds	1			; EXIT (MUST BE FIRST)
0001   (0001)           .SCIN	ds	1			; SCIN
0002   (0001)           .SCOUT	ds	1			; SCOUT
0003   (0001)           .PRINT	ds	1			; PRINT
0004   (0001)           .READ	ds	1			; READ
0005   (0001)           .WRITE	ds	1			; WRITE
0006   (0001)           .CONSL	ds	1			; SET/CLEAR CONSOLE OPTIONS
0007   (0001)           .CLRCO	ds	1			; CLEAR CONSOLE BUFFER
0008   (0001)           .LOADO	ds	1			; LOAD AN OVERLAY (obsolete)	/3.0a/
0009   (0001)           .VERS	ds	1			; RETURN HDOS VERSION NUMBER
000A   (0001)           .GDA	ds	1			; Get Device Driver Address	/3.0a/
000B   (0001)           .CRC16	ds	1			; CRC a block of memory 	/3.0a/
000C   (0001)           .SYSRES ds	1			; PRECEDING FUNCTIONS ARE RESIDENT


                        *	*HDOSOVL0.SYS*  FUNCTIONS

0020                    	org	40Q

0020   (0001)           .LINK	ds	1			; LINK	(MUST BE FIRST)
0021   (0001)           .CTLC	ds	1			; CTL-C
0022   (0001)           .OPENR	ds	1			; OPENR
0023   (0001)           .OPENW	ds	1			; OPENW
0024   (0001)           .OPENU	ds	1			; OPENU
0025   (0001)           .OPENC	ds	1			; OPENC
0026   (0001)           .CLOSE	ds	1			; CLOSE
0027   (0001)           .POSIT	ds	1			; POSITION
0028   (0001)           .DELET	ds	1			; DELETE
      = 0028            .DELETE equ	.DELET
0029   (0001)           .RENAM	ds	1			; RENAME
      = 0029            .RENAME equ	.RENAM
002A   (0001)           .SETTP	ds	1			; SETTOP
      = 002A            .SETTOP equ	.SETTP
002B   (0001)           .DECODE ds	1			; NAME DECODE
002C   (0001)           .NAME	ds	1			; GET FILE NAME FROM CHANNEL
002D   (0001)           .CLEAR	ds	1			; CLEAR CHAN
002E   (0001)           .CLEARA ds	1			; CLEAR ALL CHANS
002F   (0001)           .ERROR	ds	1			; LOOKUP ERROR
0030   (0001)           .CHFLG	ds	1			; CHANGE FLAGS
0031   (0001)           .DISMT	ds	1			; FLAG SYSTEM DISK DISMOUNTED
0032   (0001)           .LOADD	ds	1			; LOAD DEVICE DRIVER

                        *	*HDOSOVL1.SYS*  FUNCTIONS

0080                    	org	200Q

0080   (0001)           .MOUNT	ds	1			; MOUNT  (MUST BE FIRST)
0081   (0001)           .DMOUN	ds	1			; DISMOUNT
      = 0081            .DMOUNT equ	.DMOUN
0082   (0001)           .MONMS	ds	1			; MOUNT/NO MESSAGE
0083   (0001)           .DMNMS	ds	1			; DISMOUNT/NO MESSAGE
0084   (0001)           .RESET	ds	1			; RESET = DISMOUNT/MOUNT OF UNIT
0085   (0001)           .RESNMS ds	1			; RESET/NO (OR USER) MESSAGE
0086   (0001)           .DAD	ds	1			; Dismount All Disks
0087                    	XTEXT	ECDEF
0087                    	SPACE	4,10
                        **	ERROR CODE DEFINITIONS.

0000                    	ORG	0

0000   (0001)           	DS	1		; NO ERROR #0
0001   (0001)           EC.EOF	DS	1		; END OF FILE
0002   (0001)           EC.EOM	DS	1		; END OF MEDIA
0003   (0001)           EC.ILC	DS	1		; ILLEGAL SCALL CODE
0004   (0001)           EC.CNA	DS	1		; CHANNEL NOT AVAILABLE
0005   (0001)           EC.DNS	DS	1		; DEVICE NOT SUITABLE
0006   (0001)           EC.IDN	DS	1		; ILLEGAL DEVICE NAME
0007   (0001)           EC.IFN	DS	1		; ILLEGAL FILE NAME
0008   (0001)           EC.NRD	DS	1		; NO ROOM FOR DEVICE DRIVER
0009   (0001)           EC.FNO	DS	1		; CHANNEL NOT OPEN
000A   (0001)           EC.ILR	DS	1		; ILLEGAL REQUEST
000B   (0001)           EC.FUC	DS	1		; FILE USAGE CONFLICT
000C   (0001)           EC.FNF	DS	1		; FILE NAME NOT FOUND
000D   (0001)           EC.UND	DS	1		; UNKNOWN DEVICE
000E   (0001)           EC.ICN	DS	1		; ILLEGAL CHANNEL NUMBER
000F   (0001)           EC.DIF	DS	1		; DIRECTORY FULL
0010   (0001)           EC.IFC	DS	1		; ILLEGAL FILE CONTENTS
0011   (0001)           EC.NEM	DS	1		; NOT ENOUGH MEMORY
0012   (0001)           EC.RF	DS	1		; READ FAILURE
0013   (0001)           EC.WF	DS	1		; WRITE FAILURE
0014   (0001)           EC.WPV	DS	1		; WRITE PROTECTION VIOLATION
0015   (0001)           EC.WP	DS	1		; DISK WRITE PROTECTED
0016   (0001)           EC.FAP	DS	1		; FILE ALREADY PRESENT
0017   (0001)           EC.DDA	DS	1		; DEVICE DRIVER ABORT
0018   (0001)           EC.FL	DS	1		; FILE LOCKED
0019   (0001)           EC.FAO	DS	1		; FILE ALREADY OPEN
001A   (0001)           EC.IS	DS	1		; ILLEGAL SWITCH
001B   (0001)           EC.UUN	DS	1		; UNKNOWN UNIT NUMBER
001C   (0001)           EC.FNR	DS	1		; FILE NAME REQUIRED
001D   (0001)           EC.DIW	DS	1		; DEVICE IS NOT WRITABLE (OR WRITE LOCKED)
001E   (0001)           EC.UNA	DS	1		; UNIT NOT AVAILABLE
001F   (0001)           EC.ILV	DS	1		; ILLEGAL VALUE
0020   (0001)           EC.ILO	DS	1		; ILLEGAL OPTION
0021   (0001)           EC.VPM	DS	1		; VOLUME PRESENTLY MOUNTED ON DEVICE
0022   (0001)           EC.NVM	DS	1		; NO VOLUME PRESENTLY MOUNTED
0023   (0001)           EC.FOD	DS	1		; FILE OPEN ON DEVICE
0024   (0001)           EC.NPM	DS	1		; NO PROVISIONS MADE FOR REMOUNTING MORE DISKS
0025   (0001)           EC.DNI	DS	1		; DISK NOT INITIALIZED
0026   (0001)           EC.DNR	DS	1		; DISK IS NOT READABLE
0027   (0001)           EC.DSC	DS	1		; DISK STRUCTURE IS CORRUPT
0028   (0001)           EC.NCV	DS	1		; NOT CORRECT VERSION OF HDOS
0029   (0001)           EC.NOS	DS	1		; NO OPERATING SYSTEM MOUNTED
002A   (0001)           EC.IOI	DS	1		; ILLEGAL OVERLAY INDEX
002B   (0001)           EC.OTL	DS	1		; OVERLAY TOO LARGE
002C   (0001)           EC.LAD	DS	1		; File is locked against delete 	/3.0a/
002D   (0001)           EC.FIX	DS	1		; Device media is fixed 		/3.0a/
002E   (0001)           EC.ILA	DS	1		; Illegal Load Address			/3.0a/
002F   (0001)           EC.DNL	DS	1		; Device Not Loaded			/3.0a/
0030   (0001)           EC.DNP	DS	1		; Device Not Locked in Memory		/3.0a/
0031   (0001)           EC.DFM	DS	1		; Device is Fixed in Memory		/3.0a/
0032   (0001)           EC.IDF	DS	1		; Illegal Date Format			/3.0a/
0033   (0001)           EC.ITS	DS	1		; Illegal Time Format			/3.0a/
0034   (0001)           EC.CNR	DS	1		; System Clock Not Resident		/3.0a/
0035   (0001)           EC.SDR	DS	1		; System Disk is Reset			/3.0a/
0036   (0001)           EC.LBO	DS	1		; Line Buffer Overflow			/3.0a/
0037   (0001)           EC.CUI	DS	1		; Can't Unlink from Interrupt Vector	/3.0a/
0038                    	XTEXT	DDFDEF
0038                    	SPACE	3,10
                        **	DIRECTORY DEVICE FORMAT DEFINITION.
                        *

0000                    	ORG	0

0000   (0009)           DDF.BOO DS	9			; 2K BOOT PROGRAM
      = 0009            DDF.BOL EQU	*			; LENGTH OF BOOT
0009   (0001)           DDF.LAB DS	1			; LABEL SECTOR
000A   (0000)           DDF.USR DS	0			; BEGINNING OF OPEN SPACE
000A                    	XTEXT	DIRDEF
000A                    	SPACE	3,10
                        **	DIRECTORY ENTRY FORMAT.

0000                    	ORG	0

      = 00FF            DF.EMP	EQU	377Q			; ENTRY EMPTY
      = 00FE            DF.CLR	EQU	376Q			; ENTRY EMPTY, REMAINDER ALSO CLEAR

0000   (0008)           DIR.NAM DS	8			; NAME
0008   (0003)           DIR.EXT DS	3			; EXTENSION
      = 000B            DIRIDL	equ	*			; file identification length	/3.0a/

000B   (0001)           DIR.CTH DS	1			; creation time (BCD hours)	/3.0a/
000C   (0001)           DIR.CTM DS	1			; creation date (BCD minutes)	/3.0a/

000D   (0001)           DIR.NOA DS	1			; number of accesses		/3.0a/
000E   (0001)           DIR.FLG DS	1			; FLAGS
000F   (0001)           DIR.USR DS	1			; user area mask		/3.0a/
0010   (0001)           DIR.FGN DS	1			; FIRST GROUP NUMBER
0011   (0001)           DIR.LGN DS	1			; LAST GROUP NUMBER
0012   (0001)           DIR.LSI DS	1			; LAST SECTOR INDEX (IN LAST GROUP)
0013   (0002)           DIR.CRD DS	2			; CREATION DATE
0015   (0002)           DIR.ACD DS	2			; last access date		/3.0a/

      = 0017            DIRELEN EQU	*			; DIRECTORY ENTRY LENGTH
0017                    	XTEXT	DIFDEF
0017                    DIFDEF	SPACE	4,10
                        **	DIRECTORY FILE FLAGS.

      = 0080            DIF.SYS EQU	10000000B		; System file
      = 0040            DIF.LOC EQU	01000000B		; Locked from flag changes
      = 0020            DIF.WP	EQU	00100000B		; Write protected
      = 0010            DIF.CNT EQU	00010000B		; Contiguous file
      = 0008            DIF.ARC EQU	00001000B		; File archive attribute	/3.0a/
      = 0004            DIF.BAD EQU	00000100B		; File is damaged		/3.0a/
      = 0002            DIF.DL	EQU	00000010B		; Locked against delete 	/3.0a/
      = 0001            DIF.USR EQU	00000001B		; User-defined			/3.0a/
0017                    	XTEXT	DISDEF
0017                    DISDEF	SPACE	3,10
                        **	DIRECTORY BLOCK FORMAT.

0000                    	ORG	0

      = 0000            DIS.ENT EQU	*			; FIRST ENTRY ADDRESS

0000   (01FA)           	DS	22*DIRELEN		; 22 DIRECTORY ENTRYS PER BLOCK
01FA   (0001)           	DS	1			; 0 BYTE = END OF ENTRYS IN THIS BLOCK

01FB                    	ORG	512-5			; AT END OF BLOCK

01FB   (0001)           DIS.ENL DS	1			; LENGTH OF EACH ENTRY (=DIRELEN)
01FC   (0002)           DIS.SEC DS	2			; BLOCK # OF THIS BLOCK,
01FE   (0002)           DIS.LNK DS	2			; BLOCK # OF NEXT BLOCK, =0 IF LAST
0200                    	XTEXT	LABDEF
0200                    	SPACE	3,10
                        **	DISK LABEL SECTOR FORMATS.

0000                    	ORG	0

0000   (0001)           LAB.SER DS	1			; SERIAL NUMBER OF VOLUME
0001   (0002)           LAB.IND DS	2			; INITIALIZATION DATE
0003   (0002)           LAB.DIS DS	2			; SECTOR NUMBER OF 1ST DIRECTORY SECTOR
0005   (0002)           LAB.GRT DS	2			; INDEX OF GRT SECTOR
0007   (0001)           LAB.SPG DS	1			; SECTORS PER GROUP

      = 0000            LAB.DAT EQU	0			; DATA VOLUME ONLY
      = 0001            LAB.SYS EQU	1			; SYSTEM VOLUME
      = 0002            LAB.NOD EQU	2			; VOLUME HAS NO DIRECTORY

0008   (0001)           LAB.VLT DS	1			; VOLUME TYPE
0009   (0001)           LAB.VER DS	1			; VERSION OF INIT17 THAT INITED DISK

000A   (0002)           LAB.RGT DS	2			; RGT sector number

      = 000C            LAB.VPR EQU	*			; Volume dependant data
000C   (0002)           LAB.SIZ DS	2			;  Volume Size (Bytes/256)
000E   (0002)           LAB.PSS DS	2			;  Physical Sector Size
0010   (0001)           LAB.VFL DS	1			;  Volume dependant Flags
      = 0001            VFL.NSD EQU	00000001B		;   Number of Sides:  1 => 2
      = 0002            VFL.DTD EQU	00000010b		;   96 tracks per inch		/3.0a/
      = 0002            VFL.80T EQU	VFL.DTD 		;   (ditto)
      = 0004            VFL.FIX EQU	00000100b		;   Media is fixed		/3.0a/
      = 0005            LAB.VPL EQU	*-LAB.VPR		; Length of volume dependant data

                        	ERRMI	5-LAB.VPL
0011   (0000)           	DS	5-LAB.VPL		; Reserved

0011   (003C)           LAB.LAB DS	60			; LABEL
      = 003C            LAB.LBL EQU	*-LAB.LAB		; LABEL LENGTH
004D   (0002)           	DS	2			; Reserved for 0 bytes

      = 004F            LAB.AUX EQU	*			; Auxiliary Data
004F   (0001)           LAB.SPT DS	1			;  Sectors per Track
      = 0001            LAB.AXL EQU	*-LAB.AUX		; Length of Aux. Data

0050   (0002)           LAB.LVN DS	2			; Long volume number		/3.0a/
0052                    	XTEXT	HOSEQU
0052                    	SPACE	4,10
                        **	HDOS SYSTEM EQUIVALENCES.					/3.0a/
                        *

2040                    	ORG	040100A

2040   (0008)           S.EXITA DS	8			; Jump to System Exit

2048   (0010)           D.CON	DS	16			; Disk Constants

      = 2058            SYDD	EQU	*			; System Disk Entry Point

2058   (0048)           D.VEC	DS	24*3			; H17 Disk Vectors
20A0   (001F)           D.RAM	DS	31			; H17 Disk Work Area

20BF   (0024)           S.VAL	DS	36			; SYSTEM VALUES
20E3   (0093)           S.INT	DS	147			; SYSTEM INTERNAL WORK AREAS

2176   (0002)           S.SOVR	DS	2			; STACK OVERFLOW WARNING
2178   (0108)           	DS	042200A-*		; SYSTEM STACK
      = 010A            STACKL	EQU	*-S.SOVR		; STACK SIZE

      = 2280            STACK	EQU	*			; LWA+1 SYSTEM STACK
      = 2280            USERFWA EQU	*			; USER FWA

                        *	Ensure Compatibility

                        	ERRNZ	040130A-SYDD
                        	ERRNZ	040277A-S.VAL
                        	ERRNZ	040343A-S.INT
                        	ERRNZ	042200A-USERFWA
2280                    	XTEXT	EDCON
2280                    	SPACE	4,10
                        **	D.CON DETAILED EQUIVALENCES.
                        *
                        *	HOSEQU MUST BE MODIFIED WHEN THIS TABLE IS MODIFIED.

2048                    	ORG	D.CON

2048   (0002)           D.XITA	DS	2	;SEE SYSTEM ROM FOR DESCRIPTION
204A   (0001)           D.WRITA	DS	1
204B   (0001)           D.WRITB	DS	1
204C   (0001)           D.WRITC	DS	1
204D   (0001)           D.MAIA	DS	1
204E   (0001)           D.LPSA	DS	1
204F   (0001)           D.SDPA	DS	1
2050   (0001)           D.SDPB	DS	1
2051   (0001)           D.STSA	DS	1
2052   (0001)           D.STSB	DS	1
2053   (0001)           D.WHDA	DS	1
2054   (0001)           D.WNHA	DS	1
2055   (0001)           D.WSCA	DS	1

2056   (0002)           D.ERTS	DS	2	;TRACK AND SECTOR OF LAST DISK ERRORS
2058                    	XTEXT	EDRAM
2058                    	SPACE	4,10
                        **	EDRAM - DISK RAM WORKAREA DEFINITION.
                        *
                        *	ZEROED UPON BOOTING UP.
                        *
                        *	HOSEQU MUST BE CHANGED WHEN THIS DECK IS CHANGED.

20A0                    	ORG	D.RAM

20A0   (0001)           D.TT	DS	1	;TARGET TRACK (CURRENT OPERATION)
20A1   (0001)           D.TS	DS	1	;TARGET SECTOR (CURRENT OPERATION)

20A2   (0001)           D.DVCTL	DS	1	;DEVICE CONTROL BYTE

20A3   (0001)           D.DLYMO	DS	1	;MOTOR ON DELAY COUNT
20A4   (0001)           D.DLYHS	DS	1	;HEAD SETTLE DELAY COUNTER

20A5   (0002)           D.TRKPT	DS	2	;ADDRESS IN D.DRVTB FOR TRACK NUMBER
20A7   (0002)           D.VOLPT	DS	2	;ADDRESS IN D.DRVTB FOR VOLUME NUMBER

20A9   (0008)           D.DRVTB	DS	2*4	;TRACK NUMBER AND VOLUME NUMBER FOR 4 DRIVES

20B1   (0001)           D.HECNT	DS	1	;HARD ERROR COUNT
20B2   (0002)           D.SECNT	DS	2	;SOFT ERROR COUNT
20B4   (0001)           D.OECNT	DS	1	;OPERATION ERROR COUNT

                        *	GLOBAL DISK ERROR COUNTERS

20B5   (0000)           D.ERR	DS	0	;BEGINNING OF ERROR BLOCK
20B5   (0001)           D.E.MDS	DS	1	;MISSING DATA SYNC
20B6   (0001)           D.E.HSY	DS	1	;MISSING HEADER SYNC
20B7   (0001)           D.E.CHK	DS	1	;DATA CHECKSUM
20B8   (0001)           D.E.HCK	DS	1	;HEADER CHECKSUM
20B9   (0001)           D.E.VOL	DS	1	;WRONG VOLUME NUMBER
20BA   (0001)           D.E.TRK	DS	1	;BAD TRACK SEEK
20BB   (0000)           D.ERRL	DS	0	;LIMIT OF ERROR COUNTERS

                        *	I/O OPERATION COUNTS

20BB   (0002)           D.OPR	DS	2
20BD   (0002)           D.OPW	DS	2

      = 001F            D.RAML	EQU	*-D.RAM
20BF                    	XTEXT	ESVAL
20BF                    	SPACE	4,10
                        **	S.VAL - SYSTEM VALUE DEFINTIONS.
                        *
                        *	THESE VALUES ARE SET AND MAINTAINED BY THE SYSTEM.
                        *
                        *	THE DECK HOSEQU MUST BE MODIFIED WHEN THIS IS MODIFIED.

20BF                    	ORG	S.VAL

20BF   (0009)           S.DATE	DS	9			; SYSTEM DATE (IN ASCII)
20C8   (0002)           S.DATC	DS	2			; CODED DATE
20CA   (0003)           S.TIME	DS	3			; TIME (BCD HH MM SS)		/3.0a/
20CD   (0001)           S.CLKTR DS	1			; 0 if no clock task resident	/3.0a/
20CE   (0002)           S.HIMEM DS	2			; HARDWARE HIGH MEMORY ADRESS+1

20D0   (0002)           S.SYSM	DS	2			; FWA RESIDENT SYSTEM

20D2   (0002)           S.USRM	DS	2			; LWA USER MEMORY

20D4   (0002)           	DS	2			; obsolete (must be zero!!)	/3.0a/
20D6                    	SPACE	3,10
                        **	THE FOLLOWING CELLS SHOULD BE MODIFIED/READ ONLY VIA THE .CONSL SCALL

      = 0080            CSL.ECH EQU	10000000B		; SUPPRESS ECHO
      = 0004            CSL.RAW EQU	00000100B		; Raw Mode I/O
      = 0002            CSL.WRP EQU	00000010B		; WRAP LINES AT WIDTH
      = 0001            CSL.CHR EQU	00000001B		; OPERATE IN CHARACTER MODE

      = 0000            I.CSLMD EQU	0			; S.CSLMD IS FIRST BYTE
20D6   (0001)           S.CSLMD DS	1			; CONSOLE MODE


      = 0080            CTP.BKS EQU	10000000B		; TERMINAL PROCESSES BACKSPACES
      = 0040            CTP.FF	EQU	01000000B		; Terminal Processes Form-Feed
      = 0020            CTP.MLI EQU	00100000B		; MAP LOWER CASE TO UPPER ON INPUT
      = 0010            CTP.MLO EQU	00010000B		; MAP LOWER CASE TO UPPER ON OUTPUT
      = 0008            CTP.2SB EQU	00001000B		; TERMINAL NEEDS TWO STOP BITS
      = 0004            CTP.HHS EQU	00000100B		; Terminal uses hdwr handshake	/3.0a/
      = 0002            CTP.BKM EQU	00000010B		; MAP BKSP (UPON INPUT) TO RUBOUT
      = 0001            CTP.TAB EQU	00000001B		; TERMINAL SUPPORTS TAB CHARACTERS

      = 0001            I.CONTY EQU	1			; S.CONTY IS 2ND BYTE
                        	ERRNZ	*-S.CSLMD-I.CONTY
20D7   (0001)           S.CONTY DS	1			; CONSOLE TYPE FLAGS


      = 0002            I.CUSOR EQU	2			; S.CUSOR IS 3RD BYTE
                        	ERRNZ	*-S.CSLMD-I.CUSOR
20D8   (0001)           S.CUSOR DS	1			; CURRENT CURSOR POSITION


      = 0003            I.CONWI EQU	3			; S.CONWI IS 4TH BYTE
                        	ERRNZ	*-S.CSLMD-I.CONWI
20D9   (0001)           S.CONWI DS	1			; CONSOLE WIDTH


      = 0001            CO.FLG	EQU	00000001B		; CTL-O FLAG
      = 0080            CS.FLG	EQU	10000000B		; CTL-S FLAG

      = 0004            I.CONFL EQU	4			; S.CONFL IS 5TH BYTE
                        	ERRNZ	*-S.CSLMD-I.CONFL
20DA   (0001)           S.CONFL DS	1			; CONSOLE FLAGS


20DB   (0002)           S.CAADR DS	2			; ADDRESS FOR ABORT PROCESSING (>256 IF VALID)
20DD   (0006)           S.CCTAB DS	6			; ADDR FOR CTL-A, CTL-B, CTL-C PROCESSING
20E3                    	XTEXT	ESINT
20E3                    	SPACE	4,10
                        **	S.INT - SYSTEM INTERNAL WORKAREA DEFINITIONS.
                        *
                        *	THESE CELLS ARE REFERENCED BY OVERLAYS AND MAIN CODE, AND
                        *	MUST THEREFORE RESIDE IN FIXED LOW MEMORY.

20E3                    	ORG	S.INT

                        **	CONSOLE STATUS FLAGS

20E3   (0001)           S.CDB	DS	1			; CONSOLE DESCRIPTOR BYTE
      = 0000            CDB.H85	EQU	00000000B
      = 0001            CDB.H84 EQU	00000001B		; =0 IF H8-5, =1 IF H8-4
20E4   (0002)           S.BAUD	DS	2			; [0-14]  H8-4 BAUD RATE, =0 IF H8-5
                        *					; [15]	  =1 IF BAUD RATE => 2 STOP BITS

                        **	TABLE ADDRESS WORDS

20E6   (0002)           S.DLINK DS	2			; ADDRESS OF DATA IN HDOS CODE
20E8   (0002)           S.TFWA	DS	2			; FWA Task Table		/3.1a/
20EA   (0002)           S.CFWA	DS	2			; FWA CHANNEL TABLE
20EC   (0002)           S.DFWA	DS	2			; FWA DEVICE TABLE
20EE   (0002)           S.RFWA	DS	2			; FWA RESIDENT HDOS CODE

                        **	DEVICE DRIVER DELAYED LOAD FLAGS

20F0   (0002)           S.DDLDA DS	2			; DRIVER LOAD ADDRESS (HIGH BYTE=0 IF NO LOAD PENDING)
20F2   (0002)           S.DDLEN DS	2			; CODE LENGTH IN BYTES
20F4   (0001)           S.DDGRP DS	1			; GROUP NUMBER FOR DRIVER
20F5   (0001)           	DS	1			; HOLD PLACE
20F6   (0002)           S.DDDTA DS	2			; DEVICE'S ADDRESS IN DEVLST +DEV.RES
20F8   (0001)           S.DDOPC DS	1			; OPEN OPCODE PENDEDING

20F9   (000D)           	DS	13			; reserved

                        *	SYSCALL PROCESSING WORK AREAS

                        	ERRNZ	*-041006A
2106   (0001)           S.CACC	DS	1			; (ACC) UPON SYSCALL
2107   (0001)           S.CODE	DS	1			; SYSCALL INDEX IN PROGRESS

                        *	JUMPS TO ROUTINES IN RESIDENT HDOS CODE

2108   (0000)           S.JUMPS DS	0			; START OF DUMP VECTORS
2108   (0003)           S.SDD	DS	3			; JUMP TO STAND-IN DEVICE DRIVER
210B   (0003)           S.FASER DS	3			; JUMP TO FATSERR (FATAL SYSTEM ERROR)
210E   (0003)           S.DIREA DS	3			; JUMP TO DIREAD (DISK FILE READ)
2111   (0003)           S.FCI	DS	3			; JUMP TO FCI (FETCH CHANNEL INFO)
2114   (0003)           S.SCI	DS	3			; JUMP TO SCI (STORE CHANNEL INFO)
2117   (0003)           S.GUP	DS	3			; JUMP TO GUP (GET UNIT POINTER)

211A   (0001)           S.MOUNT DS	1			; <>0 IF THE SYSTEM DISK IS MOUNTED
211B   (0001)           	DS	1			; reserved			/3.0a/

211C   (0001)           S.BOOTF DS	1			; BOOT FLAGS
      = 0001            BOOT.P	EQU	00000001B		; EXECUTE PROLOGUE UPON BOOTUP

211D   (0003)           	DS	3			; reserved
2120                    	SPACE	4,10
                        **	ACTIVE I/O AREA.
                        *
                        *	THE AIO.XXX AREA CONTAINS INFORMATION ABOUT THE I/O OPERATION
                        *	CURRENTLY BEING PERFORMED. THE INFORMATION IS OBTAINED FROM
                        *	THE CHANNEL TABLE, AND WILL BE RESTORED THERE WHEN DONE.
                        *
                        *	NORMALLY, THE AIO.XXX INFORMATION WOULD BE OBTAINED DIRECTLY
                        *	FROM VARIOUS SYSTEM TABLES VIA POINTER REGISTERS. SINCE THE
                        *	8080 HAS NO GOOD INDEXED ADDRESSING, THE DATA IS MANUALLY
                        *	COPIED INTO THE AIO.XXX CELLS BEFORE PROCESSING, AND
                        *	BACKDATED AFTER PROCESSING.

                        	ERRNZ	*-041040A
2120   (0003)           AIO.VEC DS	3			; JUMP INSTRUCTION
      = 2121            AIO.DDA EQU	*-2			; DEVICE DRIVER ADDRESS
2123   (0001)           AIO.FLG DS	1			; FLAG BYTE
2124   (0002)           AIO.GRT DS	2			; ADDRESS OF GROUP RESERV TABLE
2126   (0001)           AIO.SPG DS	1			; SECTORS PER GROUP
2127   (0001)           AIO.CGN DS	1			; CURRENT GROUP NUMBER
2128   (0001)           AIO.CSI DS	1			; CURRENT SECTOR INDEX
2129   (0001)           AIO.LGN DS	1			; LAST GROUP NUMBER
212A   (0001)           AIO.LSI DS	1			; LAST SECTOR INDEX
212B   (0002)           AIO.DTA DS	2			; DEVICE TABLE ADDRESS
212D   (0002)           AIO.DES DS	2			; DIRECTORY SECTOR
212F   (0002)           AIO.DEV DS	2			; DEVICE CODE
2131   (0001)           AIO.UNI DS	1			; UNIT NUMBER (0-9)

2132   (0017)           AIO.DIR DS	DIRELEN 		; DIRECTORY ENTRY

2149   (0001)           AIO.CNT DS	1			; SECTOR COUNT
214A   (0001)           AIO.EOM DS	1			; END OF MEDIA FLAG
214B   (0001)           AIO.EOF DS	1			; END OF FILE FLAG
214C   (0002)           AIO.TFP DS	2			; TEMP FILE POINTERS
214E   (0002)           AIO.CHA DS	2			; ADDRESS OF CHANNEL BLOCK (IOC.DDA)
2150                    	SPACE	4,10
                        *	these cells set by monitor boot code

2150   (0001)           S.BDA	DS	1			; Boot Device Address (Setup by ROM)
2151   (0002)           S.SCR	DS	2			; SYSTEM SCRATCH AREA ADDRESS
2153   (0003)           	DS	3
2156   (0001)           S.OSI	DS	1			; Operating system index	/3.0a/
2157   (0001)           S.OSO	DS	1			; Operating system occurance	/3.0a/
2158   (0003)           S.OSZ	DS	3			; Operating system sector zero	/3.0a/
215B                    	XTEXT	MTRDEF
215B                    	SPACE	4,10
                        **	HDOS MONITOR PRIVATE RAM AREA DEFINITIONS.

0000                    	ORG	0

0000   (0001)           M.SYSM	DS	1			; SYSCALL ITTERATION COUNT
0001   (0001)           	DS	1			; STAND-ALONE FLAG (obsolete)	/3.0a/

0002   (0002)           M.CSL	DS	2			; Address of console data area	/3.0a/

0004   (0001)           M.SUNI	DS	1			; System Unit Number
0005   (0002)           M.SYDD	DS	2			; Address of Raw System Driver
0007                    	XTEXT	DEVDEF
0007                    	SPACE	4,10
                        ***	DEVICE TABLE ENTRYS.

0000                    	ORG	0

0000   (0002)           DEV.NAM DS	2			; DEVICE NAME
      = 0000            DV.EL	EQU	00000000B		; END OF DEVICE LIST FLAG
      = 0001            DV.NU	EQU	00000001B		; DEVICE ENTRY NOT IN USE

0002   (0001)           DEV.RES DS	1			; DRIVER RESIDENSE CODE
      = 0001            DR.IM	EQU	00000001B		; DRIVER IN MEMORY
      = 0002            DR.PR	EQU	00000010B		; DRIVER PERMANENTLY RESIDENT
      = 0004            DR.FX	equ	00000100b		; Driver FIXED in memory	/3.0a/
      = 0008            DR.UNL	equ	00001000b		; Driver unload pending 	/3.0a/
                        *	equ	00010000b		; Reserved			/3.0a/
      = 00E0            DR.SPL	equ	11100000b		; SET preamble size mask	/3.0a/

0003   (0001)           DEV.JMP DS	1			; JMP TO PROCESSOR
0004   (0002)           DEV.DDA DS	2			; DRIVER ADDRESS
0006   (0001)           DEV.FLG DS	1			; FLAG BYTE
      = 0001            DT.DD	EQU	00000001B		; DIRECTORY DEVICE
      = 0002            DT.CR	EQU	00000010B		; CAPABLE OF READ OPERATION
      = 0004            DT.CW	EQU	00000100B		; CAPABLE OF WRITE OPERATION
      = 0008            DT.RN	EQU	00001000B		; Capable of random access
      = 0010            DT.CH	EQU	00010000B		; Capable of Character mode
      = 0020            DT.FX	EQU	00100000B		; Fixed Media			/3.0a/
      = 0040            DT.P3	EQU	01000000B		; pre-3.0 media 		/3.0a/
      = 0080            DT.UL	EQU	10000000B		; requires unload notification	/3.0a/

0007   (0001)           DEV.MUM DS	1			; MOUNTED UNIT MASK
0008   (0001)           DEV.MNU DS	1			; MAXIMUM NUMBER OF UNITS
0009   (0002)           DEV.UNT DS	2			; ADDRESS OF UNIT SPECIFIC DATA TABLE

000B   (0002)           DEV.DVL DS	2			; DRIVER BYTE LENGTH
000D   (0001)           DEV.DVG DS	1			; DRIVER ROUTINE GROUP ADDRESS

      = 000E            DEVELEN EQU	*			; DEVICE TABLE ENTRY LENGTH
000E                    UNT.TAB	SPACE	4,10
                        **	UNIT SPECIFIC DEVICE DATA TABLE ENTRIES

0000                    	ORG	0

0000   (0001)           UNT.FLG DS	1			; UNIT SPECIFIC  *DEV.FLG*
0001   (0001)           UNT.SPG DS	1			; Sectors Per Group
0002   (0002)           UNT.GRT DS	2			; ADDRESS OF GRT (IF DT.DD)
0004   (0002)           UNT.GTS DS	2			; GRT SECTOR NUMBER
0006   (0002)           UNT.DIS DS	2			; DIRECTORY FIRST SECTOR NUMBER

      = 0008            UNT.SIZ EQU	*			; SIZE OF UNIT SPECIFIC DATA ENTRY
0008                    	XTEXT	IOCDEF
0008                    IOCDEF	SPACE	3,10
                        **	I/O CHANNEL DEFINITIONS.

0000                    	ORG	0

0000   (0002)           IOC.LNK DS	2			; ADDRESS OF NEXT CHANNEL, =0 IF LAST
0002   (0002)           IOC.DDA DS	2			; THREAD JUMP TO DEVICE DRIVER (VIA DEV TABLE)

0004   (0001)           IOC.FLG DS	1			; FILE TYPE FLAGS
      = 0001            FT.DD	EQU	00000001B		;  =1 IF DIRECTORY DEVICE
      = 0002            FT.OR	EQU	00000010B		;  =1 IF OPEN FOR READ
      = 0004            FT.OW	EQU	00000100B		;  =1 IF OPEN FOR WRITE
      = 0008            FT.OU	EQU	00001000B		;  =1 IF OPEN FOR UPDATE
      = 0010            FT.OC	EQU	00010000B		;  =1 IF OPEN FOR CHARACTER MODE
      = 0003            IOC.SQL EQU	*-IOC.DDA		; LENGTH OF INFO FOR SEQUENTIAL FILE

0005   (0002)           IOC.GRT DS	2			; ADDRESS OF GROUP RESERVATION TABLE
0007   (0001)           IOC.SPG DS	1			; SECTORS PER GROUP, THIS DEVICE
0008   (0001)           IOC.CGN DS	1			; CURRENT GROUP NUMBER
0009   (0001)           IOC.CSI DS	1			; CURRENT SECTOR INDEX (IN CURRENT GROUP)
000A   (0001)           IOC.LGN DS	1			; LAST GROUP NUMBER
000B   (0001)           IOC.LSI DS	1			; LAST SECTOR INDEX (IN LAST GROUP)
      = 0008            IOC.DRL EQU	*-IOC.FLG		; LENGTH OF INFO NORMALLY COPIED BACK TO
                        *					; THE CHANNEL TABLE
000C   (0002)           IOC.DTA DS	2			; DEVICE TABLE ADDRESS FOR THIS DEVICE
000E   (0002)           IOC.DES DS	2			; SECTOR NUMBER OF DIRECTORY ENTRY
0010   (0002)           IOC.DEV DS	2			; DEVICE CODE
0012   (0001)           IOC.UNI DS	1			; UNIT NUMBER (0-9)
      = 0011            IOC.DIL EQU	*-IOC.DDA		; LENGTH OF INFO FOR DIRECTORY FILE

0013   (0017)           IOC.DIR DS	DIRELEN 		; DIRECTORY ENTRY

      = 002A            IOCELEN EQU	*			; IOC ENTRY LENGTH

      = 0001            IOCCTD	EQU	1			; INDEX OF USER CHANNEL #0 IN CHANTAB (FIRST = 0)
002A                    	XTEXT	FBDEF
002A                    	SPACE	4,10
                        **	FILE BLOCK DEFINITIONS.

0000                    	ORG	0

0000   (0001)           FB.CHA	DS	1			; CHANNEL NUMBER
0001   (0001)           FB.FLG	DS	1			; FLAGS
0002   (0002)           FB.FWA	DS	2			; BUFFER FWA
0004   (0002)           FB.PTR	DS	2			; BUFFER POINTER
0006   (0002)           FB.LIM	DS	2			; LIMIT OF DATA IN BUFFER (READ)
0008   (0002)           FB.LWA	DS	2			; LWA OF BUFFER
000A   (0011)           FB.NAM	DS	4+8+4+1 		; NAME OF FILE
      = 0011            FB.NAML EQU	*-FB.NAM
      = 001B            FBENL	EQU	*			; ENTRY LENGTH
001B                    	XTEXT	DDDEF
001B                    	SPACE	3,10
                        **	DEVICE DRIVER COMMUNICATION FLAGS.
                        *

0000                    	ORG	0

0000   (0001)           DC.REA	DS	1			; READ
0001   (0001)           DC.WRI	DS	1			; WRITE
0002   (0001)           DC.RER	DS	1			; READ REGARDLESS
0003   (0001)           DC.OPR	DS	1			; OPEN FOR READ
0004   (0001)           DC.OPW	DS	1			; OPEN FOR WRITE
0005   (0001)           DC.OPU	DS	1			; OPEN FOR UPDATE
0006   (0001)           DC.CLO	DS	1			; CLOSE
0007   (0001)           DC.ABT	DS	1			; ABORT
0008   (0001)           DC.MOU	DS	1			; MOUNT DEVICE
0009   (0001)           DC.LOD	DS	1			; LOAD DEVICE DRIVER
000A   (0001)           DC.RDY	DS	1			; Device Ready
000B   (0001)           DC.SET	DS	1			; Update SET parameters 	/3.0a/
000C   (0001)           DC.UNL	DS	1			; Unload device driver		/3.0a/
000D   (0001)           DC.INT	DS	1			; Interrupt			/3.0a/
000E   (0001)           DC.DSF	DS	1			; Device-specific function	/3.0a/
000F   (0001)           DC.MAX	DS	1			; MAXIMUM ENTRY INDEX
0010                    	XTEXT	FILDEF
0010                    	SPACE	4,10
                        **	FILDEF - FILE TYPE DEFINITIONS.
                        *
                        *	DB	377Q,FT.XXX

      = 0000            FT.ABS	EQU	0			; ABSOLUTE BINARY
      = 0001            FT.PIC	EQU	1			; POSITION INDEPENDANT CODE
      = 0002            FT.REL	EQU	2			; RELOCATABLE CODE
      = 0003            FT.BAC	EQU	3			; COMPILED BASIC CODE
0010                    	XTEXT	ABSDEF
0010                    ABSDEF	SPACE	3,10
                        **	ABS FORMAT EQUIVALENCES.

0000                    	ORG	0

0000   (0001)           ABS.ID	DS	1	;377Q = BINARY FILE FLAG
0001   (0001)           	DS	1	;FILE TYPE (FT.ABS)
0002   (0002)           ABS.LDA	DS	2	;LOAD ADDRESS
0004   (0002)           ABS.LEN	DS	2	;LENGTH OF ENTIRE RECORD
0006   (0002)           ABS.ENT	DS	2	;ENTRY POINT

0008   (0000)           ABS.COD	DS	0	;CODE STARTS HERE
0008                    	XTEXT	PICDEF
0008                    PICDEF	SPACE	3,10
                        **	PIC FORMAT EQUIVALENCES.

0000                    	ORG	0

0000   (0001)           PIC.ID	DS	1			; 377Q = BINARY FILE FLAG
0001   (0001)           	DS	1			; FILE TYPE (FT.PIC)
0002   (0002)           PIC.LEN DS	2			; LENGTH OF ENTIRE RECORD
0004   (0002)           PIC.PTR DS	2			; INDEX OF START OF PIC TABLE

0006   (0000)           PIC.COD DS	0			; CODE STARTS HERE
0006                    	XTEXT	BSXDEF
0006                    	SPACE	4,10
                        **	BASEX HEADER EQUIVALENCES

0000                    	ORG	0

0000   (0001)           BSX.ID	DS	1			; 377Q = Binary File Flag
0001   (0001)           	DS	1			; File Type (FT.BSX)
0002   (0002)           BSX.PSA DS	2			; Program Start Address
0004   (0002)           BSX.PEA DS	2			; Program End Address
0006   (0002)           BSX.SSA DS	2			; Symbol_Table Start Address
0008   (0002)           BSX.SEA DS	2			; Symbol_Table End Address

000A   (0000)           BSX.COD DS	0			; Code Starts Here
000A                    	XTEXT	TASKDEF
000A                    	SPACE	4,10
                        ***	TASK Processor Definitions

      = 0041            .TASK	EQU	101Q			; Process TASK function
      = 00CF            TASKID	EQU	317Q			; Task Identification Flag
      = 00D7            TASKID. EQU	327Q

      = 0001            PROCMGR EQU	1			; Assemble for Task Manager
000A                    	SPACE	3
0000                    	ORG	0
                        ***	TASK Processor Function Codes
                        *
                        *	Calling sequences.
0000                    	SPACE	2
                        **	TAS.ID - Identify TASK
                        *
                        *	TAS.ID is used to identify a TASK to the Task Manager
                        *	and the system.  The TASK is flagged as ACTIVE upon
                        *	return with the Task Sequence Number (TSN) in (A).
                        *
                        *	Entry:	(HL) = Address of TASK Block
                        *		(B)  = TAS.ID
                        *	Exit:	'C' Set
                        *		 (A) = Error code
                        *		'C' Clear if Ok.
                        *		 (A) = Task Sequence Number
                        *	Uses:	ALL

0000   (0001)           TAS.ID	DS	1			; Identify TASK to System
0001                    	SPACE	4,34
                        **	TAS.INQ - Inquire About TASKs in System
                        *
                        *	TAS.INQ returns a pointer to the task block table in
                        *	the Task Manager or to a task block within an individual
                        *	task.  The task block table consists of the addresses of
                        *	the task blocks of all tasks known to the system.
                        *	the Task Manager.  This table consists of the addresses
                        *	An address of 000000A signifies an unused entry, while
                        *	377377A marks the end of the table.  The general form
                        *	of the table is:
                        *
                        *		DW	Address_of_TASK_Block
                        *		DW	TASK_Process_Flag
                        *
                        *	The TASK Process flag contains a '1' bit for each interrupt
                        *	vector the TASK services.  The bits are assigned in the
                        *	following manner:
                        *
                        *		Byte 0 :
                        *
                        *		    bit 7 = High order bit, Interrupt Level 7
                        *		      .
                        *		      .
                        *		    bit 1 =		    Interrupt Level 1
                        *		    bit 0 = Low order bit,  TASK is active
                        *
                        *	For example, a value of 10001000B (or 210Q) would indicate
                        *	that the TASK services the SCALL vector (INT7) and the
                        *	console vector (INT3).	Also the task is not currently active.
                        *
                        *		Byte 1 :
                        *
                        *		    Reserved for future use
                        *
                        *	Entry : (A) = TSN desired, or -1 for base of task block
                        *
                        *	Exit:	'C' Clear
                        *		 (HL) = Address of TASK block table
                        *		'C' Set
                        *		 (A) = Error code  (Illegal SCALL)
                        *		 TASK Monitor not STARTed
                        *	Uses:	A,F,H,L

0001   (0001)           TAS.INQ	DS	1			; Inquire about TASKs
0002                    	SPACE	4,25
                        **	TAS.DEA - Deactivate a TASK
                        *
                        *	TAS.DEA flags a TASK as inactive and discontinues all
                        *	processing of interrupts by the TASK.  That is, the
                        *	Task Manager will not pass control to the task at
                        *	interrupt time.  The task's function processor will
                        *	receive control, (with the value of TAS.DEA in the (A)
                        *	register), to take care of disabling interrupts,
                        *	and other 'clean up' type activity before deactivation.
                        *
                        *	*WARNING*
                        *
                        *	If an interrupt occurs after deactivation which must be
                        *	serviced by this TASK, the system will crash due to the
                        *	unserviced interrupt.  The ONLY way to re-activate any
                        *	task is via the TAS.REA function.
                        *
                        *	Entry:	(A) = Task Sequence Number
                        *	Exit:	'C' Clear, TASK deactivated
                        *		'C' Set
                        *		 (A) = Error code
                        *		 No such TASK, TASK monitor not STARTed,
                        *		 TASK not abortable, or TASK not active
                        *	Uses:	A,F

0002   (0001)           TAS.DEA	DS	1			; Deactivate Task
0003                    	SPACE	4,16
                        **	TAS.REA - Re-activate a TASK
                        *
                        *	TAS.REA Re-activates a previously deactivated task.  Control
                        *	is passed to the task's function processor, (with the value
                        *	of TAS.REA in the (A) register), to take care of any
                        *	initialization which may be required.  Such initialization
                        *	may include, but not be limited to, setting up of ports, and
                        *	re-requesting interrupt service from the Task manager
                        *
                        *	Entry:	(A) = Task Sequence Number
                        *	Exit:	'C' Clear, TASK re-activated
                        *		'C' Set
                        *		 No such TASK, TASK monitor not STARTed, or
                        *		 TASK already active
                        *	Uses:	A,F

0003   (0001)           TAS.REA	DS	1			; Reactivate TASK
0004                    	SPACE	4,23
                        **	TAS.RIS - Request Interrupt Service
                        *
                        *	TAS.RIS is called by a task to request that interrupt service
                        *	be provided by the Task Manager to the task.  It allows the
                        *	Manager to control access of interrupt driven tasks, and removes
                        *	the burden from the user of setting up and/or clearing of interrupt
                        *	service vectors.
                        *
                        *	*WARNING*
                        *
                        *	This function must be called before any interrupts occur.
                        *
                        *	Entry:	(A)  = Task Sequence Number
                        *		(B)  = TAS.RIS
                        *		(C)  = Interrupt Level	(1-7)
                        *		(HL) = Interrupt processor address
                        *	Exit:	'C' clear
                        *		 Vectors installed
                        *		'C' set
                        *		 (A) = Error code
                        *		 Unknown TSN, or Task Manager not present
                        *	Uses:	A,F
                        *
                        *	Upon entry to the particular interrupt service routine the user
                        *	must follow the following conventions;
                        *
                        *	Vectors 1-6 :	All registers pushed on the stack.
                        *		(SP+0) = return to task manager
                        *		(SP+2) = return to user program via USR.RST
                        *		(SP+4 - SP+6) = Task Manager registers
                        *		(SP+8) = return to user program via $RSTALL
                        *		(SP+10 - SP+18) = user registers
                        *		(SP+20) = users interrupted PC
                        *
                        *	Vector 7 (SCALL) :
                        *
                        *		(HL) = users return address (pointer to SCALL)
                        *		(SP+0) = return to task manager
                        *		(SP+2) = task managers (HL)
                        *		(SP+4) = users PSW
                        *		(SP+6) = users HL
                        *
                        *		All other registers unaffected.
                        *		If the task intends to handle the SCALL the
                        *		task managers return should be popped and
                        *		the SCALL handled normally

0004   (0001)           TAS.RIS DS	1			; Request interrupt service
0005                    	SPACE	4,10
                        	IF	PROCMGR 		; turn this off
                        	ENDIF
0005                    	SPACE	4,10
                        	IF	PROCMGR 		; turn this off
                        	ENDIF
0005                    	SPACE	4,10
                        	IF	PROCMGR 		; turn this off
                        	ENDIF
0005                    	SPACE	4,10
                        	IF	PROCMGR 		; turn this off
                        	ENDIF
0005                    	SPACE	4,40
                        	IF	PROCMGR 		; turn this off
                        	ENDIF
0005   (0000)           TAS.MAX	DS	0
0005                    	SPACE	4,40
                        ***	TASK Block Definition.
                        *
                        *	The TASK block is a structure used to identify TASKs
                        *	to the TASK monitor, and the system.  The format of
                        *	the block is as follows:
                        *
                        *		TASK Name	DB	'TASKNAME'
                        *		Version (BCD)	DB	BCD_VERSION
                        *		TASK Id 	DB	'XXXX'
                        *		Task Status	DB	STATUS_BYTE
                        *		Task Start	DW	START_ADDRESS
                        *		Task End	DW	END_ADDRESS
                        *		Task Processor	DW	PROCESSOR_ADDRESS

0000                    	ORG	0

0000   (0008)           TSB.NAM DS	8			; Name of the TASK
0008   (0001)           TSB.VER DS	1			; Version (BCD) of TASK
0009   (0004)           TSB.ID	DS	4			; Other Id information
000D   (0001)           TSB.STA DS	1			; Task status byte  (See definitions)
000E   (0002)           TSB.STR DS	2			; Starting address of TASK in memory
0010   (0002)           TSB.END DS	2			; Ending address of TASK in memory
0012   (0002)           TSB.PRC DS	2			; Address of TASK function processor
      = 0014            TSB.LEN EQU	*			; ... If = 0, then no processor.

                        *	Status byte definitions

      = 0001            TSS.ACT EQU	00000001B		; Task is active
      = 0000            TSS.DEA EQU	00000000B		; Task is inactive (suspended)
      = 0002            TSS.UFP EQU	00000010B		; Task uses H8 front panel
                        	IF	PROCMGR
                        	ENDIF
      = 0008            TSS.MEM EQU	00001000B		; Task uses B/S memory
      = 0080            TSS.TCA EQU	10000000B		; Task may not be de-activated.

                        *	Error code definitions

      = 00C0            EC.ITF	EQU	300Q			; Illegal TASK Function call
      = 00C1            EC.TAA	EQU	301Q			; TASK already active
      = 00C2            EC.TNA	EQU	302Q			; TASK is not active
      = 00C3            EC.TUN	EQU	303Q			; TASK unknown
      = 00C4            EC.TIF	EQU	304Q			; TASK table is full
      = 00C5            EC.TCA	EQU	305Q			; TASK can't abort
      = 00C6            EC.TSN	EQU	306Q			; Illegal Task Sequence Number
      = 00C7            EC.TNF	EQU	307Q			; Task notification failed
      = 00C8            EC.8KL	EQU	310Q			; Task too large (8K limit)
      = 00C9            EC.NTF	EQU	311Q			; File not TASK format
      = 0003            EC.NTM	EQU	003Q			; Task Manager not Present  (Bad SCALL)

      = 0010            TASMAX	EQU	16			; Maximum number of tasks in system
0014                    	STL	'SYSXIT - SYSTEM EXIT PROCESSOR'
0014                    	EJECT
                        	CODE	ABS			; Assemble Absolute

2280                    	ORG	USERFWA

2280                    	NOTE	USERFWA 	; Start
2280                    	NOTE	MEML		; Base End
2280                    	NOTE	PIP.WS		; PIP
2280                    	NOTE	IMEML		; Init End
2280                    	NOTE	IMEML-USERFWA	; Length
2280                    	NOTE	BUFFWA		; Buffer
2280                    	NOTE	RMEML		; Top
                        	ERRPL	MEML-PIP.WS

                        	ERRNZ	*-USERFWA		; Warm start MUST be at start of file.

      = 0000            SYSCMD	EQU	B.INT0			; SYSCMD Vector at RESTART 0

2280  C3 CD22           WARM	JMP	SYSXIT			; Warm start from pip

2283  53593041 4253     DEFA	DB	'SY0ABS'		; Default Default
      = 0006            DEFAL	EQU	*-DEFA
2289  53593041 4253     SYSCB	DB	'SY0ABS'		; Default for Implicit RUN (LINK)
228F  53593041 4253     RUNA	DB	'SY0ABS'		; Default for RUN
2295  53593042 4154     BATBLK	DB	'SY0BAT'		; Default for Batch Files
229B  53593054 4153     TSKBLK	DB	'SY0TAS'		; Default for Tasks

      = 0001            YES	EQU	1
      = 0000            NO	EQU	0

22A1  00                VFYFLG	DB	NO			; YES=Set VERIFY ON @ Boot
22A2  01                ECOFLG	DB	YES			; YES=Default ECHO OFF in BATCH
22A3  00                ZROFLG	DB	NO			; YES=Zero H17 I/O Statistics
22A4  00                XYZZYF	DB	NO			; YES=Default XYZZY ON
22A5  000000            	DB	0,0,0			; Three User Definable Bytes
22A8  00                ULTRA	DB	NO			; YES=Ultra ROM is Present

22A9  5359              DPDEV	DB	'SY'			; Default primary device name
22AB  444B              DADEV	DB	'DK'			; Default alternate device name

22AD  50443A00          PRIDEV	DB	'PD',':',0		; Primary Device Name
22B1  41443A00          ALTDEV	DB	'AD',':',0		; Alternate Device Name

22B5  4C503A00          LSTDEV	DB	'LP',':',0		; List Device Name

22B9  00                ALTFLG	DB	0			; Alternate device flag

22BA  00                NULFLG	DB	0			; =1 when NUL found in BATCH file

22BB  00                H19FLG	DB	0			; <>0 if H19/VT52 Terminal

22BC  0A533AA0          DPROM	DB	NL,'S:',' '+200Q	; DEFAULT SYSTEM PROMPT
22C0  00000000 00000000 	DW	0,0,0,0,0,0		;  16 characters max.
22C8  00000000
      = 0010            DPROML	EQU	*-DPROM
22CC  00                	DB	0			; MUST have trailing null
22CD                    	EJECT
                        ***	SYSXIT - SYSTEM EXIT PROCESSOR.

      = 22CD            SYSXIT	EQU	*

22CD  32 C623           	STA	SYSXITA 		; Save value.  If > 0, then abort exit.
22D0  FF 09             	SCALL	.VERS
22D2  DA BD23           	JC	SYSX1			; Had error getting version
22D5  FE 30             	CPI	VERS
22D7  C2 BD23           	JNE	SYSX1			; WRONG VERSION!

                        	IF	Z80
                        	ENDIF

      = 22DA            SYSXIT. EQU	*

22DA  21 A425           	LXI	H,SYSCMD.		; Set Up RESTART 0 Vector
22DD  22 0100           	SHLD	B.INT0+1		; Force SYSCMD. after JMP

22E0  3A 0500           	LDA	S.FMASK
22E3  E6 30             	ANI	F.TERM
22E5  FE 10             	CPI	F.H19
22E7  C2 ED22           	JNE	SYSXITH
22EA  32 BB22           	STA	H19FLG

22ED  3A 7F00           SYSXITH LDA	S.FLAG
22F0  E6 10             	ANI	S.EXITC 		; Show exit code ?
22F2  CA 2623           	JZ	SYSXIT0 		; No

22F5  3A 7F00           	LDA	S.FLAG
22F8  E6 01             	ANI	S.SYSCM 		; Is SYSCMD in memory ?
22FA  CA 0423           	JZ	SYSXEC			; No, show it

22FD  3A C623           	LDA	SYSXITA
2300  A7                	ANA	A			; Is it zero ?
2301  CA 2623           	JZ	SYSXIT0 		; Yes, don't show it

2304  3A C623           SYSXEC	LDA	SYSXITA
2307  4F                	MOV	C,A
2308  06 00             	MVI	B,0
230A  3E 03             	MVI	A,3
230C  21 2223           	LXI	H,SYSXITC
230F  CD 7047           	CALL	$UDDN
2312  CD 5E19           	CALL	$TYPTX
2315  0A457869 7420436F 	DB	NL,'Exit Code = '
231D  6465203D 20
2322  6E6E6E8A          SYSXITC DB	'nnn',ENL

2326  21 E4A0           SYSXIT0 LXI	H,RMEML 		; Top of memory w/ largest TASK
2329  FF 2A             	SCALL	.SETTOP
232B  3E 11             	MVI	A,EC.NEM		; Assume we had an error
232D  DA BF23           	JC	SYSX2			; If error  (SHOULDN'T HAPPEN)
2330  31 8022           	LXI	SP,STACK
2333  2A B522           	LHLD	LSTDEV			; List Device
2336  EB                	XCHG
2337  FF 0A             	SCALL	.GDA			; Get it's address
2339  22 C823           	SHLD	LSTADR			; Set it

233C  3A C623           	LDA	SYSXITA
233F  A7                	ANA	A			; Do we have an Abort Exit ?
2340  C4 4B25           	CNZ	PRSCL			; Yes, Preset the Console
2343  CD CA23           	CALL	CCT			; Clear channel table
2346  CD A623           	CALL	SYSXIT1 		; Clear everything out
2349  CD 8D38           	CALL	SETDEV			; Set up default devices

234C  3A 7F00           	LDA	S.FLAG
234F  E6 80             	ANI	S.INIT			; See if we have been here before
2351  CA E647           	JZ	SYSINIT 		; No, initialize SYSCMD

2354  3A 7F00           	LDA	S.FLAG
2357  E6 28             	ANI	S.BREAK+S.BATCH 	; Have we been stopped ?
2359  FE 28             	CPI	S.BREAK+S.BATCH
235B  CA 5A2A           	JE	CCBAT1			; Yes, ask if Batch should stop

235E  3A C623           	LDA	SYSXITA
2361  A7                	ANA	A			; Do we have an Abort Exit ?
2362  C2 A125           	JNZ	BATOFF			; Yes, Insure Batch is Off

2365  C7                	RST	SYSCMD

                        ***	Patch Area

2366   (0000)           PATCH	DS	0
2366  0C0A5965 7420616E 	DB	FF,NL,'Yet another fine software product'
236E  6F746865 72206669
2376  6E652073 6F667477
237E  61726520 70726F64
2386  756374
2389  20666F72 20486561 	DB	' for Heath/Zenith computers',NL
2391  74682F5A 656E6974
2399  6820636F 6D707574
23A1  6572730A

                        	ERRMI	PATCH+64-*
23A5  AA                	DC	PATCH+64-*,#0AAH
      = 0040            PATCHL	EQU	*-PATCH

                        ***	SYSXIT1 - SET SYSTEM LOW MEMORY AND CLEAR DEVICE TABLE

      = 23A6            SYSXIT1 EQU	*

23A6  3A 1A21           	LDA	S.MOUNT
23A9  A7                	ANA	A
23AA  C8                	RZ				; System disk is not mounted

23AB  CD D123           	CALL	SSM			; Set system memory lower bound
23AE  EB                	XCHG				; (HL) = New S.SYSM
23AF  22 D020           	SHLD	S.SYSM			; Set System Lower Bound
23B2  CD 2E24           	CALL	CDT			; Clear Device Table

23B5  3E 02             	MVI	A,DR.PR 		; Mark as permanent
23B7  32 2430           	STA	L.ORI
23BA  C3 F52F           	JMP	LAD..			; Lock anything above S.RFWA & return

                        *	HDOS VERSION NOT CORRECT, OR ERROR UPON RETURN.

23BD  3E 28             SYSX1	MVI	A,EC.NCV		; Not correct version
23BF  26 0A             SYSX2	MVI	H,NL
23C1  FF 2F             	SCALL	.ERROR

      = 23C3            $FATAL	EQU	*			; Misc. Fatal error exit.

23C3  CD 0B21           	CALL	S.FASER 		; Bad, bad news!!

23C6  00                SYSXITA DB	0			; PSW VALUE UPON ENTRY
23C7                    	SPACE	4
                        ***	LSTJMP - System Listing Device
                        *

23C7  C3 0000           LSTJMP	JMP	*-*			; Go to driver
      = 23C8            LSTADR	EQU	*-2
23CA                    	STL	'SYSXIT Subroutines'
23CA                    	EJECT
23CA                    	XTEXT	CCT
                        ***	CCT - CLEAR CHANNEL TABLE.
                        *
                        *	CCT CLEARS OUT THE CHANNEL TABLE.
                        *
                        *	Entry:	NONE
                        *	Exit:	NONE
                        *	Uses:	ALL

23CA  FF 2E             CCT	SCALL	.CLEARA			; CLEAR ALL
23CC  3E FF             	MVI	A,-1
23CE  FF 2D             	SCALL	.CLEAR			; Load channel, too.
23D0  C9                	RET
23D1                    	SPACE	4,10
23D1                    	XTEXT	SSM
                        ***	SSM - SET SYSTEM MEMORY.
                        *
                        *	SSM SETS THE SYSTEM LOWER MEMORY BOUND DEPENDING UPON
                        *	LOCKED DEVICE DRIVERS & DIRECTORY DEVICE DRIVERS WITH
                        *	VOLUMES WHICH ARE CURRENTLY MOUNTED.
                        *
                        *	Entry:	NONE
                        *	Exit:	(DE) = NEW S.SYSM
                        *	Uses:	ALL

      = 23D1            SSM	EQU	*

23D1  01 0E00           	LXI	B,DEVELEN		; Device table entry length
23D4  2A EE20           	LHLD	S.RFWA
23D7  EB                	XCHG				; (DE) = System Resident FWA
23D8  2A EC20           	LHLD	S.DFWA			; (HL) = Device Table FWA
23DB  7E                SSM1	MOV	A,M
23DC  A7                	ANA	A			; End of table?
23DD  C8                	RZ				; Yep ...
23DE  FE 01             	CPI	DV.NU			; Entry empty?
23E0  CA 2A24           	JE	SSM4			; Yes, go do next.
23E3  CD 9646           	CALL	$INDLB			; Get driver residence flag
23E6  0200              	DW	DEV.RES
23E8  E6 01             	ANI	DR.IM			; In memory?
23EA  CA 2A24           	JZ	SSM4			; No.  Go do next.
23ED  CD 9646           	CALL	$INDLB			; Get residence flag back
23F0  0200              	DW	DEV.RES
23F2  E6 02             	ANI	DR.PR			; Is it locked?
23F4  C2 0A24           	JNZ	SSM2			; Yes.
23F7  CD 9646           	CALL	$INDLB			; Get driver flag byte
23FA  0600              	DW	DEV.FLG
23FC  E6 01             	ANI	DT.DD			; Directory device?
23FE  CA 2A24           	JZ	SSM4			; No.
2401  CD 9646           	CALL	$INDLB			; Get mounted unit mask
2404  0700              	DW	DEV.MUM
2406  A7                	ANA	A
2407  CA 2A24           	JZ	SSM4			; Nothing's mounted
240A  D5                SSM2	PUSH	D			; Save System RFWA
240B  CD 9C18           	CALL	$INDL			; Get Driver Address
240E  0400              	DW	DEV.DDA
2410  1B                	DCX	D			; Back up two bytes		/3.0a/
2411  1B                	DCX	D			;   to include S.SYSM pointer	/3.0a/
2412  E3                	XTHL				; (HL) = RFWA, Save table addr.
2413  CD FD44           	CALL	CPDEHL			; See if this device above RFWA
2416  DA 2824           	JC	SSM3			; This driver above RFWA

2419  E5                	PUSH	H			; Save pointers 		/3.0a/
241A  D5                	PUSH	D						;/
241B  21 8022           	LXI	H,USERFWA		; Get magic address		/
241E  EB                	XCHG								/
241F  CD FD44           	CALL	CPDEHL			; Is it below the beginning ?	/
2422  D1                	POP	D			; Restore pointers		/
2423  E1                	POP	H						;/
2424  DA 2824           	JC	SSM3			; Yes, leave us alone		/3.0a/

2427  EB                	XCHG				; (HL) = Driver addr.  (New RFWA)
2428  E3                SSM3	XTHL				; Put RFWA on stack, restore table addr.
2429  D1                	POP	D			; Restore RFWA into (DE)
242A  09                SSM4	DAD	B			; Find next device entry
242B  C3 DB23           	JMP	SSM1
242E                    	SPACE	4,10
242E                    	XTEXT	CDT2
                        ***	CDT - CLEAR DEVICE TABLE.
                        *
                        *	CDT CLEARS THE DEVICE TABLE.
                        *
                        *	NON-RESIDENT DEVICE DRIVERS ARE DISCARDED.
                        *	REQUESTED RESIDENT DEVICE DRIVERS ARE UNLOADED IF POSSIBLE.
                        *
                        *	Entry:	NONE
                        *	Exit:	NONE
                        *	Uses:	ALL

242E  2A EC20           CDT	LHLD	S.DFWA			; (HL) = DEVICE TABLE FWA
2431  7E                CDT1	MOV	A,M
2432  A7                	ANA	A
2433  CA 6D24           	JZ	CDT3			; END OF TABLE, TRY TO UNLOAD
2436  E5                	PUSH	H			; SAVE ADDRESS

                        *	Have Entry

2437  23                	INX	H
2438  23                	INX	H
2439  7E                	MOV	A,M			; (A) = DEV.RES
243A  E6 03             	ANI	DR.IM+DR.PR
243C  CA 6524           	JZ	CDT2			; No, go for next.
243F  E6 02             	ANI	DR.PR			; Locked?
2441  C2 6524           	JNZ	CDT2			; Yes.
2444  CD 9C18           	CALL	$INDL			; Get driver address
2447  0200              	DW	DEV.DDA-2
2449  1B                	DCX	D			; Back up over			/3.0a/
244A  1B                	DCX	D			;   S.SYSM pointer		/3.0a/
244B  E5                	PUSH	H			; Save address of Res. flag
244C  2A D020           	LHLD	S.SYSM
244F  CD FD44           	CALL	CPDEHL
2452  E1                	POP	H
2453  DA 6524           	JC	CDT2			; Driver > SYSM
2456  CA 6524           	JZ	CDT2			; Driver = SYSM

                        *	Driver is below S.SYSM so squash it.

2459  7E                	MOV	A,M			; (A) = Residence Code
245A  E6 FE             	ANI	377Q-DR.IM		; Remove 'In memory' flag
245C  77                	MOV	M,A
245D  11 0821           	LXI	D,S.SDD 		; Stand-in Driver
2460  CD A746           	CALL	$INDS			; Set it
2463  0200              	DW	DEV.DDA-2

                        *	Advance to next entry

2465  E1                CDT2	POP	H			; (HL) = ENTRY FWA
2466  11 0E00           	LXI	D,DEVELEN
2469  19                	DAD	D
246A  C3 3124           	JMP	CDT1			; DO IT AGAIN.

                        *	Unload any requested devices if they meet all requirements

246D  2A D020           CDT3	LHLD	S.SYSM
2470  EB                	XCHG
2471  2A EE20           	LHLD	S.RFWA
2474  CD 8E18           	CALL	$CDEHL
2477  C0                	RNE				; Pointers MUST match
2478  2A EC20           CDT4	LHLD	S.DFWA			; (HL) = Device Table
247B  7E                CDT5	MOV	A,M
247C  A7                	ANA	A
247D  C8                	RZ				; End of table
247E  FE 01             	CPI	DV.NU
2480  CA 3625           	JE	CDTX			; Entry not used
2483  44                	MOV	B,H
2484  4D                	MOV	C,L
2485  03                	INX	B
2486  03                	INX	B			; (BC) = DEV.RES
                        	ERRNZ	DEV.RES-DEV.NAM-2
2487  0A                	LDAX	B			; (A) = Residence code
2488  E6 04             	ANI	DR.FX
248A  C2 3625           	JNZ	CDTX			; Device is fixed
248D  0A                	LDAX	B			; (A) = Residence code
248E  E6 08             	ANI	DR.UNL
2490  CA 3625           	JZ	CDTX			; Not unloading this one anyhow
2493  CD 9646           	CALL	$INDLB
2496  0600              	DW	DEV.FLG 		; (A) = Flag byte
2498  E6 01             	ANI	DT.DD
249A  CA A624           	JZ	CDT6			; Go ahead, not DIR device
249D  CD 9646           	CALL	$INDLB
24A0  0700              	DW	DEV.MUM 		; (A) = Mounted unit mask
24A2  A7                	ANA	A
24A3  C2 3625           	JNZ	CDTX			; Something is mounted
24A6  E5                CDT6	PUSH	H
24A7  CD 9C18           	CALL	$INDL
24AA  0400              	DW	DEV.DDA 		; (DE) = Driver address
24AC  EB                	XCHG
24AD  22 CF24           	SHLD	OURDVD			; Save for possible driver call
24B0  EB                	XCHG
24B1  2A EE20           	LHLD	S.RFWA
24B4  23                	INX	H			; Skip over pointer
24B5  23                	INX	H			; (HL) = Lowest resident addr
24B6  CD 8E18           	CALL	$CDEHL
24B9  E1                	POP	H
24BA  C2 3625           	JNZ	CDTX			; NOT lowest resident thing

                        *	All tests have passed, so let's kick it out

24BD  CD 9646           	CALL	$INDLB			; Get device flag
24C0  0600              	DW	DEV.FLG
24C2  E6 80             	ANI	DT.UL			; Does it require notification ?
24C4  CA 0225           	JZ	CDT7			; No, just pitch it

24C7  3E 0C             	MVI	A,DC.UNL		; Yes, tell it what to expect
24C9  E5                	PUSH	H			; Save the
24CA  C5                	PUSH	B			;  good stuff
24CB  CD 3D25           	CALL	CC.OFF			; Prohibit control char.
24CE  CD 0000           	CALL	*-*			; Hey driver, guess what !?!
      = 24CF            OURDVD	EQU	*-2
24D1  F5                	PUSH	PSW
24D2  CD 4425           	CALL	CC.ON			; Allow control char.
24D5  F1                	POP	PSW
24D6  C1                	POP	B			; Restore the
24D7  E1                	POP	H			;  good stuff
24D8  D2 0225           	JNC	CDT7			; All is well !

24DB  F5                	PUSH	PSW
24DC  0A                	LDAX	B
24DD  E6 F7             	ANI	377Q-DR.UNL
24DF  02                	STAX	B			; Clear unload pending
24E0  CD 8918           	CALL	$HLIHL
24E3  22 EA24           	SHLD	CDTDV
24E6  CD 5E19           	CALL	$TYPTX
24E9  0A                	DB	NL
24EA  58583A20 2D20556E CDTDV	DB	'XX: - Unload Failed,',' '+200Q
24F2  6C6F6164 20466169
24FA  6C65642C A0
24FF  C3 5E25           	JMP	ERROR1

2502  11 0821           CDT7	LXI	D,S.SDD 		; (DE) = Stand-in driver addr
2505  CD A746           	CALL	$INDS
2508  0400              	DW	DEV.DDA 		; Poke it into table entry
250A  0A                	LDAX	B			; (A) = Residence code
250B  E6 F0             	ANI	377Q-DR.UNL-DR.FX-DR.PR-DR.IM
250D  02                	STAX	B			; Clear all known bits

250E  CD 8918           	CALL	$HLIHL			; Get device name
2511  22 1825           	SHLD	CDTDN			; Save it
2514  CD 5E19           	CALL	$TYPTX
2517  0A                	DB	NL
2518  58583A20 2D20556E CDTDN	DB	'XX: - Unloaded',ENL
2520  6C6F6164 65648A

2527  2A EE20           	LHLD	S.RFWA
252A  CD 8918           	CALL	$HLIHL			; (HL) = Previous S.RFWA
252D  22 EE20           	SHLD	S.RFWA			; Set new pointers
2530  22 D020           	SHLD	S.SYSM			;   to previous value
2533  C3 7824           	JMP	CDT4			; Try for another one

2536  01 0E00           CDTX	LXI	B,DEVELEN
2539  09                	DAD	B
253A  C3 7B24           	JMP	CDT5			; Try next entry
253D                    	SPACE	4,10
                        ***	PROHIBIT PROCESSING OF CTL-A, CTL-B, OR CTL-C

253D  E5                CC.OFF	PUSH	H
253E  2A E620           	LHLD	S.DLINK
2541  34                	INR	M
2542  E1                	POP	H
2543  C9                	RET

                        ***	ALLOW PROCESSING OF CTL-A, CTL-B, OR CTL-C

2544  E5                CC.ON	PUSH	H
2545  2A E620           	LHLD	S.DLINK
2548  35                	DCR	M
2549  E1                	POP	H
254A  C9                	RET
254B                    	SPACE	4,10
254B                    	XTEXT	PRSCL
                        ***	PRSCL - PRESET CONSOLE.
                        *
                        *	PRSCL PRESETS THE CONSOLE UART, SETS THE DEFAULT CONTROL PARAMETERS,
                        *	AND CLEARS THE TYPE-AHEAD BUFFER.
                        *
                        *	Entry:	NONE
                        *	Exit:	NONE
                        *	Uses:	ALL

254B  11 5454           PRSCL	LXI	D,'TT'
254E  FF 0A             	SCALL	.GDA
2550  3E 0E             	MVI	A,DC.DSF
2552  CD 6C32           	CALL	$PCHL

2555  CD 5E19           	CALL	$TYPTX
2558  87                	DB	BELL+200Q
2559  C9                	RET
255A                    	STL	'COMMAND PROCESSOR'
255A                    	EJECT
                        ***	SYSCMD/plus - SYSTEM COMMAND PROCESSOR.

255A  F5                ERROR	PUSH	PSW			; SAVE ERROR CODE.
255B  CD 4746           	CALL	$GNL
255E  FF 07             ERROR1	SCALL	.CLRCO			; CLEAR BUFFER & CTL/O
2560  F1                	POP	PSW
2561  26 07             	MVI	H,BELL
2563  FF 2F             	SCALL	.ERROR
2565  CD 6C25           	CALL	BATBIT			; BATCH = OFF, ECHO = ON
2568  AF                	XRA	A
2569  C3 CD22           	JMP	SYSXIT

256C  3A 7F00           BATBIT	LDA	S.FLAG
256F  E6 D3             	ANI	377Q-S.BATCH-S.ECHO-S.BREAK	; BATCH = OFF, ECHO = ON
2571  32 7F00           	STA	S.FLAG			; Clear Break Bit Also
2574  AF                	XRA	A
2575  32 BA22           	STA	NULFLG			; Reset NUL flag
2578  C9                	RET

2579  CD 5E19           ILLCOM	CALL	$TYPTX
257C  0A07              	DB	NL,BELL
257E  496C6C65 67616C20 	DB	'Illegal Comman','d'+200Q
2586  436F6D6D 616EE4
258D  C9                	RET

258E  CD 7925           ILLSYN	CALL	ILLCOM
2591  CD 5E19           	CALL	$TYPTX
2594  2053796E 7461F8   	DB	' Synta','x'+200Q
259B  C3 A125           	JMP	BATOFF

259E  CD 7925           ILLCMD	CALL	ILLCOM
                        *	JMP	BATOFF
                        	ERRNZ	*-BATOFF

25A1  CD 6C25           BATOFF	CALL	BATBIT			; BATCH = OFF, ECHO = ON

      = 25A4            SYSCMD. EQU	*

25A4  3A BA22           	LDA	NULFLG
25A7  A7                	ANA	A
25A8  C4 6C25           	CNZ	BATBIT			; BATCH = OFF, ECHO = ON

25AB  CD A623           	CALL	SYSXIT1 		; Tidy up while we're at it

25AE  3A A822           	LDA	ULTRA			; Do we have an Ultra ROM ?
25B1  A7                	ANA	A
25B2  CA DF25           	JZ	CCBJ			; No, move along

25B5  3A BB22           	LDA	H19FLG			; Do we have H19 ?
25B8  A7                	ANA	A
25B9  CA DF25           	JZ	CCBJ			; No, move along

25BC  3A CD20           	LDA	S.CLKTR 		; Is system clock task resident ?
25BF  A7                	ANA	A
25C0  CA DF25           	JZ	CCBJ			; No, move along

25C3  3E 8D             	MVI	A,CR+200Q		; Required CR at end
25C5  32 2A31           	STA	ENDTIM
25C8  3A D820           	LDA	S.CUSOR 		; Get current cursor position
25CB  F5                	PUSH	PSW			;  and save it
25CC  CD 5E19           	CALL	$TYPTX
25CF  1B6A              	DB	ESC,'j' 		; Save cursor position
25D1  1BD8              	DB	ESC,'X'+200Q		; Tell ultra what's coming
25D3  CD 1431           	CALL	DISPLA. 		; Send time to ultra
25D6  CD 5E19           	CALL	$TYPTX
25D9  1BEB              	DB	ESC,'k'+200Q		; Restore cursor position
25DB  F1                	POP	PSW			; Get previous cursor position
25DC  32 D820           	STA	S.CUSOR 		;  and restore it

25DF  21 552A           CCBJ	LXI	H,CCBAT0		; Becomes JMP CCBAT0 if ^C hit

25E2  3A 7F00           	LDA	S.FLAG
25E5  E6 08             	ANI	S.BATCH 		; In Batch Mode ?
25E7  C2 FB25           	JNZ	S.CMD.			; Yes

25EA  21 3E2A           	LXI	H,CCHIT
25ED  3E 03             	MVI	A,CTLC
25EF  FF 21             	SCALL	.CTLC			; SET UP CTL/C PROCESSOR

25F1  21 933F           	LXI	H,EDLINE
25F4  3E 01             	MVI	A,CTLA
25F6  FF 21             	SCALL	.CTLC			; Set up CTL/A processor

25F8  C3 0926           	JMP	S.CMD

25FB  21 4F2A           S.CMD.	LXI	H,CCBAT
25FE  3E 03             	MVI	A,CTLC
2600  FF 21             	SCALL	.CTLC			; Reassign Ctl-C

2602  21 0000           	LXI	H,0
2605  3E 01             	MVI	A,CTLA
2607  FF 21             	SCALL	.CTLC			; Disable Ctl-A

2609  3A 7F00           S.CMD	LDA	S.FLAG
260C  F6 01             	ORI	S.SYSCM 		; Flag SYSCMD.SYS as here
260E  E6 DF             	ANI	377Q-S.BREAK		; Insure Break Bit is Clear
2610  32 7F00           	STA	S.FLAG

2613  E6 04             	ANI	S.ECHO			; Is ECHO off ?
2615  CC 4746           	CZ	$GNL			; No, guarantee new line

2618  21 A425           	LXI	H,SYSCMD.		; Set Up RESTART 0 Vector
261B  22 0100           	SHLD	B.INT0+1		; Force SYSCMD. after JMP

261E  31 8022           	LXI	SP,STACK
2621  CD A72A           	CALL	TT.CCM			; CLEAR SPECIAL CONSOLE MODES
2624  CD F044           	CALL	$CCO			; CLEAR CTL/O

2627  CD 8646           	CALL	HLDSCR2 		; Clear hold screen mode on H19

262A  3A 7F00           	LDA	S.FLAG			; Is type-ahead buffer stuffed
262D  E6 44             	ANI	S.TABUF+S.ECHO		; or is ECHO off?
262F  CC F042           	CZ	PROM$$			; No, show PROMPT

2632  3A 7F00           	LDA	S.FLAG
2635  E6 BF             	ANI	377Q-S.TABUF		; Clear Buffer Stuffed Flag
2637  32 7F00           	STA	S.FLAG

263A  AF                	XRA	A
263B  32 B922           	STA	ALTFLG			; Assume command will be for Pri. Dev.
263E  32 283A           	STA	B.CNT			; Initialize BATCH byte count

2641  21 7F80           	LXI	H,LINE
2644  CD 0B47           	CALL	$RTL			; READ COMMAND LINE (NO CASE MAPPING)
2647  DA A425           	JC	SYSCMD. 		; CTL/D STRUCK
264A  2B                PROMZ	DCX	H
264B  36 20             	MVI	M,' '			; Init *LINE* in case your command
264D  23                	INX	H			;   is 'n:filename'

264E  3A 7F00           	LDA	S.FLAG
2651  E6 08             	ANI	S.BATCH 	;: In Batch Mode ?
2653  C2 6226           	JNZ	PROMZZ			; Yes, skip command move

2656  EB                	XCHG				; DE=>Command
2657  2A 5E00           	LHLD	S.EDLIN 		; HL=>Buffer
265A  1A                PROMZL	LDAX	D			; Move command to buffer ...
265B  77                	MOV	M,A
265C  23                	INX	H
265D  13                	INX	D
265E  B7                	ORA	A
265F  C2 5A26           	JNZ	PROMZL			; ... until a NULL byte

2662  21 7F80           PROMZZ	LXI	H,LINE
2665  CD 5647           	CALL	$SOB
2668  FE 3A             	CPI	':'			; If first non-white char is ':'
266A  CA A425           	JE	SYSCMD. 		;  then it is a label, skip over it
266D  CD 5647           PROM1	CALL	$SOB			; Skip over leading spaces, tabs, etc.
2670  FE 2E             	CPI	'.'			; Do we clear and hold ?
      = 2671            CLRCHR	EQU	*-1
2672  C2 8026           	JNE	PROM2			; No
2675  36 20             	MVI	M,' '			; Yes, blank '.'
2677  CD 5346           	CALL	CLRSCRN 		; Clear screen
267A  CD 7A46           	CALL	HLDSCRN 		; Hold screen mode
267D  CD 5647           	CALL	$SOB			; Get next non-blank
2680  FE 3B             PROM2	CPI	';'			; Is for alternate device?
      = 2681            ALTCHR	EQU	*-1
2682  C2 8D26           	JNE	SYSC0			; No
2685  36 20             	MVI	M,' '			; Yes, blank ';'
2687  32 B922           	STA	ALTFLG			; Set for alternate
268A  C3 6D26           	JMP	PROM1			; Check '.' in case wasn't first

268D  E5                SYSC0	PUSH	H			; Save command address

                        *	ADD DEVICE NAME TO 'n:' UNLESS PREVIOUS CHAR IS ALPHA OR NUM

268E  2B                	DCX	H			; Pre-decrement
268F  23                PARSE	INX	H			; Advance
2690  7E                	MOV	A,M
2691  A7                	ANA	A			; Is it null ?
2692  CA 0527           	JZ	SYSCX			; At end of line, carry on
2695  FE 3A             	CPI	':'
2697  C2 8F26           	JNE	PARSE			; Not a device delimiter
269A  E5                	PUSH	H
269B  2B                	DCX	H
269C  7E                	MOV	A,M			; Get char before ':'
269D  FE 30             	CPI	'0'
269F  DA E126           	JC	PARSE2			; < '0', Not valid unit #
26A2  FE 38             	CPI	'7'+1
26A4  D2 E126           	JNC	PARSE2			; > '7', Not valid unit #
26A7  2B                	DCX	H
26A8  7E                	MOV	A,M			; Get char before unit #
26A9  CD D846           	CALL	$MCU			; Map char to upper case
26AC  FE 30             	CPI	'0'
26AE  DA C026           	JC	PARSE1			; Is probably a file name
26B1  FE 3A             	CPI	':'
26B3  DA E126           	JC	PARSE2			; Is a digit, skip it
26B6  FE 41             	CPI	'A'
26B8  DA C026           	JC	PARSE1			; Is probably a file name
26BB  FE 5B             	CPI	'['
26BD  DA E126           	JC	PARSE2			; Is alpha, skip it
26C0  23                PARSE1	INX	H			; Point at unit #
26C1  54                	MOV	D,H
26C2  5D                	MOV	E,L			; Save source pointer
26C3  23                	INX	H
26C4  23                	INX	H			; Bump destination pointer
26C5  E5                	PUSH	H
26C6  44                	MOV	B,H
26C7  4D                	MOV	C,L			; BC = pointer
26C8  CD 0C42           	CALL	FEC			; HL => FINAL 0 BYTE
26CB  23                	INX	H			; Bump for accurate count
26CC  7D                	MOV	A,L			; Subtract BC from HL
26CD  93                	SUB	E
26CE  4F                	MOV	C,A			; Save result in BC
26CF  7C                	MOV	A,H
26D0  9A                	SBB	D
26D1  47                	MOV	B,A			; BC = count
26D2  E1                	POP	H
26D3  CD AA18           	CALL	$MOVE			; Spread out to add 2 chars
26D6  E1                	POP	H			; HL => where ':' was
26D7  E5                	PUSH	H
26D8  2B                	DCX	H			; Back up to where unit # was
26D9  EB                	XCHG				; Save HL
26DA  CD BE2D           	CALL	GETDEV
26DD  EB                	XCHG				; (DE) = device name, (HL) = pointer
26DE  CD D346           	CALL	ISDEHL
26E1  E1                PARSE2	POP	H
26E2  C3 8F26           	JMP	PARSE			; Keep looking

26E5  21 0780           CRACK	LXI	H,VERB			; Crack command name
26E8  1A                SYSC1	LDAX	D
26E9  FE 2E             	CPI	'.'
26EB  CA FF26           	JZ	SYSC2			; Valid file specification character
26EE  FE 30             	CPI	'0'
26F0  D8                	RC				; < '0' and not '.'
26F1  FE 3B             	CPI	':'+1
26F3  DA FF26           	JC	SYSC2			; Numeric, or ':'
26F6  CD D846           	CALL	$MCU			; Map character to upper case
26F9  FE 3F             	CPI	'A'-2
26FB  D8                	RC				; Not alpha, num.,':','.','?', or '@'
26FC  FE 5B             	CPI	'Z'+1
26FE  D0                	RNC				; Not alpha

                        *	HAVE ALPHA CHARACTER, BUILD INTO COMMAND VERB

26FF  77                SYSC2	MOV	M,A
2700  23                	INX	H
2701  13                	INX	D
2702  C3 E826           	JMP	SYSC1

      = 2705            SYSCX	EQU	*

                        *	CRACK COMMAND NAME

2705  3E 80             	MVI	A,200Q
2707  32 0680           	STA	VERB-1			; REQUIRED BY VERB SCANNING
270A  D1                	POP	D			; Retrieve line address

270B  CD E526           	CALL	CRACK			; Do the cracking

                        *	HAVE SPLIT OUT THE VERB.  SEE IF WE KNOW IT.

270E  D5                SYSC3	PUSH	D			; SAVE LINE POINTER
270F  36 00             	MVI	M,0			; FORCE END OF VERB
2711  2B                	DCX	H
2712  7E                	MOV	A,M
2713  EE 80             	XRI	200Q			; SET END OF WORD
2715  F2 A425           	JP	SYSCMD. 		; NULL COMMAND

                        *	SEE IF WE KNOW THIS COMMAND

2718  11 0780           	LXI	D,VERB
271B  21 C528           	LXI	H,SYSCC
271E  CD E845           	CALL	$FST
2721  C2 9627           	JNZ	SYSC5			; NOT BUILT-IN COMMAND
2724  7E                	MOV	A,M			; (A) = INDEX
2725  CD 3119           	CALL	$TJMP			; ENTER PROCESSOR

2728                    	STL	'COMMAND PROCESSOR TABLES'
2728                    	EJECT
2728   (0000)           SYSCA	DS	0

      = 0000            I.RUN	EQU	*-SYSCA/2
2728  AE2A              	DW	RUN

      = 0001            I.HEL	EQU	*-SYSCA/2
272A  CF2A              	DW	HELP

      = 0002            I.PRN	EQU	*-SYSCA/2
272C  F52A              	DW	PRINT

      = 0003            I.TYP	EQU	*-SYSCA/2
272E  312B              	DW	TYPE

      = 0004            I.CLS	EQU	*-SYSCA/2
2730  652B              	DW	CLS

      = 0005            I.DEL	EQU	*-SYSCA/2
2732  692B              	DW	DELETE

      = 0006            I.PLO	EQU	*-SYSCA/2
2734  C531              	DW	PICLOA

      = 0007            I.LOG	EQU	*-SYSCA/2
2736  6D32              	DW	TOGLOG

      = 0008            I.TIM	EQU	*-SYSCA/2
2738  7830              	DW	TIME

      = 0009            I.CHK	EQU	*-SYSCA/2
273A  492E              	DW	CHECK

      = 000A            I.REN	EQU	*-SYSCA/2
273C  892B              	DW	RENAME

      = 000B            I.MOU	EQU	*-SYSCA/2
273E  982C              	DW	MOUNT

      = 000C            I.MN	EQU	*-SYSCA/2
2740  B22C              	DW	MN

      = 000D            I.DMO	EQU	*-SYSCA/2
2742  9D2C              	DW	DMOUNT

      = 000E            I.DN	EQU	*-SYSCA/2
2744  B72C              	DW	DN

      = 000F            I.RES	EQU	*-SYSCA/2
2746  A22C              	DW	RESET

      = 0010            I.RN	EQU	*-SYSCA/2
2748  BC2C              	DW	RN

      = 0011            I.QM	EQU	*-SYSCA/2
274A  DB2C              	DW	XQMNT

      = 0012            I.MM	EQU	*-SYSCA/2
274C  DE2C              	DW	XMNT

      = 0013            I.MD	EQU	*-SYSCA/2
274E  502D              	DW	XDMNT

      = 0014            I.DAT	EQU	*-SYSCA/2
2750  2E30              	DW	DATE

      = 0015            I.DIR	EQU	*-SYSCA/2
2752  B42B              	DW	DIR

      = 0016            I.CN	EQU	*-SYSCA/2
2754  C92B              	DW	CN

      = 0017            I.PCN	EQU	*-SYSCA/2
2756  EC2B              	DW	PCN

      = 0018            I.DEV	EQU	*-SYSCA/2
2758  4536              	DW	DEVICE

      = 0019            I.DMM	EQU	*-SYSCA/2
275A  9232              	DW	DMM

      = 001A            I.COP	EQU	*-SYSCA/2
275C  A72B              	DW	COPY

      = 001B            I.BYE	EQU	*-SYSCA/2
275E  A239              	DW	BYE

      = 001C            I.VER	EQU	*-SYSCA/2
2760  692E              	DW	VERSN

      = 001D            I.VERX	EQU	*-SYSCA/2
2762  6D2E              	DW	VERSNX

      = 001E            I.LOA	EQU	*-SYSCA/2
2764  142F              	DW	LOADD

      = 001F            I.FLO	EQU	*-SYSCA/2
2766  172F              	DW	FLOADD

      = 0020            I.UNL	EQU	*-SYSCA/2
2768  3B2F              	DW	UNLOAD

      = 0021            I.DEF	EQU	*-SYSCA/2
276A  D137              	DW	DEFAULT

      = 0022            I.CLR	EQU	*-SYSCA/2
276C  A531              	DW	CLR

      = 0023            I.PIP	EQU	*-SYSCA/2
276E  3942              	DW	PIPX

      = 0024            I.VFY	EQU	*-SYSCA/2
2770  C938              	DW	VERIFY

      = 0025            I.PRM	EQU	*-SYSCA/2
2772  1939              	DW	PROMPT

      = 0026            I.PTH	EQU	*-SYSCA/2
2774  5C39              	DW	PATH

      = 0027            I.ASK	EQU	*-SYSCA/2
2776  333C              	DW	ASK

      = 0028            I.BIT	EQU	*-SYSCA/2
2778  C43C              	DW	BIT

      = 0029            I.COU	EQU	*-SYSCA/2
277A  843C              	DW	COUNT

      = 002A            I.ECH	EQU	*-SYSCA/2
277C  E23B              	DW	ECHO

      = 002B            I.END	EQU	*-SYSCA/2
277E  8F3F              	DW	END

      = 002C            I.GOT	EQU	*-SYSCA/2
2780  1E3D              	DW	GOTO

      = 002D            I.JMP	EQU	*-SYSCA/2
2782  213D              	DW	JUMP

      = 002E            I.IF	EQU	*-SYSCA/2
2784  CB3D              	DW	IF

      = 002F            I.PAU	EQU	*-SYSCA/2
2786  303C              	DW	PAUSE

      = 0030            I.REM	EQU	*-SYSCA/2
2788  2E3C              	DW	REM

      = 0031            I.SHF	EQU	*-SYSCA/2
278A  7E3C              	DW	SHIFT

      = 0032            I.WAIT	EQU	*-SYSCA/2
278C  5E3F              	DW	WAIT

      = 0033            I.XYZZY EQU	*-SYSCA/2
278E  FC39              	DW	XYZZY

      = 0034            I.SI	EQU	*-SYSCA/2
2790  0034              	DW	SI

                        *	Extra room for expansion

2792  C323              	DW	$FATAL
2794  C323              	DW	$FATAL

                        *	Can't find the command in the 'built-in' list.
                        *	Try to link to it.

2796  CD F146           SYSC5	CALL	$MOVEL			; Preset default
2799  06008922 0080     	DW	6,SYSCB,SYSBLK
279F  C1                SYSC5.	POP	B			; (BC) = START OF PARAMETERS
27A0  CD 1542           	CALL	PCL			; PASS COMMAND LINE ON STACK
27A3  2A 5A00           	LHLD	S.PATH
27A6  22 C328           	SHLD	PTHPTR			; Preset pointer
27A9  CD B242           	CALL	SCGONE			; Flag SYSCMD.SYS as gone

27AC  21 7F80           SYSC6	LXI	H,LINE			; File name
27AF  11 0080           	LXI	D,SYSBLK		; Default
27B2  AF                	XRA	A			; Channel
27B3  FF 20             	SCALL	.LINK			; Try to LINK to it

                        *	File could not be linked to so we assume it isn't there and try
                        *	the next PATH entry.

27B5  CD 5C28           	CALL	PATH..			; Do error check first
27B8  C2 AC27           	JNZ	SYSC6			; Try again

                        *	Maybe he wants a BATCH file ?

27BB  21 A425           	LXI	H,SYSCMD.		; Set Up RESTART 0 Vector
27BE  22 0100           	SHLD	B.INT0+1		; Force SYSCMD. after JMP

27C1  2A 5A00           	LHLD	S.PATH
27C4  22 C328           	SHLD	PTHPTR			; Preset pointer
27C7  CD F146           	CALL	$MOVEL
27CA  06009522 0080     	DW	6,BATBLK,SYSBLK 	; Preset default

27D0  21 7F80           SYSC9	LXI	H,LINE			; File name
27D3  11 0080           	LXI	D,SYSBLK		; Default
27D6  AF                	XRA	A			; Channel
27D7  FF 22             	SCALL	.OPENR			; Open for read
27D9  D2 E527           	JNC	SYSC12			; It worked !

                        *	File could not be opened so we assume it isn't there and try
                        *	the next PATH entry.

27DC  CD 5C28           	CALL	PATH..			; Do error check first
27DF  C2 D027           	JNZ	SYSC9			; Try again

27E2  C3 9E25           	JMP	ILLCMD			; Absolutely NO idea what you want !

27E5  E5                SYSC12	PUSH	H			; HL advanced past file name
27E6  2A 4221           	LHLD	AIO.DIR+DIR.FGN 	; Get FGN and LGN of BATCH file
27E9  22 5200           	SHLD	BATGNS			;  and save it
27EC  AF                	XRA	A			; Get complete file name
27ED  21 E480           	LXI	H,LABEL 		;  in a known format
27F0  11 F880           	LXI	D,LABEL+20
27F3  FF 2C             	SCALL	.NAME
27F5  DA 5A25           	JC	ERROR

27F8  CD F146           	CALL	$MOVEL			; Preset BATCH file name
27FB  0300F880 4000     	DW	3,LABEL+20,BATNAME
2801  36 3A             	MVI	M,':'			; Force colon
2803  23                	INX	H
2804  11 E480           	LXI	D,LABEL
2807  CD 0345           	CALL	$CPF
280A  36 2E             	MVI	M,'.'			; Force dot
280C  23                	INX	H			; To
280D  11 FB80           	LXI	D,LABEL+23		; From
2810  01 0300           	LXI	B,3			; Count
2813  CD AA18           	CALL	$MOVE
2816  AF                	XRA	A
2817  77                	MOV	M,A			; Force final null
2818  32 5100           	STA	BATSEC			; Preset secter index
281B  32 BA22           	STA	NULFLG			; Preset NUL flag
281E  32 6100           	STA	S.SHIFT 		; Zero SHIFT count

2821  CD 4D3B           	CALL	B.R1			; Read first sector

2824  2A 5400           	LHLD	BATBUF			; Point at buffer
2827  0E 00             	MVI	C,0			; Count = 256
2829  7E                SYSC20	MOV	A,M			; Get byte
282A  E6 80             	ANI	200Q			; See if hi bit set
282C  3E 10             	MVI	A,EC.IFC		; Assume error
282E  C2 5A25           	JNZ	ERROR			; Hi bit set, NOT ascii
2831  23                	INX	H			; Bump pointer
2832  0D                	DCR	C			; Count down
2833  C2 2928           	JNZ	SYSC20			; Try next byte

2836  E1                	POP	H			; Pass BATCH argument line
2837  CD 5647           	CALL	$SOB
283A  EB                	XCHG				; (DE) = Argument string
283B  2A 5800           	LHLD	SUBBUF			; (HL) = Subst. buffer
283E  1A                PBCL	LDAX	D
283F  77                	MOV	M,A			; If NUL is first thing
2840  13                	INX	D			;   then NO arguments
2841  23                	INX	H
2842  A7                	ANA	A
2843  C2 3E28           	JNZ	PBCL			; Loop til NUL

2846  3A 7F00           	LDA	S.FLAG
2849  F6 08             	ORI	S.BATCH
284B  32 7F00           	STA	S.FLAG			; Turn on batch processing

284E  21 293A           	LXI	H,B.BAT
2851  22 0A3A           	SHLD	B.XXX			; Preset logic to normal input

2854  3A A222           	LDA	ECOFLG			; See if we want ECHO OFF
2857  A7                	ANA	A
2858  C2 0E3C           	JNZ	ECHOFF			; Yes, go through ECHO routine

285B  C7                	RST	SYSCMD			; No, just start going
285C                    	SPACE	4,10
                        *	Follow the path

285C  FE 0C             PATH..	CPI	EC.FNF			; First be sure we are not in
285E  CA 8728           	JE	PATH.X			;  trouble
2861  FE 1B             	CPI	EC.UUN
2863  CA 8728           	JE	PATH.X
2866  F5                	PUSH	PSW
2867  2A C328           	LHLD	PTHPTR
286A  EB                	XCHG
286B  2A 5A00           	LHLD	S.PATH
286E  CD 8E18           	CALL	$CDEHL			; If first pass then not PATH'S fault
2871  CA 5E25           	JE	ERROR1
2874  CD 5E19           	CALL	$TYPTX
2877  43686563 6B205061 	DB	'Check Path -',' '+200Q
287F  7468202D A0
2884  C3 5E25           	JMP	ERROR1

2887  2A C328           PATH.X	LHLD	PTHPTR

                        *	Skip over path delimiters

288A  2B                SKPD	DCX	H			; Predecrement
288B  23                SKPD1	INX	H			; Bump pointer
288C  7E                	MOV	A,M			; Get char
288D  FE 20             	CPI	' '
288F  CA 8B28           	JE	SKPD1			; Skip space
2892  FE 09             	CPI	TAB
2894  CA 8B28           	JE	SKPD1			; Skip tab
2897  FE 3A             	CPI	':'
2899  CA 8B28           	JE	SKPD1			; Skip colon
289C  FE 3B             	CPI	';'
289E  CA 8B28           	JE	SKPD1			; Skip semi
28A1  FE 2C             	CPI	','
28A3  CA 8B28           	JE	SKPD1			; Skip comma

28A6  11 0080           	LXI	D,SYSBLK
28A9  0E 03             	MVI	C,3
28AB  7E                PATH.0	MOV	A,M			; Get char
28AC  A7                	ANA	A			; Test for NUL
28AD  C8                	RZ				; At end of path
28AE  12                	STAX	D			; Stuff it
28AF  23                	INX	H			; Bump *from*
28B0  13                	INX	D			; Bump *to*
28B1  0D                	DCR	C			; Count down
28B2  C2 AB28           	JNZ	PATH.0
28B5  FE 3A             	CPI	':'			; If third char is ':' ...
28B7  C2 BE28           	JNE	PATH.1
28BA  3E 30             	MVI	A,'0'
28BC  1B                	DCX	D
28BD  12                	STAX	D			; ... then it should be '0'
28BE  22 C328           PATH.1	SHLD	PTHPTR
28C1  A7                	ANA	A			; Turn off zero flag bit
28C2  C9                	RET

28C3  0000              PTHPTR	DW	0
28C5                    	EJECT
                        ***	COMMAND TABLE.
                        *
                        *	DATA VALUES ARE INDEXES INTO SYSCA.

      = 0080            .	SET	200Q			; Parity bit (designates optional)
      = 007F            $	EQU	177Q			; Any numeric (0-7) character
      = 2945            $$	EQU	$+.			; Optional numeric (0-7) character

      = 28C5            SYSCC	EQU	*

28C5  3FBFBF80 01       	DB	'?','?'+.,'?'+.,.,I.HEL
28CA  4153CB80 27       	DB	'AS','K'+.,.,I.ASK
28CF  42495480 28       	DB	'BIT',.,I.BIT
28D4  42594580 1B       	DB	'BYE',.,I.BYE
28D9  43C1D480 15       	DB	'C','A'+.,'T'+.,.,I.DIR
28DE  43DE8016          	DB	'C',$,.,I.CN				; sequence sensitive
28E2  4348C5C3 CB8009   	DB	'CH','E'+.,'C'+.,'K'+.,.,I.CHK
28E9  434C5280 22       	DB	'CLR',.,I.CLR
28EE  434C5380 04       	DB	'CLS',.,I.CLS
28F3  434F55CE D48029   	DB	'COU','N'+.,'T'+.,.,I.COU
28FA  434FD0D9 801A     	DB	'CO','P'+.,'Y'+.,.,I.COP
2900  43524380 09       	DB	'CRC',.,I.CHK
2905  44C9D3CD CFD5CED4 	DB	'D','I'+.,'S'+.,'M'+.,'O'+.,'U'+.,'N'+.,'T'+.,.,I.DMO
290D  800D
290F  4445800E          	DB	'D',$$,.,I.DN				; sequence sensitive
2913  4441D4C5 8014     	DB	'DA','T'+.,'E'+.,.,I.DAT
2919  444546C1 D5CCD480 	DB	'DEF','A'+.,'U'+.,'L'+.,'T'+.,.,I.DEF
2921  21
2922  44454CC5 D4C58005 	DB	'DEL','E'+.,'T'+.,'E'+.,.,I.DEL
292A  444556C9 C3C5D380 	DB	'DEV','I'+.,'C'+.,'E'+.,'S'+.,.,I.DEV
2932  18
2933  44495280 15       	DB	'DIR',.,I.DIR
2938  444DCD80 19       	DB	'DM','M'+.,.,I.DMM
293D  4543C8CF 802A     	DB	'EC','H'+.,'O'+.,.,I.ECH
2943  454E4480 2B       	DB	'END',.,I.END
2948  455241D3 C58005   	DB	'ERA','S'+.,'E'+.,.,I.DEL
294F  464CC1C7 D3801A   	DB	'FL','A'+.,'G'+.,'S'+.,.,I.COP
2956  474FD4CF 802C     	DB	'GO','T'+.,'O'+.,.,I.GOT
295C  48C5CCD0 8001     	DB	'H','E'+.,'L'+.,'P'+.,.,I.HEL
2962  4944801D          	DB	'ID',.,I.VERX
2966  4946802E          	DB	'IF',.,I.IF
296A  4A55CDD0 802D     	DB	'JU','M'+.,'P'+.,.,I.JMP
2970  4CCFC1C4 801E     	DB	'L','O'+.,'A'+.,'D'+.,.,I.LOA
2976  4C4F4144 46801F   	DB	'LOADF',.,I.FLO
297D  4C49D3D4 8003     	DB	'LI','S'+.,'T'+.,.,I.TYP
2983  4C4F4780 07       	DB	'LOG',.,I.LOG
2988  4DCFD5CE D4800B   	DB	'M','O'+.,'U'+.,'N'+.,'T'+.,.,I.MOU
298F  4D45800C          	DB	'M',$$,.,I.MN				; sequence sensitive
2993  4D448013          	DB	'MD',.,I.MD
2997  4D4D8012          	DB	'MM',.,I.MM
299B  5041D4C8 8026     	DB	'PA','T'+.,'H'+.,.,I.PTH
29A1  504155D3 C5802F   	DB	'PAU','S'+.,'E'+.,.,I.PAU
29A8  50434580 17       	DB	'PC',$$,.,I.PCN
29AD  50495080 23       	DB	'PIP',.,I.PIP
29B2  5052C9CE D48002   	DB	'PR','I'+.,'N'+.,'T'+.,.,I.PRN
29B9  50524FCD D0D48025 	DB	'PRO','M'+.,'P'+.,'T'+.,.,I.PRM
29C1  514D8011          	DB	'QM',.,I.QM
29C5  51D5C9D4 801B     	DB	'Q','U'+.,'I'+.,'T'+.,.,I.BYE
29CB  52454D80 30       	DB	'REM',.,I.REM
29D0  52C5D3C5 D4800F   	DB	'R','E'+.,'S'+.,'E'+.,'T'+.,.,I.RES
29D7  52458010          	DB	'R',$$,.,I.RN				; sequence sensitive
29DB  52454EC1 CDC5800A 	DB	'REN','A'+.,'M'+.,'E'+.,.,I.REN
29E3  5255CE80 00       	DB	'RU','N'+.,.,I.RUN
29E8  5348C9C6 D48031   	DB	'SH','I'+.,'F'+.,'T'+.,.,I.SHF
29EF  53498034          	DB	'SI',.,I.SI
29F3  5354C1D2 D48006   	DB	'ST','A'+.,'R'+.,'T'+.,.,I.PLO
29FA  5449CDC5 8008     	DB	'TI','M'+.,'E'+.,.,I.TIM
2A00  54D9D0C5 8003     	DB	'T','Y'+.,'P'+.,'E'+.,.,I.TYP
2A06  554E4CCF C1C48020 	DB	'UNL','O'+.,'A'+.,'D'+.,.,I.UNL
                        	IF	USER
                        	ENDIF
2A0E  564552D3 C9CFCE80 	DB	'VER','S'+.,'I'+.,'O'+.,'N'+.,.,I.VER
2A16  1C
2A17  56455249 C6D98024 	DB	'VERI','F'+.,'Y'+.,.,I.VFY
2A1F  57414954 8032     	DB	'WAIT',.,I.WAIT
2A25  58595A5A 598033   	DB	'XYZZY',.,I.XYZZY

2A2C  0000              	DB	0,0

2A2E  00000000 00000000 	DW	0,0,0,0,0,0,0,0
2A36  00000000 00000000
2A3E                    	SPACE	4,10
                        ***	CCHIT - CTL/C PROCESSOR.
                        *
                        *	Note:	The stack is re-initialized because if the console is
                        *		running slow (300 baud), multiple CTL/C's can overrun
                        *		the stack due to the time required to actually print
                        *		'^C'.  This problem can (and WILL) result in a system
                        *		crash!

2A3E  31 8022           CCHIT	LXI	SP,STACK		; Set stack anew ...
2A41  FF 07             	SCALL	.CLRCO			; CLEAR BUFFER
2A43  CD 5E19           	CALL	$TYPTX
2A46  5EC3              	DB	'^','C'+200Q
2A48  CD CA23           	CALL	CCT			; No channels open, please ...
2A4B  CD A623           	CALL	SYSXIT1 		; Clear device table
2A4E  C7                	RST	SYSCMD
2A4F                    	SPACE	4,10
                        ***	CCBAT - CTL/C PROCESSOR FOR BATCH MODE

2A4F  3E C3             CCBAT	MVI	A,303Q			; JMP code
2A51  32 DF25           	STA	CCBJ			; Force jump to CCBAT0
2A54  C9                	RET

2A55  CD 5E19           CCBAT0	CALL	$TYPTX
2A58  5EC3              	DB	'^','C'+200Q

2A5A  21 0000           CCBAT1	LXI	H,0
2A5D  3E 03             	MVI	A,CTLC
2A5F  FF 21             	SCALL	.CTLC			; Disable Ctl-C

2A61  3E 21             	MVI	A,21H			; LXI H, code
2A63  32 DF25           	STA	CCBJ			; Skip jump to CCBAT0

2A66  FF 07             	SCALL	.CLRCO			; Clear console buffer
2A68  CD 5E19           	CALL	$TYPTX
2A6B  0A41626F 72742042 	DB	NL,'Abort Batch Job ? (Y/N) <N>',' '+200Q
2A73  61746368 204A6F62
2A7B  203F2028 592F4E29
2A83  203C4E3E A0
2A88  CD A02A           	CALL	TT.CE			; Set character mode/no echo
2A8B  FF 01             CCBAT2	SCALL	.SCIN			; Get Key
2A8D  DA 8B2A           	JC	CCBAT2
2A90  FF 02             	SCALL	.SCOUT			; Show it
2A92  F5                	PUSH	PSW			; Save it
2A93  CD 4746           	CALL	$GNL			; New line
2A96  F1                	POP	PSW			; Get it back
2A97  CD D846           	CALL	$MCU			; Map it
2A9A  FE 59             	CPI	'Y'			; Is it Yes
2A9C  CA A125           	JE	BATOFF			; Yes, bail out
2A9F  C7                	RST	SYSCMD			; No, proceed with batch job
2AA0                    	SPACE	4,10
                        ***	TT.CE - Set character mode with no echo

                        	ERRNZ	I.CSLMD
2AA0  AF                TT.CE	XRA	A			; A = I.CSLMD
2AA1  06 81             	MVI	B,CSL.CHR+CSL.ECH	; Character mode + No echo
2AA3  48                	MOV	C,B
2AA4  FF 06             	SCALL	.CONSL			; Set it
2AA6  C9                	RET
2AA7                    	SPACE	4,10
                        ***	TT.CCM - Clear Special Console Modes

                        	ERRNZ	I.CSLMD
2AA7  AF                TT.CCM	XRA	A			; A = I.CSLMD
2AA8  47                	MOV	B,A			; Line mode with Echo
2AA9  0E 85             	MVI	C,CSL.ECH+CSL.RAW+CSL.CHR	; Also clear Raw mode
2AAB  FF 06             	SCALL	.CONSL			; Set it
2AAD  C9                	RET
2AAE                    	STL	'RUN - PROCESS RUN COMMAND'
2AAE                    	EJECT
2AAE                    	XTEXT	RUN
                        ***	RUN - PROCESS RUN COMMAND.
                        *
                        *	RU[N] FNAME [PARAMETER LIST]

2AAE  E1                RUN	POP	H			; (HL) = COMMAND LINE ADDRESS
2AAF  CD 5347           	CALL	M$SOB			; MAP + SKIP LEADING BLANKS
2AB2  EB                	XCHG				; (DE) = PROGRAM NAME
2AB3  21 7F80           	LXI	H,LINE			; (HL) = LINE BUFFER
2AB6  01 6300           	LXI	B,99			; Max count
2AB9  CD AA18           	CALL	$MOVE			; COPY LINE OVER ITSELF
2ABC  21 7F80           	LXI	H,LINE
2ABF  CD 213F           	CALL	FNST			; Find end of word
2AC2  E5                	PUSH	H			; Save parameter list addr
2AC3  CD F146           	CALL	$MOVEL			; Preset default
2AC6  06008F22 0080     	DW	6,RUNA,SYSBLK
2ACC  C3 9F27           	JMP	SYSC5.			; PROCESS AS IMPLICIT RUN

2ACF                    	STL	'HELP - TYPE HELP FILE'
2ACF                    	EJECT
2ACF                    	XTEXT	HELP
                        ***	HELP - TYPE HELP FILE.
                        *
                        *	H[ELP]
                        *	?[??]

2ACF  CD F146           HELP	CALL	$MOVEL
2AD2  1600DF2A 7F80     	DW	HELPAL,HELPA,LINE	; Command line
2AD8  21 7F80           	LXI	H,LINE
2ADB  E3                	XTHL
2ADC  C3 312B           	JMP	TYPE			; Do as in TYPE command

2ADF  5359303A 53595348 HELPA	DB	'SY0:SYSHELP.DOC/SU/SU',0
2AE7  454C502E 444F432F
2AEF  53552F53 5500
      = 0016            HELPAL	EQU	*-HELPA

2AF5                    	STL	'PRINT - PRINT FILE ON LINE PRINTER'
2AF5                    	EJECT
2AF5                    	XTEXT	PRINT
                        ***	PRINT - Print file(s) on line printer device.
                        *
                        *	PR[INT] FNAME

2AF5  2A C823           PRINT	LHLD	LSTADR			; Get list address
2AF8  7C                	MOV	A,H
2AF9  B5                	ORA	L			;
2AFA  CA 5A2C           	JZ	NOLST			; No list device around ...

2AFD  E1                	POP	H			; Get line address
2AFE  CD 5647           	CALL	$SOB			; Skip spaces
2B01  A7                	ANA	A			; Null line?
2B02  CA 8E25           	JZ	ILLSYN			; Dumb user didn't type anything
2B05  E5                	PUSH	H			; Put new line address in place

2B06  2A B522           	LHLD	LSTDEV
2B09  22 292B           	SHLD	LISTA			; Set list device name for PIP

2B0C  CD F146           	CALL	$MOVEL
2B0F  0800292B E480     	DW	LISTAL,LISTA,LABEL	; Set up PIP commands

2B15  E1                	POP	H
2B16  CD 5647           	CALL	$SOB			; Skip blanks
2B19  EB                	XCHG
2B1A  21 EC80           	LXI	H,LABEL+LISTAL		; After the device specification
2B1D  01 7800           	LXI	B,120			; Can't be more than 120 bytes!
2B20  CD AA18           	CALL	$MOVE
2B23  01 E480           	LXI	B,LABEL
2B26  C3 3A42           	JMP	PIP			; EXECUTE PIP

2B29  7878303A 2A2E2A3D LISTA	DB	'xx0:*.*='		; Do the copy as seperate file(s)
      = 0008            LISTAL	EQU	*-LISTA

2B31                    	STL	'TYPE - TYPE FILE ON CONSOLE'
2B31                    	EJECT
2B31                    	XTEXT	TYPE
                        ***	TYPE - TYPE FILE TO SYSTEM CONSOLE.
                        *
                        *	T[YPE] FNAME
                        *	LI[ST] FNAME

2B31  CD F146           TYPE	CALL	$MOVEL			; SET UP COMMANDS FOR PIP
2B34  04005D2B E480     	DW	TYPEAL,TYPEA,LABEL
2B3A  E1                	POP	H
2B3B  CD 5647           	CALL	$SOB			; Skip blanks
2B3E  EB                	XCHG
2B3F  21 E880           	LXI	H,LABEL+TYPEAL		; After the device specification
2B42  01 7800           	LXI	B,120			; Can't be more than 120 bytes!
2B45  CD AA18           	CALL	$MOVE
2B48  01 E480           	LXI	B,LABEL 		; New command line
2B4B  CD 0C42           	CALL	FEC			; Find end of it
2B4E  01 0400           	LXI	B,TYPEBL
2B51  11 612B           	LXI	D,TYPEB
2B54  CD AA18           	CALL	$MOVE			; MOVE IN '/SUPRESS'
2B57  01 E480           	LXI	B,LABEL
2B5A  C3 3A42           	JMP	PIP			; GOTO PIP

2B5D  54543A3D          TYPEA	DB	'TT:='
      = 0004            TYPEAL	EQU	*-TYPEA

2B61  2F535500          TYPEB	DB	'/SU',0
      = 0004            TYPEBL	EQU	*-TYPEB

2B65                    	STL	'CLS - CLEAR CONSOLE SCREEN'
2B65                    	EJECT
2B65                    	XTEXT	CLS
                        ***	CLS - CLEAR CONSOLE SCREEN
                        *
                        *	CLS

      = 2B65            CLS	EQU	*

2B65  CD 5346           	CALL	CLRSCRN 		; Clear Screen, Graphics & Reverse

2B68  C7                	RST	SYSCMD

2B69                    	STL	'DELETE - DELETE FILES'
2B69                    	EJECT
2B69                    	XTEXT	DELETE
                        ***	DELETE - DELETE FILES.
                        *
                        *	DEL[ETE] FNAME [,FNAME,...,FNAME]
                        *	ERA[SE] FNAME [,FNAME,...,FNAME]

2B69  E1                DELETE	POP	H
2B6A  CD 5647           	CALL	$SOB
2B6D  A7                	ANA	A
2B6E  CA 8E25           	JZ	ILLSYN

2B71  44                	MOV	B,H
2B72  4D                	MOV	C,L
2B73  C5                	PUSH	B			; SAVE COMMAND ADDRESS
2B74  CD 0C42           	CALL	FEC			; FIND END OF COMMAND LINE
2B77  01 0500           	LXI	B,DELAL
2B7A  11 842B           	LXI	D,DELA
2B7D  CD AA18           	CALL	$MOVE			; ADD '/DELETE' COMMAND
2B80  C1                	POP	B
2B81  C3 3A42           	JMP	PIP

2B84  2F44454C 00       DELA	DB	'/DEL',0
      = 0005            DELAL	EQU	*-DELA

2B89                    	STL	'RENAME - RENAME FILES'
2B89                    	EJECT
2B89                    	XTEXT	RENAME
                        ***	RENAME - RENAME FILES.
                        *
                        *	REN[AME] NEWNAME=OLDNAME

2B89  E1                RENAME	POP	H
2B8A  CD 5647           	CALL	$SOB
2B8D  A7                	ANA	A
2B8E  CA 8E25           	JZ	ILLSYN

2B91  44                	MOV	B,H
2B92  4D                	MOV	C,L
2B93  C5                	PUSH	B			; (BC) = START OF COMMAND
2B94  CD 0C42           	CALL	FEC			; FIND END OF COMMAND
2B97  01 0300           	LXI	B,RENAL
2B9A  11 A42B           	LXI	D,RENA
2B9D  CD AA18           	CALL	$MOVE			; MOVE IN '/RENAME'
2BA0  C1                	POP	B
2BA1  C3 3A42           	JMP	PIP

2BA4  2F5200            RENA	DB	'/R',0
      = 0003            RENAL	EQU	*-RENA

2BA7                    	STL	'COPY - COPY FILE'
2BA7                    	EJECT
2BA7                    	XTEXT	COPY
                        ***	COPY - COPY FILES.
                        *
                        *	CO[PY] DESTINATION=SOURCE

2BA7  E1                COPY	POP	H			; Get line address
2BA8  CD 5647           	CALL	$SOB
2BAB  A7                	ANA	A
2BAC  CA 8E25           	JZ	ILLSYN

2BAF  44                	MOV	B,H
2BB0  4D                	MOV	C,L			; (BC) = ARG. ADDRESS
2BB1  C3 3A42           	JMP	PIP			; DO LIKE PIP

2BB4                    	STL	'DIR / CAT / Cn / PCn - DIRECTORY LIST DEVICE'
2BB4                    	EJECT
2BB4                    	XTEXT	DIR
                        ***	DIR - DIRECTORY LIST FOR DEVICE.
                        *
                        *	DIR [[DEV:]NAMES]
                        *	C[AT] [[DEV:]NAMES]

2BB4  C1                DIR	POP	B
2BB5  C5                	PUSH	B
2BB6  CD 0C42           	CALL	FEC			; FIND END OF COMMAND LINE
2BB9  01 0300           	LXI	B,DIRAL
2BBC  11 C62B           	LXI	D,DIRA			; /LIST
2BBF  CD AA18           	CALL	$MOVE
2BC2  C1                	POP	B
2BC3  C3 3A42           	JMP	PIP

2BC6  2F4C00            DIRA	DB	'/L',0
      = 0003            DIRAL	EQU	*-DIRA
2BC9                    	EJECT
                        ***	Cn - PRINT DIRECTORY ON CONSOLE
                        *
                        *	C[n] [NAMES]

2BC9  CD CA2D           CN	CALL	GUN			; Get unit number

2BCC  32 EA2B           	STA	CUNIT			; Set device unit for Cat
2BCF  CD BE2D           	CALL	GETDEV			; Get device
2BD2  22 E82B           	SHLD	CDEV			; Set it

2BD5  CD F146           	CALL	$MOVEL			; Set up beginning of command line
2BD8  0B00E12B E480     	DW	CAL,CA,LABEL

2BDE  C3 1E2C           	JMP	CPCCOM			; Go to common code

2BE1  5454303A 42503D   CA	DB	'TT0:BP='
2BE8  7878              CDEV	DB	'xx'
2BEA  6E3A              CUNIT	DB	'n:'
      = 000B            CAL	EQU	*-CA
2BEC                    	EJECT
                        ***	PCn - PRINT DIRECTORY ON LINE PRINTER
                        *
                        *	PC[n] [NAMES]

2BEC  2A C823           PCN	LHLD	LSTADR			; Get address of list device
2BEF  7C                	MOV	A,H
2BF0  B5                	ORA	L
2BF1  CA 5A2C           	JZ	NOLST

2BF4  CD CA2D           	CALL	GUN			; Get unit number

2BF7  32 582C           	STA	PCUNIT			; Set device unit for Print Cat
2BFA  CD BE2D           	CALL	GETDEV
2BFD  22 562C           	SHLD	PCDEV			; Set device name

2C00  2A B522           	LHLD	LSTDEV			; Get list device
2C03  22 4F2C           	SHLD	PCA			; Set it

2C06  CD F146           	CALL	$MOVEL			; Set up beginning of command line
2C09  0B004F2C E480     	DW	PCAL,PCA,LABEL
2C0F  E5                	PUSH	H			; Save this (HL)

2C10  21 B522           	LXI	H,LSTDEV
2C13  FF 32             	SCALL	.LOADD			; Load the driver
2C15  DA 5A25           	JC	ERROR

2C18  3E 04             	MVI	A,DC.OPW		; Open for write
2C1A  CD C723           	CALL	LSTJMP

2C1D  E1                	POP	H

                        *	Cn / PCn Common Code

2C1E  22 3E2C           CPCCOM	SHLD	PCT			; Set next address in line
2C21  E1                	POP	H			; Get address of parameters
2C22  CD 5647           	CALL	$SOB			; Skip leading spaces in parameters
2C25  22 3C2C           	SHLD	PCF			; Set *FROM* address for copy
2C28  44                	MOV	B,H
2C29  4D                	MOV	C,L			; (BC) = Parameter List
2C2A  CD 0C42           	CALL	FEC			; Find end of list
2C2D  C5                	PUSH	B			; Save list pointer
2C2E  E3                	XTHL				; (HL) = List Pointer
2C2F  D1                	POP	D			; (DE) = End of list
2C30  CD 9418           	CALL	$CHL			; Negate (HL) so we can subtract it
2C33  19                	DAD	D			; (HL) = Length of list
2C34  22 3A2C           	SHLD	PCLN			; Set it for move

2C37  CD F146           	CALL	$MOVEL			; Move in parameters list
2C3A  0000              PCLN	DW	0			; Length
2C3C  0000              PCF	DW	0			; From
2C3E  0000              PCT	DW	0			; To

2C40  11 C62B           	LXI	D,DIRA			; /LIST
2C43  01 0300           	LXI	B,DIRAL
2C46  CD AA18           	CALL	$MOVE			; Move it in

2C49  01 E480           	LXI	B,LABEL
2C4C  C3 3A42           	JMP	PIP			; Let PIP do all the work

2C4F  7878303A 42503D   PCA	DB	'xx0:BP='
2C56  7878              PCDEV	DB	'xx'
2C58  6E3A              PCUNIT	DB	'n:'
      = 000B            PCAL	EQU	*-PCA

                        ***	No list device is present in the system

2C5A  2A B522           NOLST	LHLD	LSTDEV			; Get device name
2C5D  22 742C           	SHLD	NOLSTA
2C60  CD 5E19           	CALL	$TYPTX
2C63  0A546865 206C6973 	DB	NL,'The list device '
2C6B  74206465 76696365
2C73  20
2C74  78783A20 6973206E NOLSTA	DB	'xx: is not present in the system.',ENL
2C7C  6F742070 72657365
2C84  6E742069 6E207468
2C8C  65207379 7374656D
2C94  2E8A
2C96  E1                	POP	H
2C97  C7                	RST	SYSCMD

2C98                    	STL	'MOUNT / DISMOUNT / RESET DISK'
2C98                    	EJECT
2C98                    	XTEXT	MDR
                        ***	MOUNT - MOUNT DISK.
                        *
                        *	M[OUNT] DEV:

      = 2C98            MOUNT	EQU	*

2C98  3E 80             	MVI	A,.MOUNT		; MOUNT SYSCALL INDEX
2C9A  C3 A42C           	JMP	MDRX
2C9D                    	SPACE	4,10
                        ***	DISMOUNT - DISMOUNT DISK.
                        *
                        *	D[ISMOUNT] DEV:

      = 2C9D            DMOUNT	EQU	*

2C9D  3E 81             	MVI	A,.DMOUN		; DISMOUNT SYSCALL INDEX
2C9F  C3 A42C           	JMP	MDRX
2CA2                    	SPACE	4,10
                        ***	RESET - RESET DISK.
                        *
                        *	R[ESET] DEV:

      = 2CA2            RESET	EQU	*

2CA2  3E 84             	MVI	A,.RESET		; RESET SYSCALL INDEX
                        *	JMP	MDRX

                        	ERRNZ	*-MDRX

2CA4  32 D62C           MDRX	STA	MDRSC			; STUFF SYSCALL INDEX
2CA7  E1                	POP	H			; (HL) = LINE ADDRESS
2CA8  CD 5347           	CALL	M$SOB			; (A) = NEXT CHARACTER (upper case)
2CAB  A7                	ANA	A
2CAC  C2 D02C           	JNZ	MDR0			; HAVE AN ARGUMENT
2CAF  C3 8E25           	JMP	ILLSYN			; MUST GIVE DEVICE
2CB2                    	EJECT
                        ***	Mn - Mount Device unit 'n'
                        *
                        *	Mn

      = 2CB2            MN	EQU	*

2CB2  3E 80             	MVI	A,.MOUNT		; MOUNT SYSCALL INDEX
2CB4  C3 BE2C           	JMP	MDRN
2CB7                    	SPACE	4,10
                        ***	Dn - Dismount Device unit 'n'
                        *
                        *	Dn

      = 2CB7            DN	EQU	*

2CB7  3E 81             	MVI	A,.DMOUN		; DISMOUNT SYSCALL INDEX
2CB9  C3 BE2C           	JMP	MDRN
2CBC                    	SPACE	4,10
                        ***	Rn - Reset Device unit 'n'
                        *
                        *	Rn

      = 2CBC            RN	EQU	*

2CBC  3E 84             	MVI	A,.RESET		; RESET SYSCALL INDEX
                        *	JMP	MDRN

                        	ERRNZ	*-MDRN

2CBE  32 D62C           MDRN	STA	MDRSC
2CC1  CD CA2D           	CALL	GUN
2CC4  32 E82D           	STA	MUNIT
2CC7  CD BE2D           	CALL	GETDEV
2CCA  22 E62D           	SHLD	MDEVIC

2CCD  21 E62D           	LXI	H,MDEVIC
2CD0  E5                MDR0	PUSH	H
2CD1  CD EE2D           	CALL	SY0CHK			; CHECK FOR 'SY0:'
2CD4  E1                	POP	H
2CD5  FF 00             	SCALL	0
      = 2CD6            MDRSC	EQU	*-1
2CD7  DA 5A25           	JC	ERROR			; Huh?
2CDA  C7                	RST	SYSCMD
2CDB                    	EJECT
                        ***	MM - MULTIPLE MOUNT DISKS
                        *
                        *	MM [xx[:]]

      = 2CDB            XQMNT	EQU	*

2CDB  3E 82             	MVI	A,.MONMS
2CDD  21                	DB	MI.LXIH

      = 2CDE            XMNT	EQU	*

2CDE  3E 80             	MVI	A,.MOUNT
2CE0  32 3F2D           	STA	XMM3A

2CE3  E1                	POP	H			; (HL) = LINE ADDRESS
2CE4  CD 5347           	CALL	M$SOB			; (A) = NEXT CHARACTER (upper case)
2CE7  A7                	ANA	A
2CE8  C2 F12C           	JNZ	XMM1			; HAVE A DEVICE SPEC.
2CEB  CD BE2D           	CALL	GETDEV
2CEE  C3 F42C           	JMP	XMM2

2CF1  CD 8918           XMM1	CALL	$HLIHL
2CF4  22 E62D           XMM2	SHLD	MDEVIC
2CF7  3E 30             	MVI	A,'0'			; Set unit to 0 in preparation
2CF9  32 E82D           	STA	MUNIT			;  for the attempted load
2CFC  21 E62D           	LXI	H,MDEVIC
2CFF  FF 32             	SCALL	.LOADD
2D01  DA 5A25           	JC	ERROR
2D04  2A E62D           	LHLD	MDEVIC
2D07  EB                	XCHG
2D08  FF 0A             	SCALL	.GDA			; Error shouldn't happen
2D0A  DA 5A25           	JC	ERROR			;  since we passed .LOADD above
2D0D  21 0800           	LXI	H,DEV.MNU
2D10  09                	DAD	B
2D11  7E                	MOV	A,M
2D12  32 4B2D           	STA	XMM5			; SAVE MAX. NUMBER OF UNITS
2D15  21 0400           	LXI	H,DEV.DDA
2D18  09                	DAD	B
2D19  CD 8918           	CALL	$HLIHL
2D1C  22 2A2D           	SHLD	OURDEV			; SAVE ADDRESS
2D1F  AF                	XRA	A			; START WITH UNIT 0

2D20  F5                XMM3	PUSH	PSW
2D21  32 3121           	STA	AIO.UNI
2D24  3E 0A             	MVI	A,DC.RDY
2D26  CD 3D25           	CALL	CC.OFF			; Prohibit Control Char.
2D29  CD 0000           	CALL	*-*
      = 2D2A            OURDEV	EQU	*-2
2D2C  F5                	PUSH	PSW
2D2D  CD 4425           	CALL	CC.ON			; Allow Control Char.
2D30  F1                	POP	PSW
2D31  DA 482D           	JC	XMM4
2D34  F1                	POP	PSW			; GET UNIT #
2D35  F5                	PUSH	PSW
2D36  C6 30             	ADI	'0'			; MAKE IT ASCII
2D38  32 E82D           	STA	MUNIT
2D3B  21 E62D           	LXI	H,MDEVIC
2D3E  FF 80             	SCALL	.MOUNT			; MOUNT
      = 2D3F            XMM3A	EQU	*-1
2D40  D2 482D           	JNC	XMM4			; SUCCESS, TRY THE NEXT ONE
2D43  FE 21             	CPI	EC.VPM			; ALREADY MOUNTED
2D45  C4 B22D           	CNE	XMDERR			; SOMRTHING ELSE IS WRONG

2D48  F1                XMM4	POP	PSW			; TRY NEXT UNIT
2D49  3C                	INR	A
2D4A  FE 00             	CPI	0
      = 2D4B            XMM5	EQU	*-1
2D4C  DA 202D           	JC	XMM3
2D4F  C7                	RST	SYSCMD
2D50                    	EJECT
                        ***	MD - MULTIPLE DISMOUNT DISKS
                        *
                        *	MD [xx[:]]

      = 2D50            XDMNT	EQU	*

2D50  E1                	POP	H			; (HL) = LINE ADDRESS
2D51  CD 5347           	CALL	M$SOB			; (A) = NEXT CHARACTER (upper case)
2D54  A7                	ANA	A
2D55  C2 5E2D           	JNZ	XMD1			; HAVE A DEVICE SPEC.
2D58  CD BE2D           	CALL	GETDEV
2D5B  C3 612D           	JMP	XMD2

2D5E  CD 8918           XMD1	CALL	$HLIHL
2D61  22 E62D           XMD2	SHLD	MDEVIC
2D64  EB                	XCHG
2D65  FF 0A             	SCALL	.GDA
2D67  DA 5A25           	JC	ERROR			; Unknown device
2D6A  21 0200           	LXI	H,DEV.RES
2D6D  09                	DAD	B
2D6E  7E                	MOV	A,M			; Get residence byte
2D6F  E6 01             	ANI	DR.IM
2D71  3E 2F             	MVI	A,EC.DNL		; Assume error
2D73  CA 5A25           	JZ	ERROR			; Device not loaded
2D76  21 0800           	LXI	H,DEV.MNU
2D79  09                	DAD	B
2D7A  7E                	MOV	A,M
2D7B  32 AD2D           	STA	XMD5			; SAVE MAX. NUMBER OF UNITS
2D7E  AF                	XRA	A			; START WITH UNIT 0

2D7F  F5                XMD3	PUSH	PSW
2D80  C6 30             	ADI	'0'			; MAKE IT ASCII
2D82  32 E82D           	STA	MUNIT

                        *	Test for SY0: so we don't truncate the device table accidentally.
                        *	User is forced to dismount SY0: seperately the first time,
                        *	if he really wants to remove the system disk.

2D85  FE 30             	CPI	'0'
2D87  C2 9D2D           	JNE	XMD3.			; Can't be SY0:
2D8A  3A 1A21           	LDA	S.MOUNT
2D8D  A7                	ANA	A
2D8E  CA 9D2D           	JZ	XMD3.			; SY0: has been dismounted before
2D91  2A E62D           	LHLD	MDEVIC
2D94  11 5359           	LXI	D,'YS'			; If this is SY0: and it has not
2D97  CD 8E18           	CALL	$CDEHL			;  been dismounted before, we MUST
2D9A  CA AA2D           	JE	XMD4			;   NOT do it now.

2D9D  21 E62D           XMD3.	LXI	H,MDEVIC
2DA0  FF 81             	SCALL	.DMOUN			; DISMOUNT
2DA2  D2 AA2D           	JNC	XMD4			; SUCCESS, TRY THE NEXT ONE
2DA5  FE 22             	CPI	EC.NVM			; EMPTY DRIVE
2DA7  C4 B22D           	CNE	XMDERR			; SOMETHING ELSE IS WRONG

2DAA  F1                XMD4	POP	PSW			; TRY NEXT UNIT
2DAB  3C                	INR	A
2DAC  FE 00             	CPI	0
      = 2DAD            XMD5	EQU	*-1
2DAE  DA 7F2D           	JC	XMD3
2DB1  C7                	RST	SYSCMD
2DB2                    	SPACE	4,10
2DB2  F5                XMDERR	PUSH	PSW			; SOMETHING IS WRONG
2DB3  21 E62D           	LXI	H,MDEVIC
2DB6  FF 03             	SCALL	.PRINT			; SHOW 'DEV: - '
2DB8  F1                	POP	PSW
2DB9  26 0A             	MVI	H,NL
2DBB  FF 2F             	SCALL	.ERROR
2DBD  C9                	RET
2DBE                    	EJECT
                        ***	GETDEV - Get device name according to ALTFLG
                        *
                        *	Entry:	NONE
                        *	Exit:	(HL) = Device name
                        *		 'Z' Set is primary device
                        *		 'Z' Clear is alternate device
                        *	Uses:	A,F,H,L

2DBE  2A AD22           GETDEV	LHLD	PRIDEV			; Assume we want primary
2DC1  3A B922           	LDA	ALTFLG			; Get alternate flag
2DC4  A7                	ANA	A
2DC5  C8                	RZ
2DC6  2A B122           	LHLD	ALTDEV			; Get other device name
2DC9  C9                	RET
2DCA                    	SPACE	4,10
                        ***	GUN - Get unit number from command line.
                        *
                        *	Entry:	((SP)) = Start of parameters on line
                        *	Exit:	(A) = Unit number '0'-'7'
                        *	Uses:	A,F,H,L,D,E

2DCA  D1                GUN	POP	D			; Get (RET) address
2DCB  E1                	POP	H			; Get line address
2DCC  E5                	PUSH	H			;
2DCD  D5                	PUSH	D			; Put stack back like it was
2DCE  2B                GUN1	DCX	H			; Point to prev. character
2DCF  7E                	MOV	A,M
2DD0  FE 20             	CPI	' '
2DD2  CA CE2D           	JE	GUN1			; Ignore spaces
2DD5  FE 09             	CPI	TAB
2DD7  CA CE2D           	JE	GUN1			;  and TABs
2DDA  FE 30             	CPI	'0'			; Is < '0'?
2DDC  DA E22D           	JC	GUN2			; Yes, assume '0'
2DDF  FE 38             	CPI	'7'+1			; Is > '7'?
2DE1  D8                	RC				; Character is Ok.

                        *	Don't know what it was, so assume default unit

2DE2  3A 6C00           GUN2	LDA	S.DFBLK+2
2DE5  C9                	RET

2DE6  7878              MDEVIC	DB	'xx'
2DE8  6E3A00            MUNIT	DB	'n:',0
      = 0004            MDEVL	EQU	*-MDEVIC-1		; DON'T COUNT THE NULL BYTE
2DEB  202DA0            	DB	' -',' '+200Q
2DEE                    	EJECT
                        ***	SY0CHK - CHECK DEVICE SPEC. FOR 'SY0:'
                        *
                        *	IF DEVICE SPEC. IS 'SY0:' AND YOU ARE DISMOUNTING OR RESETING
                        *	THEN BE SURE PIP IS IN MEMORY.
                        *
                        *	ENTRY	HL => POINTS AT DEVICE SPEC.

      = 2DEE            SY0CHK	EQU	*

2DEE  3A 9142           	LDA	PIPMEM			; IS PIP ALREADY HERE
2DF1  A7                	ANA	A
2DF2  C0                	RNZ				; YES, SO FORGET I ASKED

2DF3  3A D62C           	LDA	MDRSC
2DF6  FE 80             	CPI	.MOUNT			; ARE WE MOUNTING A DISK
2DF8  C8                	RZ				; YES, SO ALL IS WELL

2DF9  7E                	MOV	A,M
2DFA  FE 53             	CPI	'S'			; IS IT 'S'
2DFC  C0                	RNZ				; NO, CAN'T BE 'SY0:'
2DFD  23                	INX	H
2DFE  7E                	MOV	A,M
2DFF  FE 59             	CPI	'Y'			; IS IT 'Y'
2E01  C0                	RNZ				; NO, CAN'T BE 'SY0:'
2E02  23                	INX	H
2E03  7E                	MOV	A,M
2E04  FE 3A             	CPI	':'
2E06  CA 0C2E           	JE	SY0CK			; IMPLIED '0'
2E09  FE 30             	CPI	'0'			; IS IT '0'
2E0B  C0                	RNZ				; NO, IT'S NOT 'SY0:'

                        *	IT IS 'SY0:' SO PROCESS AS PIP COMMAND TO GET PIP IN MEMORY

2E0C  CD C142           SY0CK	CALL	CHKPIP			; CHECK FOR CO-RES PIP FIRST
2E0F  C0                	RNE				; NO, GO AHEAD AND DO IT
2E10  3E 01             	MVI	A,1
2E12  32 9242           	STA	PIPCHK			; Flag as OK

2E15  E1                	POP	H			; DISCARD RETURN ADDRESS
2E16  C1                	POP	B			; BC => DEVICE SPEC.

2E17  21 E480           	LXI	H,LABEL 		; COPY DEVICE NAME TO BUFFER
2E1A  0A                SY0CK0	LDAX	B
2E1B  A7                	ANA	A
2E1C  CA 252E           	JZ	SY0CK1
2E1F  77                	MOV	M,A
2E20  23                	INX	H
2E21  03                	INX	B
2E22  C3 1A2E           	JMP	SY0CK0

2E25  3A D62C           SY0CK1	LDA	MDRSC
2E28  FE 81             	CPI	.DMOUN
2E2A  01 0500           	LXI	B,RESAL
                        	ERRNZ	RESAL-DISAL
2E2D  11 3F2E           	LXI	D,RESA
2E30  C2 362E           	JNE	SY0CK2

2E33  11 442E           	LXI	D,DISA
2E36  CD AA18           SY0CK2	CALL	$MOVE			; APPEND SWITCH TO BUFFER

2E39  01 E480           	LXI	B,LABEL
2E3C  C3 3A42           	JMP	PIP			; PROCESS AS PIP COMMAND

2E3F  2F524553 00       RESA	DB	'/RES',0
      = 0005            RESAL	EQU	*-RESA

2E44  2F444953 00       DISA	DB	'/DIS',0
      = 0005            DISAL	EQU	*-DISA

2E49                    	STL	'CHECK - Checksum file'
2E49                    	EJECT
2E49                    	XTEXT	CHECK
                        ***	CHECK - CRC FILES.
                        *
                        *	CH[ECK] FNAME [,FNAME,...,FNAME]
                        *	CRC FNAME [,FNAME,...,FNAME]

2E49  E1                CHECK	POP	H
2E4A  CD 5647           	CALL	$SOB
2E4D  A7                	ANA	A
2E4E  CA 8E25           	JZ	ILLSYN

2E51  44                	MOV	B,H
2E52  4D                	MOV	C,L
2E53  C5                	PUSH	B			; SAVE COMMAND ADDRESS
2E54  CD 0C42           	CALL	FEC			; FIND END OF COMMAND LINE
2E57  01 0500           	LXI	B,CHEAL
2E5A  11 642E           	LXI	D,CHEA
2E5D  CD AA18           	CALL	$MOVE			; ADD '/CRC' COMMAND
2E60  C1                	POP	B
2E61  C3 3A42           	JMP	PIP

2E64  2F435243 00       CHEA	DB	'/CRC',0
      = 0005            CHEAL	EQU	*-CHEA

2E69                    	STL	'VERSN - SHOW VERSION'
2E69                    	EJECT
2E69                    	XTEXT	VERSN
                        ***	VERSN - SHOW VERSION NUMBER.
                        *
                        *	VER[SION]
                        *	ID

2E69  CD BA2E           VERSN	CALL	VERSN0
2E6C  C7                	RST	SYSCMD

2E6D  CD BA2E           VERSNX	CALL	VERSN0
2E70  01 8022           	LXI	B,USERFWA
2E73  21 942E           	LXI	H,VERSV0
2E76  CD C747           	CALL	$UOW.
2E79  01 E547           	LXI	B,MEML-1
2E7C  21 A22E           	LXI	H,VERSV1
2E7F  CD C747           	CALL	$UOW.
2E82  01 0080           	LXI	B,BUFFWA
2E85  21 B12E           	LXI	H,VERSV2
2E88  CD C747           	CALL	$UOW.
2E8B  CD 5E19           	CALL	$TYPTX
2E8E  46574120 3D20     	DB	'FWA = '
2E94  3030302E 30303009 VERSV0	DB	'000.000',TAB,'LWA = '
2E9C  4C574120 3D20
2EA2  3030302E 30303009 VERSV1	DB	'000.000',TAB,'Data = '
2EAA  44617461 203D20
2EB1  3030302E 3030308A VERSV2	DB	'000.000',ENL
2EB9  C7                	RST	SYSCMD

2EBA  CD 5E19           VERSN0	CALL	$TYPTX
2EBD  0A535953 434D442F 	DB	NL,'SYSCMD/plus Version: '
2EC5  706C7573 20566572
2ECD  73696F6E 3A20
2ED3  332E30            	DB	VERS/16+'0','.',VERS&0FH+'0'
2ED6  20526576 2E204120 	DB	' Rev. ','A'+CUSTOM,' ','['+200Q	; Show Revision
2EDE  DB

                        *	Any options assembled will show, also ...

2EDF  3A BB22           	LDA	H19FLG
2EE2  A7                	ANA	A
2EE3  CA ED2E           	JZ	VERSN1

2EE6  CD 5E19           	CALL	$TYPTX
2EE9  204831B9          	DB	' H1','9'+200Q

2EED  3A A822           VERSN1	LDA	ULTRA
2EF0  A7                	ANA	A
2EF1  CA FD2E           	JZ	VERSN2

2EF4  CD 5E19           	CALL	$TYPTX
2EF7  20556C74 72E1     	DB	' Ultr','a'+200Q

2EFD  CD 5E19           VERSN2	CALL	$TYPTX
                        	IF	Z80
                        	ENDIF
                        	IF	USER
                        	ENDIF
2F00  205D2041 73206F66 	DB	' ] As of '
2F08  20
2F09  31 312D 4D61722D31	DATE
2F11  35
2F12  8A                	DB	ENL
2F13  C9                	RET

2F14                    	STL	'LOAD - LOAD DEVICE DRIVER'
2F14                    	EJECT
2F14                    	XTEXT	LOADD
                        ***	LOADD  - Load and lock device driver.
                        *	FLOAD  - Load and lock device driver, fix in memory.
                        *	UNLOAD - Unload device driver.
                        *
                        *	L[OAD] xx[:]
                        *	LOADF xx[:]
                        *	UNL[OAD] xx[:]
                        *	UNL[OAD] *		Unload all possible devices

2F14  3E 02             LOADD	MVI	A,DR.PR 		; Locked

2F16  21                	DB	21H			; Fake 'LXI H,' CODE

2F17  3E 06             FLOADD	MVI	A,DR.PR+DR.FX		; Locked and Fixed
2F19  F5                	PUSH	PSW

2F1A  CD A623           	CALL	SYSXIT1 		; Clear out dormant devices

2F1D  F1                	POP	PSW
2F1E  32 2430           	STA	L.ORI			; set residence mode

2F21  E1                	POP	H			; (HL) = Device specification
2F22  CD 5347           	CALL	M$SOB			; Map + Skip over blanks
2F25  A7                	ANA	A
2F26  CA 8E25           	JZ	ILLSYN			; User doesn't want to load anything
2F29  E5                	PUSH	H			; Save spec. address
2F2A  23                	INX	H			; Bump
2F2B  23                	INX	H			;  past it
2F2C  36 3A             	MVI	M,':'			; Force a colon
2F2E  23                	INX	H			;  and
2F2F  36 00             	MVI	M,NUL			;   a zero
2F31  E1                	POP	H			; Restore spec. address
2F32  FF 32             	SCALL	.LOADD			; Try to load
2F34  DA 5A25           	JC	ERROR			; Not good
2F37  CD EF2F           	CALL	LAD.			; Lock devices above us

2F3A  C7                	RST	SYSCMD

2F3B  E1                UNLOAD	POP	H			; Get command pointer
2F3C  CD 5347           	CALL	M$SOB			; Map + Skip over blanks
2F3F  A7                	ANA	A
2F40  CA 8E25           	JZ	ILLSYN			; No argument

2F43  3A 1A21           	LDA	S.MOUNT
2F46  A7                	ANA	A
2F47  C2 562F           	JNZ	UNL.OK			; System disk is mounted

2F4A  CD 5E19           	CALL	$TYPTX
2F4D  078A              	DB	BELL,ENL
2F4F  3E 35             	MVI	A,EC.SDR
2F51  26 0A             	MVI	H,NL
2F53  FF 2F             	SCALL	.ERROR			; System disk is reset
2F55  C7                	RST	SYSCMD

2F56  7E                UNL.OK	MOV	A,M
2F57  FE 2A             	CPI	'*'
2F59  CA AE2F           	JE	UNLALL			; Do all possible devices

2F5C  CD 8918           	CALL	$HLIHL			; Get device name
2F5F  22 982F           	SHLD	UNLDN			; Save it
2F62  EB                	XCHG				; DE = Device Name
2F63  FF 0A             	SCALL	.GDA			; BC => DEV. TABLE ENTRY
2F65  DA 5A25           	JC	ERROR			; NO SUCH DEVICE
2F68  21 0200           	LXI	H,DEV.RES
2F6B  09                	DAD	B			; HL => FLAG BYTE
2F6C  7E                	MOV	A,M			; (A) = FLAG BYTE
2F6D  E6 01             	ANI	DR.IM
2F6F  3E 2F             	MVI	A,EC.DNL		; ASSUME ERROR
2F71  CA 5A25           	JZ	ERROR			; Device Not Loaded
2F74  7E                	MOV	A,M			; (A) = FLAG BYTE
2F75  E6 04             	ANI	DR.FX
2F77  3E 31             	MVI	A,EC.DFM		; ASSUME ERROR
2F79  C2 5A25           	JNZ	ERROR			; Device Fixed in Memory
2F7C  7E                	MOV	A,M			; (A) = FLAG BYTE
2F7D  E6 02             	ANI	DR.PR
2F7F  3E 30             	MVI	A,EC.DNP		; ASSUME ERROR
2F81  CA 5A25           	JZ	ERROR			; Device Not Locked
2F84  7E                	MOV	A,M
2F85  F6 08             	ORI	DR.UNL			; FLAG FOR UNLOAD
2F87  77                	MOV	M,A			; PUT IT BACK
2F88  E5                	PUSH	H
2F89  CD A623           	CALL	SYSXIT1 		; TRY TO CLEAR IT OUT NOW
2F8C  E1                	POP	H
2F8D  7E                	MOV	A,M
2F8E  E6 1F             	ANI	377Q-DR.SPL
2F90  C4 942F           	CNZ	UNLPND
2F93  C7                	RST	SYSCMD

2F94  CD 5E19           UNLPND	CALL	$TYPTX
2F97  0A                	DB	NL
2F98  58583A20 2D20556E UNLDN	DB	'XX: - Unload Pending',ENL
2FA0  6C6F6164 2050656E
2FA8  64696E67 8A
2FAD  C9                	RET

                        *	Unload all possible devices

2FAE  2A EC20           UNLALL	LHLD	S.DFWA			; Point at device table
2FB1  7E                UNL0	MOV	A,M
2FB2  A7                	ANA	A
2FB3  CA A425           	JZ	SYSCMD. 		; All finished

2FB6  E5                	PUSH	H			; Save table entry
2FB7  E5                	PUSH	H			;  address twice
2FB8  CD 8918           	CALL	$HLIHL			; Get device name
2FBB  22 982F           	SHLD	UNLDN			; Save it
2FBE  E1                	POP	H
2FBF  23                	INX	H
2FC0  23                	INX	H			; (HL) = DEV.RES
2FC1  7E                	MOV	A,M
2FC2  E6 01             	ANI	DR.IM
2FC4  CA E22F           	JZ	UNL1			; Not in memory
2FC7  7E                	MOV	A,M
2FC8  E6 04             	ANI	DR.FX
2FCA  C2 E22F           	JNZ	UNL1			; Is fixed in memory
2FCD  7E                	MOV	A,M
2FCE  E6 02             	ANI	DR.PR
2FD0  CA E22F           	JZ	UNL1			; Not locked in memory
2FD3  7E                	MOV	A,M
2FD4  F6 08             	ORI	DR.UNL			; Flag for unload pending
2FD6  77                	MOV	M,A
2FD7  E5                	PUSH	H
2FD8  CD A623           	CALL	SYSXIT1 		; Try to unload it now
2FDB  E1                	POP	H
2FDC  7E                	MOV	A,M
2FDD  E6 1F             	ANI	377Q-DR.SPL
2FDF  C4 942F           	CNZ	UNLPND			; Still there, try later

2FE2  E1                UNL1	POP	H
2FE3  11 0E00           	LXI	D,DEVELEN
2FE6  19                	DAD	D
2FE7  C3 B12F           	JMP	UNL0			; Try next entry
2FEA                    	SPACE	4,10
                        ***	LAD - Lock All Drivers.
                        *
                        *	LAD locks into memory all device drivers which it happens
                        *	to find hanging around.
                        *
                        *	Entry:	NONE
                        *	Exit:	NONE
                        *	Uses:	ALL

2FEA  3E 02             LAD	MVI	A,DR.PR
2FEC  32 2430           	STA	L.ORI

2FEF  2A D020           LAD.	LHLD	S.SYSM			; Get bottom of memory
2FF2  22 EE20           	SHLD	S.RFWA			; Now everything's part of HDOS

2FF5  01 0E00           LAD..	LXI	B,DEVELEN		; Device table entry size
2FF8  2A EC20           	LHLD	S.DFWA			; Start of device table

2FFB  7E                LAD1	MOV	A,M			; Get 1st byte
2FFC  A7                	ANA	A
2FFD  C8                	RZ				; End of table
2FFE  FE 01             	CPI	DV.NU			; Entry used ?
3000  CA 2A30           	JE	LAD2			; No ...

3003  E5                	PUSH	H			; Save pointer
3004  CD 9C18           	CALL	$INDL			; Get driver address
3007  0400              	DW	DEV.DDA
3009  2A EE20           	LHLD	S.RFWA			; Get S.RFWA
300C  EB                	XCHG
300D  CD FD44           	CALL	CPDEHL
3010  E1                	POP	H			; Restore pointer
3011  DA 2A30           	JC	LAD2			; DDA below S.RFWA

3014  CD 9646           	CALL	$INDLB
3017  0200              	DW	DEV.RES 		; Get residence code
3019  E6 01             	ANI	DR.IM			; Is driver in?
301B  CA 2A30           	JZ	LAD2			; No.  Go for next.
301E  CD 9646           	CALL	$INDLB
3021  0200              	DW	DEV.RES 		; Get code back
3023  F6 02             	ORI	DR.PR			; Now it shows as locked.
      = 3024            L.ORI	EQU	*-1
3025  CD C246           	CALL	$INDSB
3028  0200              	DW	DEV.RES 		; Set it.

302A  09                LAD2	DAD	B
302B  C3 FB2F           	JMP	LAD1

302E                    	STL	'DATE - PROCESS DATE COMMAND'
302E                    	EJECT
302E                    	XTEXT	DATE
                        ***	DATE - PROCESS DATE COMMAND.
                        *
                        *	DA[TE]		      -> PRINT DATE
                        *	DA[TE] DD[-MMM[-YY]]  -> SET DATE
                        *	DA[TE] NO-DATE	      -> SET NO-DATE

302E  E1                DATE	POP	H
302F  CD 5347           	CALL	M$SOB			; Map + Skip over blanks
3032  A7                	ANA	A
3033  CA 4D30           	JZ	DATE3			; JUST WANTS TO KNOW THE DATE

                        *	SET NEW DATE

3036  CD F243           	CALL	$CAD			; CODE AUGUSTAN DATE
3039  D2 4130           	JNC	DATE2			; WAS OK.
303C  3E 32             	MVI	A,EC.IDF
303E  C3 5A25           	JMP	ERROR

3041  EB                DATE2	XCHG
3042  22 C820           	SHLD	S.DATC
3045  EB                	XCHG
3046  21 BF20           	LXI	H,S.DATE
3049  CD 2B45           	CALL	$DAD			; DECODE INTO ASCII
304C  C7                	RST	SYSCMD

                        *	DISPLAY THE CURRENT DATE

304D  CD 6430           DATE3	CALL	PR.CS
3050  CD 5E19           	CALL	$TYPTX
3053  44617465 206973A0 	DB	'Date is',' '+200Q

305B  21 BF20           	LXI	H,S.DATE
305E  3E 09             	MVI	A,9
3060  CD 6447           	CALL	$TYPCC			; TYPE THE DATE
3063  C7                	RST	SYSCMD

3064  CD 5E19           PR.CS	CALL	$TYPTX
3067  0A437572 72656E74 	DB	NL,'Current System',' '+200Q
306F  20537973 74656DA0
3077  C9                	RET

3078                    	STL	'TIME - PROCESS TIME COMMAND'
3078                    	EJECT
3078                    	XTEXT	TIME
                        ***	TIME - Display / Set System Time
                        *
                        *	TI[ME]		    --> Display Time
                        *	TI[ME] /	    --> Display Time Continuous
                        *	TI[ME] HH:MM[:SS]   --> Set Time

3078  E1                TIME	POP	H			; Clear off pointer to line
3079  CD 5347           	CALL	M$SOB			; Map + Skip over blanks
307C  A7                	ANA	A			; Check for command line
307D  CA FD30           	JZ	DISPLA			; Nothing entered.  Show the time.
3080  FE 2F             	CPI	'/'
3082  CA 4531           	JE	CONTIM

                        *	Decode time from command line

3085  CD CB45           	CALL	$DDD			; Decode hours
3088  7A                	MOV	A,D
3089  A7                	ANA	A
308A  C2 F830           	JNZ	TIMSYN			; Bad time given
308D  7B                	MOV	A,E
308E  FE 18             	CPI	24			; Only 24 hours in a day
3090  D2 F830           	JNC	TIMSYN
3093  32 F530           	STA	HOURS
3096  3E 3A             	MVI	A,':'
3098  BE                	CMP	M			; Require minutes
3099  C2 F830           	JNE	TIMSYN
309C  23                	INX	H
309D  CD CB45           	CALL	$DDD			; Decode minutes
30A0  7A                	MOV	A,D
30A1  A7                	ANA	A
30A2  C2 F830           	JNZ	TIMSYN
30A5  7B                	MOV	A,E
30A6  FE 3C             	CPI	60			; Only 60 minutes in an hour
30A8  D2 F830           	JNC	TIMSYN
30AB  32 F630           	STA	MINUTES
30AE  AF                	XRA	A			; Get a 0
30AF  32 F730           	STA	SECONDS 		; Put into seconds in case none given
30B2  3E 3A             	MVI	A,':'
30B4  BE                	CMP	M
30B5  C2 CA30           	JNE	SETTIM			; No seconds.  Go set the time.
30B8  23                	INX	H
30B9  CD CB45           	CALL	$DDD			; Decode seconds
30BC  7A                	MOV	A,D
30BD  A7                	ANA	A
30BE  C2 F830           	JNZ	TIMSYN
30C1  7B                	MOV	A,E
30C2  FE 3C             	CPI	60			; Only 60 seconds in a minute
30C4  D2 F830           	JNC	TIMSYN
30C7  32 F730           	STA	SECONDS

                        *	Have the time.	Convert to BCD and move it into place.

30CA  3E 03             SETTIM	MVI	A,3			; Three bytes
30CC  21 F530           	LXI	H,NEWTIM
30CF  F5                STLOOP	PUSH	PSW
30D0  E5                	PUSH	H
30D1  4E                	MOV	C,M
30D2  06 00             	MVI	B,0
30D4  11 0A00           	LXI	D,10
30D7  CD 4618           	CALL	$DU66
30DA  7D                	MOV	A,L
30DB  07                	RLC				; Shift to left nibble
30DC  07                	RLC
30DD  07                	RLC
30DE  07                	RLC
30DF  B3                	ORA	E			; Bring in right nibble
30E0  E1                	POP	H
30E1  77                	MOV	M,A			; A = bcd value
30E2  23                	INX	H
30E3  F1                	POP	PSW
30E4  3D                	DCR	A			; Count down
30E5  C2 CF30           	JNZ	STLOOP			; Next byte

30E8  21 CA20           	LXI	H,S.TIME
30EB  11 F530           	LXI	D,NEWTIM
30EE  01 0300           	LXI	B,3
30F1  CD AA18           	CALL	$MOVE			; Set the time.
30F4  C7                	RST	SYSCMD

      = 30F5            NEWTIM	EQU	*
30F5  00                HOURS	DB	0
30F6  00                MINUTES DB	0
30F7  00                SECONDS DB	0

30F8  3E 33             TIMSYN	MVI	A,EC.ITS
30FA  C3 5A25           	JMP	ERROR

                        *	Display Time.

30FD  3E 80             DISPLA	MVI	A,200Q
30FF  32 2A31           	STA	ENDTIM			; Set for display
3102  CD 6430           	CALL	PR.CS
3105  CD 5E19           	CALL	$TYPTX
3108  54696D65 206973A0 	DB	'Time is',' '+200Q
3110  CD 1431           	CALL	DISPLA.
3113  C7                	RST	SYSCMD

3114  0E 03             DISPLA. MVI	C,3			; Three bytes
3116  11 2231           	LXI	D,DISTIM
3119  21 CA20           	LXI	H,S.TIME		; HL => BCD time
311C  CD 2C31           	CALL	DISPL
311F  CD 5E19           	CALL	$TYPTX
3122  68683A6D 6D3A7373 DISTIM	DB	'hh:mm:ss'
312A  80                ENDTIM	DB	200Q
312B  C9                	RET

312C  7E                DISPL	MOV	A,M
312D  E6 F0             	ANI	0F0H			; Mask high nibble
312F  0F                	RRC				; Shift right
3130  0F                	RRC
3131  0F                	RRC
3132  0F                	RRC
3133  C6 30             	ADI	30H			; Make it ascii
3135  12                	STAX	D			; Poke it
3136  13                	INX	D
3137  7E                	MOV	A,M
3138  E6 0F             	ANI	0FH			; Mask low nibble
313A  C6 30             	ADI	30H			; Make it ascii
313C  12                	STAX	D			; Poke it
313D  13                	INX	D
313E  13                	INX	D			; Skip ':'
313F  23                	INX	H
3140  0D                	DCR	C			; Count down
3141  C2 2C31           	JNZ	DISPL			; Next byte
3144  C9                	RET

                        *	Continuous mode display.

3145  3A CD20           CONTIM	LDA	S.CLKTR 		; Is system clock task resident ?
3148  A7                	ANA	A
3149  C2 5131           	JNZ	CONTIM0 		; Yes, let's go
314C  3E 34             	MVI	A,EC.CNR
314E  C3 5A25           	JMP	ERROR			; Clock Not Resident

3151  CD A02A           CONTIM0 CALL	TT.CE			; Set character mode/no echo
3154  3E 8D             	MVI	A,CR+200Q
3156  32 2A31           	STA	ENDTIM			; Set for continuous display

3159  3A BB22           	LDA	H19FLG
315C  A7                	ANA	A
315D  CA 6631           	JZ	CONTIM1 		; Not H19
3160  CD 5E19           	CALL	$TYPTX
3163  1B78B5            	DB	ESC,'x','5'+200Q	; Cursor off

3166  CD 1431           CONTIM1 CALL	DISPLA. 		; Display the time
3169  3A CC20           	LDA	S.TIME+2
316C  4F                	MOV	C,A			; Save current second

316D  FF 01             CONTIM2 SCALL	.SCIN
316F  D2 9431           	JNC	CONTIM3 		; Do it until he hits a key

3172  3A CC20           	LDA	S.TIME+2		; Get second
3175  B9                	CMP	C			; Has it changed yet ?
3176  CA 6D31           	JE	CONTIM2 		; No, Again ? ... Again !
3179  4F                	MOV	C,A			; Yes, save new second
317A  C5                	PUSH	B
317B  CD 1431           	CALL	DISPLA. 		; Show current time

317E  3A A822           	LDA	ULTRA
3181  A7                	ANA	A
3182  CA 9031           	JZ	CTIM			; Not Ultra

3185  3A BB22           	LDA	H19FLG
3188  A7                	ANA	A
3189  CA 9031           	JZ	CTIM			; Not H19

318C  3E 12             	MVI	A,CTLR
318E  FF 02             	SCALL	.SCOUT			; Tick the clock !

3190  C1                CTIM	POP	B
3191  C3 6D31           	JMP	CONTIM2 		; One more time

3194  3A BB22           CONTIM3 LDA	H19FLG
3197  A7                	ANA	A
3198  CA A131           	JZ	CONTIM4 		; Not H19
319B  CD 5E19           	CALL	$TYPTX
319E  1B79B5            	DB	ESC,'y','5'+200Q	; Cursor on

31A1  CD 2545           CONTIM4 CALL	$CRLF			; Newline
31A4  C7                	RST	SYSCMD

31A5                    	STL	'CLR - CLEAR FILE FLAGS'
31A5                    	EJECT
31A5                    	XTEXT	FLAG
                        *	FLAGS & USER enter PIP with the same code setup as COPY

                        ***	FLAG - SET OR CLEAR FILE FLAGS.
                        *	USER - PUT OR REMOVE USER AREA FLAGS.
                        *
                        *	FL[AGS] FNAME [,FNAME,...,FNAME]/SET:f..
                        *	FL[AGS] FNAME [,FNAME,...,FNAME]/CLR[:f..]
                        *	US[ER] FNAME [,FNAME,...,FNAME]/PUT:u..
                        *	US[ER] FNAME [,FNAME,...,FNAME]/REM[:u..]

                        ***	CLR - CLEAR FILE FLAGS.
                        *
                        *	CLR FNAME [,FNAME,...,FNAME]

31A5  E1                CLR	POP	H
31A6  CD 5647           	CALL	$SOB
31A9  A7                	ANA	A
31AA  CA 8E25           	JZ	ILLSYN

31AD  44                	MOV	B,H
31AE  4D                	MOV	C,L
31AF  C5                	PUSH	B			; SAVE COMMAND ADDRESS
31B0  CD 0C42           	CALL	FEC			; FIND END OF COMMAND LINE
31B3  01 0500           	LXI	B,CLRXL
31B6  11 C031           	LXI	D,CLRXA
31B9  CD AA18           	CALL	$MOVE			; ADD '/CLR' COMMAND
31BC  C1                	POP	B
31BD  C3 3A42           	JMP	PIP

31C0  2F434C52 00       CLRXA	DB	'/CLR',0
      = 0005            CLRXL	EQU	*-CLRXA

31C5                    	STL	'START - PROCESS POSITION INDEPENDANT LOAD'
31C5                    	EJECT
31C5                    	XTEXT	START
                        **	START - Load Real Time TASK file.
                        *
                        *	ST[ART] filename

      = 0020            TSKSIZ	EQU	8*1024/256		; Task size in sectors

31C5  E1                PICLOA	POP	H			; Point to start of parameters
31C6  CD 5347           	CALL	M$SOB			; Map + Skip over blanks
31C9  A7                	ANA	A
31CA  CA 8E25           	JZ	ILLSYN			; No name was given

31CD  22 E480           	SHLD	TSKBUF			; Stash name pointer away somewhere
31D0  CD F146           	CALL	$MOVEL			; Preset default
31D3  06009B22 0080     	DW	6,TSKBLK,SYSBLK
31D9  2A 5A00           	LHLD	S.PATH
31DC  22 C328           	SHLD	PTHPTR			; Preset pointer

31DF  2A E480           PICLD	LHLD	TSKBUF			; Fetch back name pointer
31E2  11 0080           	LXI	D,SYSBLK		; Default
31E5  AF                	XRA	A
31E6  FF 22             	SCALL	.OPENR
31E8  D2 F631           	JNC	PICLOA0 		; Found it

                        *	File could not be opened so we assume it isn't there and try
                        *	the next PATH entry.

31EB  CD 5C28           	CALL	PATH..			; Do error check first
31EE  3E 0C             	MVI	A,EC.FNF		; Assume error
31F0  CA 5A25           	JZ	ERROR
31F3  C3 DF31           	JMP	PICLD

31F6  11 E480           PICLOA0 LXI	D,TSKBUF		; Task buffer
31F9  01 0021           	LXI	B,TSKSIZ+1*256		; Allow max. 8k tasks
31FC  AF                	XRA	A
31FD  FF 04             	SCALL	.READ
31FF  DA 0A32           	JC	PICLOA1 		; Had error.  (That's good)

3202  AF                	XRA	A
3203  FF 2D             	SCALL	.CLEAR			; Clear the channel
3205  3E C8             	MVI	A,EC.8KL		; Task too large (8K limit)
3207  C3 5A25           	JMP	ERROR

320A  FE 01             PICLOA1 CPI	EC.EOF			; Should have been EOF
320C  C2 5A25           	JNE	ERROR			; huh??
320F  AF                	XRA	A
3210  FF 26             	SCALL	.CLOSE			; Close it nice

3212  2A E480           	LHLD	TSKBUF			; Get file type/subtype
3215  11 FF02           	LXI	D,FT.REL*256+377Q	; 377 002 = TSK
3218  CD 8E18           	CALL	$CDEHL
321B  3E C9             	MVI	A,EC.NTF		; Not Task File
321D  C2 5A25           	JNZ	ERROR

3220  CD A623           PICLOA3 CALL	SYSXIT1 		; Clear out drivers, etc ...
3223  CD EA2F           	CALL	LAD			; Lock in anything that's left

3226  2A E880           	LHLD	TSKBUF+4		; Displacement to PIC table
3229  E5                	PUSH	H			; Save it for later
322A  11 FAFF           	LXI	D,-6			; Don't need task header
322D  19                	DAD	D			; (HL) = Actual code length
322E  E3                	XTHL				; Save it.  (HL) = TSKBUF+4
322F  11 E480           	LXI	D,TSKBUF
3232  19                	DAD	D			; (HL) = Addr. of PIC table
3233  E3                	XTHL				; Save it.  Get back code length.
3234  E5                	PUSH	H			; Save that again, too.
3235  CD 9418           	CALL	$CHL			; Make length negative
3238  EB                	XCHG				; Put that in (DE)
3239  2A EE20           	LHLD	S.RFWA
323C  19                	DAD	D			; (HL) = New RFWA & Task destination
323D  22 D020           	SHLD	S.SYSM
3240  22 EE20           	SHLD	S.RFWA			; Set it for HDOS
3243  11 FAFF           	LXI	D,-6
3246  19                	DAD	D			; Offset since we won't need header
3247  EB                	XCHG				; (DE) = Task destination address
3248  E1                	POP	H			; (HL) = Code length
3249  E3                	XTHL				; Swap it with PIC table address
324A  01 E480           	LXI	B,TSKBUF
324D  CD 7F1B           	CALL	$REL			; Use H17 ROM to relocate it
3250  2A EE20           	LHLD	S.RFWA			; Code destination
3253  11 EA80           	LXI	D,TSKBUF+6		; Relocated code
3256  C1                	POP	B			; Length we want to move
3257  CD AA18           	CALL	$MOVE			; Move it up
325A  2A EE20           	LHLD	S.RFWA			; Also entry point for code
325D  CD 6C32           	CALL	$PCHL			; Go to it.
3260  D2 CD22           	JNC	SYSXIT
3263  22 EE20           	SHLD	S.RFWA			; Set new system memory as provided
3266  22 D020           	SHLD	S.SYSM			;  by the task

3269  C3 CD22           	JMP	SYSXIT			; Go back to SYSCMD

326C  E9                $PCHL	PCHL

326D                    	STL	'LOG - TOGGLE LOG ON/OFF  (Uses ECHO.TAS)'
326D                    	EJECT
326D                    	XTEXT	LOG
                        ***	LOG - Toggle System Log On/Off.
                        *
                        *	Uses ECHO.TAS, or BATCH.TAS
                        *
                        *	LOG [ON]
                        *	LOG OF[F]

      = 007F            .LOG	EQU	177Q			; SCALL for Logging Task

326D  E1                TOGLOG	POP	H			; Get pointer to command line
326E  CD 5347           	CALL	M$SOB			; Map + Skip over blanks
3271  A7                	ANA	A
3272  CA 8D32           	JZ	LOGON			; Default LOG ON
3275  CD 8918           	CALL	$HLIHL			; Get 1st 2 characters
3278  11 4F4E           	LXI	D,'NO'			; 'ON'
327B  CD 8E18           	CALL	$CDEHL
327E  CA 8D32           	JE	LOGON			; Turn log on
3281  16 46             	MVI	D,'F'			; 'OF'
3283  CD 8E18           	CALL	$CDEHL
3286  C2 8E25           	JNE	ILLSYN			; Illegal syntax.  Not ON or OFF.

                        *	Turn log off.

3289  AF                	XRA	A
328A  FF 7F             LOG..	SCALL	.LOG			; Call the task
328C  C7                	RST	SYSCMD			; Done ...

328D  3E 01             LOGON	MVI	A,1			; Turn log on.
328F  C3 8A32           	JMP	LOG..			; Go do it

3292                    	STL	'DMM - DISPLAY MAIN MEMORY'
3292                    	EJECT
3292                    	XTEXT	DMM
                        ***	DMM - Display Main Memory Information
                        *
                        *	DM[M]

3292  E1                DMM	POP	H			; Clear stack

                        ***	Calculate User Memory Size

3293  21 8022           	LXI	H,USERFWA		; Start of user memory
3296  CD 9418           	CALL	$CHL
3299  EB                	XCHG
329A  2A D020           	LHLD	S.SYSM			; Start of system memory
329D  19                	DAD	D			; (HL) = User area size
329E  E5                	PUSH	H			; Save it
329F  E5                	PUSH	H
32A0  44                	MOV	B,H
32A1  4D                	MOV	C,L
32A2  21 C633           	LXI	H,DMMVH
32A5  3E 05             	MVI	A,5
32A7  CD 7547           	CALL	$UDDS
32AA  F1                	POP	PSW			; (A) = High byte of size
32AB  E6 FC             	ANI	11111100B
32AD  0F                	RRC
32AE  0F                	RRC				; Divide it by 4
32AF  4F                	MOV	C,A
32B0  06 00             	MVI	B,0			; (BC) = # k (whole)
32B2  21 D333           	LXI	H,DMMVHK
32B5  3E 02             	MVI	A,2
32B7  CD 7547           	CALL	$UDDS			; Put it in message

32BA  E1                	POP	H
32BB  11 0500           	LXI	D,5
32BE  19                	DAD	D			; Round to 1/100 th K
32BF  7C                	MOV	A,H
32C0  E6 03             	ANI	11B
32C2  57                	MOV	D,A
32C3  5D                	MOV	E,L
32C4  3E 32             	MVI	A,50
32C6  CD 0719           	CALL	$MU86
32C9  44                	MOV	B,H
32CA  4D                	MOV	C,L			; (BC) = Remainder*50
32CB  11 0002           	LXI	D,512			; (DE) = 1K / 2
32CE  CD 4618           	CALL	$DU66
32D1  44                	MOV	B,H
32D2  4D                	MOV	C,L			; (BC) = 00-99
32D3  3E 02             	MVI	A,2
32D5  21 D633           	LXI	H,DMMVHF		; .nnK
32D8  CD 6F19           	CALL	$UDD			; MUST pad with zeros in case = .01

                        *	Calculate HDOS Reserved Memory Size

32DB  2A D020           	LHLD	S.SYSM			; Get FWA of System reserved
32DE  CD 9418           	CALL	$CHL
32E1  EB                	XCHG
32E2  2A CE20           	LHLD	S.HIMEM
32E5  19                	DAD	D
32E6  23                	INX	H			; (HL) = Size of reserved area
32E7  E5                	PUSH	H			; Save it
32E8  E5                	PUSH	H
32E9  44                	MOV	B,H
32EA  4D                	MOV	C,L
32EB  21 A333           	LXI	H,DMMVG
32EE  3E 05             	MVI	A,5
32F0  CD 7547           	CALL	$UDDS
32F3  F1                	POP	PSW			; (A) = High byte of size
32F4  E6 FC             	ANI	11111100B
32F6  0F                	RRC
32F7  0F                	RRC				; Divide it by 4
32F8  4F                	MOV	C,A
32F9  06 00             	MVI	B,0			; (BC) = # k (whole)
32FB  21 B033           	LXI	H,DMMVGK
32FE  3E 02             	MVI	A,2
3300  CD 7547           	CALL	$UDDS			; Put it in message

3303  E1                	POP	H
3304  11 0500           	LXI	D,5
3307  19                	DAD	D			; Round to 1/100 th K
3308  7C                	MOV	A,H
3309  E6 03             	ANI	11B
330B  57                	MOV	D,A
330C  5D                	MOV	E,L
330D  3E 32             	MVI	A,50
330F  CD 0719           	CALL	$MU86
3312  44                	MOV	B,H
3313  4D                	MOV	C,L			; (BC) = Remainder*50
3314  11 0002           	LXI	D,512			; (DE) = 1K / 2
3317  CD 4618           	CALL	$DU66
331A  44                	MOV	B,H
331B  4D                	MOV	C,L			; (BC) = 00-99
331C  3E 02             	MVI	A,2
331E  21 B333           	LXI	H,DMMVGF		; .nnK
3321  CD 6F19           	CALL	$UDD			; MUST pad with zeros in case = .01

                        *	Calculate HDOS Locked Memory Size

3324  2A EE20           	LHLD	S.RFWA			; Get FWA of HDOS reserved
3327  CD 9418           	CALL	$CHL
332A  EB                	XCHG
332B  2A CE20           	LHLD	S.HIMEM
332E  19                	DAD	D
332F  23                	INX	H			; (HL) = Size of locked area
3330  E5                	PUSH	H			; Save it
3331  E5                	PUSH	H
3332  44                	MOV	B,H
3333  4D                	MOV	C,L
3334  21 7E33           	LXI	H,DMMVF
3337  3E 05             	MVI	A,5
3339  CD 7547           	CALL	$UDDS
333C  F1                	POP	PSW			; (A) = High byte of size
333D  E6 FC             	ANI	11111100B
333F  0F                	RRC
3340  0F                	RRC				; Divide it by 4
3341  4F                	MOV	C,A
3342  06 00             	MVI	B,0			; (BC) = # k (whole)
3344  21 8B33           	LXI	H,DMMVFK
3347  3E 02             	MVI	A,2
3349  CD 7547           	CALL	$UDDS			; Put it in message

334C  E1                	POP	H
334D  11 0500           	LXI	D,5
3350  19                	DAD	D			; Round to 1/100 th K
3351  7C                	MOV	A,H
3352  E6 03             	ANI	11B
3354  57                	MOV	D,A
3355  5D                	MOV	E,L
3356  3E 32             	MVI	A,50
3358  CD 0719           	CALL	$MU86
335B  44                	MOV	B,H
335C  4D                	MOV	C,L			; (BC) = Remainder*50
335D  11 0002           	LXI	D,512			; (DE) = 1K / 2
3360  CD 4618           	CALL	$DU66
3363  44                	MOV	B,H
3364  4D                	MOV	C,L			; (BC) = 00-99
3365  3E 02             	MVI	A,2
3367  21 8E33           	LXI	H,DMMVFF		; .nnK
336A  CD 6F19           	CALL	$UDD			; MUST pad with zeros in case = .01

                        ***	Tell the tale ...

336D  CD 5E19           	CALL	$TYPTX
3370  0A                	DB	NL
3371  48444F53 204C6F63 	DB	'HDOS Locked:',TAB
3379  6B65643A 09
337E  6E6E6E6E 6E204279 DMMVF	DB	'nnnnn Bytes',TAB,'(nn.nn k)',NL
3386  74657309 286E6E2E
338E  6E6E206B 290A
      = 338B            DMMVFK	EQU	*-9
      = 338E            DMMVFF	EQU	*-6

3394  48444F53 20526573 	DB	'HDOS Reserved:',TAB
339C  65727665 643A09
33A3  6E6E6E6E 6E204279 DMMVG	DB	'nnnnn Bytes',TAB,'(nn.nn k)',NL
33AB  74657309 286E6E2E
33B3  6E6E206B 290A
      = 33B0            DMMVGK	EQU	*-9
      = 33B3            DMMVGF	EQU	*-6

33B9  55736572 204D656D 	DB	'User Memory:',TAB
33C1  6F72793A 09
33C6  6E6E6E6E 6E204279 DMMVH	DB	'nnnnn Bytes',TAB,'(nn.nn k)',NL
33CE  74657309 286E6E2E
33D6  6E6E206B 290A
      = 33D3            DMMVHK	EQU	*-9
      = 33D6            DMMVHF	EQU	*-6

33DC  0A504950 206973A0 	DB	NL,'PIP is',' '+200Q

33E4  3A 9142           	LDA	PIPMEM	;Is PIP in memory ?
33E7  A7                	ANA	A
33E8  C2 F233           	JNZ	DMM.Y
33EB  CD 5E19           	CALL	$TYPTX
33EE  4E4F54A0          	DB	'NOT',' '+200Q

33F2  CD 5E19           DMM.Y	CALL	$TYPTX
33F5  696E206D 656D6F72 	DB	'in memory',ENL
33FD  798A

33FF  C7                	RST	SYSCMD

3400                    	STL	'SI - SHOW SYSTEM INFORMATION'
3400                    	EJECT
3400                    	XTEXT	SI
                        ***	SI - System Information
                        *
                        *	SI

3400  E1                SI	POP	H			; Clear stack

3401  FF 09             	SCALL	.VERS			; Get version #
3403  DA BD23           	JC	SYSX1			; Oops !
3406  21 9435           	LXI	H,MSG1V
3409  F5                	PUSH	PSW
340A  1F                	RAR
340B  1F                	RAR
340C  1F                	RAR
340D  1F                	RAR
340E  CD B547           	CALL	NIBL			; Unpack first digit
3411  23                	INX	H			; Skip '.'
3412  F1                	POP	PSW
3413  CD B547           	CALL	NIBL			; Unpack second digit

3416  3A 0B00           	LDA	S.REV			; Get revision #
3419  06 00             	MVI	B,0
341B  4F                	MOV	C,A
341C  3E 03             	MVI	A,3
341E  21 9D35           	LXI	H,MSG1A
3421  CD 7047           	CALL	$UDDN			; Unpack revision #

3424  2A 0C00           	LHLD	S.REV+1 		; Get assembly date
3427  EB                	XCHG
3428  21 A735           	LXI	H,MSG1B
342B  CD 2B45           	CALL	$DAD			; Unpack assembly date

342E  2A 0E00           	LHLD	S.REV+3 		; Get assembly time
3431  22 E480           	SHLD	LABEL			; Save for now
3434  3E 61             	MVI	A,'a'
3436  32 B935           	STA	MSG1D			; Assume am
3439  7D                	MOV	A,L			; Get hours
343A  FE 12             	CPI	12H
343C  DA 4834           	JC	SI.T0			; am
343F  3E 70             	MVI	A,'p'
3441  32 B935           	STA	MSG1D			; Make pm
3444  7D                	MOV	A,L			; Get hours
3445  D6 12             	SUI	12H
3447  27                	DAA				; Adjust from military time
3448  A7                SI.T0	ANA	A			; Test for 00:XXm
3449  C2 4E34           	JNZ	SI.T1
344C  3E 12             	MVI	A,12H			; Force 12:XXm
344E  32 E480           SI.T1	STA	LABEL			; Set time
3451  0E 02             	MVI	C,2
3453  11 B435           	LXI	D,MSG1C
3456  21 E480           	LXI	H,LABEL
3459  CD 2C31           	CALL	DISPL			; Unpack assembly time

345C  21 8535           	LXI	H,MSG1
345F  FF 03             	SCALL	.PRINT

3461  3A 0500           	LDA	S.FMASK
3464  E6 C0             	ANI	F.CPU
                        	ERRNZ	F.CPU-11000000B
3466  07                	RLC
3467  07                	RLC
3468  21 6535           	LXI	H,CTAB
346B  CD 5B35           	CALL	SAYTYPE

346E  21 D535           	LXI	H,MSG2
3471  FF 03             	SCALL	.PRINT

3473  3A 0500           	LDA	S.FMASK
3476  E6 30             	ANI	F.TERM
                        	ERRNZ	F.TERM-00110000B
3478  0F                	RRC
3479  0F                	RRC
347A  0F                	RRC
347B  0F                	RRC
347C  21 6D35           	LXI	H,TTAB
347F  CD 5B35           	CALL	SAYTYPE

3482  21 EC35           	LXI	H,MSG3
3485  FF 03             	SCALL	.PRINT

3487  3A 0500           	LDA	S.FMASK
348A  E6 0C             	ANI	F.MACH
                        	ERRNZ	F.MACH-00001100B
348C  0F                	RRC
348D  0F                	RRC
348E  21 7535           	LXI	H,MTAB
3491  CD 5B35           	CALL	SAYTYPE

3494  21 0536           	LXI	H,MSG4
3497  FF 03             	SCALL	.PRINT

3499  3A 0500           	LDA	S.FMASK
349C  E6 03             	ANI	F.CLK
                        	ERRNZ	F.CLK-00000011B
349E  21 7D35           	LXI	H,STAB
34A1  CD 5B35           	CALL	SAYTYPE

34A4  21 2436           	LXI	H,MSG5
34A7  FF 03             	SCALL	.PRINT

34A9  2A CE20           	LHLD	S.HIMEM
34AC  23                	INX	H
34AD  7C                	MOV	A,H			; number of pages
34AE  0F                	RRC
34AF  0F                	RRC
34B0  E6 3F             	ANI	00111111B		; (A) = # K-bytes
34B2  C2 B734           	JNZ	OKK			; non-zero
34B5  3E 40             	MVI	A,64			;  else is 64k

34B7  4F                OKK	MOV	C,A
34B8  06 00             	MVI	B,0
34BA  3E 02             	MVI	A,2
34BC  21 3236           	LXI	H,MSG6
34BF  E5                	PUSH	H
34C0  CD 6F19           	CALL	$UDD			; unpack

34C3  E1                	POP	H
34C4  FF 03             	SCALL	.PRINT			; say #k

                        *	Show S.MOUNT status

34C6  CD 5E19           	CALL	$TYPTX
34C9  0A537973 74656D20 	DB	NL,'System Disk is',' '+200Q
34D1  4469736B 206973A0
34D9  3A 1A21           	LDA	S.MOUNT
34DC  A7                	ANA	A
34DD  C2 EB34           	JNZ	SI.M
34E0  CD 5E19           	CALL	$TYPTX
34E3  52657365 F4       	DB	'Rese','t'+200Q
34E8  C3 F534           	JMP	SI.C

34EB  CD 5E19           SI.M	CALL	$TYPTX
34EE  4D6F756E 7465E4   	DB	'Mounte','d'+200Q

                        *	Show S.CLKTR status

34F5  CD 5E19           SI.C	CALL	$TYPTX
34F8  0A537973 74656D20 	DB	NL,'System Clock is',' '+200Q
3500  436C6F63 6B206973
3508  A0
3509  3A CD20           	LDA	S.CLKTR
350C  A7                	ANA	A
350D  C2 1735           	JNZ	SI.C.
3510  CD 5E19           	CALL	$TYPTX
3513  4E4F54A0          	DB	'NOT',' '+200Q
3517  CD 5E19           SI.C.	CALL	$TYPTX
351A  52657369 64656EF4 	DB	'Residen','t'+200Q

                        *	Show .MFLAG status

3522  CD 5E19           	CALL	$TYPTX
3525  0A557365 7220436C 	DB	NL,'User Clock Vector is',' '+200Q
352D  6F636B20 56656374
3535  6F722069 73A0
353B  3A 0820           	LDA	.MFLAG
353E  E6 01             	ANI	UO.CLK
3540  CA 4B35           	JZ	SI.D
3543  CD 5E19           	CALL	$TYPTX
3546  45EE              	DB	'E','n'+200Q
3548  C3 5135           	JMP	SI.D.

354B  CD 5E19           SI.D	CALL	$TYPTX
354E  4469F3            	DB	'Di','s'+200Q
3551  CD 5E19           SI.D.	CALL	$TYPTX
3554  61626C65 648A     	DB	'abled',ENL

355A  C7                	RST	SYSCMD			; All through

355B  87                SAYTYPE ADD	A
355C  CD 3A18           	CALL	$DADA
355F  CD 8918           	CALL	$HLIHL
3562  FF 03             	SCALL	.PRINT
3564  C9                	RET

                        *	CPU Table

3565  D035              CTAB	DW	M8080
3567  CB35              	DW	M8085
3569  C735              	DW	MZ80
356B  3D36              	DW	UNKNOWN

                        *	Terminal Table

356D  DF35              TTAB	DW	MTTY
356F  E835              	DW	MH19
3571  3D36              	DW	UNKNOWN
3573  3D36              	DW	UNKNOWN

                        *	Machine Table

3575  F935              MTAB	DW	MH8
3577  FC35              	DW	MH89
3579  0036              	DW	MZ100
357B  3D36              	DW	UNKNOWN

                        *	Speed Table

357D  1236              STAB	DW	M2MHZ
357F  1836              	DW	M4MHZ
3581  1E36              	DW	M6MHZ
3583  3D36              	DW	UNKNOWN

                        *	Messages

3585  0A48444F 53205665 MSG1	DB	NL,'HDOS Version: '
358D  7273696F 6E3A20
3594  6E2E6E20 5265762E MSG1V	DB	'n.n Rev. '
359C  20
359D  6E6E6E20 4173206F MSG1A	DB	'nnn As of '
35A5  6620
35A7  30302D3F 3F3F2D30 MSG1B	DB	'00-???-00 at '
35AF  30206174 20
35B4  30303A30 30       MSG1C	DB	'00:00'
35B9  6D0A0A            MSG1D	DB	'm',NL,NL


35BC  09435055 20547970 	DB	TAB,'CPU Type:',TAB+EOL
35C4  653A89

35C7  5A38308A          MZ80	DB	'Z80',ENL
35CB  38303835 8A       M8085	DB	'8085',ENL
35D0  38303830 8A       M8080	DB	'8080',ENL

35D5  09546572 6D696E61 MSG2	DB	TAB,'Terminal',TAB+EOL
35DD  6C89

35DF  44756D62 20545459 MTTY	DB	'Dumb TTY',ENL
35E7  8A
35E8  4831398A          MH19	DB	'H19',ENL

35EC  09537973 74656D20 MSG3	DB	TAB,'System Type',TAB+EOL
35F4  54797065 89

35F9  48388A            MH8	DB	'H8',ENL
35FC  4838398A          MH89	DB	'H89',ENL
3600  5A313030 8A       MZ100	DB	'Z100',ENL

3605  09436C6F 636B2053 MSG4	DB	TAB,'Clock Speed',TAB+EOL
360D  70656564 89

3612  32204D48 7A8A     M2MHZ	DB	'2 MHz',ENL
3618  34204D48 7A8A     M4MHZ	DB	'4 MHz',ENL
361E  36204D48 7A8A     M6MHZ	DB	'6 MHz',ENL

3624  09546F74 616C204D MSG5	DB	TAB,'Total Memory',TAB+EOL
362C  656D6F72 7989

3632  3F3F204B 2D427974 MSG6	DB	'?? K-Bytes',ENL
363A  65738A

363D  556E6B6E 6F776E8A UNKNOWN DB	'Unknown',ENL

3645                    	STL	'DEV - SHOW ALL DEVICES'
3645                    	EJECT
3645                    	XTEXT	DEV
                        ***	DEVICES - Show All Devices
                        *
                        *	DEV[ICES]		Show all devices
                        *	DEV[ICES] xx[:] 	Show xx device

3645  CD 2545           DEVICE	CALL	$CRLF			; blank line for looks

3648  E1                	POP	H			; get command address
3649  CD 5347           	CALL	M$SOB			; Map + Skip white space
364C  A7                	ANA	A			; any argument?
364D  CA 6236           	JZ	DEVNA			; no, do all.

                        *	have argument, check for valid device.

3650  CD 8918           	CALL	$HLIHL			; (hl) = name
3653  EB                	XCHG				; in (de)
3654  FF 0A             	SCALL	.GDA			; get the driver's address
3656  DA 5A25           	JC	ERROR			; gong.

3659  60                	MOV	H,B
365A  69                	MOV	L,C			; (hl) = table entry address
365B  22 C537           	SHLD	DEVPTR			; save it
365E  CD 7C36           	CALL	SHODEV			;  display the information

3661  C7                	RST	SYSCMD			; exit.

                        *	display all devices

3662  2A EC20           DEVNA	LHLD	S.DFWA			; get device FWA

3665  22 C537           DEVLP	SHLD	DEVPTR			; save it
3668  7E                	MOV	A,M			; see if anything there
3669  B7                	ORA	A			; end of table
366A  CA A425           	JZ	SYSCMD. 		; all done
366D  3D                	DCR	A			; anything of importance
366E  C4 7C36           	CNZ	SHODEV			; show the device
3671  2A C537           	LHLD	DEVPTR			; get the pointer back
3674  3E 0E             	MVI	A,DEVELEN		; entry length
3676  CD 3A18           	CALL	$DADA			; add it in
3679  C3 6536           	JMP	DEVLP			; try again
367C                    	SPACE	3
      = 367C            SHODEV	EQU	*			; show all about the device

                        *	SHODEV -- This routine is used to show the status of all
                        *	units of a specified device.

367C  E5                	PUSH	H			; save it on the stack
367D  CD 8918           	CALL	$HLIHL			; get device characters in (HL)
3680  22 A536           	SHLD	DEVNAM			; save it
3683  E1                	POP	H			; get to the max unit
3684  3E 08             	MVI	A,DEV.MNU		; maximum number of units available
3686  CD 3A18           	CALL	$DADA			; add it in
3689  7E                	MOV	A,M			; get it
368A  32 C837           	STA	MAXUNI			; set maximum unit possible
368D  AF                	XRA	A			; set current unit to zero
368E  32 C737           	STA	CURUNI			; done
      = 3691            UNITS	EQU	*			; show units till done
3691  3A C837           	LDA	MAXUNI			; get maximum unit
3694  47                	MOV	B,A			; store it
3695  3A C737           	LDA	CURUNI			; get that too ...
3698  B8                	CMP	B			; is CURUNI >= MAXUNI
3699  D0                	RNC				; yup, return
369A  F6 30             	ORI	'0'			; make ascii
369C  32 A736           	STA	DEVUNI			; set it in there

                        *	Print device name at beginning of line

369F  CD 4746           	CALL	$GNL			; get a new line

36A2  CD 5E19           	CALL	$TYPTX
36A5  5858              DEVNAM	DB	'XX'
36A7  583AA0            DEVUNI	DB	'X:',240Q		; device name out

                        *	Next, The residence code '++' = in memory
                        *				 '**' = in memory & locked
                        *				 '##' = fixed in memory
                        *				 '--' = unload pending

36AA  2A C537           	LHLD	DEVPTR			; get our pointer back
36AD  3E 02             	MVI	A,DEV.RES		; get to it's flag
36AF  CD 3A18           	CALL	$DADA			; add it in
36B2  7E                	MOV	A,M			; see if in memory
36B3  E6 1F             	ANI	377Q-DR.SPL		; mask off set preamble length
36B5  CA 8437           	JZ	SHOCAP			; no, show capabilities
36B8  E6 04             	ANI	DR.FX
36BA  3E 23             	MVI	A,'#'			; fixed in memory
36BC  C2 D136           	JNZ	RES.
36BF  7E                	MOV	A,M
36C0  E6 08             	ANI	DR.UNL
36C2  3E 2D             	MVI	A,'-'			; unload pending
36C4  C2 D136           	JNZ	RES.
36C7  7E                	MOV	A,M
36C8  E6 02             	ANI	DR.PR
36CA  3E 2A             	MVI	A,'*'			; in memory and locked
36CC  C2 D136           	JNZ	RES.
36CF  3E 2B             	MVI	A,'+'			; in memory
36D1  FF 02             RES.	SCALL	.SCOUT
36D3  FF 02             	SCALL	.SCOUT
36D5  3E 04             	MVI	A,DEV.FLG-DEV.RES	; get to the device flag
36D7  CD 3A18           	CALL	$DADA			; do it
36DA  7E                	MOV	A,M			; now test the bits of directory
36DB  E6 01             	ANI	DT.DD			; is it directory
36DD  CA 8437           	JZ	SHOCAP			; sho capabilities
36E0  3E 01             	MVI	A,DEV.MUM-DEV.FLG	; get to the mounted units
36E2  CD 3A18           	CALL	$DADA			; do it
36E5  4E                	MOV	C,M			; get the value
36E6  3A C737           	LDA	CURUNI			; get the current unit
36E9  47                	MOV	B,A			; put it in (B) for BITS
36EA  AF                	XRA	A
36EB  CD E343           	CALL	BITS			; set the correct bits
36EE  A1                	ANA	C			; and it through mounted units
36EF  CA 8437           	JZ	SHOCAP			; show capabilities

                        ***	Got a mounted unit on a device
                        *
                        *	Calculate free areas on the disk

36F2  2A C537           	LHLD	DEVPTR			; get the pointer
36F5  3E 09             	MVI	A,DEV.UNT		; set to unit specific data
36F7  CD 3A18           	CALL	$DADA			; get to it
36FA  CD 8918           	CALL	$HLIHL			; got the pointer
36FD  3A C737           	LDA	CURUNI			; get the unit
3700  B7                UNT$LP	ORA	A			; is this the block
3701  CA 0F37           	JZ	GOTUNT			; got unit specific data
3704  F5                	PUSH	PSW			; save it
3705  3E 08             	MVI	A,UNT.SIZ		; get the length
3707  CD 3A18           	CALL	$DADA			; add it in
370A  F1                	POP	PSW			; get back unit
370B  3D                	DCR	A
370C  C3 0037           	JMP	UNT$LP			; loop through again

      = 370F            GOTUNT	EQU	*			; got the unit specific data for it
370F  3E 01             	MVI	A,UNT.SPG		; get sectors / group
3711  CD 3A18           	CALL	$DADA			; got it
3714  7E                	MOV	A,M			; get and save
3715  F5                	PUSH	PSW			; save for multiply
3716  23                	INX	H			; bump to GRT address
                        	ERRNZ	UNT.GRT-UNT.SPG-1
3717  CD 8918           	CALL	$HLIHL			; get GRT address
371A  01 0000           	LXI	B,0			; going to count groups
371D  7E                GRPCNT	MOV	A,M			; get it's value
371E  03                	INX	B
371F  B7                	ORA	A			; is it null
3720  6F                	MOV	L,A			; put it in there
3721  C2 1D37           	JNZ	GRPCNT			; count another group
3724  0B                	DCX	B			; drop counter by one
3725  F1                	POP	PSW			; restore SPG
3726  C5                	PUSH	B
3727  D1                	POP	D			; put it in DE
3728  CD 0719           	CALL	$MU86			; multiply it
372B  E5                	PUSH	H
372C  C1                	POP	B
372D  3E 05             	MVI	A,5
372F  21 4237           	LXI	H,DEVFRE		; free areas
3732  CD 7047           	CALL	$UDDN			; unpack 'em
3735  CD 5E19           	CALL	$TYPTX
3738  094D6F75 6E746564 	DB	9,'Mounted',9,'['
3740  095B
3742  2F445443 2F5D89   DEVFRE	DB	'/DTC/]',211Q		; tab for label buffer

                        *	Now print Label buffer

3749  2A C537           	LHLD	DEVPTR			; set up a jump to it
374C  3E 03             	MVI	A,DEV.JMP		; jump vector
374E  CD 3A18           	CALL	$DADA			; add it in
3751  22 6937           	SHLD	DEVADD			; set device address
3754  21 0900           	LXI	H,9			; sector 9
3757  11 E480           	LXI	D,LABEL
375A  01 0001           	LXI	B,256
375D  3A C737           	LDA	CURUNI
3760  32 3121           	STA	AIO.UNI			; set up the unit
3763  3E 02             	MVI	A,DC.RER		; if H17, were reading TR. 0
3765  CD 3D25           	CALL	CC.OFF			; Prohibit Control Char.
3768  CD 0000           	CALL	*-*			; do the call
      = 3769            DEVADD	EQU	*-2
376B  F5                	PUSH	PSW
376C  CD 4425           	CALL	CC.ON			; Allow Control Char.
376F  F1                	POP	PSW
3770  DA A737           	JC	NXTUNI			; do the next unit
3773  21 F580           	LXI	H,LABEL+LAB.LAB 	; get to label
3776  CD AE37           	CALL	$DTB			; delete trailing blanks
3779  7E                DPRINT	MOV	A,M			; get the value
377A  B7                	ORA	A			; null
377B  CA A737           	JZ	NXTUNI			; do the next unit
377E  FF 02             	SCALL	.SCOUT			; print it
3780  23                	INX	H
3781  C3 7937           	JMP	DPRINT			; try again

      = 3784            SHOCAP	EQU	*			; Show capabilities
3784  CD 5E19           	CALL	$TYPTX
3787  0989              	DB	TAB,TAB+200Q		; TAB over a few
3789  2A C537           	LHLD	DEVPTR			; get the pointer
378C  3E 06             	MVI	A,DEV.FLG
378E  CD 3A18           	CALL	$DADA			; add to it
3791  7E                	MOV	A,M			; get the value
3792  21 C937           	LXI	H,SHO.F 		; point at flags
3795  0E 08             	MVI	C,8			; check all 8
3797  0F                SHO.0	RRC				; rotate right to test next bit
3798  F5                	PUSH	PSW			; save magic byte
3799  7E                	MOV	A,M			; get flag
379A  DA 9F37           	JC	SHO.1			; it was on so show it
379D  3E 2D             	MVI	A,'-'			; it wasn't on so pad it
379F  FF 02             SHO.1	SCALL	.SCOUT			; show flag or pad char
37A1  23                	INX	H			; bump flag pointer
37A2  F1                	POP	PSW			; restore byte
37A3  0D                	DCR	C			; count down
37A4  C2 9737           	JNZ	SHO.0			; more to go

37A7  21 C737           NXTUNI	LXI	H,CURUNI
37AA  34                	INR	M			; bump it
37AB  C3 9136           	JMP	UNITS			; try again

      = 37AE            $DTB	EQU	*			; delete trailing blanks
37AE  E5                	PUSH	H			; save it
37AF  CD B437           	CALL	$DTB.
37B2  E1                	POP	H
37B3  C9                	RET				; to caller

37B4  7E                $DTB.	MOV	A,M			; look for null
37B5  23                	INX	H
37B6  B7                	ORA	A
37B7  C2 B437           	JNZ	$DTB.			; try again
37BA  2B                	DCX	H
37BB  2B                $DTB..	DCX	H			; drop again
37BC  7E                	MOV	A,M			; check for space
37BD  FE 20             	CPI	' '			; is it
37BF  C0                	RNZ				; nope
37C0  36 00             	MVI	M,0
37C2  C3 BB37           	JMP	$DTB..			; try again

37C5  0000              DEVPTR	DW	0
37C7  00                CURUNI	DB	0
37C8  00                MAXUNI	DB	0

37C9  44525755 43463F4E SHO.F	DB	'DRWUCF?N'

37D1                    	STL	'DEFAULT - SET/SHOW SYSTEM DEFAULT DEVICE'
37D1                    	EJECT
37D1                    	XTEXT	DEFAULT
                        ***	DEFAULT - SET/SHOW SYSTEM DEFAULT DEVICE
                        *
                        *	DEF[AULT]	   -> SHOW DEFAULT
                        *	DEF[AULT] XX[n][:] -> SET DEFAULT ( implied unit = 0 )
                        *	DEF[AULT] DEVEXT   -> SET DEFAULT DEVICE & EXTENSION
                        *	DEF[AULT] :	   -> SET DEFAULT DEFAULT
                        *	DEF[AULT] 0	   -> SET DEFAULT EXTENSION TO NULLS


37D1  E1                DEFAULT POP	H
37D2  CD 5347           	CALL	M$SOB			; Map + Skip over blanks
37D5  A7                	ANA	A
37D6  CA 1138           	JZ	DEF3			; JUST WANTS TO KNOW THE DEFAULT

                        *	SET NEW DEFAULT

37D9  FE 30             	CPI	'0'
37DB  CA 2B38           	JE	DEF4			; NULL EXTENSION
37DE  FE 3A             	CPI	':'
37E0  CA 3538           	JE	DEF5			; SET DEFAULT DEFAULT
37E3  CD 4238           	CALL	CVDD			; CHECK FOR VALID DIR DEVICE
37E6  DA 5A25           	JC	ERROR			; SOMETHING WRONG

37E9  22 6A00           DEF2	SHLD	S.DFBLK 		; STORE 'XX'
37EC  21 6C00           	LXI	H,S.DFBLK+2		; STORE UNIT #
37EF  77                	MOV	M,A
37F0  23                	INX	H
37F1  0A                	LDAX	B			; Get possible char.
37F2  A7                	ANA	A			; Is it null
37F3  CA 3E38           	JZ	DEF6			; Yes, end of command line
37F6  FE 3A             	CPI	':'			; Is it ':'
37F8  C2 0138           	JNE	DEF2.0			; No, start stuffing
37FB  03                	INX	B			; Bump past ':'
37FC  0A                	LDAX	B			; Get possible char.
37FD  A7                	ANA	A			; Is it null
37FE  CA 3E38           	JZ	DEF6			; Yes, end of command line
3801  77                DEF2.0	MOV	M,A			; Stuff first extension char.
3802  23                	INX	H
3803  03                	INX	B
3804  0A                	LDAX	B			; Get next char.
3805  77                	MOV	M,A			; Stuff second extension char.
3806  23                	INX	H
3807  03                	INX	B
3808  A7                	ANA	A			; Was second char. a null
3809  CA 0D38           	JZ	DEF2.1			; Yes, stuff null in last byte
380C  0A                	LDAX	B			; No, get next char.
380D  77                DEF2.1	MOV	M,A			; Stuff third extension char.
380E  C3 3E38           	JMP	DEF6

                        *	DISPLAY THE CURRENT DEFAULT

3811  CD 6430           DEF3	CALL	PR.CS
3814  CD 5E19           	CALL	$TYPTX
3817  44656661 756C7420 	DB	'Default is',' '+200Q
381F  6973A0

3822  21 6A00           	LXI	H,S.DFBLK
3825  3E 06             	MVI	A,6			; TYPE THE DEFAULT DEVICE
3827  CD 6447           	CALL	$TYPCC			; AND EXTENSION
382A  C7                	RST	SYSCMD

382B  21 6D00           DEF4	LXI	H,S.DFBLK+3		; FORCE NULL EXTENSION
382E  AF                	XRA	A
382F  77                	MOV	M,A
3830  23                	INX	H
3831  77                	MOV	M,A
3832  23                	INX	H
3833  77                	MOV	M,A
3834  C7                	RST	SYSCMD			; GO HOME

3835  CD F146           DEF5	CALL	$MOVEL			; SET DEFAULT DEFAULT
3838  06008322 6A00     	DW	DEFAL,DEFA,S.DFBLK

383E  CD 8D38           DEF6	CALL	SETDEV			; SET DEVICE NAMES
3841  C7                	RST	SYSCMD			; GO HOME

      = 3842            CVDD	EQU	*			; CHECK FOR VALID DIR DEVICE

3842  5E                	MOV	E,M
3843  23                	INX	H
3844  56                	MOV	D,M			; (DE) = 'XX'
3845  23                	INX	H			; HL => n
3846  E5                	PUSH	H
3847  FF 0A             	SCALL	.GDA			; BC => DEV. TABLE ENTRY
3849  E1                	POP	H
384A  D8                	RC				; UNKNOWN DEVICE
384B  E5                	PUSH	H
384C  21 0600           	LXI	H,DEV.FLG
384F  09                	DAD	B			; HL => FLAG BYTE
3850  7E                	MOV	A,M			; (A) = FLAG BYTE
3851  E6 01             	ANI	DT.DD			; IS IT DIRECTORY DEVICE
3853  37                	STC				; ASSUME IT ISN'T
3854  E1                	POP	H
3855  3E 05             	MVI	A,EC.DNS
3857  C8                	RZ				; DEVICE NOT SUITABLE
3858  E5                	PUSH	H
3859  21 0800           	LXI	H,DEV.MNU
385C  09                	DAD	B			; HL => MAX. NO. OF UNITS
385D  5E                	MOV	E,M			; (E) = MAX. NO. OF UNITS
385E  1D                	DCR	E			; (E) = MAX. UNIT #
385F  E1                	POP	H
3860  7E                	MOV	A,M			; (A) = ASCII UNIT #
3861  FE 3A             	CPI	':'
3863  CA 8938           	JE	UNIT0			; ASSUME '0'
3866  A7                	ANA	A
3867  CA 8938           	JZ	UNIT0			; END OF COMMAND LINE, ASSUME '0'
386A  D6 30             	SUI	'0'			; MAKE (A) BINARY
386C  57                	MOV	D,A			; D = BINARY UNIT #
386D  3E 06             	MVI	A,EC.IDN
386F  D8                	RC				; ILLEGAL DEVICE NAME
3870  23                	INX	H			; BUMP PAST n
3871  3E 07             	MVI	A,7
3873  BA                	CMP	D
3874  3E 06             	MVI	A,EC.IDN
3876  D8                	RC				; ILLEGAL DEVICE NAME
3877  7B                	MOV	A,E			; (A) = MAX. UNIT #
3878  BA                	CMP	D
3879  3E 1B             	MVI	A,EC.UUN
387B  D8                	RC				; UNKNOWN UNIT #
387C  7A                	MOV	A,D			; (A) = BINARY UNIT #
387D  C6 30             UNITX	ADI	'0'			; MAKE IT ASCII
387F  F5                	PUSH	PSW			; SAVE ASCII UNIT #
3880  CD E247           	CALL	XCHGBC			; BC => BYTE AFTER n, HL => DEV. NAME
3883  CD 8918           	CALL	$HLIHL			; (HL) = DEV. NAME
3886  F1                	POP	PSW			; RESTORE ASCII UNIT #
3887  A7                	ANA	A			; CLEAR CARRY
3888  C9                	RET

3889  AF                UNIT0	XRA	A			; FORCE UNIT # = 0
388A  C3 7D38           	JMP	UNITX


      = 388D            SETDEV	EQU	*

388D  2A 6A00           	LHLD	S.DFBLK 		; (HL) = 'XX'
3890  7C                	MOV	A,H
3891  B5                	ORA	L
3892  C8                	RZ				; NO DEFAULT, LEAVE US ALONE

3893  3A 6C00           	LDA	S.DFBLK+2		; (A) = ASCII UNIT #
3896  22 8922           	SHLD	SYSCB			; Set up implicit RUN
3899  32 8B22           	STA	SYSCB+2
389C  22 8F22           	SHLD	RUNA			; Set up RUN
389F  32 9122           	STA	RUNA+2
38A2  22 9522           	SHLD	BATBLK			; Set up Batch files
38A5  32 9722           	STA	BATBLK+2
38A8  22 9B22           	SHLD	TSKBLK			; Set up Tasks
38AB  32 9D22           	STA	TSKBLK+2
38AE  22 AD22           	SHLD	PRIDEV			; Set Up Primary Device

38B1  EB                	XCHG				; (DE) = DEFAULT
38B2  2A A922           	LHLD	DPDEV			; (HL) = DEF. PRIMARY

38B5  CD 8E18           	CALL	$CDEHL			; Is it default primary device
38B8  2A AB22           	LHLD	DADEV			; Assume yes.  (HL) = DEF. ALT.
38BB  CA C538           	JE	SETDV0			; Yes, set default alternate

38BE  CD 8E18           	CALL	$CDEHL			; Is it default alternate device
38C1  2A A922           	LHLD	DPDEV			; Assume yes.  (HL) = DEF. PRI.
38C4  C0                	RNE				; No, leave alternate alone

38C5  22 B122           SETDV0	SHLD	ALTDEV			; Set Up Alternate Device
38C8  C9                	RET

38C9                    	STL	'VERIFY - SET/SHOW CURRENT VERIFY STATE'
38C9                    	EJECT
38C9                    	XTEXT	VERIFY
                        ***	VERIFY - SET/SHOW CURRENT VERIFY STATE
                        *
                        *	VERI[FY]	- SHOW CURRENT STATE
                        *	VERI[FY] ON	- SET STATE ON
                        *	VERI[FY] OF[F]	- SET STATE OFF

38C9  E1                VERIFY	POP	H			; Get pointer to command line
38CA  CD 5347           	CALL	M$SOB			; Map + Skip over blanks
38CD  A7                	ANA	A
38CE  CA F638           	JZ	VFYX			; Just wants to see it
38D1  CD 8918           	CALL	$HLIHL			; Get 1st 2 characters
38D4  11 4F4E           	LXI	D,'NO'			; 'ON'
38D7  CD 8E18           	CALL	$CDEHL
38DA  CA ED38           	JE	VFYON			; Turn verify on
38DD  16 46             	MVI	D,'F'			; 'OF'
38DF  CD 8E18           	CALL	$CDEHL
38E2  C2 8E25           	JNE	ILLSYN			; Illegal syntax.  Not ON or OFF.

                        *	Turn verify off

38E5  3A 7F00           	LDA	S.FLAG
38E8  E6 FD             	ANI	377Q-S.VFLG
38EA  C3 F238           	JMP	VFY..

                        *	Turn verify on

38ED  3A 7F00           VFYON	LDA	S.FLAG
38F0  F6 02             	ORI	S.VFLG
38F2  32 7F00           VFY..	STA	S.FLAG			; Set flag byte
38F5  C7                	RST	SYSCMD			; Done ...

38F6  CD 5E19           VFYX	CALL	$TYPTX
38F9  0A564552 49465920 	DB	NL,'VERIFY is',' '+200Q
3901  6973A0
3904  3A 7F00           	LDA	S.FLAG
3907  E6 02             	ANI	S.VFLG
3909  CA 1239           	JZ	VFYOFF
390C  CD 5E19           VFYXON	CALL	$TYPTX
390F  4FCE              	DB	'O','N'+200Q
3911  C7                	RST	SYSCMD			; Done ...

3912  CD 5E19           VFYOFF	CALL	$TYPTX
3915  4F46C6            	DB	'OF','F'+200Q
3918  C7                	RST	SYSCMD			; Done ...

3919                    	STL	'PROMPT - SET/SHOW SYSTEM PROMPT'
3919                    	EJECT
3919                    	XTEXT	PROMPT
                        ***	PROMPT - SET/SHOW SYSTEM PROMPT
                        *
                        *	PRO[MPT]		- SHOW CURRENT PROMPT STRING
                        *	PRO[MPT] prompt string	- SET NEW PROMPT STRING
                        *	PRO[MPT] ~		- CLEAR PROMPT STRING (USE DEFAULT)

3919  E1                PROMPT	POP	H
391A  CD 5647           	CALL	$SOB
391D  A7                	ANA	A
391E  CA 3C39           	JZ	PRMSHOW
3921  FE 7E             	CPI	'~'
3923  CA 5639           	JE	PRMCLR

                        *	SET NEW PROMPT STRING UNTIL LIMIT OR NULL

3926  EB                	XCHG
3927  2A 5C00           	LHLD	S.PRMT			; BUFFER
392A  EB                	XCHG
392B  0E 64             	MVI	C,100			; CHAR. LIMIT
392D  7E                PRM1	MOV	A,M
392E  12                	STAX	D
392F  A7                	ANA	A
3930  CA A425           	JZ	SYSCMD. 		; FOUND NULL
3933  23                	INX	H
3934  13                	INX	D
3935  0D                	DCR	C
3936  C2 2D39           	JNZ	PRM1
3939  AF                	XRA	A
393A  12                	STAX	D			; FORCE FINAL NULL
393B  C7                	RST	SYSCMD			; REACHED LIMIT

393C  CD 5E19           PRMSHOW CALL	$TYPTX
393F  0A50524F 4D505420 	DB	NL,'PROMPT ','"'+200Q
3947  A2
3948  2A 5C00           	LHLD	S.PRMT			; PRINT STRING DATA
394B  7E                PRM2	MOV	A,M
394C  A7                	ANA	A
394D  CA 9739           	JZ	PAT3			; UNTIL WE FIND A NULL BYTE
3950  FF 02             	SCALL	.SCOUT
3952  23                	INX	H
3953  C3 4B39           	JMP	PRM2

3956  AF                PRMCLR	XRA	A
3957  2A 5C00           	LHLD	S.PRMT
395A  77                	MOV	M,A			; Clear PROMPT string
395B  C7                	RST	SYSCMD

395C                    	STL	'PATH - SET/SHOW IMPLICIT RUN PATH'
395C                    	EJECT
395C                    	XTEXT	PATH
                        ***	PATH - SET/SHOW SYSTEM PATH
                        *
                        *	PA[TH]			- SHOW CURRENT PATH STRING
                        *	PA[TH] path string	- SET NEW PATH STRING
                        *	PA[TH] ~		- CLEAR PATH STRING

395C  E1                PATH	POP	H
395D  CD 5347           	CALL	M$SOB			; Map + Skip over blanks
3960  A7                	ANA	A
3961  CA 7F39           	JZ	PATSHOW 		; Show us what you got
3964  FE 7E             	CPI	'~'
3966  CA 9C39           	JE	PATCLR			; Clear it

                        *	SET NEW PATH STRING UNTIL LIMIT OR NULL

3969  EB                	XCHG
396A  2A 5A00           	LHLD	S.PATH			; BUFFER
396D  EB                	XCHG
396E  0E 64             	MVI	C,100			; CHAR. LIMIT
3970  7E                PAT1	MOV	A,M
3971  12                	STAX	D
3972  A7                	ANA	A
3973  CA A425           	JZ	SYSCMD. 		; FOUND NULL
3976  23                	INX	H
3977  13                	INX	D
3978  0D                	DCR	C
3979  C2 7039           	JNZ	PAT1
397C  AF                	XRA	A
397D  12                	STAX	D			; FORCE FINAL NULL
397E  C7                	RST	SYSCMD			; REACHED LIMIT

397F  CD 5E19           PATSHOW CALL	$TYPTX
3982  0A504154 4820A2   	DB	NL,'PATH ','"'+200Q
3989  2A 5A00           	LHLD	S.PATH			; PRINT STRING DATA
398C  7E                PAT2	MOV	A,M
398D  A7                	ANA	A
398E  CA 9739           	JZ	PAT3			; UNTIL WE FIND A NULL BYTE
3991  FF 02             	SCALL	.SCOUT
3993  23                	INX	H
3994  C3 8C39           	JMP	PAT2

3997  3E 22             PAT3	MVI	A,'"'
3999  FF 02             	SCALL	.SCOUT
399B  C7                	RST	SYSCMD

399C  AF                PATCLR	XRA	A
399D  2A 5A00           	LHLD	S.PATH
39A0  77                	MOV	M,A			; Clear PATH string
39A1  C7                	RST	SYSCMD

39A2                    	STL	'BYE - SYSTEM END'
39A2                    	EJECT
39A2                    	XTEXT	BYE
                        ***	BYE - DISMOUNTS ALL MOUNTED DISKS AND REBOOTS THE SYSTEM.
                        *
                        *	Also deactivates all tasks in system.	/81.08.bp/
                        *
                        *	BYE
                        *	Q[UIT]

39A2  C1                BYE	POP	B			; clean off command

39A3  FF 86             	SCALL	.DAD			; DISMOUNT ALL DEVICES

39A5  3E 0F             	MVI	A,TASMAX-1		; (A) = Maximum number of tasks

39A7  F5                BYE1	PUSH	PSW			; Save task number
39A8  06 02             	MVI	B,TAS.DEA		; Deactivate function
39AA  FF 41             	SCALL	.TASK			; Call task manager
39AC  F1                	POP	PSW			; Restore task number
39AD  3D                	DCR	A			; Decrement it
39AE  C2 A739           	JNZ	BYE1			; Not done, do another.

39B1  3A A322           	LDA	ZROFLG			; See if to zero stats
39B4  A7                	ANA	A
39B5  CA C039           	JZ	BYE2

39B8  21 B120           	LXI	H,D.HECNT		; I/O statistics block
39BB  06 0E             	MVI	B,14
39BD  CD 8A19           	CALL	$ZERO			; Gone now ...

39C0  3E FA             BYE2	MVI	A,250
39C2  CD 2B00           	CALL	.DLY
39C5  3E FA             	MVI	A,250
39C7  CD 2B00           	CALL	.DLY

39CA  CD 5346           	CALL	CLRSCRN
39CD  0E 0B             	MVI	C,11
39CF  3E 0A             BYE3	MVI	A,NL
39D1  FF 02             	SCALL	.SCOUT
39D3  0D                	DCR	C
39D4  C2 CF39           	JNZ	BYE3

39D7  CD 5E19           	CALL	$TYPTX
39DA  09090920 20202020 	DB	TAB,TAB,TAB,32,32,32,32,32
39E2  596F7520 61726520 	DB	'You are at Witt''s End','.'+200Q
39EA  61742057 69747427
39F2  7320456E 64AE

39F8  F3                	DI				; off with the interrupts
39F9  C3 F939           	JMP	*			; I'm getting dizzy

39FC                    	STL	'XYZZY - DISPLAY EXIT CODE ?'
39FC                    	EJECT
39FC                    	XTEXT	XYZZY
                        ***	XYZZY - DISPLAY EXIT CODE ?
                        *
                        *	XYZZY		- TOGGLE STATE OF FLAG

39FC  E1                XYZZY	POP	H			; Clear stack

39FD  3A 7F00           	LDA	S.FLAG			; Get System Flag
3A00  EE 10             	XRI	S.EXITC 		; Toggle XYZZY bit
3A02  32 7F00           	STA	S.FLAG			; Save System Flag

3A05  C7                	RST	SYSCMD

3A06                    	XTEXT	BATCH
3A06                    	STL	'BATCH Subroutines'
3A06                    	EJECT
                        ***	BATCH Facility

                        ***	B.BYTE - Get a byte from the BATCH facility

3A06  E5                B.BYTE	PUSH	H			; Save registers
3A07  D5                	PUSH	D
3A08  C5                	PUSH	B

3A09  CD 293A           	CALL	B.BAT			; Get next byte
      = 3A0A            B.XXX	EQU	*-2
3A0C  4F                	MOV	C,A			; Save it

3A0D  21 283A           	LXI	H,B.CNT 		; Point at byte count
3A10  34                	INR	M			; Bump it
3A11  7E                	MOV	A,M			; Get it
3A12  FE 65             	CPI	101			; Is it 101 yet ?
3A14  3E 36             	MVI	A,EC.LBO		; Assume error
3A16  CA 5A25           	JE	ERROR			; Yes, abort BATCH job

3A19  3A 7F00           	LDA	S.FLAG
3A1C  E6 04             	ANI	S.ECHO			; Do we echo ?
3A1E  79                	MOV	A,C			; Restore byte
3A1F  C2 243A           	JNZ	B.BR			; No
3A22  FF 02             	SCALL	.SCOUT			; Yes

3A24  C1                B.BR	POP	B			; Restore registers
3A25  D1                	POP	D
3A26  E1                	POP	H
3A27  C9                	RET

3A28  00                B.CNT	DB	0			; Byte count

3A29  CD 113B           B.BAT	CALL	B.GET			; Get next byte from Batch file
3A2C  A7                	ANA	A
3A2D  C2 363A           	JNZ	B.B1			; Not a NUL

3A30  3C                B.B0	INR	A
3A31  32 BA22           	STA	NULFLG			; Flag that NUL found
3A34  AF                	XRA	A			;  and return with a NUL
3A35  C9                	RET

3A36  FE 25             B.B1	CPI	'%'
3A38  C0                	RNE				; Not the magic char.

                        *	CHECK FOR SUBSTITUTE MODE

3A39  CD 113B           	CALL	B.GET			; Get next byte from Batch file
3A3C  4F                	MOV	C,A			; Save actual char
3A3D  CD D846           	CALL	$MCU			; Map to upper case
3A40  FE 4E             	CPI	'N'
3A42  CA 863A           	JE	B.DEV
3A45  FE 55             	CPI	'U'
3A47  CA 923A           	JE	B.UNI
3A4A  FE 58             	CPI	'X'
3A4C  CA 9E3A           	JE	B.EXT
3A4F  FE 3A             	CPI	':'
3A51  CA AD3A           	JE	B.XXN
3A54  FE 30             	CPI	'0'
3A56  DA EC3A           	JC	B.NSUB			; Less than '0'
3A59  CA C93A           	JE	B.NAM			; User wants Batch file name
3A5C  FE 3A             	CPI	'9'+1
3A5E  D2 EC3A           	JNC	B.NSUB			; Greater than '9'

                        *	FIND SUBSTITUTE STRING

3A61  D6 30             	SUI	'0'			; Make binary
3A63  4F                	MOV	C,A			; Save in C
3A64  3A 6100           	LDA	S.SHIFT
3A67  81                	ADD	C
3A68  4F                	MOV	C,A
3A69  2A 5800           	LHLD	SUBBUF
3A6C  CD 5647           B.B4	CALL	$SOB
3A6F  0D                	DCR	C
3A70  CA CC3A           	JZ	B.B6			; Got the one we want
3A73  7E                B.B5	MOV	A,M
3A74  A7                	ANA	A
3A75  CA CC3A           	JZ	B.B6			; Found end of buffer
3A78  23                	INX	H
3A79  FE 20             	CPI	' '
3A7B  CA 6C3A           	JE	B.B4			; At end of word
3A7E  FE 09             	CPI	TAB
3A80  CA 6C3A           	JE	B.B4			; At end of word
3A83  C3 733A           	JMP	B.B5			; Loop thru this argument

3A86  2A 6A00           B.DEV	LHLD	S.DFBLK
3A89  22 C43A           	SHLD	B.ARGX
3A8C  21 C63A           	LXI	H,B.ARGX+2
3A8F  C3 BC3A           	JMP	B.ARG

3A92  3A 6C00           B.UNI	LDA	S.DFBLK+2
3A95  32 C43A           	STA	B.ARGX
3A98  21 C53A           	LXI	H,B.ARGX+1
3A9B  C3 BC3A           	JMP	B.ARG

3A9E  01 0300           B.EXT	LXI	B,3
3AA1  11 6D00           	LXI	D,S.DFBLK+3
3AA4  21 C43A           	LXI	H,B.ARGX
3AA7  CD AA18           	CALL	$MOVE
3AAA  C3 BC3A           	JMP	B.ARG

3AAD  01 0300           B.XXN	LXI	B,3
3AB0  11 6A00           	LXI	D,S.DFBLK
3AB3  21 C43A           	LXI	H,B.ARGX
3AB6  CD AA18           	CALL	$MOVE
3AB9  36 3A             	MVI	M,':'
3ABB  23                	INX	H
                        *	JMP	B.ARG
                        	ERRNZ	*-B.ARG

3ABC  36 00             B.ARG	MVI	M,0
3ABE  21 C43A           	LXI	H,B.ARGX
3AC1  C3 CC3A           	JMP	B.B6

3AC4  00000000 00       B.ARGX	DB	0,0,0,0,0

3AC9  21 4000           B.NAM	LXI	H,BATNAME		; Point to Batch file name

                        *	SUBSTITUTE MODE

3ACC  22 0F3B           B.B6	SHLD	SUBPTR			; Set pointer
3ACF  21 D53A           	LXI	H,B.SUB
3AD2  22 0A3A           	SHLD	B.XXX			; Patch logic to substitute
3AD5  2A 0F3B           B.SUB	LHLD	SUBPTR			; Get pointer
3AD8  7E                	MOV	A,M			; Get next byte from subst. buffer
3AD9  A7                	ANA	A
3ADA  CA 063B           	JZ	B.B9			; NUL is end of buffer
3ADD  FE 20             	CPI	' '
3ADF  CA 063B           	JE	B.B9			; SPACE is end of arg
3AE2  FE 09             	CPI	TAB
3AE4  CA 063B           	JE	B.B9			; TAB is end of arg
3AE7  23                	INX	H			; Bump
3AE8  22 0F3B           	SHLD	SUBPTR			;   and save pointer
3AEB  C9                	RET

                        *	INVALID % USAGE

3AEC  79                B.NSUB	MOV	A,C			; Restore actual char
3AED  32 003B           	STA	B.NX0			; Save byte after '%'
3AF0  21 F93A           	LXI	H,B.NEXT
3AF3  22 0A3A           	SHLD	B.XXX			; Patch logic to get next char
3AF6  3E 25             	MVI	A,'%'			; Force '%'
3AF8  C9                	RET

3AF9  21 293A           B.NEXT	LXI	H,B.BAT
3AFC  22 0A3A           	SHLD	B.XXX			; Patch logic to normal input
3AFF  3E 00             	MVI	A,0			; Restore byte after '%'
      = 3B00            B.NX0	EQU	*-1
3B01  A7                	ANA	A
3B02  CA 303A           	JZ	B.B0
3B05  C9                	RET

                        *	END OF SUBSTITUTION

3B06  21 293A           B.B9	LXI	H,B.BAT
3B09  22 0A3A           	SHLD	B.XXX			; Patch logic to normal input
3B0C  C3 293A           	JMP	B.BAT

3B0F  0000              SUBPTR	DW	0			; Subst. buffer pointer

                        *	GET A CHARACTER FROM THE BATCH FILE

3B11  2A 5600           B.GET	LHLD	BATPTR			; Get pointer
3B14  EB                	XCHG				; Save in DE
3B15  2A 5400           	LHLD	BATBUF			; Get buffer FWA
3B18  24                	INR	H			; Make it LWA+1
3B19  CD 8E18           	CALL	$CDEHL			; Compare
3B1C  CC 2D3B           	CE	B.READ			; At end of buffer, get next sector
3B1F  DA 2B3B           	JC	B.GET0
3B22  2A 5600           	LHLD	BATPTR
3B25  7E                	MOV	A,M			; Get next byte
3B26  23                	INX	H			; Bump
3B27  22 5600           	SHLD	BATPTR			;  and save pointer
3B2A  C9                	RET

3B2B  AF                B.GET0	XRA	A			; Force NUL
3B2C  C9                	RET
3B2D                    	SPACE	4,10
                        ***	B.READ - Read next BATCH file sector

3B2D  CD 6C3B           B.READ	CALL	B.OPEN			; Reopen Batch file
3B30  3A 5100           	LDA	BATSEC
3B33  3C                	INR	A			; Bump
3B34  32 5100           	STA	BATSEC			;  and save sector pointer
3B37  4F                	MOV	C,A
3B38  06 00             	MVI	B,0			; BC = sector pointer
3B3A  AF                	XRA	A			; Channel zero
3B3B  FF 27             	SCALL	.POSIT
3B3D  D2 4D3B           	JNC	B.R1
3B40  FE 01             	CPI	EC.EOF
3B42  C2 5A25           	JNE	ERROR
3B45  AF                B.R0	XRA	A
3B46  FF 26             	SCALL	.CLOSE
3B48  DA 5A25           	JC	ERROR
3B4B  37                	STC
3B4C  C9                	RET

3B4D  2A 5400           B.R1	LHLD	BATBUF
3B50  22 5600           	SHLD	BATPTR
3B53  EB                	XCHG
3B54  01 0001           	LXI	B,256
3B57  AF                	XRA	A
3B58  FF 04             	SCALL	.READ
3B5A  D2 653B           	JNC	B.R2
3B5D  FE 01             	CPI	EC.EOF
3B5F  C2 5A25           	JNE	ERROR
3B62  C3 453B           	JMP	B.R0

3B65  AF                B.R2	XRA	A
3B66  FF 26             	SCALL	.CLOSE
3B68  DA 5A25           	JC	ERROR
3B6B  C9                	RET
3B6C                    	SPACE	4,10
                        ***	B.OPEN - Reopen BATCH file

3B6C  3E 04             B.OPEN	MVI	A,4			; We will try three times
3B6E  32 D83B           	STA	REPCNT
3B71  CD F146           	CALL	$MOVEL			; Set proper device name
3B74  03004000 D33B     	DW	3,BATNAME,BATDEV
3B7A  21 4000           B.OPE1	LXI	H,BATNAME		; Current Batch file name
3B7D  11 9522           	LXI	D,BATBLK		; Default block
3B80  AF                	XRA	A			; Channel zero
3B81  FF 22             	SCALL	.OPENR
3B83  DA 943B           	JC	B.OPE2			; Something wrong
3B86  2A 4221           	LHLD	AIO.DIR+DIR.FGN
3B89  EB                	XCHG
3B8A  2A 5200           	LHLD	BATGNS
3B8D  CD 8E18           	CALL	$CDEHL
3B90  C2 9E3B           	JNE	B.OPE3			; Right name but wrong file
3B93  C9                	RET				; All is well

3B94  FE 0C             B.OPE2	CPI	EC.FNF
3B96  CA 9E3B           	JE	B.OPE3
3B99  FE 1B             	CPI	EC.UUN
3B9B  C2 5A25           	JNE	ERROR			; Bad news !
3B9E  CD 4746           B.OPE3	CALL	$GNL
3BA1  CD 5E19           	CALL	$TYPTX
3BA4  070A4241 54434820 	DB	BELL,NL,'BATCH File Not Found',ENL
3BAC  46696C65 204E6F74
3BB4  20466F75 6E648A
3BBB  3A D83B           	LDA	REPCNT
3BBE  3D                	DCR	A			; Count Down
3BBF  CA A125           	JZ	BATOFF			; Third time wasn't the charm
3BC2  32 D83B           	STA	REPCNT
3BC5  21 D33B           	LXI	H,BATDEV		; Device name
3BC8  01 FFFF           	LXI	B,-1			; Use standard message
3BCB  FF 85             	SCALL	.RESNMS
3BCD  DA 5A25           	JC	ERROR			; Ouch
3BD0  C3 7A3B           	JMP	B.OPE1			; Try to find it now

3BD3  5359303A 00       BATDEV	DB	'SY0:',0
3BD8  00                REPCNT	DB	0			; Repeat count

3BD9  3A 7F00           CHKBAT	LDA	S.FLAG
3BDC  E6 08             	ANI	S.BATCH
3BDE  C0                	RNZ
3BDF  C3 9E25           	JMP	ILLCMD
3BE2                    	STL	'ECHO - Display text'
3BE2                    	EJECT
                        ***	ECHO - Display text
                        *
                        *	EC[HO] [ON|OF[F]]	Show or Set ECHO state
                        *	EC[HO] text		Print text to console

3BE2  E1                ECHO	POP	H
3BE3  CD 5647           	CALL	$SOB
3BE6  A7                	ANA	A
3BE7  CA 173C           	JZ	ECHOX			; Just show state
3BEA  CD D846           	CALL	$MCU			; Map character to upper case
3BED  FE 4F             	CPI	'O'
3BEF  C2 023C           	JNE	ECHOTT
3BF2  23                	INX	H
3BF3  7E                	MOV	A,M
3BF4  CD D846           	CALL	$MCU			; Map character to upper case
3BF7  FE 4E             	CPI	'N'
3BF9  CA 063C           	JE	ECHON
3BFC  FE 46             	CPI	'F'
3BFE  CA 0E3C           	JE	ECHOFF
3C01  2B                	DCX	H
3C02  CD F842           ECHOTT	CALL	PROMPT$
3C05  C7                	RST	SYSCMD

3C06  3A 7F00           ECHON	LDA	S.FLAG
3C09  E6 FB             	ANI	377Q-S.ECHO
3C0B  C3 133C           	JMP	ECHO.

3C0E  3A 7F00           ECHOFF	LDA	S.FLAG
3C11  F6 04             	ORI	S.ECHO
3C13  32 7F00           ECHO.	STA	S.FLAG
3C16  C7                	RST	SYSCMD

3C17  CD 5E19           ECHOX	CALL	$TYPTX
3C1A  0A454348 4F206973 	DB	NL,'ECHO is',' '+200Q
3C22  A0
3C23  3A 7F00           	LDA	S.FLAG
3C26  E6 04             	ANI	S.ECHO
3C28  CA 0C39           	JZ	VFYXON
3C2B  C3 1239           	JMP	VFYOFF
3C2E                    	STL	'REM - Remark'
3C2E                    	EJECT
                        ***	REM - Remark
                        *
                        *	REM [text]		Comments, ignored by SYSCMD

3C2E  E1                REM	POP	H			; Clear stack
3C2F  C7                	RST	SYSCMD			; Do nothing
3C30                    	STL	'PAUSE/ASK - Display text and wait'
3C30                    	EJECT
                        ***	PAUSE - Display text and wait for user to touch a key
                        *
                        *	PAU[SE] [text]		Print text on console and wait for a key

3C30  3E C3             PAUSE	MVI	A,0C3H			; JMP code

                        ***	ASK - Display text and wait for user to touch a key
                        *	      The ascii value of the key is saved for further processing
                        *
                        *	AS[K] [text]		Print text on console and wait for a key
                        *				Ascii value saved at *SYSXITA*

3C32  21                	DB	21H			; Fake LXI H,
3C33  3E 21             ASK	MVI	A,21H			; LXI H, code
3C35  32 483C           	STA	ASKX
3C38  E1                	POP	H
3C39  CD D93B           	CALL	CHKBAT			; PAUSE & ASK valid ONLY in BATCH mode
3C3C  CD 5647           	CALL	$SOB
3C3F  A7                	ANA	A
3C40  C4 F842           	CNZ	PROMPT$
3C43  FF 07             	SCALL	.CLRCO
3C45  CD A02A           	CALL	TT.CE			; Set character mode/no echo
3C48  C3 5B3C           ASKX	JMP	PAUSE0
3C4B  FF 01             ASK0	SCALL	.SCIN
3C4D  DA 4B3C           	JC	ASK0
3C50  FF 02             	SCALL	.SCOUT
3C52  CD D846           	CALL	$MCU
3C55  32 C623           	STA	SYSXITA
3C58  C3 7A3C           	JMP	PAUSEX

3C5B  CD 5E19           PAUSE0	CALL	$TYPTX
3C5E  546F7563 68206120 	DB	'Touch a key when ready',' '+200Q
3C66  6B657920 7768656E
3C6E  20726561 6479A0
3C75  FF 01             PAUSE1	SCALL	.SCIN
3C77  DA 753C           	JC	PAUSE1
3C7A  CD 4746           PAUSEX	CALL	$GNL
3C7D  C7                	RST	SYSCMD
3C7E                    	STL	'SHIFT - Shift arguments left one position'
3C7E                    	EJECT
                        ***	SHIFT - Shift arguments left one position
                        *
                        *	SH[IFT]

3C7E  E1                SHIFT	POP	H			; Clear stack
3C7F  21 6100           	LXI	H,S.SHIFT
3C82  34                	INR	M			; Increment Shift Counter
3C83  C7                	RST	SYSCMD
3C84                    	STL	'COUNT - Batch Loop Counter'
3C84                    	EJECT
                        ***	COUNT - Batch Loop Counter
                        *
                        *	COU[NT] 		- Zero counter
                        *	COU[NT] [=] value	- Set counter to value (0..255)
                        *	COU[NT] +		- Increment counter
                        *	COU[NT] -		- Decrement counter

3C84  E1                COUNT	POP	H			; Pointer
3C85  CD 5647           	CALL	$SOB			; Skip over blanks
3C88  A7                	ANA	A
3C89  CA BF3C           	JZ	C.ZERO			; No arg, just clear it
3C8C  FE 2B             	CPI	'+'
3C8E  CA B23C           	JE	C.INC			; Wants to add 1
3C91  FE 2D             	CPI	'-'
3C93  CA B53C           	JE	C.DEC			; Wants to subtract 1

                        *	Set counter value

3C96  FE 3D             	CPI	'='
3C98  C2 A33C           	JNE	COU1
3C9B  23                	INX	H
3C9C  CD 5647           	CALL	$SOB
3C9F  A7                	ANA	A
3CA0  CA BF3C           	JZ	C.ZERO			; Clear count

3CA3  CD CB45           COU1	CALL	$DDD			; DE = Decoded decimal digits
3CA6  DA 8E25           	JC	ILLSYN			; Bad value
3CA9  7A                	MOV	A,D
3CAA  A7                	ANA	A
3CAB  C2 8E25           	JNZ	ILLSYN			; Can't be > 255
3CAE  7B                	MOV	A,E			; (A) = value
3CAF  C3 C03C           	JMP	C.Z

                        *	Increment counter

3CB2  3E 34             C.INC	MVI	A,34H			; INR M code
3CB4  21                	DB	21H			; Fake LXI H,

                        *	Decrement counter

3CB5  3E 35             C.DEC	MVI	A,35H			; DCR M code
3CB7  32 BD3C           	STA	C.TOG
3CBA  21 6000           	LXI	H,S.COUNT
3CBD  34                C.TOG	INR	M
3CBE  C7                	RST	SYSCMD

                        *	Zero counter

3CBF  AF                C.ZERO	XRA	A			; Zero A
3CC0  32 6000           C.Z	STA	S.COUNT 		; Set value
3CC3  C7                	RST	SYSCMD
3CC4                    	STL	'BIT - Set or Clear a BIT Flag'
3CC4                    	EJECT
                        ***	BIT - Set or Clear a BIT Flag
                        *
                        *	BIT S[ET]		- Set all BIT flags
                        *	BIT S[ET] digit 	- Set specific BIT flag (0..7)
                        *	BIT C[LEAR]		- Clear all BIT flags
                        *	BIT C[LEAR] digit	- Clear specific BIT flag (0..7)

3CC4  3E FF             BIT	MVI	A,377Q
3CC6  32 193D           	STA	BIT.ALL+1		; Assume Set All

3CC9  E1                	POP	H			; Pointer
3CCA  CD 5347           	CALL	M$SOB			;Map + Skip over blanks
3CCD  A7                	ANA	A
3CCE  CA 8E25           	JZ	ILLSYN
3CD1  FE 53             	CPI	'S'
3CD3  CA DF3C           	JE	BIT.X			; Wants to Set
3CD6  FE 43             	CPI	'C'
3CD8  C2 8E25           	JNE	ILLSYN
3CDB  AF                	XRA	A			; Wants to Clear
3CDC  32 193D           	STA	BIT.ALL+1		; Assume Clear All

3CDF  CD 213F           BIT.X	CALL	FNST
3CE2  A7                	ANA	A
3CE3  CA 183D           	JZ	BIT.ALL 		; Set or Clear all bits
3CE6  CD 5647           	CALL	$SOB
3CE9  A7                	ANA	A
3CEA  CA 183D           	JZ	BIT.ALL 		; Set or Clear all bits
3CED  FE 30             	CPI	'0'
3CEF  DA 8E25           	JC	ILLSYN			; Less than 0
3CF2  FE 38             	CPI	'7'+1
3CF4  D2 8E25           	JNC	ILLSYN			; Greater than 7
3CF7  D6 30             	SUI	'0'			; Make it binary
3CF9  47                	MOV	B,A
3CFA  AF                	XRA	A
3CFB  CD E343           	CALL	BITS
3CFE  4F                	MOV	C,A			; (C) = MASK
3CFF  3A 193D           	LDA	BIT.ALL+1
3D02  A7                	ANA	A
3D03  CA 0D3D           	JZ	BIT.CLR

                        *	Set bits

3D06  3A 6200           	LDA	S.BITS
3D09  B1                	ORA	C
3D0A  C3 1A3D           	JMP	BIT.S

                        *	Clear bits

3D0D  3E FF             BIT.CLR MVI	A,377Q
3D0F  A9                	XRA	C
3D10  4F                	MOV	C,A
3D11  3A 6200           	LDA	S.BITS
3D14  A1                	ANA	C
3D15  C3 1A3D           	JMP	BIT.S

3D18  3E 00             BIT.ALL MVI	A,0
3D1A  32 6200           BIT.S	STA	S.BITS			; Save BIT Flag
3D1D  C7                	RST	SYSCMD
3D1E                    	STL	'GOTO - Goto a label'
3D1E                    	EJECT
                        ***	GOTO - Goto a label
                        *
                        *	GO[TO] label		Goto the label given
                        *
                        *	The search for the label starts at the beginning of the Batch file
                        *	and proceeds to the end of the Batch file.

3D1E  3E 21             GOTO	MVI	A,21H			; LXI H, code

                        ***	JUMP - Jump to a label
                        *
                        *	JU[MP] label		Jump to the label given
                        *
                        *	The search for the label starts with the next Batch command
                        *	and proceeds to the end of the Batch file.

3D20  21                	DB	21H			; Fake LXI H,
3D21  3E C3             JUMP	MVI	A,0C3H			; JMP code
3D23  32 463D           	STA	GOTOJ

3D26  E1                	POP	H
3D27  CD D93B           	CALL	CHKBAT			; GOTO valid ONLY in BATCH mode
3D2A  CD 5347           	CALL	M$SOB			; Map + Skip over blanks
3D2D  A7                	ANA	A
3D2E  CA 8E25           	JZ	ILLSYN			; You forgot the label
3D31  0E 00             	MVI	C,0
3D33  11 E480           	LXI	D,LABEL 		; Save label spec
3D36  7E                GOTOL	MOV	A,M
3D37  12                	STAX	D
3D38  23                	INX	H
3D39  13                	INX	D
3D3A  0C                	INR	C
3D3B  A7                	ANA	A
3D3C  C2 363D           	JNZ	GOTOL			; Found NUL, end of label

3D3F  79                	MOV	A,C
3D40  32 933D           	STA	STRCNT
3D43  32 BF3D           	STA	STRCNT1
3D46  C3 673D           GOTOJ	JMP	GOTO1

3D49  AF                	XRA	A
3D4A  32 BA22           	STA	NULFLG			; Reset NULL flag

3D4D  2A 5400           	LHLD	BATBUF
3D50  22 5600           	SHLD	BATPTR			; Reset buffer pointer
3D53  3A 5100           	LDA	BATSEC
3D56  A7                	ANA	A
3D57  CA 673D           	JZ	GOTO1			; Sector zero already present
3D5A  3E FF             	MVI	A,-1
3D5C  32 5100           	STA	BATSEC
3D5F  CD 2D3B           	CALL	B.READ			; Rewind BATCH file
3D62  3E 01             	MVI	A,EC.EOF		; Assume End of File if Error
3D64  DA 5A25           	JC	ERROR			; Should never happen
3D67  3A 7F00           GOTO1	LDA	S.FLAG
3D6A  32 CA3D           	STA	GOTOFB			; Save system flag byte
3D6D  F6 04             	ORI	S.ECHO
3D6F  32 7F00           	STA	S.FLAG			; Force ECHO off

                        *	Read lines from BATCH file

3D72  3A BA22           GOTO2	LDA	NULFLG
3D75  A7                	ANA	A
3D76  C2 A43D           	JNZ	GOTOX			; End of file
3D79  32 283A           	STA	B.CNT			; Zero char counter
3D7C  21 7F80           	LXI	H,LINE
3D7F  CD 0447           	CALL	$RTL.
3D82  CD 5647           	CALL	$SOB
3D85  FE 3A             	CPI	':'			; Is it label marker
3D87  C2 723D           	JNE	GOTO2			; No, try next line

                        *	Have a marker, check for label

3D8A  23                	INX	H			; Skip over colon
3D8B  CD 5647           	CALL	$SOB
3D8E  A7                	ANA	A
3D8F  CA 723D           	JZ	GOTO2			; No label here, try again

                        *	Have a label, check for match

3D92  0E 00             	MVI	C,0			; String length
      = 3D93            STRCNT	EQU	*-1
3D94  11 E480           	LXI	D,LABEL
3D97  CD 3018           	CALL	$COMP
3D9A  C2 723D           	JNZ	GOTO2			; No match, try some more

                        *	Have match, next line is what we want

3D9D  3A CA3D           	LDA	GOTOFB			; Restore system flag byte
3DA0  32 7F00           	STA	S.FLAG
3DA3  C7                	RST	SYSCMD

3DA4  3A CA3D           GOTOX	LDA	GOTOFB			; Restore system flag byte
3DA7  32 7F00           	STA	S.FLAG
3DAA  CD 5E19           	CALL	$TYPTX
3DAD  0A074361 6E277420 	DB	NL,BELL,'Can''t find ','"'+200Q
3DB5  66696E64 20A2
3DBB  21 E480           	LXI	H,LABEL
3DBE  3E 00             	MVI	A,0
      = 3DBF            STRCNT1 EQU	*-1
3DC0  CD 6447           	CALL	$TYPCC
3DC3  CD 5E19           	CALL	$TYPTX
3DC6  A2                	DB	'"'+200Q
3DC7  C3 A125           	JMP	BATOFF

3DCA  00                GOTOFB	DB	0
3DCB                    	STL	'IF - If conditional'
3DCB                    	EJECT
                        ***	IF - If conditional
                        *
                        *	IF [NOT] condition command
                        *
                        *	Valid conditionals:
                        *		BIT digit		single digit
                        *		COU[NT] = value 	8 bit value
                        *		CRC = value		16 bit value
                        *		ERR[OR] = value 	8 bit value
                        *		EXI[ST] filename
                        *		KEY = value		8 bit value
                        *		string = string

3DCB  3E C2             IF	MVI	A,302Q			; JNE code
3DCD  32 DA3E           	STA	IFXX			; Set false jump
3DD0  E1                	POP	H			; Get line pointer
3DD1  CD 5647           IF0	CALL	$SOB
3DD4  A7                	ANA	A
3DD5  CA 8E25           	JZ	ILLSYN
3DD8  3E 80             	MVI	A,200Q
3DDA  32 0680           	STA	VERB-1
3DDD  EB                	XCHG				; DE = line pointer
3DDE  21 0780           	LXI	H,VERB
3DE1  CD 323F           	CALL	IFCRAK			; Get first argument
3DE4  D5                	PUSH	D			; Save line pointer
3DE5  36 00             	MVI	M,0
3DE7  2B                	DCX	H
3DE8  7E                	MOV	A,M
3DE9  EE 80             	XRI	200Q
3DEB  F2 8E25           	JP	ILLSYN
3DEE  11 0780           	LXI	D,VERB
3DF1  21 EE3E           	LXI	H,IFTAB
3DF4  CD E845           	CALL	$FST
3DF7  C2 0C3E           	JNZ	IFEQ			; Not specific, MUST be string
3DFA  7E                	MOV	A,M			; (A) = index
3DFB  CD 3119           	CALL	$TJMP

3DFE   (0000)           IFNDX	DS	0

      = 0000            I.IFB	EQU	*-IFNDX/2
3DFE  6A3E              	DW	IFBIT

      = 0001            I.IFC	EQU	*-IFNDX/2
3E00  A23E              	DW	IFCNT

      = 0002            I.CRC	EQU	*-IFNDX/2
3E02  8C3E              	DW	IFCRC

      = 0003            I.ERR	EQU	*-IFNDX/2
3E04  A83E              	DW	IFER

      = 0004            I.EXI	EQU	*-IFNDX/2
3E06  423E              	DW	IFEX

      = 0005            I.NOT	EQU	*-IFNDX/2
3E08  313E              	DW	IFNOT

3E0A  C323              	DW	$FATAL			; Room for another
3E0C                    	SPACE	4,10
                        ***	IF [NOT] string = string command

3E0C  E1                IFEQ	POP	H			; Pointer

3E0D  CD 493F           	CALL	CKEQ			; Check for '=' and arg

3E10  E5                	PUSH	H			; Save second string pointer
3E11  E5                	PUSH	H			;  twice
3E12  CD 213F           	CALL	FNST			; Find end of word
3E15  A7                	ANA	A
3E16  CA 8E25           	JZ	ILLSYN			; End of line
3E19  36 00             	MVI	M,0			; Mark end of word
3E1B  23                	INX	H			; Bump past NUL
3E1C  22 DE3E           	SHLD	IFPTR			; Command pointer
3E1F  D1                	POP	D			; Get second string pointer
3E20  EB                	XCHG				; (HL) = start (DE) = end+2
3E21  CD 9418           	CALL	$CHL			; Negate start
3E24  EB                	XCHG				; (HL) = end+2 (DE) = -start
3E25  19                	DAD	D			; HL = length of string plus NUL
3E26  4D                	MOV	C,L			; C = length
3E27  D1                	POP	D			; (DE) = second string
3E28  21 0780           	LXI	H,VERB			; (HL) = first string
3E2B  CD 3018           	CALL	$COMP			; Compare strings
3E2E  C3 DA3E           	JMP	IFXX
3E31                    	SPACE	4,10
                        ***	IF NOT condition command

3E31  E1                IFNOT	POP	H			; Pointer
3E32  3A DA3E           	LDA	IFXX			; See if we were here before
3E35  FE CA             	CPI	312Q			; JE code
3E37  CA 8E25           	JE	ILLSYN			; Yes, naughty naughty
3E3A  3E CA             	MVI	A,312Q			; No, flag opposite state
3E3C  32 DA3E           	STA	IFXX			;  at jump point
3E3F  C3 D13D           	JMP	IF0			; Process next item
3E42                    	SPACE	4,10
                        ***	IF [NOT] EX[IST] filename command

3E42  E1                IFEX	POP	H			; Pointer
3E43  CD 5647           	CALL	$SOB
3E46  A7                	ANA	A
3E47  CA 8E25           	JZ	ILLSYN			; End of line
3E4A  E5                	PUSH	H			; Save filename pointer
3E4B  CD 213F           	CALL	FNST			; Find end of word
3E4E  A7                	ANA	A
3E4F  CA 8E25           	JZ	ILLSYN			; End of line
3E52  22 DE3E           	SHLD	IFPTR			; Command pointer
3E55  E1                	POP	H			; (HL) = filename
3E56  11 8922           	LXI	D,SYSCB 		; (DE) = default
3E59  AF                	XRA	A			; channel 0
3E5A  FF 22             	SCALL	.OPENR
3E5C  DA 663E           	JC	IFEX1			; Assume file not found
3E5F  AF                	XRA	A
3E60  FF 26             	SCALL	.CLOSE
3E62  DA 5A25           	JC	ERROR			; Gasp !
3E65  AF                	XRA	A			; Set true state
3E66  A7                IFEX1	ANA	A			; Affect zero flag
3E67  C3 DA3E           	JMP	IFXX
3E6A                    	SPACE	4,10
                        ***	IF [NOT] BIT digit command

3E6A  E1                IFBIT	POP	H			; Pointer
3E6B  CD 5647           	CALL	$SOB
3E6E  FE 30             	CPI	'0'
3E70  DA 8E25           	JC	ILLSYN			; Less than 0
3E73  FE 38             	CPI	'7'+1
3E75  D2 8E25           	JNC	ILLSYN			; Greater than 7
3E78  23                	INX	H			; Bump past digit
3E79  22 DE3E           	SHLD	IFPTR			; Command pointer
3E7C  D6 30             	SUI	'0'			; Make it binary
3E7E  47                	MOV	B,A
3E7F  AF                	XRA	A
3E80  CD E343           	CALL	BITS
3E83  47                	MOV	B,A
3E84  3A 6200           	LDA	S.BITS
3E87  A0                	ANA	B
3E88  A8                	XRA	B
3E89  C3 DA3E           	JMP	IFXX
3E8C                    	SPACE	4,10
                        ***	IF [NOT] CRC = value command

3E8C  E1                IFCRC	POP	H

3E8D  CD 493F           	CALL	CKEQ			; Check for '=' and arg

3E90  CD CB45           	CALL	$DDD			; DE = Decoded decimal digits
3E93  DA 8E25           	JC	ILLSYN			; Bad value
3E96  22 DE3E           	SHLD	IFPTR			; Command pointer
3E99  2A 1720           	LHLD	.CRCSUM 		; Latest CRC value
3E9C  CD 8E18           	CALL	$CDEHL			; Are they equal ?
3E9F  C3 DA3E           	JMP	IFXX
3EA2                    	SPACE	4,10
                        ***	IF [NOT] COU[NT] = value command

3EA2  21 6000           IFCNT	LXI	H,S.COUNT
3EA5  C3 AB3E           	JMP	IFER1

                        ***	IF [NOT] ERR[OR] = value command

                        ***	IF [NOT] KEY = value command

3EA8  21 C623           IFER	LXI	H,SYSXITA
3EAB  22 D73E           IFER1	SHLD	IFDATA
3EAE  E1                	POP	H			; Pointer

3EAF  CD 493F           	CALL	CKEQ			; Check for '=' and arg

3EB2  FE 00             	CPI	''''			; Is he giving me ascii ?
3EB4  C2 C83E           	JNE	IFER2			; No, decode number
3EB7  23                	INX	H			; Yes, bump past tick
3EB8  7E                	MOV	A,M			; Get char
3EB9  CD D846           	CALL	$MCU			; Map to upper case
3EBC  5F                	MOV	E,A			; Save char
3EBD  23                	INX	H			; Bump past char
3EBE  7E                	MOV	A,M			; Get byte
3EBF  FE 00             	CPI	''''			; Is it a tick ?
3EC1  C2 8E25           	JNE	ILLSYN			; Must have closing tick
3EC4  23                	INX	H			; Bump past tick
3EC5  C3 D33E           	JMP	IFER3

3EC8  CD CB45           IFER2	CALL	$DDD			; DE = Decoded decimal digits
3ECB  DA 8E25           	JC	ILLSYN			; Bad value
3ECE  7A                	MOV	A,D
3ECF  A7                	ANA	A
3ED0  C2 8E25           	JNZ	ILLSYN			; Value > 255 NOT allowed

3ED3  22 DE3E           IFER3	SHLD	IFPTR			; Command pointer
3ED6  3A C623           	LDA	SYSXITA 		; Get error level
      = 3ED7            IFDATA	EQU	*-2
3ED9  BB                	CMP	E			; Compare to our value

                        *	If user specifies NOT then a JE code is poked at *IFXX*

3EDA  C2 A425           IFXX	JNE	SYSCMD. 		; False

3EDD  21 0000           	LXI	H,*-*			; True, get command pointer
      = 3EDE            IFPTR	EQU	*-2
3EE0  11 7F80           	LXI	D,LINE
3EE3  7E                IFXXL	MOV	A,M
3EE4  12                	STAX	D
3EE5  A7                	ANA	A
3EE6  CA 6226           	JZ	PROMZZ			; Process command
3EE9  23                	INX	H
3EEA  13                	INX	D
3EEB  C3 E33E           	JMP	IFXXL

      = 3EEE            IFTAB	EQU	*

3EEE  42495480 00       	DB	'BIT',.,I.IFB
3EF3  434F55CE D48001   	DB	'COU','N'+.,'T'+.,.,I.IFC
3EFA  43524380 02       	DB	'CRC',.,I.CRC
3EFF  455252CF D28003   	DB	'ERR','O'+.,'R'+.,.,I.ERR
3F06  455849D3 D48004   	DB	'EXI','S'+.,'T'+.,.,I.EXI
3F0D  4B455980 03       	DB	'KEY',.,I.ERR
3F12  4E4F5480 05       	DB	'NOT',.,I.NOT
3F17  0000              	DB	0,0
3F19  00000000 00000000 	DW	0,0,0,0
3F21                    	SPACE	4,10
                        *	Find end of word by locating a NUL, a SPACE, or a TAB

3F21  7E                FNST	MOV	A,M			; Get character
3F22  CD D846           	CALL	$MCU			; Map character to upper case
3F25  77                	MOV	M,A			; Put it back
3F26  A7                	ANA	A
3F27  C8                	RZ				; is NUL
3F28  FE 20             	CPI	' '
3F2A  C8                	RE				; is SPACE
3F2B  FE 09             	CPI	TAB
3F2D  C8                	RE				; is TAB
3F2E  23                	INX	H			; Bump pointer
3F2F  C3 213F           	JMP	FNST			; Try again
3F32                    	SPACE	4,10
                        *	Crack first IF argument, terminated by NUL, SPACE, TAB, or '='

3F32  1A                IFCRAK	LDAX	D
3F33  A7                	ANA	A
3F34  CA 8E25           	JZ	ILLSYN			; End of line
3F37  FE 20             	CPI	' '
3F39  C8                	RE				; is SPACE
3F3A  FE 09             	CPI	TAB
3F3C  C8                	RE				; is TAB
3F3D  FE 3D             	CPI	'='
3F3F  C8                	RE				; is '='
3F40  CD D846           	CALL	$MCU			; Map character to upper case
3F43  77                	MOV	M,A			; Add to verb
3F44  23                	INX	H			; Bump
3F45  13                	INX	D			;  pointers
3F46  C3 323F           	JMP	IFCRAK
3F49                    	SPACE	4,10
                        *	Check for '=' followed by an argument

3F49  CD 5647           CKEQ	CALL	$SOB
3F4C  A7                	ANA	A
3F4D  CA 8E25           	JZ	ILLSYN			; End of line
3F50  FE 3D             	CPI	'='
3F52  C2 8E25           	JNE	ILLSYN			; MUST have '=' between strings
3F55  23                	INX	H			; Bump past =
3F56  CD 5647           	CALL	$SOB
3F59  A7                	ANA	A
3F5A  CA 8E25           	JZ	ILLSYN			; End of line
3F5D  C9                	RET

3F5E                    	STL	'WAIT - Wait for nnnnn seconds'
3F5E                    	EJECT
                        ***	WAIT - Wait for nnnnn seconds, then continue
                        *
                        *	WAIT [nnnnn]		Default = 1 second

3F5E  E1                WAIT	POP	H
3F5F  3A CD20           	LDA	S.CLKTR
3F62  A7                	ANA	A			; Is system clock there
3F63  CA A425           	JZ	SYSCMD. 		; No, do nothing

3F66  CD 5647           	CALL	$SOB			; Yes, crack argument
3F69  A7                	ANA	A
3F6A  11 0100           	LXI	D,1
3F6D  CA 7B3F           	JZ	WAIT0			; Default to 1 second
3F70  CD CB45           	CALL	$DDD			; DE = Decoded decimal digits
3F73  DA 8E25           	JC	ILLSYN
3F76  7A                	MOV	A,D
3F77  B3                	ORA	E
3F78  CA A425           	JZ	SYSCMD. 		; He said WAIT 0

3F7B  3A CC20           WAIT0	LDA	S.TIME+2
3F7E  4F                	MOV	C,A			; Save current second
3F7F  13                	INX	D			; Add 1 to skip first partial second

3F80  3A CC20           WAIT1	LDA	S.TIME+2
3F83  B9                	CMP	C
3F84  CA 803F           	JE	WAIT1
3F87  4F                	MOV	C,A			; Save new second
3F88  1B                	DCX	D			; Count down the seconds
3F89  7A                	MOV	A,D
3F8A  B3                	ORA	E
3F8B  C2 803F           	JNZ	WAIT1			; Not there yet

3F8E  C7                	RST	SYSCMD			; Time's up !
3F8F                    	STL	'END - End Batch session'
3F8F                    	EJECT
                        ***	END - End Batch session
                        *
                        *	END

3F8F  E1                END	POP	H			; Clear stack
3F90  C3 A125           	JMP	BATOFF			; Turn BATCH off

3F93                    	STL	'EDLINE - SYSCMD.SYS Command Line Editor'
3F93                    	EJECT
3F93                    	XTEXT	EDLINE
                        **	EDLINE - SYSCMD.SYS Command Line Editor 		/3.0a/

                        *	Invoked by CTRL-A at the SYSCMD prompt.
                        *	Edit previous command string.

                        *	Command 	Description

                        *	nSPACE BAR	advance cursor right by 'n' characters (default =1)
                        *			each character is displayed as cursor moves.

                        *	nBACK SPACE	move cursor left by 'n' characters (default =1)
                        *			each character is blanked as cursor moves but is
                        *			NOT removed from buffer.

                        *	nDELETE 	same as BACK SPACE but characters are ALSO deleted
                        *			from buffer and any characters to the right are
                        *			brought back to fill the space.

                        *	A		ABORT current editing and restart editor with
                        *			original buffer contents.

                        *	C		enter CHANGE mode (overstrike). as user types new
                        *			characters they replace buffer contents at cursor
                        *			position. mode is exited with ESC or CR (below).

                        *	nD		DELETE 'n' characters to right of cursor (default =1)
                        *			delimit deleted text so user can see if he needs to
                        *			abort and try again.

                        *	H		HACK off rest of buffer and enter INSERT mode.

                        *	I		enter INSERT mode. as user types new characters
                        *			they push buffer contents to right so they fit in.
                        *			horn toots if buffer full. mode is exited with
                        *			ESC or CR (below).

                        *	xKc		KILL (delete) characters until the 'x'th occurence
                        *			of the character 'c'. delimits deleted text. if
                        *			character not found then uses rest of line.

                        *	L		LIST rest of line buffer and positions cursor at
                        *			start of line.

                        *	Q or CTL-D	QUIT editor and return to SYSCMD prompt. original
                        *			previous command still in tact.

                        *	xSc		SEARCH for 'x'th occurence of the character 'c'
                        *			and position cursor there.  all previous characters
                        *			are displayed.

                        *	X		add EXTRA text at end of line. position cursor at
                        *			end of line and enter INSERT mode.

                        *	ESC		ESCAPE from INSERT or CHANGE mode. still in editor
                        *			waiting for next command.

                        *	CR		RETURN (or ENTER) KEY. exit INSERT or CHANGE mode,
                        *			if user is in either, and return to SYSCMD with
                        *			edited command ready for execution.

      = 3F93            EDLINE	EQU	*
3F93  21 0000           	LXI	H,0
3F96  3E 01             	MVI	A,CTLA
3F98  FF 21             	SCALL	.CTLC	;disable ctl-a
3F9A  FF 07             	SCALL	.CLRCO	;clear console buffer
3F9C  31 8022           	LXI	SP,STACK;reset stack
3F9F  CD A02A           	CALL	TT.CE	;set character mode/no echo

3FA2  21 E480           EL0	LXI	H,LABEL ;edline work buffer addr
3FA5  22 0A42           	SHLD	ELPTR	;reset pointer
3FA8  06 65             	MVI	B,ELBUFL
3FAA  CD 8A19           	CALL	$ZERO	;fill buffer with nulls
3FAD  2A 5E00           	LHLD	S.EDLIN
3FB0  11 E480           	LXI	D,LABEL
3FB3  7E                EL1	MOV	A,M	;move command buffer to edit buffer
3FB4  12                	STAX	D
3FB5  23                	INX	H
3FB6  13                	INX	D
3FB7  B7                	ORA	A
3FB8  C2 B33F           	JNZ	EL1
3FBB  CD 2545           	CALL	$CRLF	;new line
3FBE  CD FD41           	CALL	ELPL	;print buffer
3FC1  22 0A42           	SHLD	ELPTR	;set pointer at end of command

3FC4  AF                ELRC	XRA	A
3FC5  32 0942           	STA	ELCNT	;reset count
3FC8  CD C341           EL3	CALL	ELCHR	;get a keystroke
3FCB  CD D846           	CALL	$MCU	;map it to upper case
3FCE  FE 41             	CPI	'A'	;abort
3FD0  CA A23F           	JZ	EL0
3FD3  FE 43             	CPI	'C'	;change
3FD5  CA 3E40           	JZ	ELC
3FD8  FE 44             	CPI	'D'	;delete
3FDA  CA 7940           	JZ	ELD
3FDD  FE 48             	CPI	'H'	;hack
3FDF  CA A240           	JZ	ELH
3FE2  FE 49             	CPI	'I'	;insert
3FE4  CA B640           	JZ	ELI
3FE7  FE 4B             	CPI	'K'	;kill
3FE9  CA 7640           	JZ	ELK
3FEC  FE 4C             	CPI	'L'	;list
3FEE  CA 2941           	JZ	ELL
3FF1  FE 51             	CPI	'Q'	;quit
3FF3  CA 3D41           	JZ	ELQ
3FF6  FE 04             	CPI	CTLD	;^D
3FF8  CA 3841           	JZ	ELCD
3FFB  FE 53             	CPI	'S'	;search
3FFD  CA 3E41           	JZ	ELS
4000  FE 58             	CPI	'X'	;extra
4002  CA B040           	JZ	ELX
4005  FE 20             	CPI	' '	;space bar
4007  CA 4141           	JZ	ELSP
400A  FE 08             	CPI	BS	;back space
400C  CA 5A41           	JZ	ELBS
400F  FE 7F             	CPI	DEL	;delete key
4011  CA 7B41           	JZ	ELDEL
4014  FE 0A             	CPI	NL	;enter key
4016  CA 9841           	JZ	ELNL
4019  FE 30             	CPI	'0'
401B  DA 3740           	JC	EL4
401E  FE 3A             	CPI	'9'+1
4020  D2 3740           	JNC	EL4
4023  D6 30             	SUI	'0'	;accumulate count
4025  F5                	PUSH	PSW
4026  3A 0942           	LDA	ELCNT
4029  87                	ADD	A	;x2
402A  4F                	MOV	C,A
402B  87                	ADD	A	;x4
402C  87                	ADD	A	;x8
402D  81                	ADD	C	;x10
402E  4F                	MOV	C,A
402F  F1                	POP	PSW
4030  81                	ADD	C
4031  32 0942           	STA	ELCNT	;update count
4034  C3 C83F           	JMP	EL3

4037  3E 07             EL4	MVI	A,BELL	;toot
4039  FF 02             	SCALL	.SCOUT
403B  C3 C83F           	JMP	EL3

      = 403E            ELC	EQU	*	;change
403E  2A 0A42           ELC0	LHLD	ELPTR
4041  7E                ELC1	MOV	A,M
4042  A7                	ANA	A
4043  CA 6F40           	JZ	ELC3
4046  CD C341           ELC2	CALL	ELCHR
4049  FE 1B             	CPI	ESC
404B  CA C43F           	JZ	ELRC	;reset count and return
404E  FE 04             	CPI	CTLD	;^D
4050  CA 3841           	JZ	ELCD	;quit
4053  FE 0A             	CPI	NL
4055  CA 9841           	JZ	ELNL
4058  FE 20             	CPI	' '	;other control codes NOT allowed
405A  DA 4640           	JC	ELC2
405D  FE 7F             	CPI	DEL	;not even delete
405F  CA 4640           	JZ	ELC2
4062  FF 02             	SCALL	.SCOUT	;else, print it
4064  2A 0A42           	LHLD	ELPTR
4067  77                	MOV	M,A	;and poke it
4068  23                	INX	H	;bump pointer
4069  22 0A42           	SHLD	ELPTR
406C  C3 4140           	JMP	ELC1	;loop for more til ESC or CTLD

406F  3E 07             ELC3	MVI	A,BELL
4071  FF 02             	SCALL	.SCOUT
4073  C3 C43F           	JMP	ELRC	;reset count and return

      = 4076            ELK	EQU	*	;kill
4076  CD DC41           	CALL	ELTRGT	;get count to target
                        *	JMP	ELD		process delete command
                        	ERRNZ	*-ELD

      = 4079            ELD	EQU	*	;delete
4079  2A 0A42           ELD0	LHLD	ELPTR
407C  7E                	MOV	A,M
407D  A7                	ANA	A
407E  CA 6F40           	JZ	ELC3	;at end of line
4081  3E 7B             	MVI	A,'{'	;delimiter
4083  FF 02             	SCALL	.SCOUT
4085  CD B541           	CALL	ELFC	;fetch count
4088  4F                	MOV	C,A	;save in C
4089  2A 0A42           ELD1	LHLD	ELPTR
408C  7E                	MOV	A,M
408D  A7                	ANA	A
408E  CA 9B40           	JZ	ELD2	;at end of line
4091  FF 02             	SCALL	.SCOUT	;print character as we go
4093  23                	INX	H
4094  CD CF41           	CALL	ELSHL.	;shift buffer left
4097  0D                	DCR	C
4098  C2 8940           	JNZ	ELD1	;loop for count
409B  3E 7D             ELD2	MVI	A,'}'	;delimiter
409D  FF 02             	SCALL	.SCOUT
409F  C3 C43F           	JMP	ELRC	;reset count and return

      = 40A2            ELH	EQU	*	;hack & insert
40A2  2A 0A42           	LHLD	ELPTR
40A5  7E                ELH0	MOV	A,M	;clear buffer until a NUL
40A6  B7                	ORA	A
40A7  CA B640           	JZ	ELI
40AA  AF                	XRA	A
40AB  77                	MOV	M,A
40AC  23                	INX	H
40AD  C3 A540           	JMP	ELH0

      = 40B0            ELX	EQU	*	;extra & insert
40B0  CD FD41           	CALL	ELPL	;print rest of line
40B3  22 0A42           	SHLD	ELPTR	;save new pointer
                        *	JMP	ELI		process insert command
                        	ERRNZ	*-ELI

      = 40B6            ELI	EQU	*	;insert
40B6  2A 0A42           	LHLD	ELPTR
40B9  CD C341           ELI0	CALL	ELCHR	;get keystroke
40BC  FE 1B             	CPI	ESC	;escape
40BE  CA C43F           	JZ	ELRC	;reset count and return
40C1  FE 04             	CPI	CTLD	;^D
40C3  CA 3841           	JZ	ELCD	;quit
40C6  FE 0A             	CPI	NL
40C8  CA 9841           	JZ	ELNL
40CB  FE 08             	CPI	BS	;backspace
40CD  CA 0741           	JZ	ELIBS
40D0  FE 7F             	CPI	DEL	;delete key
40D2  CA 1A41           	JZ	ELIDEL
40D5  FE 20             	CPI	' '	;test for valid character
40D7  D2 E140           	JNC	ELI2
40DA  3E 07             ELI1	MVI	A,BELL	;toot
40DC  FF 02             	SCALL	.SCOUT
40DE  C3 B940           	JMP	ELI0
40E1  F5                ELI2	PUSH	PSW
40E2  11 4781           	LXI	D,LABEL+ELBUFL-2
40E5  1A                	LDAX	D
40E6  B7                	ORA	A	;test for buffer full
40E7  CA EE40           	JZ	ELI3	;if not
40EA  F1                	POP	PSW
40EB  C3 DA40           	JMP	ELI1	;if full
40EE  13                ELI3	INX	D	;shift buffer right
40EF  12                	STAX	D
40F0  1B                	DCX	D
40F1  CD 8E18           	CALL	$CDEHL	;until we reach pointer
40F4  CA FC40           	JZ	ELI4
40F7  1B                	DCX	D
40F8  1A                	LDAX	D
40F9  C3 EE40           	JMP	ELI3
40FC  F1                ELI4	POP	PSW
40FD  FF 02             	SCALL	.SCOUT
40FF  77                	MOV	M,A	;insert character
4100  23                	INX	H	;bump pointer
4101  22 0A42           ELI5	SHLD	ELPTR	;save in case we exit next
4104  C3 B940           	JMP	ELI0

4107  11 E480           ELIBS	LXI	D,LABEL ;backspace in INSERT mode
410A  CD 8E18           	CALL	$CDEHL	;test for start of line
410D  CA DA40           	JZ	ELI1	;if so, bail out
4110  CD 5E19           	CALL	$TYPTX	;back up a character
4113  082088            	DB	BS,' ',BS+80H
4116  2B                	DCX	H	;back up pointer
4117  C3 0141           	JMP	ELI5

411A  11 E480           ELIDEL	LXI	D,LABEL ;delete key in INSERT mode
411D  CD 8E18           	CALL	$CDEHL	;test for start of line
4120  CA DA40           	JZ	ELI1	;if so, bail out
4123  CD C941           	CALL	ELSHL	;shift buffer left
4126  C3 0141           	JMP	ELI5

      = 4129            ELL	EQU	*	;list
4129  CD FD41           	CALL	ELPL	;print rest of line
412C  CD 2545           	CALL	$CRLF	;go to next line
412F  21 E480           	LXI	H,LABEL
4132  22 0A42           	SHLD	ELPTR	;reset pointer
4135  C3 C43F           	JMP	ELRC	;reset count and return

4138  CD 5E19           ELCD	CALL	$TYPTX	;^D
413B  5EC4              	DB	'^','D'+200Q

      = 413D            ELQ	EQU	*	;quit
413D  C7                	RST	SYSCMD	;return to SYSCMD

      = 413E            ELS	EQU	*	;search
413E  CD DC41           	CALL	ELTRGT	;get count to target
                        *	JMP	ELSP		process space bar command
                        	ERRNZ	*-ELSP

      = 4141            ELSP	EQU	*	;space bar
4141  CD B541           ELSP0	CALL	ELFC	;fetch count
4144  4F                	MOV	C,A	;save in C
4145  2A 0A42           	LHLD	ELPTR
4148  7E                ELSP1	MOV	A,M
4149  B7                	ORA	A	;test for NUL
414A  CA 5441           	JZ	ELSP2	;if so, bail out
414D  FF 02             	SCALL	.SCOUT	;if not, print it
414F  23                	INX	H	;bump pointer
4150  0D                	DCR	C
4151  C2 4841           	JNZ	ELSP1	;loop for count
4154  22 0A42           ELSP2	SHLD	ELPTR	;save new pointer
4157  C3 C43F           	JMP	ELRC	;reset count and return

      = 415A            ELBS	EQU	*	;backspace
415A  CD B541           	CALL	ELFC	;fetch count
415D  4F                	MOV	C,A	;save in C
415E  2A 0A42           	LHLD	ELPTR
4161  11 E480           ELBS0	LXI	D,LABEL
4164  CD 8E18           	CALL	$CDEHL	;test for start of line
4167  CA 7541           	JZ	ELBS1	;if so, bail out
416A  CD 5E19           	CALL	$TYPTX	;back up a character
416D  082088            	DB	BS,' ',BS+80H
4170  2B                	DCX	H	;back up pointer
4171  0D                	DCR	C
4172  C2 6141           	JNZ	ELBS0	;loop for count
4175  22 0A42           ELBS1	SHLD	ELPTR	;save new pointer
4178  C3 C43F           	JMP	ELRC	;reset count and return

      = 417B            ELDEL	EQU	*	;delete key
417B  CD B541           	CALL	ELFC	;fetch count
417E  4F                	MOV	C,A	;save in C
417F  2A 0A42           	LHLD	ELPTR
4182  11 E480           ELDEL0	LXI	D,LABEL
4185  CD 8E18           	CALL	$CDEHL	;test for start of line
4188  CA 9241           	JZ	ELDEL3	;if so, bail out
418B  CD C941           	CALL	ELSHL	;shift buffer left
418E  0D                	DCR	C
418F  C2 8241           	JNZ	ELDEL0	;loop for count
4192  22 0A42           ELDEL3	SHLD	ELPTR	;save new pointer
4195  C3 C43F           	JMP	ELRC	;reset count and return

      = 4198            ELNL	EQU	*	;return key
4198  CD FD41           	CALL	ELPL
419B  21 E480           	LXI	H,LABEL
419E  11 7F80           	LXI	D,LINE
41A1  7E                ELNL0	MOV	A,M	;move buffer back to command line
41A2  12                	STAX	D
41A3  23                	INX	H
41A4  13                	INX	D
41A5  B7                	ORA	A
41A6  C2 A141           	JNZ	ELNL0
41A9  CD A72A           	CALL	TT.CCM	;clear special console modes
41AC  CD 2545           	CALL	$CRLF
41AF  21 7F80           	LXI	H,LINE
41B2  C3 4A26           	JMP	PROMZ	;return to SYSCMD with a command

      = 41B5            ELFC	EQU	*	;fetch count
41B5  3A 0942           	LDA	ELCNT
41B8  B7                	ORA	A
41B9  CA C141           	JZ	ELFC0	;if zero, make one
41BC  FE 65             	CPI	ELBUFL
41BE  D8                	RC
41BF  3E 64             	MVI	A,ELBUFL-1;if > buffer length, make = buffer length
41C1  3C                ELFC0	INR	A
41C2  C9                	RET

41C3  FF 01             ELCHR	SCALL	.SCIN
41C5  DA C341           	JC	ELCHR
41C8  C9                	RET

41C9  CD 5E19           ELSHL	CALL	$TYPTX	;back up a character
41CC  082088            	DB	BS,' ',BS+80H
41CF  E5                ELSHL.	PUSH	H	;shift buffer left
41D0  7E                ELSHL1	MOV	A,M
41D1  2B                	DCX	H
41D2  77                	MOV	M,A
41D3  23                	INX	H
41D4  23                	INX	H
41D5  B7                	ORA	A	;test for NUL
41D6  C2 D041           	JNZ	ELSHL1	;if not, loop
41D9  E1                	POP	H
41DA  2B                	DCX	H	;back up pointer
41DB  C9                	RET

41DC  CD C341           ELTRGT	CALL	ELCHR	;get target character
41DF  4F                	MOV	C,A	;save it
41E0  06 00             	MVI	B,0	;zero delete count
41E2  CD B541           	CALL	ELFC	;fetch count
41E5  5F                	MOV	E,A	;save in E
41E6  2A 0A42           	LHLD	ELPTR
41E9  23                ELT2	INX	H	;search for target character
41EA  04                	INR	B	;bump delete count
41EB  7E                	MOV	A,M
41EC  B7                	ORA	A	;test for NUL
41ED  CA F841           	JZ	ELT3	;if so, bail out
41F0  B9                	CMP	C	;test for target
41F1  C2 E941           	JNZ	ELT2	;if not
41F4  1D                	DCR	E
41F5  C2 E941           	JNZ	ELT2
41F8  78                ELT3	MOV	A,B
41F9  32 0942           	STA	ELCNT	;save delete count as count
41FC  C9                	RET

41FD  2A 0A42           ELPL	LHLD	ELPTR	;print rest of line
4200  7E                ELPL0	MOV	A,M
4201  B7                	ORA	A	;test for NUL
4202  C8                	RZ
4203  FF 02             	SCALL	.SCOUT	;print character
4205  23                	INX	H	;bump pointer
4206  C3 0042           	JMP	ELPL0

4209  00                ELCNT	DB	0	;count
420A  E480              ELPTR	DW	LABEL	;pointer

      = 0065            ELBUFL	EQU	101	;buffer length

420C                    	STL	'Miscellaneous Subroutines'
420C                    	EJECT
420C                    	XTEXT	FEC
                        ***	FEC - FIND END OF COMMAND LINE.
                        *
                        *	FEC LOCATED THE END OF THE CURRENT COMMAND LINE.
                        *
                        *	Entry:	(BC) = START OF LINE
                        *	Exit:	(HL) = ADDRESS OF TERMINATING NULL BYTE
                        *	Uses:	A,F,H,L

420C  60                FEC	MOV	H,B
420D  69                	MOV	L,C
420E  7E                FEC1	MOV	A,M
420F  A7                	ANA	A
4210  C8                	RZ			; AT END
4211  23                	INX	H
4212  C3 0E42           	JMP	FEC1
4215                    	SPACE	4,10
4215                    	XTEXT	PCL
                        ***	PCL - PASS COMMAND LINE.
                        *
                        *	PCL PASSES A COMMAND LINE INTO THE STACK, FOR USE BY THE PROGRAM
                        *	WHICH WILL BE 'LINK'ED TO.
                        *
                        *	THE N BYTES ARE PUT IN THE STACK STARTING AT 'STACK-N' TO 'STACK-1'
                        *
                        *	** NOTE **
                        *
                        *	THIS ROUTINE PLAYS WITH THE STACK.  IT IS ENTERED VIA A CALL, BUT
                        *	IT THEN EMPTIES THE STACK TO SET UP THE COMMAND LINE.  THUS PCL'S
                        *	CALLER MUST NOT TRY TO RETURN TO IT'S CALLER.
                        *
                        *	Entry:	(BC) = LINE ADDRESS
                        *	Exit:	TO CALLER
                        *		(SP) = #STACK - N
                        *	Uses:	ALL

4215  E1                PCL	POP	H			; (HL) = RETURN ADDRESS
4216  F3                	DI				; NO INTERRUPTIONS WHILE MESSING W/ STACK
4217  22 3742           	SHLD	PCLA			; SET RETURN ADDRESS

421A  60                	MOV	H,B
421B  69                	MOV	L,C
421C  CD E146           	CALL	$MLU			; Map line to upper case

421F  11 8022           	LXI	D,STACK
4222  CD 0C42           	CALL	FEC			; FIND END OF COMMAND
4225  0A                	LDAX	B
4226  A7                	ANA	A
4227  CA 3342           	JZ	PCL2			; HAVE NO LINE TO PASS

                        *	GOT A LINE, MOVE INTO STACK AREA.

422A  7E                PCL1	MOV	A,M
422B  1B                	DCX	D
422C  12                	STAX	D			; STORE
422D  7D                	MOV	A,L
422E  B9                	CMP	C
422F  2B                	DCX	H
4230  C2 2A42           	JNE	PCL1			; MORE TO GO

4233  EB                PCL2	XCHG
4234  F9                	SPHL				; SET (SP) BELOW DATA
4235  FB                	EI
4236  C3 0000           	JMP	*-*			; EXIT
      = 4237            PCLA	EQU	*-2
4239                    	SPACE	4,10
4239                    	XTEXT	PIP
                        ***	PIPX - RUN PIP.
                        *
                        *	PIP [ANY VALID COMMAND]

4239  C1                PIPX	POP	B			; (BC) = Command Line

                        	ERRNZ	*-PIP

                        ***	PIP - INVOKE 'PIP'.
                        *
                        *	PIP IS ENTERED (VIA A JUMP) TO CAUSE A LINK TO 'SY0:PIP.ABS'.
                        *
                        *	Entry:	(BC) = FWA OF COMMAND LINE
                        *	Exit:	TO 'PIP.ABS' IF LINK IS OK.
                        *		TO *SYSCMD*, VIA ERROR MESSAGE IF ERROR.
                        *	Uses:	ALL

      = 4800            PIP.WS	EQU	110000A 		; PIP Warm start address

423A  CD 1542           PIP	CALL	PCL			; PASS COMMAND LINE

423D  3A 9142           	LDA	PIPMEM			; Is PIP in memory ?
4240  A7                	ANA	A
4241  C2 A142           	JNZ	PIPJMP			; YES, jump to warm start

4244  3A 9242           	LDA	PIPCHK			; Has PIP been checked ?
4247  A7                	ANA	A
4248  C2 5142           	JNZ	PIP1			; YES, don't check again

424B  CD C142           	CALL	CHKPIP			; Check for valid PIP first
424E  C2 AC42           	JNE	ODDPIP			; PIP with a different warm start addr

4251  3E 01             PIP1	MVI	A,1
4253  32 9142           	STA	PIPMEM			; Flag PIP as in memory

                        *	SO FAR, SO GOOD, TRY LINKING TO IT

4256  21 6942           PIP2	LXI	H,PIPA
4259  FF 20             	SCALL	.LINK

                        *	COULDN'T LINK TO PIP

425B  AF                PIP.	XRA	A			; Insure PIP-in-memory flag
425C  32 9142           	STA	PIPMEM			;   is reset

425F  CD 5E19           	CALL	$TYPTX
4262  0A07              	DB	NL,BELL
4264  46696C65 20       	DB	'File '
4269  5359303A 5049502E PIPA	DB	'SY0:PIP.ABS',0
4271  41425300
4275  20526571 75697265 	DB	' Required For This Command',ENL
427D  6420466F 72205468
4285  69732043 6F6D6D61
428D  6E648A
4290  C7                	RST	SYSCMD

4291  00                PIPMEM	DB	0			; PIP in memory flag

4292  00                PIPCHK	DB	0			; PIP has been checked flag

4293  F5                PIPERR	PUSH	PSW			; Something is wrong
4294  CD 5E19           	CALL	$TYPTX
4297  50495020 2DA0     	DB	'PIP -',' '+200Q
429D  F1                	POP	PSW
429E  C3 5A25           	JMP	ERROR

42A1  21 DD20           PIPJMP	LXI	H,S.CCTAB
42A4  06 06             	MVI	B,6
42A6  CD 8A19           	CALL	$ZERO			; Clear Vector Table
42A9  C3 0048           	JMP	PIP.WS			; PIP, Please !

42AC  CD B242           ODDPIP	CALL	SCGONE
42AF  C3 5642           	JMP	PIP2			; Try linking to odd PIP

42B2  3A 7F00           SCGONE	LDA	S.FLAG
42B5  E6 FE             	ANI	377Q-S.SYSCM		; Flag SYSCMD gone
42B7  32 7F00           	STA	S.FLAG
42BA  21 0B21           	LXI	H,S.FASER
42BD  22 0100           	SHLD	B.INT0+1		; Set RESTART 0 -> Fatal System Error
42C0  C9                	RET

                        **	MAKE SURE WE HAVE A COMPATIBLE VERSION OF PIP

42C1  21 6942           CHKPIP	LXI	H,PIPA			; Name
42C4  11 8322           	LXI	D,DEFA			; Default
42C7  AF                	XRA	A			; Channel
42C8  FF 22             	SCALL	.OPENR
42CA  D2 D542           	JNC	PIP3
42CD  FE 0C             	CPI	EC.FNF
42CF  CA 5B42           	JE	PIP.			; File Not Found
42D2  C3 9342           	JMP	PIPERR			; Oh Noooo !

42D5  11 E480           PIP3	LXI	D,LABEL 		; Buffer
42D8  01 0001           	LXI	B,1*256 		; One sector
42DB  AF                	XRA	A			; Channel
42DC  FF 04             	SCALL	.READ
42DE  DA 9342           	JC	PIPERR
42E1  AF                	XRA	A			; Channel
42E2  FF 26             	SCALL	.CLOSE
42E4  DA 9342           	JC	PIPERR

42E7  11 0048           	LXI	D,PIP.WS		; DE = Warm Start
42EA  2A E680           	LHLD	LABEL+ABS.LDA		; HL = Load Address
42ED  C3 8E18           	JMP	$CDEHL		;: MUST be equal
42F0                    	SPACE	4,10
42F0                    	XTEXT	PROMSHO
42F0  2A 5C00           PROM$$	LHLD	S.PRMT			; HL => SYSTEM PROMPT BUFFER
42F3  7E                	MOV	A,M			; Check for defined SYSTEM PROMPT
42F4  A7                	ANA	A
42F5  CA C343           	JZ	PR.P.			; JUST SHOW DEFAULT PROMPT

      = 42F8            PROMPT$ EQU	*

42F8  7E                PROML	MOV	A,M			; GET CHARACTER
42F9  A7                	ANA	A
42FA  C8                	RZ				; END OF BUFFER
42FB  E5                	PUSH	H			; SAVE POINTER
42FC  FE 24             	CPI	'$'			; IS IT MAGIC CHARACTER
42FE  C2 DC43           	JNE	PROMX			; NO, TYPE IT
4301  E1                	POP	H			; YES, RESTORE POINTER
4302  23                	INX	H			; BUMP POINTER
4303  7E                	MOV	A,M			; GET SECOND MAGIC CHARACTER
4304  A7                	ANA	A
4305  C8                	RZ				; PREMATURE END OF BUFFER
4306  E5                	PUSH	H			; SAVE POINTER
4307  CD D846           	CALL	$MCU			; MAP TO UPPER CASE
430A  FE 44             	CPI	'D'
430C  CA 6243           	JE	PR.D			; SHOW DATE
430F  FE 54             	CPI	'T'
4311  CA 6A43           	JE	PR.T			; SHOW TIME
4314  FE 56             	CPI	'V'
4316  CA 7543           	JE	PR.V			; SHOW VERSION #
4319  FE 4E             	CPI	'N'
431B  CA 7F43           	JE	PR.N			; SHOW DEFAULT DEVICE
431E  FE 55             	CPI	'U'
4320  CA 8743           	JE	PR.U			; SHOW DEFAULT UNIT
4323  FE 3A             	CPI	':'
4325  CA 9843           	JE	PR.XXU			; SHOW DEF. DEV. & UNIT & :
4328  FE 58             	CPI	'X'
432A  CA 8D43           	JE	PR.X			; SHOW DEFAULT EXTENSION
432D  FE 45             	CPI	'E'
432F  CA A343           	JE	PR.E			; SEND ESCAPE CHARACTER
4332  FE 5F             	CPI	'_'
4334  CA A643           	JE	PR.NL			; SEND NEW LINE CHARACTER
4337  FE 3D             	CPI	'='
4339  CA A943           	JE	PR.CR			; SEND CARRIAGE RETURN
433C  FE 5E             	CPI	'^'
433E  CA AC43           	JE	PR.FF			; SEND FORM FEED
4341  FE 48             	CPI	'H'
4343  CA BA43           	JE	PR.H			; SEND BACKSPACE+SPACE+BACKSPACE
4346  FE 53             	CPI	'S'
4348  CA AF43           	JE	PR.S			; SEND SPACE
434B  FE 2C             	CPI	','
434D  CA B243           	JE	PR.C			; SEND TAB
4350  FE 42             	CPI	'B'
4352  CA B543           	JE	PR.B			; SEND BELL
4355  FE 00             	CPI	''''
4357  CA D343           	JE	PR.TK			; SEND SHORT BELL
435A  FE 50             	CPI	'P'
435C  CA C543           	JE	PR.P			; SEND DEFAULT SYSTEM PROMPT
435F  C3 DC43           	JMP	PROMX			; WHO KNOWS, JUST SHOW IT

4362  21 BF20           PR.D	LXI	H,S.DATE
4365  3E 09             	MVI	A,9
4367  C3 9243           	JMP	PROMT

436A  3E 80             PR.T	MVI	A,200Q
436C  32 2A31           	STA	ENDTIM
436F  CD 1431           	CALL	DISPLA.
4372  C3 DE43           	JMP	PROMY

4375  CD 5E19           PR.V	CALL	$TYPTX
4378  332E30E1          	DB	VERS/16+'0','.',VERS&0FH+'0','a'+CUSTOM+200Q
437C  C3 DE43           	JMP	PROMY

437F  21 6A00           PR.N	LXI	H,S.DFBLK
4382  3E 02             	MVI	A,2
4384  C3 9243           	JMP	PROMT

4387  3A 6C00           PR.U	LDA	S.DFBLK+2
438A  C3 DC43           	JMP	PROMX

438D  21 6D00           PR.X	LXI	H,S.DFBLK+3
4390  3E 03             	MVI	A,3
4392  CD 6447           PROMT	CALL	$TYPCC
4395  C3 DE43           	JMP	PROMY

4398  21 6A00           PR.XXU	LXI	H,S.DFBLK
439B  3E 03             	MVI	A,3
439D  CD 6447           	CALL	$TYPCC
43A0  3E 3A             	MVI	A,':'
43A2  01                	DB	1			; FAKE LXI B,
43A3  3E 1B             PR.E	MVI	A,ESC
43A5  01                	DB	1
43A6  3E 0A             PR.NL	MVI	A,NL
43A8  01                	DB	1
43A9  3E 0D             PR.CR	MVI	A,CR
43AB  01                	DB	1
43AC  3E 0C             PR.FF	MVI	A,FF
43AE  01                	DB	1
43AF  3E 20             PR.S	MVI	A,' '
43B1  01                	DB	1
43B2  3E 09             PR.C	MVI	A,TAB
43B4  01                	DB	1
43B5  3E 07             PR.B	MVI	A,BELL
43B7  C3 DC43           	JMP	PROMX

43BA  CD 5E19           PR.H	CALL	$TYPTX
43BD  082088            	DB	BKSP,' ',BKSP+200Q
43C0  C3 DE43           	JMP	PROMY

43C3  2B                PR.P.	DCX	H			; PREDECREMENT FOR *PROMY*
43C4  E5                	PUSH	H			; SAVE POINTER

43C5  21 BC22           PR.P	LXI	H,DPROM 		; SYSTEM PROMPT
43C8  7E                PR.PL	MOV	A,M
43C9  A7                	ANA	A
43CA  CA DE43           	JZ	PROMY			; AT END OF IT
43CD  FF 02             	SCALL	.SCOUT
43CF  23                	INX	H
43D0  C3 C843           	JMP	PR.PL

43D3  3A A822           PR.TK	LDA	ULTRA
43D6  A7                	ANA	A
43D7  CA DE43           	JZ	PROMY
43DA  3E 12             	MVI	A,CTLR			; Tick sound

43DC  FF 02             PROMX	SCALL	.SCOUT			; SHOW CHARACTER
43DE  E1                PROMY	POP	H			; RESTORE POINTER
43DF  23                	INX	H			; BUMP POINTER
43E0  C3 F842           	JMP	PROML			; MORE TO GO

43E3                    	STL	'COMMON DECKS'
43E3                    	EJECT
43E3                    	XTEXT	H17SUBS
43E3                    	SPACE	4,10
                        **	$COMP - COMPARE TWO CHARACTER STRINGS.
                        *
                        *	$COMP COMPARES TWO BYTE STRINGS.
                        *
                        *	ENTRY	(C) = COMPARE COUNT
                        *		(DE) = FWA OF STRING #1
                        *		(HL) = FWA OF STRING #2
                        *	EXIT	'Z' CLEAR, IS MIS-MATCH
                        *		 (C) = LENGTH REMAINING
                        *		 (DE) = ADDRESS OF MISMATCH IN STRING#1
                        *		 (HL) = ADDRESS OF MISMATCH IN STRING #2
                        *		'Z' SET, HAVE MATCH
                        *		 (C) = 0
                        *		 (DE) = (DE) + (0C)
                        *		 (HL) = (HL) + (0C)
                        *	USES	A,F,C,D,E,H,L

      = 1830            $COMP	EQU	30060A	;IN H17 ROM
43E3                    	SPACE	4,10
                        **	$DADA - PERFORM (H,L) = (H,L) + (0,A)
                        *
                        *	ENTRY	(H,L) = BEFORE VALUE
                        *		(A) = BEFORE VALUE
                        *	EXIT	(H,L) = (H,L) + (0,A)
                        *		'C' SET IF OVERFLOW
                        *	USES	F,H,L

      = 183A            $DADA	EQU	30072A	;IN H17 ROM
43E3                    	SPACE	4,10
                        **	$DADA. - ADD (0,A) TO (H,L)
                        *
                        *	ENTRY	NONE
                        *	EXIT	(HL) = (HL) + (0A)
                        *	USES	A,F,H,L

      = 1841            $DADA.	EQU	30101A	;IN H17 ROM
43E3                    	SPACE	4,10
                        **	$DU66 - UNSIGNED 16 / 16 DIVIDE.
                        *
                        *	(HL) = (BC)/(DE)
                        *
                        *	ENTRY	(BC), (DE) PRESET
                        *	EXIT	(HL) = RESULT
                        *		(DE) = REMAINDER
                        *	USES	ALL

      = 1846            $DU66	EQU	30106A	;IN H17 ROM
43E3                    	SPACE	4,10
                        **	$HLIHL - LOAD HL INDIRECT THROUGH HL.
                        *
                        *	(HL) = ((HL))
                        *
                        *	ENTRY	NONE
                        *	EXIT	NONE
                        *	USES	A,H,L

      = 1889            $HLIHL	EQU	30211A	;IN H17 ROM
43E3                    	SPACE	4,10
                        **	$CDEHL - COMPARE (DE) TO (HL)
                        *
                        *	$CDEHL COMPARES (DE) TO (HL) FOR EQUALITY.
                        *
                        *	ENTRY	NONE
                        *	EXIT	'Z' SET IF (DE) = (HL)
                        *	USES	A,F

      = 188E            $CDEHL	EQU	30216A	;IN H17 ROM
43E3                    	SPACE	4,10
                        **	$CHL - COMPLEMENT (HL).
                        *
                        *	(HL) = -(HL)		TWO'S COMPLEMENT
                        *
                        *	ENTRY	NONE
                        *	EXIT	NONE
                        *	USES	A,F,H,L

      = 1894            $CHL	EQU	30224A	;IN H17 ROM
43E3                    	SPACE	4,10
                        **	$INDL - INDEXED LOAD.
                        *
                        *	$INDL LOADS DE WITH THE TWO BYTES AT (HL)+DISPLACMENT
                        *
                        *	THIS ACTS AS AN INDEXED FULL WORD LOAD.
                        *
                        *	(DE) = ( (HL) + DSPLACEMENT )
                        *
                        *	ENTRY	((RET)) = DISPLACMENT (FULL WORD)
                        *		(HL) = TABLE ADDRESS
                        *	EXIT	TO (RET+2)
                        *	USES	A,F,D,E

      = 189C            $INDL	EQU	30234A	;IN H17 ROM
43E3                    	SPACE	4,10
                        **	$MOVE - MOVE DATA
                        *
                        *	$MOVE MOVES A BLOCK OF BYTES TO A NEW MEMORY ADDRESS.
                        *	IF THE MOVE IS TO A LOWER ADDRESS, THE BYTES ARE MOVED FROM
                        *	FIRST TO LAST.
                        *
                        *	IF THE MOVE IS TO A HIGHER ADDRESS, THE BYTES ARE MOVED FROM
                        *	LAST TO FIRST.
                        *
                        *	THIS IS DONE SO THAT AN OVERLAPED MOVE WILL NOT 'RIPPLE'.
                        *
                        *	ENTRY	(BC) = COUNT
                        *		(DE) = FROM
                        *		(HL) = TO
                        *	EXIT	MOVED
                        *		(DE) = ADDRESS OF NEXT FROM BYTE
                        *		(HL) = ADDRESS OF NEXT *TO* BYTE
                        *		'C' CLEAR
                        *	USES	ALL

      = 18AA            $MOVE	EQU	30252A	;IN H17 ROM
43E3                    	SPACE	4,10
                        **	$MU10 - MULTIPLY UNSIGNED 16 BIT QUANTITY BY 10
                        *
                        *	(HL) = (DE) * 10
                        *
                        *	ENTRY:	(DE) = MULTIPLIER
                        *	EXIT:	'C' CLEAR IF OK
                        *		 (HL) = PRODUCT
                        *		'C' SET IF ERROR
                        *	USES:	F,D,E,H,L

      = 18D4            $MU10	EQU	30324A	;IN H17 ROM
43E3                    	SPACE	4,10
                        **	$MU66 - UNSIGNED 16 X 16 MULTIPLY.
                        *
                        *	ENTRY:	(BC) = MULTIPLICAND
                        *		(DE) = MULTIPLIER
                        *	EXIT:	(HL) = RESULT
                        *		'Z' SET IF NOT OVERFLOW
                        *	USES:	ALL

      = 18DF            $MU66	EQU	30337A	;IN H17 ROM
43E3                    	SPACE	4,10
                        **	$MU86 - MULTIPLY 8 X 16 UNSIGNED.
                        *
                        *	$MU86 MULTIPLIES A 16 BIT VALUE BY AN 8 BIT VALUE.
                        *
                        *	ENTRY	(A) = MULTIPLIER
                        *		(DE) = MULTIPLICAND
                        *	EXIT	(HL) = RESULT
                        *		'Z' SET IF NOT OVERFLOW
                        *	USES	A,F,H,L

      = 1907            $MU86	EQU	31007A	;IN H17 ROM
43E3                    	SPACE	4,10
                        **	$RSTALL - RESTORE ALL REGISTERS.
                        *
                        *	$RSTALL RESTORES ALL THE REGISTERS OFF THE STACK, AND
                        *	RETURNS TO THE PREVIOUS CALLER.
                        *
                        *	ENTRY	(SP) = PSW
                        *		(SP+2) = BC
                        *		(SP+4) = DE
                        *		(SP+6) = HL
                        *		(SP+8) = RET
                        *	EXIT	TO *RET*, REGISTERS RESTORED
                        *	USES	ALL

      = 1927            $RSTALL	EQU	31047A	;IN H17 ROM
43E3                    	SPACE	4,10
                        **	$SAVALL - SAVE ALL REGISTERS ON STACK.
                        *
                        *	$SAVALL SAVES ALL THE REGISTERS ON THE STACK.
                        *
                        *	ENTRY	NONE
                        *	EXIT	(SP) = PSW
                        *		(SP+2) = BC
                        *		(SP+4) = DE
                        *		(SP+6) = HL
                        *	USES	H,L

      = 192C            $SAVALL	EQU	31054A	;IN H17 ROM
43E3                    	SPACE	  4,10
                        **	$TJMP - TABLE JUMP.
                        *
                        *	USAGE
                        *
                        *	CALL	  $TJMP 	   (A) = INDEX
                        *	DW	  ADDR1
                        *	.	    .
                        *	.	    .
                        *	.	    .
                        *	DW	  ADDRN
                        *
                        *	ENTRY	  (A) = INDEX
                        *	EXIT	  TO PROCESSOR
                        *		 (A) = INDEX*2
                        *	USES	  NONE.

      = 1931            $TJMP	EQU	31061A	;IN H17 ROM, (A) = INDEX*2

      = 1932            $TJMP.	EQU	31062A	;IN H17 ROM
43E3                    	SPACE	4,10
                        **	$TBRA - BRANCH RELATIVE THROUGH TABLE.
                        *
                        *	$TBRA USES THE SUPPLIED INDEX TO SELECT A BYTE FROM THE
                        *	JUMP TABLE. THE CONTENTS OF THIS BYTE ARE ADDED TO THE
                        *	ADDRESS OF THE BYTE, YIELDING THE PROCESSOR ADDRESS.
                        *
                        *	CALL	$TBRA
                        *	DB	LAB1-*		; INDEX = 0 FOR LAB1
                        *	DB	LAB2-*		; INDEX = 1 FOR LAB2
                        *	DB	LABN-*		; INDEX = N-1 FOR LABN
                        *
                        *	ENTRY:	(A) = INDEX
                        *		(RET) = TABLE FWA
                        *	EXIT:	TO COMPUTED ADDRESS
                        *	USES:	F,H,L

      = 193E            $TBRA	EQU	31076A	;IN H17 ROM
43E3                    	SPACE	4,10
                        **	$TBLS - TABLE SEARCH
                        *
                        *	TABLE FORMAT
                        *
                        *	DB	KEY1,VAL1,
                        *	.	.
                        *	.	.
                        *	DB	KEYN,VALN
                        *	DB	0
                        *
                        *	ENTRY	(A) = PATTERN
                        *		(H,L) = TABLE FWA
                        *	EXIT	(A) = PATTERN IF FOUND
                        *		'Z' SET IF FOUND
                        *		'Z' CLEAR IF NOT FOUND OR PATTERN=0
                        *	USES	A,F,H,L

                        	IF	H17TBLS
      = 1949            $TBLS	EQU	31111A	;IN H17 ROM
                        	ELSE
                        	ENDIF
43E3                    	SPACE	4,10
                        **	$TYPTX - TYPE TEXT.
                        *
                        *	$TYPTX IS CALLED TO TYPE A BLOCK OF TEXT ON THE SYSTEM CONSOLE.
                        *
                        *	A BYTE WITH THE 200Q BIT SET IS THE LAST BYTE IN THE MESSAGE.
                        *
                        *	ENTRY	(RET) = TEXT
                        *	EXIT	TO (RET+LENGTH)
                        *	USES	A,F

      = 195E            $TYPTX	EQU	31136A	;IN H17 ROM

      = 1964            $TYPTX.	EQU	31144A	;IN H17 ROM
43E3                    	SPACE	4,10
                        **	$UDD - UNPACK DECIMAL DIGITS.
                        *
                        *	UDD CONVERTS A 16 BIT VALUE INTO A SPECIFIED NUMBER OF
                        *	DECIMAL DIGITS. THE RESULT IS ZERO FILLED.
                        *
                        *	ENTRY	(B,C) = ADDRESS VALUE
                        *		(A) = DIGIT COUNT
                        *		(H,L) = MEMORY ADDRESS
                        *	EXIT	(HL) = (HL) + (A)
                        *	USES	ALL

      = 196F            $UDD	EQU	31157A	;IN H17 ROM
43E3                    	SPACE	4,10
                        **	$ZERO - ZERO MEMORY
                        *
                        *	$ZERO ZEROS A BLOCK OF MEMORY.
                        *
                        *	ENTRY	(HL) = ADDRESS
                        *		(B) = COUNT
                        *	EXIT	(A) = 0
                        *	USES	A,B,F,H,L

      = 198A            $ZERO	EQU	31212A	;IN H17 ROM
43E3                    	SPACE	4,10
                        **	8 CONSTANT ZERO BYTES.

      = 19D0            $ZEROS	EQU	31320A	;IN H17 ROM
43E3                    	SPACE	4,10
                        **	$REL - RELOCATE CODE.
                        *
                        *	REL PROCESSES A RELOCATION LIST.
                        *
                        *	ENTRY:	(BC) = DISPLACEMENT FROM ASSEMBLED ADDRESS
                        *		(DE) = RELOCATION FACTOR (FROM CURRENT ADDRESS)
                        *		(HL) = FWA RELOCATION LIST
                        *	EXIT:	NONE
                        *	USES:	ALL
                        *
                        *	IF (DE) WILL BE EQUAL TO (BC), CALL $REL.

      = 1B7D            $REL.	EQU	33175A	;IN H17 ROM

      = 1B7F            $REL	EQU	33177A	;IN H17 ROM
43E3                    	SPACE	4,10
                        **	BOOT - BOOT CODE.
                        *
                        *	ENTERED TO BOOT DISK SYSTEM.

      = 1F0C            BOOT	EQU	37014A	;IN H17 ROM
43E3                    	XTEXT	BITS
43E3                    	SPACE	4,10
                        ***	BITS - BIT SET.
                        *
                        *	BITS SETS THE SPECIFIED BIT IN THE ACCUMULATOR.
                        *
                        *	ENTRY:	(A)  =	ORIGINAL (A)
                        *		(B)  =	NUMBER OF BIT TO SET (7=HIGH, ... ,0=LOW)
                        *	EXIT:	(A)  =	ORIGINAL (A) WITH BIT (B) SET
                        *	USES:	A,F

43E3  C5                BITS	PUSH	B

43E4  F5                	PUSH	PSW
43E5  3E 80             	MVI	A,10000000B
43E7  04                	INR	B
43E8  07                BITS1	RLC
43E9  05                	DCR	B
43EA  C2 E843           	JNZ	BITS1

43ED  4F                	MOV	C,A
43EE  F1                	POP	PSW
43EF  B1                	ORA	C

43F0  C1                	POP	B
43F1  C9                	RET
43F2                    	XTEXT	CAD
43F2                    	SPACE	4,10
                        **	$CAD - CODE AUGUSTAN DATE.
                        *
                        *	$CAD IS CALLED TO CODE AN AUGUSTAN DATE INTO THE FORM:
                        *
                        *
                        *	----------------------------------------
                        *	I  0  I  6 BITS  I  4 BITS  I  5 BITS  I
                        *	----------------------------------------
                        *		YEAR-70       MON       DAY
                        *		 1-63        1-12       1-31
                        *
                        *	FROM THE FORM:
                        *
                        *	DD-MMM-YY
                        *
                        *	Optional partial forms: 				/3.0a/
                        *
                        *	DD-MMM		If same year				/3.0a/
                        *	DD		If same month and year			/3.0a/
                        *
                        *	Rest of date is filled in from the S.DATE system area	/3.0a/
                        *
                        *	ENTRY	(HL) = ADDRESS OF STRING
                        *	EXIT	'C' CLEAR IF OK
                        *		 (DE) = 15 BIT VALUE
                        *		 (HL) ADVANCED PAST '-YY' or Short Form Date if Used
                        *		'C' SET IF ERROR
                        *	USES	ALL

43F2  E5                $CAD	PUSH	H
43F3  0E 07             	MVI	C,$CADBL
43F5  11 E244           	LXI	D,$CADB
43F8  CD 3018           	CALL	$COMP
43FB  C2 0444           	JNZ	$CAD0	;Is not 'No-Date'
43FE  D1                	POP	D
43FF  11 0000           	LXI	D,0	;0  =>  No Date
4402  A7                	ANA	A	;Clear 'C'
4403  C9                	RET

4404  E1                $CAD0	POP	H
4405  CD CB45           	CALL	$DDD	;DECODE DECIMAL DIGITS
4408  D8                	RC			ERROR
4409  7A                	MOV	A,D
440A  A7                	ANA	A
440B  37                	STC			ASSUME;TOO LARGE
440C  C0                	RNZ			TOO;LARGE
440D  7B                	MOV	A,E
440E  A7                	ANA	A
440F  37                	STC
4410  C8                	RZ			TOO;SMALL FOR DD
4411  FE 20             	CPI	32
4413  3F                	CMC	
4414  D8                	RC			TOO;LARGE
4415  EB                	XCHG			(HL);= DAY
4416  3E 20             	MVI	A,100000B
4418  85                	ADD	L
4419  6F                	MOV	L,A	;COUNT 1ST MONTH
441A  EB                	XCHG			(DE);= DD*16+1, (HL) = ADDRESS

                        *	DECODE MONTH

441B  D5                	PUSH	D	;SAVE DD*16+1
441C  3E C9             	MVI	A,311Q	;RET Code			/3.0a/
441E  32 AA44           	STA	CADR	;Assume whole DATE given 	/3.0a/
4421  7E                	MOV	A,M
4422  FE 2D             	CPI	'-'
4424  CA 4C44           	JE	CAD.M	;OK so far			/3.0a/
4427  CD AF44           	CALL	$CADD	;Is it end of entry ?		/3.0a/
442A  C2 6C44           	JNZ	$CAD2	;FORMAT ERROR

442D  22 AC44           	SHLD	CADHL	;Given ONLY day, save (HL)	/3.0a/
4430  AF                	XRA	A	;and poke NULL at end so 	|
4431  32 AA44           	STA	CADR	;(HL) gets restored		|
4434  21 C220           	LXI	H,S.DATE+3;Point at MMM-YY in system	|
4437  11 E944           	LXI	D,DBUF	;and copy it to buffer		|
443A  0E 06             	MVI	C,6					;|
443C  7E                CADL	MOV	A,M					;|
443D  CD D846           	CALL	$MCU	;Map to upper case		|
4440  12                	STAX	D					;|
4441  23                	INX	H					;|
4442  13                	INX	D					;|
4443  0D                	DCR	C					;|
4444  C2 3C44           	JNZ	CADL					;|
4447  AF                	XRA	A	;Mark end of string		|
4448  12                	STAX	D	;with a NULL byte		|
4449  21 E844           	LXI	H,DBUF-1;Point to buffer 		|

444C  23                CAD.M	INX	H	;Bump pointer			/3.0a/
444D  11 BD44           	LXI	D,$CADA ;(DE) = MONTH TABLE ADDRESS
4450  01 0300           $CAD1	LXI	B,3
4453  E5                	PUSH	H	;SAVE TEXT ADDRESS, $CADA ADDRESS
4454  D5                	PUSH	D
4455  CD 3018           	CALL	$COMP	;COMPARE
4458  D1                	POP	D	;(DE) = *$CADA* ADDRESS
4459  CA 6F44           	JE	$CAD3	;GOT MONTH
445C  E1                	POP	H	;(HL) = BUFFER ADDRESS OF MMM-YY
445D  13                	INX	D
445E  13                	INX	D
445F  13                	INX	D	;TRY NEXT MONTH
4460  E3                	XTHL
4461  3E 20             	MVI	A,100000B
4463  CD 4118           	CALL	$DADA.	;COUNT MONTH
4466  E3                	XTHL
4467  1A                	LDAX	D	;(A) = ENTRY IN $CADA
4468  A7                	ANA	A
4469  C2 5044           	JNZ	$CAD1	;MORE MONTHS TO GO

                        *	ERROR

446C  E1                $CAD2	POP	H	;CLEAR STACK
446D  37                	STC
446E  C9                	RET			FLAG;ERROR

                        *	CRACK -YY

446F  C1                $CAD3	POP	B	;DISCARD ADDRESS IF MMM-YY
4470  7E                	MOV	A,M
4471  FE 2D             	CPI	'-'
4473  CA 8F44           	JE	CAD.Y	;OK So Far			/3.0a/
4476  CD AF44           	CALL	$CADD	;Is it end of entry ?		/3.0a/
4479  C2 6C44           	JNZ	$CAD2	;FORMAT ERROR

447C  22 AC44           	SHLD	CADHL	;Given all but year, save (HL)	/3.0a/
447F  AF                	XRA	A	;and poke NULL at end so (HL)	|
4480  32 AA44           	STA	CADR	;gets restored			|
4483  32 EB44           	STA	DBUF+2	;Mark end of number with NULL	|
4486  2A C620           	LHLD	S.DATE+7;Get ascii year from system	|
4489  22 E944           	SHLD	DBUF	;and put it in buffer		|
448C  21 E844           	LXI	H,DBUF-1;Point to buffer 		|

448F  23                CAD.Y	INX	H	;Bump pointer			/3.0a/
4490  CD CB45           	CALL	$DDD	;DECODE DECIMAL DIGITS
4493  DA 6C44           	JC	$CAD2	;IF ERROR
4496  7A                	MOV	A,D
4497  A7                	ANA	A
4498  C2 6C44           	JNZ	$CAD2	;ERROR
449B  7B                	MOV	A,E	;(A) = YEAR
449C  D6 46             	SUI	70	;SUBTRACT DISPLACEMENT
449E  DA 6C44           	JC	$CAD2	;ERROR
44A1  FE 3F             	CPI	63
44A3  D2 6C44           	JNC	$CAD2	;TOO LARGE
44A6  D1                	POP	D	;(DE) = MONTH AND DAY
44A7  87                	ADD	A	;(A) = YEAR*2
44A8  82                	ADD	D
44A9  57                	MOV	D,A	;MERGE WITH REST OF IT

44AA  C9                CADR	RET			or;NOP if we must restore (HL)	/3.0a/
44AB  21 0000           	LXI	H,*-*					;|
      = 44AC            CADHL	EQU	*-2					;/3.0a/
44AE  C9                	RET

44AF  A7                $CADD	ANA	A	;CHECK FOR A VALID DELIMITER	/3.0a/
44B0  C8                	RZ			NULL			;|
44B1  FE 2F             	CPI	'/'					;|
44B3  C8                	RE			SLASH			;|
44B4  FE 20             	CPI	' '					;|
44B6  C8                	RE			SPACE			;|
44B7  FE 09             	CPI	TAB					;|
44B9  C8                	RE			TAB			;|
44BA  FE 2C             	CPI	','					;|
44BC  C9                	RET			COMMA			;/3.0a/

44BD   (0000)           $CADA	DS	0	;TABLE OF MONTHS
44BD  4A414E46 45424D41 	DB	'JAN','FEB','MAR','APR','MAY','JUN'
44C5  52415052 4D41594A
44CD  554E
44CF  4A554C41 55475345 	DB	'JUL','AUG','SEP','OCT','NOV','DEC'
44D7  504F4354 4E4F5644
44DF  4543
44E1  00                	DB	0

44E2  4E4F2D44 415445   $CADB	DB	'NO-DATE'
      = 0007            $CADBL	EQU	*-$CADB

44E9  4D4D4D2D 595900   DBUF	DB	'MMM-YY',0	  ;Date Buffer for Partials	/3.0a/
44F0                    	XTEXT	CCO
44F0                    CCO	SPACE	4,10
                        **	$CCO - CLEAR CONTROL-O
                        *
                        *	$CCO IS CALLED TO CLEAR THE EFFECT OF THE CTL-O CHARACTER.
                        *
                        *	ENTRY	NONE
                        *	EXIT	NONE
                        *	USES	NONE


44F0  CD 2C19           $CCO	CALL	$SAVALL 		; SAVE REGISTERS
44F3  3E 04             	MVI	A,I.CONFL
44F5  01 0100           	LXI	B,CO.FLG		; CLEAR CO.FLG
44F8  FF 06             	SCALL	.CONSL
44FA  C3 2719           	JMP	$RSTALL 		; RESTORE REGISTERS AND RETURN
44FD                    	XTEXT	CPDEHL
44FD                    	SPACE	4,10
                        ***	CPDEHL - Compare (HL) to (DE)
                        *
                        *	Entry:	NONE
                        *	Exit:	'C' Set if (HL) < (DE)
                        *		'Z' Set if (HL) = (DE)
                        *		 else (HL) > (DE)
                        *	Uses:	A,F

44FD  7C                CPDEHL	MOV	A,H
44FE  BA                	CMP	D
44FF  C0                	RNZ
4500  7D                	MOV	A,L
4501  BB                	CMP	E
4502  C9                	RET
4503                    	XTEXT	CPF
4503                    	SPACE	4,10
                        **	$CPF - COPY FILE NAME.
                        *
                        *	$CPF COPIES A FILE NAME FROM ONE LOCATION TO ANOTHER.
                        *
                        *	THE CHARACTERS ARE COPIED UNTIL A DELIMITER (',', ' ', '=', OR 00)
                        *	IS FOUND.
                        *
                        *	THE FILE NAME IS THEN TERMINATED WITH A 00 BYTE.
                        *
                        *	ENTRY:	(DE) = FROM ADDRESS
                        *		(HL) = TO ADDRESS
                        *	EXIT:	'C' CLEAR IF OK
                        *		 (DE) = ADVANCED PAST NAME AND DELIMITER
                        *		 (HL) POINTS TO 00 BYTE OF DESTINATION
                        *		 (A) = DELIMITER
                        *		'C' SET IF ERROR
                        *	USES:	ALL

4503  06 12             $CPF	MVI	B,FB.NAML+1		; SET MAXIMUM LENGTH
4505  1A                $CPF1	LDAX	D
4506  A7                	ANA	A
4507  CA 2245           	JZ	$CPF2			; END
450A  13                	INX	D
450B  FE 2C             	CPI	','
450D  CA 2245           	JE	$CPF2
4510  FE 3D             	CPI	'='
4512  CA 2245           	JE	$CPF2
4515  FE 20             	CPI	' '
4517  CA 2245           	JE	$CPF2			; IS BLANK
451A  77                	MOV	M,A			; COPY
451B  23                	INX	H
451C  05                	DCR	B
451D  C2 0545           	JNZ	$CPF1			; IF MORE GO TO
4520  37                	STC				; OVERFLOW OF AREA
4521  C9                	RET

                        *	DONE.

4522  36 00             $CPF2	MVI	M,0			; TERMINATE
4524  C9                	RET
4525                    	XTEXT	CRLF
4525                    CRLF	SPACE	4,10
                        **	$CRLF - TYPE CARRIAGE RETURN/ LINE FEED
                        *
                        *	$CRLF IS USED TO GENERATE PADDED CRLF'S.
                        *
                        *	ENTRY	NONE
                        *	EXIT	(A) = 0
                        *	USES	A,F

4525  3E 0A             $CRLF	MVI	A,NL
4527  FF 02             	SCALL	.SCOUT
4529  AF                	XRA	A
452A  C9                	RET
452B                    	XTEXT	DAD
452B                    	SPACE	4,10
                        **	$DAD - DECODE AUGUSTAN DATE.
                        *
                        *	$DAD DECODES A 15 BIT DATE CODE OF THE FORMAT:
                        *
                        *	----------------------------------------
                        *	I  0  I  6 BITS  I  4 BITS  I  5 BITS  I
                        *	----------------------------------------
                        *		YEAR-70       MON       DAY
                        *		 1-63        1-12       1-31
                        *
                        *	TO THE FORM:
                        *
                        *	DD-MMM-YY
                        *
                        *	ENTRY	(DE) = 15 BIT VALUE
                        *		(HL) = ADDRESS FOR DECODE
                        *	EXIT	(HL) = (HL)+9
                        *	USES	ALL

452B  7A                $DAD	MOV	A,D
452C  B3                	ORA	E
452D  CA 8C45           	JZ	DAD2	;No-Date

4530  22 8445           	SHLD	DAD1.	;Save HL in case of bad data

4533  42                	MOV	B,D
4534  4B                	MOV	C,E
4535  11 2000           	LXI	D,32
4538  E5                	PUSH	H	;SAVE ADDRESS
4539  CD 4618           	CALL	$DU66	;(DE) = DAY, (HL) = YEAR & MONTH
453C  E3                	XTHL			(HL);= ADDRESS
453D  42                	MOV	B,D
453E  4B                	MOV	C,E
453F  7B                	MOV	A,E
4540  A7                	ANA	A
4541  CA 8245           	JZ	DAD1X	;BAD VALUE
4544  3E 02             	MVI	A,2
4546  CD 6F19           	CALL	$UDD	;UNPACK DAY
4549  36 2D             	MVI	M,'-'
454B  23                	INX	H
454C  C1                	POP	B	;(BC) = YEAR & MONTH
454D  11 1000           	LXI	D,16
4550  E5                	PUSH	H	;SAVE ADDRESS
4551  CD 4618           	CALL	$DU66
4554  E3                	XTHL			(HL);= ADDRESS, ((SP)) = YEAR
4555  7B                	MOV	A,E
4556  87                	ADD	A
4557  83                	ADD	E	;(A) = 3*MONTH
4558  CA 8245           	JZ	DAD1X	;BAD VALUE
455B  FE 27             	CPI	13*3
455D  D2 8245           	JNC	DAD1X	;TOO LARGE
4560  EB                	XCHG			(DE);= ADDRESS
4561  21 9245           	LXI	H,DADB-3
4564  CD 4118           	CALL	$DADA.	;(HL) = ADDRESS OF MONTH
4567  01 0300           	LXI	B,3
456A  EB                	XCHG			(HL);= BUFFER ADDR, (DE) = ADDR IN 'DADB'
456B  CD AA18           	CALL	$MOVE	;MOVE MONTH IN
456E  36 2D             	MVI	M,'-'
4570  23                	INX	H
4571  C1                	POP	B	;(BC) = YEAR
4572  79                	MOV	A,C
4573  C6 46             	ADI	70
4575  FE 64             	CPI	100
4577  D2 8345           	JNC	DAD1	;TOO LARGE
457A  4F                	MOV	C,A	;(BC) = YEAR
457B  3E 02             	MVI	A,2
457D  CD 6F19           	CALL	$UDD	;UNPACK YEAR
4580  A7                	ANA	A
4581  C9                	RET

                        *	ILLEGAL FORMAT

4582  E1                DAD1X	POP	H	;RESTORE STACK
4583  21 0000           DAD1	LXI	H,*-*
      = 4584            DAD1.	EQU	*-2
4586  11 C245           	LXI	D,DADCX
4589  C3 8F45           	JMP	DAD3

                        *	No-Date

458C  11 B945           DAD2	LXI	D,DADC
458F  01 0900           DAD3	LXI	B,DADCL
4592  C3 AA18           	JMP	$MOVE

4595  4A616E46 65624D61 DADB	DB	'Jan','Feb','Mar','Apr','May','Jun'
459D  72417072 4D61794A
45A5  756E
45A7  4A756C41 75675365 	DB	'Jul','Aug','Sep','Oct','Nov','Dec'
45AF  704F6374 4E6F7644
45B7  6563

45B9  3C4E6F2D 44617465 DADC	DB	'<No-Date>'
45C1  3E
      = 0009            DADCL	EQU	*-DADC

45C2  3F3F2D3F 3F3F2D3F DADCX	DB	'??-???-??'
45CA  3F
                        	ERRNZ	*-DADCX-DADCL
45CB                    	XTEXT	DDD
45CB                    	SPACE	4,10
                        **	$DDD - DECODE DECIMAL DIGITS.
                        *
                        *	$DDD DECODES A STRING OF DECIMAL DIGITS INTO A DECIMAL INTEGER.
                        *
                        *	THE CHARACTERS ARE TAKEN OUT OF MEMORY. CONVERSION STOPS WITH THE
                        *	FIRST NON-DIGIT CHARACTER FOUND.
                        *
                        *	ENTRY	(HL) = ADDRESS OF CHARACTERS
                        *	EXIT	'C' CLEAR IF OK
                        *		 (DE) = NUMBER
                        *		 (HL) = INDEX OF FIRST NON-DIGIT ENCOUNTERED
                        *		'C' SET IF ERROR
                        *	USES	A,F,D,E,H,L

45CB  11 0000           $DDD	LXI	D,0			; (DE) = ACCUM

45CE  7E                $DDD1	MOV	A,M
45CF  D6 30             	SUI	'0'
45D1  3F                	CMC
45D2  D0                	RNC				; TOO SMALL
45D3  FE 0A             	CPI	10
45D5  D0                	RNC				; TOO LARGE
45D6  23                	INX	H			; ADVANCE ADDRESS
45D7  E5                	PUSH	H			; SAVE (HL)
45D8  CD D418           	CALL	$MU10			; (HL) = ACCUM*10
45DB  EB                	XCHG				; (DE) = ACCUM
45DC  E1                	POP	H			; (HL) = ADDRESS OF STRING
45DD  D8                	RC				; OVERFLOW
45DE  83                	ADD	E
45DF  5F                	MOV	E,A
45E0  3E 00             	MVI	A,0
45E2  8A                	ADC	D
45E3  57                	MOV	D,A
45E4  D2 CE45           	JNC	$DDD1			; NOT OVERFLOW
45E7  C9                	RET
45E8                    	XTEXT	FST2
45E8                    	SPACE	4,10
                        ***	$FST - FIND IN SERIAL TABLE.
                        *
                        *	$FST SEARCHES A SERIAL TABLE FOR A SPECIFIC KEY.
                        *
                        *	ENTRY:	(HL) = ADDRESS OF TABLE
                        *		(DE) = ADDRESS OF SEARCH KEY
                        *	EXIT:	(DE) UNCHANGED
                        *		'Z' CLEAR IF NO MATCH FOUND
                        *		 (HL) = ADDRESS OF NEXT AVAILABLE BYTE
                        *		'Z' SET IF MATCH FOUND
                        *		 (HL) = ADDRESS OF FIRST DATA BYTE
                        *	USES:	A,F,H,L

45E8  C5                $FST	PUSH	B			; SAVE REGISTERS
45E9  D5                	PUSH	D

45EA  D1                FST1	POP	D			; RESTORE ADDRESS OF SEARCH KEY
45EB  D5                	PUSH	D

45EC  7E                FST1A	MOV	A,M			; GET A CHARACTER
45ED  E6 7F             	ANI	177Q			; REMOVE PARITY
45EF  CA 3746           	JZ	FST4			; HAVE COMPLETE MATCH
45F2  47                	MOV	B,A			; SAVE THE CHARACTER
45F3  1A                	LDAX	D			; CHARACTER WE WANT TO MATCH
45F4  E6 7F             	ANI	177Q			; Remove parity
45F6  B8                	CMP	B			; COMPARE IT WITH TABLE
45F7  C2 FF45           	JNE	FST2			; NOT THE SAME
45FA  13                	INX	D			; BUMP POINTER
45FB  23                	INX	H
45FC  C3 EC45           	JMP	FST1A			; GO DO NEXT CHARACTER

                        *	HAVE MIS-MATCH.  SEE IF MISSING CHARACTER IS SIGNIFICANT.

45FF  7E                FST2	MOV	A,M
4600  3C                	INR	A			; check for optional number
4601  CA 0846           	JZ	FST2A			; check for it
4604  3D                	DCR	A
4605  FA 3746           	JM	FST4			; YEP, HAVE A MATCH.
4608  7E                FST2A	MOV	A,M			; GET CHAR. BACK FROM KEY
4609  E6 7F             	ANI	177Q			; mask off high bit
460B  FE 7F             	CPI	177Q			; IS NUMBER ACCEPTABLE?
460D  C2 2646           	JNZ	FST3			; NO.

                        *	Check if optional

4610  1A                	LDAX	D			; GET THE CHARACTER
4611  E6 7F             	ANI	177Q			; Trim parity
4613  FE 30             	CPI	'0'			; CHECK FOR 0-7
4615  DA 2146           	JC	FST2B			; check if optional specified
4618  FE 38             	CPI	'7'+1
461A  13                	INX	D			; BUMP PAST IT
461B  DA 3746           	JC	FST4			; ONE FOR THE GOOD GUYS!
461E  C3 2646           	JMP	FST3			; skip this key

4621  7E                FST2B	MOV	A,M			; get the table key back
4622  B7                	ORA	A			; is high bit set ?
4623  FA 3746           	JM	FST4			; han'l it, pronto

                        *	SKIP OVER THIS KEY

4626  7E                FST3	MOV	A,M			; GET CHARACTER
4627  23                	INX	H			; BUMP DOWN
4628  FE 80             	CPI	200Q			; END OF KEY?
462A  C2 2646           	JNE	FST3			; NO, KEEP GOING
462D  23                	INX	H			; START OF NEXT SWITCH
462E  7E                	MOV	A,M			; 1ST CHARACTER
462F  A7                	ANA	A			; IF IT'S NULL, END OF TABLE
4630  C2 EA45           	JNZ	FST1			; OK TO KEEP TRYING
4633  3C                	INR	A			; CLEAR 'Z' SINCE NO MATCH
4634  D1                	POP	D			; PUT REGISTERS BACK
4635  C1                	POP	B
4636  C9                	RET				; WITH NO MATCH

                        *	HAVE A MATCH.  FIND DATA CHARACTER AFTER KEY.

4637  1A                FST4	LDAX	D			; GET LAST CHARACTER OF KEY
4638  A7                	ANA	A			; BETTER BE NULL
4639  C2 2646           	JNZ	FST3			; NO MATCH HERE.
463C  7E                FST4A	MOV	A,M			; GET CHARACTER FROM TABLE
463D  FE 80             	CPI	200Q			; END?
463F  23                	INX	H
4640  C2 3C46           	JNE	FST4A			; KEEP LOOKING
4643  AF                	XRA	A			; SET 'Z' SINCE HAVE MATCH
4644  D1                	POP	D			; RESTORE
4645  C1                	POP	B
4646  C9                	RET				; WITH MATCH
4647                    	XTEXT	GNL
4647                    	SPACE	4,10
                        **	$GNL - GUARANTEE NEW LINE.
                        *
                        *	$GNL GUARANTEES THE START OF A NEW LINE BY ISSUING A CRLF
                        *	IF THE CURSOR IS NOT AT COLUMN 1..
                        *
                        *	ENTRY	NONE
                        *	EXIT	NONE
                        *	USES	ALL

4647  3E 02             $GNL	MVI	A,I.CUSOR
4649  01 0000           	LXI	B,0
464C  FF 06             	SCALL	.CONSL			; READ CURSOR
464E  3D                	DCR	A
464F  C8                	RZ				; AT COLUMN 1
4650  C3 2545           	JMP	$CRLF			;  ELSE, NEW LINE
4653                    	XTEXT	H19SUBS
4653                    	SPACE	4,10
                        ***	CLRSCRN - CLEAR TERMINAL SCREEN.
                        *
                        *	ENTRY:	NONE
                        *	EXIT:	NONE
                        *	USES:	A,F

4653  3A BB22           CLRSCRN LDA	H19FLG
4656  A7                	ANA	A
4657  CA 6D46           	JZ	CLRSCR
465A  CD 5E19           CLSCR	CALL	$TYPTX			; Send H19 ESC sequence
465D  1B48              	DB	ESC,'H' 		; Home cursor
465F  1B45              	DB	ESC,'E' 		; Clear Screen
4661  1B47              	DB	ESC,'G' 		; Exit graphics mode
4663  1B71              	DB	ESC,'q' 		; Exit reverse video mode
4665  1B7931            	DB	ESC,'y1'		; Disable 25th line
4668  1B7935            	DB	ESC,'y5'		; Cursor on
466B  8D                	DB	CR+200Q 		; Reset Cursor Position to 1
466C  C9                	RET

466D  C5                CLRSCR	PUSH	B			; Save BC
466E  0E 18             	MVI	C,24			; Send 24 blank lines
4670  3E 0A             CLRSC	MVI	A,NL
4672  FF 02             	SCALL	.SCOUT
4674  0D                	DCR	C
4675  C2 7046           	JNZ	CLRSC
4678  C1                	POP	B			; Restore BC
4679  C9                	RET
467A                    	SPACE	4,10
                        ***	HLDSCRN - Set up HOLD SCREEN mode on the H19.
                        *
                        *	ENTRY:	None
                        *	EXIT:	None
                        *	USES:	A,F

467A  3A BB22           HLDSCRN LDA	H19FLG
467D  A7                	ANA	A
467E  C8                	RZ
467F  CD 5E19           	CALL	$TYPTX
4682  1B5B8D            	DB	ESC,'[',CR+200Q 	; Set HOLD SCREEN
4685  C9                	RET

4686  3A BB22           HLDSCR2 LDA	H19FLG
4689  A7                	ANA	A
468A  C8                	RZ
468B  CD 5E19           	CALL	$TYPTX
468E  1BDC              	DB	ESC,'\'+200Q		; Clear HOLD SCREEN
4690  C9                	RET
4691                    	XTEXT	ILDEHL
4691                    	SPACE	4,10
                        ***	ILDEHL - INDEXED LOAD OF (DE) FROM (HL).
                        *
                        *	LOAD (DE) WITH THE FULL WORD VALUE POINTED TO BY (HL).
                        *
                        *	ENTRY:	(HL) = ADDRESS OF VALUE
                        *	EXIT:	(DE) = ((HL))
                        *		(HL) = (HL) + 2
                        *	USES:	D,E

4691  5E                ILDEHL	MOV	E,M
4692  23                	INX	H
4693  56                	MOV	D,M
4694  23                	INX	H
4695  C9                	RET
4696                    	XTEXT	INDXX
4696                    	SPACE	4,10
                        **	$INDLB	-  INDEXED LOAD BYTE
                        *
                        *	BYTE INDEXED LOAD PRIMITIVE
                        *
                        *	ENTRY:	HL = BASE ADDRESS
                        *		(RET) = FULL WORD RELOCATION
                        *	EXIT:	A = ( HL + (RET) )
                        *	USES:	A

4696  EB                $INDLB	XCHG				; DE = BASE
4697  E3                	XTHL				; SAVE	.DE.
4698  D5                	PUSH	D			; SAVE	BASE
4699  C5                	PUSH	B			; SAVE	.BC.

469A  4E                	MOV	C,M
469B  23                	INX	H
469C  46                	MOV	B,M			; BC = OFFSET
469D  23                	INX	H			; HL =	.RET.

469E  EB                	XCHG				; HL = BASE
469F  09                	DAD	B			; HL = BASE + OFFSET
46A0  7E                	MOV	A,M			; A  = ( BASE + OFFSET )
46A1  EB                	XCHG				; HL =	.RET.

46A2  C1                	POP	B			; RESTORE  .BC.
46A3  D1                	POP	D			; RESTORE  BASE
46A4  E3                	XTHL				; HL = .DE. ; (SP) = .RET.
46A5  EB                	XCHG				; DE = .DE. ; HL = BASE
46A6  C9                	RET
46A7                    	SPACE	4,10
                        **	$INDS	-  INDEXED STORE
                        *
                        *	INDEXED STORE PRIMITIVE.
                        *
                        *	ENTRY:	HL = BASE ADDRESS
                        *		DE = VALUE TO STORE
                        *	EXIT:	( HL + (RET) ) = DE
                        *	USES:	NONE

46A7  CD E247           $INDS	CALL	XCHGBC
46AA  E3                	XTHL				; SAVE	.BC.
46AB  D5                	PUSH	D
46AC  CD 9146           	CALL	ILDEHL			; DE = OFFSET
46AF  CD E247           	CALL	XCHGBC			; BC = .RET.
46B2  EB                	XCHG				; DE = BASE ; HL = OFFSET
46B3  19                	DAD	D			; HL = BASE + OFFSET
46B4  EB                	XCHG
46B5  E3                	XTHL				; SAVE	BASE
46B6  EB                	XCHG				; DE = VALUE
46B7  CD D346           	CALL	ISDEHL
46BA  E1                	POP	H			; HL = BASE
46BB  CD E247           	CALL	XCHGBC
46BE  E3                	XTHL				; RESTORE  .BC.
46BF  C3 E247           	JMP	XCHGBC
46C2                    	SPACE	4,10
                        **	$INDSB	-  INDEXED BYTE STORE
                        *
                        *	INDEXED BYTE STORE.
                        *
                        *	ENTRY:	A = VALUE TO STORE
                        *		HL = BASE ADDRESS
                        *		(RET) = OFFSET
                        *	EXIT:	NONE
                        *	USES:	PSW

46C2  EB                $INDSB	XCHG				; DE = BASE
46C3  E3                	XTHL				; SAVE	.DE.
46C4  D5                	PUSH	D			; SAVE	BASE
46C5  C5                	PUSH	B			; SAVE	.BC.

46C6  4E                	MOV	C,M
46C7  23                	INX	H
46C8  46                	MOV	B,M			; BC = OFFSET
46C9  23                	INX	H			; HL =	.RET.

46CA  EB                	XCHG				; HL = BASE
46CB  09                	DAD	B			; HL = BASE + OFFSET
46CC  77                	MOV	M,A			; ( BASE + OFFSET ) = A
46CD  EB                	XCHG

46CE  C1                	POP	B			; RESTORE  .BC.
46CF  D1                	POP	D			; RESTORE  BASE
46D0  E3                	XTHL				; HL = .DE. ; (SP) = .RET.
46D1  EB                	XCHG				; DE = .DE. ; HL = BASE
46D2  C9                	RET
46D3                    	XTEXT	ISDEHL
46D3                    	SPACE	4,10
                        **	ISDEHL	-  INDEXED STORE OF DE AT HL
                        *
                        *	STORE 'DE' AT THE ADDRESS POINTED TO BY 'HL', AND INCREMENT 'HL'
                        *	BY 2.
                        *
                        *	ENTRY:	DE = VALUE
                        *		HL = ADDRESS OF VALUE
                        *	EXIT:	(HL) = DE
                        *		HL = HL + 2
                        *	USES:	HL

46D3  73                ISDEHL	MOV	M,E
46D4  23                	INX	H
46D5  72                	MOV	M,D
46D6  23                	INX	H
46D7  C9                	RET
46D8                    	XTEXT	MCU
46D8                    	SPACE	4,10
                        **	MCU - MAP LOWER CASE TO UPPER CASE.
                        *
                        *	MCU MAPS A LOWER CASE ALPHABETIC TO UPPER
                        *	CASE.
                        *
                        *	ENTRY	(A) = CHARACTER
                        *	EXIT	(A) = CHARACTER RESULT
                        *	USES	A,F

46D8  FE 61             $MCU	CPI	'a'
46DA  D8                	RC				; NOT LOWER CASE
46DB  FE 7B             	CPI	'z'+1
46DD  D0                	RNC				; NOT LOWER CASE
46DE  D6 20             	SUI	'a'-'A'
46E0  C9                	RET
46E1                    	XTEXT	MLU
46E1                    	SPACE	4,10
                        **	MLU - MAP LOWER CASE LINE TO UPPER CASE.
                        *
                        *	MLU MAPS THE LOWER CASE ALPHABETICS IN A LINE TO UPPER CASE.
                        *
                        *	ENTRY	(HL)  = LINE FWA
                        *	EXIT	NONE
                        *	USES	NONE

46E1  F5                $MLU	PUSH	PSW	;SAVE (PSW)
46E2  E5                	PUSH	H	;SAVE FWA
46E3  2B                	DCX	H	;ANTICIPATE INX H
46E4  23                $MLU1	INX	H
46E5  7E                	MOV	A,M	;(A)= CHARACTER
46E6  CD D846           	CALL	$MCU	;MAP CHAR TO UPPER
46E9  77                	MOV	M,A
46EA  A7                	ANA	A
46EB  C2 E446           	JNZ	$MLU1	;MORE TO GO
46EE  E1                	POP	H	;RESTORE (HL)
46EF  F1                	POP	PSW	;RESTORE (PSW)
46F0  C9                	RET
46F1                    	XTEXT	MOVEL
46F1                    	SPACE	4,10
                        **	$MOVEL - MOVE DATA
                        *
                        *	$MOVEL MOVES A BLOCK OF BYTES TO A NEW MEMORY ADDRESS.
                        *	IF THE MOVE IS TO A LOWER ADDRESS, THE BYTES ARE MOVED FROM
                        *	FIRST TO LAST.
                        *
                        *	IF THE MOVE IS TO A HIGHER ADDRESS, THE BYTES ARE MOVED FROM
                        *	LAST TO FIRST.
                        *
                        *	THIS IS DONE SO THAT AN OVERLAPED MOVE WILL NOT 'RIPPLE'.
                        *
                        *	CALL	$MOVEL
                        *	DW	COUNT
                        *	DW	FROM
                        *	DW	TO
                        *
                        *	ENTRY	((SP)) = RET
                        *		(RET+0) = COUNT (WORD VALUE)
                        *		(RET+2) = FROM
                        *		(RET+4) = TO
                        *	EXIT	TO (RET+6)
                        *		(DE) = ADDRESS OF NEXT FROM BYTE
                        *		(HL) = ADDRESS OF NEXT *TO* BYTE
                        *		'C' CLEAR
                        *	USES	ALL

46F1  E1                $MOVEL	POP	H			; (HL) = RET
46F2  4E                	MOV	C,M
46F3  23                	INX	H
46F4  46                	MOV	B,M			; (BC) = COUNT
46F5  23                	INX	H
46F6  5E                	MOV	E,M
46F7  23                	INX	H
46F8  56                	MOV	D,M			; (DE) = FROM
46F9  23                	INX	H
46FA  D5                	PUSH	D			; ((SP)) = FROM
46FB  5E                	MOV	E,M
46FC  23                	INX	H
46FD  56                	MOV	D,M			; (DE) = TO
46FE  23                	INX	H
46FF  E3                	XTHL				; ((SP)) = RET, (HL) = FROM
4700  EB                	XCHG				; (DE) = FROM , (HL) = TO
4701  C3 AA18           	JMP	$MOVE			; MOVE IT
4704                    	XTEXT	RTL2
4704                    	SPACE	4,10
                        **	$RTL - READ TEXT LINE.
                        *
                        *	$RTL READS A LINE FROM THE TERMINAL.
                        *
                        *	CHARACTER ARE ACCEPTED FROM THE TERMINAL, RUBOUT AND BACKSPACE
                        *	CHARACTERS ARE PROCESSED. WHEN A CARRIAGE RETURN IS ENTERED,
                        *	$RTL RETURNS.
                        *
                        *	IF USER SETS:
                        *
                        *	$MULTI	EQU	0
                        *
                        *	THEN USER CAN ENTER MULTIPLE COMMANDS ON ONE
                        *	LINE SEPERATED BY A '\'
                        *
                        *	ENTRY	(HL) = BUFFER FWA
                        *	EXIT	'C' CLEAR IF OK
                        *		 DATA IN BUFFER
                        *		 (A) = TEXT LENGTH
                        *		'C' SET IF CTL-D STRUCK
                        *	USES	A,F

4704  CD 0B47           $RTL.	CALL	$RTL	;$RTL IN UPPER CASE
4707  D8                	RC			CTL-D
4708  C3 E146           	JMP	$MLU	;MAP LINE TO UPPER CASE

      = 470B            $RTL	EQU	*
470B  E5                	PUSH	H	;SAVE FWA

      = 470C            $RTL1	EQU	*
                        	IF	$BATCH
470C  3A 7F00           	LDA	S.FLAG
470F  E6 08             	ANI	S.BATCH
4711  CA 1A47           	JZ	$RTLX
4714  CD 063A           	CALL	B.BYTE
4717  C3 1F47           	JMP	$RTLXX
                        	ENDIF

471A  FF 01             $RTLX	SCALL	.SCIN	;READ CHARACTER
471C  DA 1A47           	JC	$RTLX

471F  FE 04             $RTLXX	CPI	CTLD
4721  CA 4A47           	JE	$RTL4	;CTL-D STRUCK
4724  77                	MOV	M,A
4725  23                	INX	H

                        	IF	$BATCH
4726  A7                	ANA	A
4727  CA 4347           	JZ	$RTL3
                        	ENDIF

                        	IF	$MULTI
472A  FE 5C             	CPI	'\'
472C  C2 3A47           	JNE	$RTLY
472F  3A 7F00           	LDA	S.FLAG
4732  F6 40             	ORI	S.TABUF
4734  32 7F00           	STA	S.FLAG
4737  C3 3F47           	JMP	$RTL2

      = 473A            $RTLY	EQU	*
                        	ENDIF

473A  FE 0A             	CPI	NL
473C  C2 0C47           	JNE	$RTL1
473F  2B                $RTL2	DCX	H
4740  36 00             	MVI	M,0
4742  23                	INX	H

                        *	ALL DONE. COMPUTE LENGTH

4743  EB                $RTL3	XCHG			(DE);= LWA+1
4744  E3                	XTHL			(HL);= FWA
4745  7B                	MOV	A,E
4746  95                	SUB	L	;(A) = LENGTH
4747  A7                	ANA	A	;CLEAR CARRY
4748  D1                	POP	D	;RESTORE (DE)
4749  C9                	RET

                        *	CTL-D STRUCK

474A  CD 5E19           $RTL4	CALL	$TYPTX
474D  5E448A            	DB	'^D',ENL
4750  E1                	POP	H	;(HL) = FWA
4751  37                	STC
4752  C9                	RET
4753                    	SPACE	4,10
                        ***	M$SOB - Map Line First, then Skip Over Blanks

4753  CD E146           M$SOB	CALL	$MLU			; Map Line to Upper Case

4756                    	XTEXT	SOB
4756                    	SPACE	4,10
                        **	$SOB - SKIP OVER BLANKS.
                        *
                        *	$SOB IS CALLED TO SKIP AN ARBITRARILY LONG STRING OF BLANKS AND TABS.
                        *
                        *	ENTRY	(HL) = FWA OF (POSSIBLE) BLANK STRING
                        *	EXIT	(HL) = LWA+1 OF BLANK STRING (UNCHANGED IF NO BLANKS)
                        *		(A) = FIRST NON-BLANK, NON-TAB CHARACTER EEN
                        *	USES	A,F,H,L

4756  2B                $SOB	DCX	H			; PRE-DECREMENT
4757  23                $SOB1	INX	H
4758  7E                	MOV	A,M
4759  FE 20             	CPI	' '
475B  CA 5747           	JE	$SOB1			; GOT BLANK
475E  FE 09             	CPI	TAB
4760  CA 5747           	JE	$SOB1			; GOT TAB
4763  C9                	RET
4764                    	XTEXT	TYPCC
4764                    	SPACE	4,10
                        **	$TYPCC - TYPE A CHARACTER STRING BY COUNT.
                        *
                        *	$TYPCC TYPES A STRING OF CHARACTERS. THE CALLER SUPPLIES
                        *	THE CHARACTER ADDRESS AND COUNT.
                        *
                        *	ENTRY	(HL) = ADDRESS
                        *		(A) = COUNT
                        *	EXIT	(HL) = LAST CHARACTER ADDRESS+1
                        *	USES	A,F,H,L

      = 4764            $TYPCC	EQU	*

4764  A7                	ANA	A
4765  C8                	RZ				; NOTHING TO TYPE
4766  F5                	PUSH	PSW			; SAVE COUNT
4767  7E                	MOV	A,M			; (A) = CHARACTER
4768  23                	INX	H
4769  FF 02             	SCALL	.SCOUT
476B  F1                	POP	PSW
476C  3D                	DCR	A
476D  C3 6447           	JMP	$TYPCC
4770                    	XTEXT	UDDX
4770                    	SPACE	4,10
                        **	$UDDX - UNPACK DECIMAL DIGITS.					/3.0/
                        *
                        *	UDDX CONVERTS A 16 BIT VALUE INTO A SPECIFIED NUMBER OF DECIMAL
                        *	DIGITS.
                        *
                        *	$UDDN = PAD WITH NULLS
                        *
                        *	$UDDS = PAD WITH SPACES
                        *
                        *	ENTRY	(B,C) = ADDRESS VALUE
                        *		(A) = DIGIT COUNT
                        *		(H,L) = MEMORY ADDRESS
                        *	EXIT	(HL) = (HL) + (A)
                        *	USES	ALL

      = 4770            $UDDN	EQU	*

4770  57                	MOV	D,A	;SAVE (A)
4771  AF                	XRA	A	;(A) = NUL
4772  C3 7847           	JMP	$UDDX

      = 4775            $UDDS	EQU	*

4775  57                	MOV	D,A	;SAVE (A)
4776  3E 20             	MVI	A,' '	;(A) = SPACE

4778  32 A347           $UDDX	STA	UDDPAD	;SET PAD CHARACTER
477B  7A                	MOV	A,D	;RESTORE (A)
477C  CD 3A18           	CALL	$DADA
477F  E5                	PUSH	H	;SAVE FINAL (H,L) VALUE

4780  F5                UDDX1	PUSH	PSW
4781  E5                	PUSH	H
4782  11 0A00           	LXI	D,10
4785  CD 4618           	CALL	$DU66	;(H,L) = VALUE/10
4788  44                	MOV	B,H
4789  4D                	MOV	C,L	;(BC) = QUOTIENT
478A  E1                	POP	H
478B  3E 30             	MVI	A,'0'
478D  83                	ADD	E	;ADD REMAINDER
478E  2B                	DCX	H
478F  77                	MOV	M,A	;STORE DIGIT
4790  78                	MOV	A,B
4791  B1                	ORA	C
4792  CA 9C47           	JZ	UDDX2	;ALL ZEROS
4795  F1                	POP	PSW
4796  3D                	DCR	A
4797  C2 8047           	JNZ	UDDX1	;IF MORE TO GO

                        *	ALL DONE. EXIT

479A  E1                UDDX1.5	POP	H	;RESTORE H
479B  C9                	RET			RETURN

                        *	DIGITS LEADING THIS ONE ARE ZERO. STORE NULLS INSTEAD.

479C  F1                UDDX2	POP	PSW
479D  3D                UDDX3	DCR	A
479E  CA 9A47           	JE	UDDX1.5 ;ALL DONE
47A1  2B                	DCX	H
47A2  36 00             	MVI	M,0
      = 47A3            UDDPAD	EQU	*-1
47A4  C3 9D47           	JMP	UDDX3
47A7                    	XTEXT	UHW
47A7                    	SPACE	4,8
                        **	$UHW - UNPACK HEXADECIMAL WORD
                        *
                        *	ENTRY	(BC) = VALUE
                        *		(HL) = MEMORY ADDRESS
                        *	EXIT	(HL) = (HL) + 4
                        *	USES	A,F,H,L
                        *
47A7                    	SPACE	3,10
                        **	$UHB - UNPACK HEXADECIMAL BYTE
                        *
                        *	ENTRY	(A) = VALUE
                        *		(HL) = MEMORY ADDRESS
                        *	EXIT	(HL) = (HL) + 2
                        *	USES	A,F,H,L

47A7  78                $UHW	MOV	A,B			; GET MSB
47A8  CD AC47           	CALL	$UHB
47AB  79                	MOV	A,C			; GET LSB

47AC  F5                $UHB	PUSH	PSW
47AD  1F                	RAR				; ROTATE DIGIT INTO PLACE
47AE  1F                	RAR
47AF  1F                	RAR
47B0  1F                	RAR
47B1  CD B547           	CALL	NIBL
47B4  F1                	POP	PSW
47B5  E6 0F             NIBL	ANI	00001111B		; MASK OFF EXCESS
47B7  C6 90             	ADI	90H			; MAKE IT 0 THRU F
47B9  27                	DAA
47BA  CE 40             	ACI	40H
47BC  27                	DAA				; MAKE IT ASCII
47BD  77                	MOV	M,A			; POKE DIGIT
47BE  23                	INX	H			; BUMP POINTER
47BF  C9                	RET
47C0                    	XTEXT	UOW
47C0                    	SPACE	4,8
                        **	$UOW - UNPACK OCTAL WORD
                        *
                        *	ENTRY	(BC) = VALUE
                        *		(HL) = MEMORY ADDRESS
                        *	EXIT	(HL) = (HL) + 6
                        *	USES	A,F,H,L
                        *
47C0                    	SPACE	3,8
                        **	$UOW. - UNPACK OCTAL WORD (ADD '.' BETWEEN BYTES)
                        *
                        *	ENTRY	(BC) = VALUE
                        *		(HL) = MEMORY ADDRESS
                        *	EXIT	(HL) = (HL) + 7
                        *	USES	A,F,H,L
                        *
47C0                    	SPACE	3,10
                        **	$UOB - UNPACK OCTAL BYTE
                        *
                        *	ENTRY	(A) = VALUE
                        *		(HL) = MEMORY ADDRESS
                        *	EXIT	(HL) = (HL) + 3
                        *	USES	A,F,H,L

47C0  78                $UOW	MOV	A,B
47C1  CD CF47           	CALL	$UOB
47C4  C3 CE47           	JMP	UOW1

47C7  78                $UOW.	MOV	A,B			; GET MSB
47C8  CD CF47           	CALL	$UOB
47CB  36 2E             	MVI	M,'.'			; FOR SHOW
47CD  23                	INX	H

47CE  79                UOW1	MOV	A,C			; GET LSB

47CF  A7                $UOB	ANA	A			; CLEAR CARRY
47D0  CD D647           	CALL	UOD
47D3  CD D647           	CALL	UOD

                        *	UNPACK OCTAL DIGIT

47D6  17                UOD	RAL				; ROTATE DIGIT INTO PLACE
47D7  17                	RAL
47D8  17                	RAL
47D9  F5                	PUSH	PSW
47DA  E6 07             	ANI	00000111B		; MASK OFF EXCESS
47DC  C6 30             	ADI	'0'			; MAKE IT ASCII
47DE  77                	MOV	M,A			; POKE DIGIT
47DF  23                	INX	H			; BUMP POINTER
47E0  F1                	POP	PSW
47E1  C9                	RET
47E2                    	XTEXT	XCHGBC
47E2                    	SPACE	4,10
                        ***	XCHGBC - Exchange (HL) with (BC).
                        *
                        *	Entry:	NONE
                        *	Exit:	(HL) = (BC)
                        *		(BC) = (HL)
                        *	Uses:	B,C,H,L
                        *
                        *	Note:	Whoever wrote the original version of this routine
                        *		(that distributed by Heath), really ought to be shot.

47E2  C5                XCHGBC	PUSH	B			; Put (BC) on stack
47E3  E3                	XTHL				; Swap it with (HL)
47E4  C1                	POP	B			; Pop new (BC)
47E5  C9                	RET

      = 47E6            MEML	EQU	*			; Program LWA + 1

47E6                    	STL	'SYSCMD Initialization Code'
47E6                    	EJECT
                        ***	SYSINIT - Initialize SYSCMD at boot time
                        *
                        *	This routine is only used once.
                        *	PIP is allowed to overlay it if necessary.

      = 47E6            SYSINIT EQU	*

47E6  3A 7F00           	LDA	S.FLAG
47E9  F6 80             	ORI	S.INIT
47EB  32 7F00           	STA	S.FLAG			; FLAG so we DON'T repeat this code

47EE  2A 6A00           	LHLD	S.DFBLK 		; CHECK FOR A SYSTEM DEFAULT
47F1  7C                	MOV	A,H
47F2  B5                	ORA	L
47F3  C2 0248           	JNZ	SI0			; HAVE ALREADY PRESET DEVICE NAMES

47F6  2A A922           	LHLD	DPDEV			; PRESET DEFAULT PRIMARY DEVICE
47F9  22 AD22           	SHLD	PRIDEV
47FC  2A AB22           	LHLD	DADEV			; PRESET DEFAULT ALTERNATE DEVICE
47FF  22 B122           	SHLD	ALTDEV

4802  3A A122           SI0	LDA	VFYFLG			; GET BOOT DEFAULT STATE
4805  A7                	ANA	A
4806  CA 1148           	JZ	SI1
4809  3A 7F00           	LDA	S.FLAG
480C  F6 02             	ORI	S.VFLG			; PRESET VERIFY FLAG
480E  32 7F00           	STA	S.FLAG

4811  3A A422           SI1	LDA	XYZZYF
4814  A7                	ANA	A
4815  CA 2048           	JZ	SI2
4818  3A 7F00           	LDA	S.FLAG
481B  F6 10             	ORI	S.EXITC 		; PRESET XYZZY FLAG
481D  32 7F00           	STA	S.FLAG

4820  3A 1C21           SI2	LDA	S.BOOTF 		; Get boot flags
4823  E6 01             	ANI	BOOT.P			; Did user say 'Ignore'
4825  CA A425           	JZ	SYSCMD. 		; Yes, forget AUTOEXEC.BAT

                        *	CHECK FOR AUTOEXEC.BAT AT BOOT TIME

4828  21 3D48           	LXI	H,PROLOG		; 'AUTOEXEC'
482B  11 9522           	LXI	D,BATBLK		; DEFAULT BLOCK
482E  AF                	XRA	A			; CHAN. 0
482F  FF 22             	SCALL	.OPENR
4831  D2 E527           	JNC	SYSC12			; SET UP BATCH FILE USAGE
4834  FE 0C             	CPI	EC.FNF
4836  CA A425           	JE	SYSCMD. 		; NO PROLOG FILE, DO NOTHING
4839  F5                AUTOER	PUSH	PSW
483A  CD 5E19           	CALL	$TYPTX
483D  4155544F 45584543 PROLOG	DB	'AUTOEXEC',0,' -',' '+200Q
4845  00202DA0
4849  F1                	POP	PSW
484A  C3 5A25           	JMP	ERROR			; ERROR WITH PROLOG FILE, DO NOTHING
484D                    	SPACE	4,10
                        **	"what" identification

484D  40282329 53595343 	DB	'@(#)SYSCMD/Plus by Richard Musgrave',NL
4855  4D442F50 6C757320
485D  62792052 69636861
4865  7264204D 75736772
486D  6176650A

4871  0100              	DW	.DATE.			; assembly date
4873  0200              	DW	.TIME.			;  and time.

      = 4875            IMEML	EQU	*			; LWA including init. code + 1
4875                    	STL	'WORKING BUFFERS'
4875                    	EJECT
                        ***	BUFFERS

      = 8000            BUFFWA	EQU	200000A

      = 8000            SYSBLK	EQU	BUFFWA			; Default Block for PATH usage

      = 8006            VERB.	EQU	SYSBLK+6		; Verb 200Q byte
      = 8007            VERB	EQU	VERB.+1 		; Verb buffer

      = 807F            LINE	EQU	VERB+120		; Line buffer

      = 80E4            LABEL	EQU	LINE+101		; Label buffer
      = 80E4            TSKBUF	EQU	LABEL			; Task buffer  (Overlays label buffer)

      = A0E4            RMEML	EQU	8*1024+TSKBUF		; 8k above us for Task Buffer

4875   (22CD)           	END	SYSXIT

00000 Total Errors


00010 Total Warnings

$                  007F E  $$                 2945 E  $BATCH             0000 E
$CAD               43F2    $CAD0              4404    $CAD1              4450
$CAD2              446C    $CAD3              446F    $CADA              44BD
$CADB              44E2    $CADBL             0007 E  $CADD              44AF
$CCO               44F0    $CDEHL             188E E  $CHL               1894 E
$COMP              1830 E  $CPF               4503    $CPF1              4505
$CPF2              4522    $CRLF              4525    $DAD               452B
$DADA              183A E  $DADA.             1841 E  $DDD               45CB
$DDD1              45CE    $DTB               37AE E  $DTB.              37B4
$DTB..             37BB    $DU66              1846 E  $FATAL             23C3 E
$FST               45E8    $GNL               4647    $HLIHL             1889 E
$INDL              189C E  $INDLB             4696    $INDS              46A7
$INDSB             46C2    $MCU               46D8    $MLU               46E1
$MLU1              46E4    $MOVE              18AA E  $MOVEL             46F1
$MU10              18D4 E  $MU66              18DF E  $MU86              1907 E
$MULTI             0000 E  $PCHL              326C    $REL               1B7F E
$REL.              1B7D E  $RSTALL            1927 E  $RTL               470B E
$RTL.              4704    $RTL1              470C E  $RTL2              473F
$RTL3              4743    $RTL4              474A    $RTLX              471A
$RTLXX             471F    $RTLY              473A E  $SAVALL            192C E
$SOB               4756    $SOB1              4757    $TBLS              1949 E
$TBRA              193E E  $TJMP              1931 E  $TJMP.             1932 E
$TYPCC             4764 E  $TYPTX             195E E  $TYPTX.            1964 E
$UDD               196F E  $UDDN              4770 E  $UDDS              4775 E
$UDDX              4778    $UHB               47AC    $UHW               47A7
$UOB               47CF    $UOW               47C0    $UOW.              47C7
$ZERO              198A E  $ZEROS             19D0 E  .                  0080 S
.ABUSS             2014 E  .ALEDS             200B E  .CHFLG             0030
.CLEAR             002D    .CLEARA            002E    .CLOSE             0026
.CLRCO             0007    .CONSL             0006    .CRC16             000B
.CRCSUM            2017 E  .CTL2FL            2036 E  .CTLC              0021
.CTLFLG            2009 E  .DAD               0086    .DATE.             0001 E
.DECODE            002B    .DELET             0028    .DELETE            0028 E
.DISMT             0031    .DLEDS             2011 E  .DLY               002B E
.DMNMS             0083    .DMOUN             0081    .DMOUNT            0081 E
.DSPMOD            2007 E  .DSPROT            2006 E  .ERROR             002F
.EXIT              0000    .GDA               000A    .IOWRK             2002 E
.LINK              0020    .LOADD             0032    .LOADO             0008
.LOG               007F E  .MFLAG             2008 E  .MONMS             0082
.MOUNT             0080    .NAME              002C    .NMIRET            2034 E
.OPENC             0025    .OPENR             0022    .OPENU             0024
.OPENW             0023    .POSIT             0027    .PRINT             0003
.READ              0004    .REGI              2005 E  .REGPTR            201D E
.RENAM             0029    .RENAME            0029 E  .RESET             0084
.RESNMS            0085    .SCIN              0001    .SCOUT             0002
.SETTOP            002A E  .SETTP             002A    .START             2000 E
.SYSRES            000C    .TASK              0041 E  .TICCNT            201B E
.TIME.             0002 E  .TPERRX            2019 E  .UIVEC             201F E
.VERS              0009    .WRITE             0005    ABS.COD            0008
ABS.ENT            0006    ABS.ID             0000    ABS.LDA            0002
ABS.LEN            0004    AIO.CGN            2127    AIO.CHA            214E
AIO.CNT            2149    AIO.CSI            2128    AIO.DDA            2121 E
AIO.DES            212D    AIO.DEV            212F    AIO.DIR            2132
AIO.DTA            212B    AIO.EOF            214B    AIO.EOM            214A
AIO.FLG            2123    AIO.GRT            2124    AIO.LGN            2129
AIO.LSI            212A    AIO.SPG            2126    AIO.TFP            214C
AIO.UNI            2131    AIO.VEC            2120    ALTCHR             2681 E
ALTDEV             22B1    ALTFLG             22B9    ASK                3C33
ASK0               3C4B    ASKX               3C48    AUTOER             4839
B.ARG              3ABC    B.ARGX             3AC4    B.B0               3A30
B.B1               3A36    B.B4               3A6C    B.B5               3A73
B.B6               3ACC    B.B9               3B06    B.BAT              3A29
B.BR               3A24    B.BYTE             3A06    B.CNT              3A28
B.DEV              3A86    B.END              0080 E  B.EXT              3A9E
B.GET              3B11    B.GET0             3B2B    B.INT0             0000
B.INT1             0008    B.INT2             0010    B.INT3             0018
B.INT4             0020    B.INT5             0028    B.INT6             0030
B.INT7             0038    B.NAM              3AC9    B.NEXT             3AF9
B.NMI              0066    B.NMIFL            0069    B.NSUB             3AEC
B.NX0              3B00 E  B.OPE1             3B7A    B.OPE2             3B94
B.OPE3             3B9E    B.OPEN             3B6C    B.R0               3B45
B.R1               3B4D    B.R2               3B65    B.READ             3B2D
B.SCALL            003B    B.SUB              3AD5    B.UNI              3A92
B.XXN              3AAD    B.XXX              3A0A E  BATBIT             256C
BATBLK             2295    BATBUF             0054    BATDEV             3BD3
BATGNS             0052    BATNAME            0040    BATOFF             25A1
BATPTR             0056    BATSEC             0051    BELL               0007 E
BIT                3CC4    BIT.ALL            3D18    BIT.CLR            3D0D
BIT.S              3D1A    BIT.X              3CDF    BITS               43E3
BITS1              43E8    BKSP               0008 E  BOOT               1F0C E
BOOT.P             0001 E  BS                 0008 E  BSX.COD            000A
BSX.ID             0000    BSX.PEA            0004    BSX.PSA            0002
BSX.SEA            0008    BSX.SSA            0006    BUFFWA             8000 E
BYE                39A2    BYE1               39A7    BYE2               39C0
BYE3               39CF    C.DEC              3CB5    C.INC              3CB2
C.STX              0002 E  C.SYN              0016 E  C.TOG              3CBD
C.Z                3CC0    C.ZERO             3CBF    CA                 2BE1
CAD.M              444C    CAD.Y              448F    CADHL              44AC E
CADL               443C    CADR               44AA    CAL                000B E
CB.CLI             0040 E  CB.MTL             0020 E  CB.SPK             0080 E
CB.SSI             0010 E  CB2.CLI            0002 E  CB2.ORG            0020 E
CB2.SID            0040 E  CB2.SSI            0001 E  CC.OFF             253D
CC.ON              2544    CCBAT              2A4F    CCBAT0             2A55
CCBAT1             2A5A    CCBAT2             2A8B    CCBJ               25DF
CCHIT              2A3E    CCT                23CA    CDB.H84            0001 E
CDB.H85            0000 E  CDEV               2BE8    CDT                242E
CDT1               2431    CDT2               2465    CDT3               246D
CDT4               2478    CDT5               247B    CDT6               24A6
CDT7               2502    CDTDN              2518    CDTDV              24EA
CDTX               2536    CHEA               2E64    CHEAL              0005 E
CHECK              2E49    CHKBAT             3BD9    CHKPIP             42C1
CKEQ               3F49    CLR                31A5    CLRCHR             2671 E
CLRSC              4670    CLRSCR             466D    CLRSCRN            4653
CLRXA              31C0    CLRXL              0005 E  CLS                2B65 E
CLSCR              465A    CN                 2BC9    CN.170M            000C E
CN.174M            0003 E  CN.ABO             0080 E  CN.BAU             0040 E
CN.MEM             0020 E  CN.PRI             0010 E  CND.H17            0000 E
CND.H47            0001 E  CND.NDI            0000 E  CO.FLG             0001 E
CONTIM             3145    CONTIM0            3151    CONTIM1            3166
CONTIM2            316D    CONTIM3            3194    CONTIM4            31A1
COPY               2BA7    COU1               3CA3    COUNT              3C84
CPCCOM             2C1E    CPDEHL             44FD    CR                 000D E
CRACK              26E5    CS.FLG             0080 E  CSL.CHR            0001 E
CSL.ECH            0080 E  CSL.RAW            0004 E  CSL.WRP            0002 E
CSLIBUF            003E    CTAB               3565    CTIM               3190
CTLA               0001 E  CTLB               0002 E  CTLC               0003 E
CTLD               0004 E  CTLE               0005 E  CTLO               000F E
CTLP               0010 E  CTLQ               0011 E  CTLR               0012 E
CTLS               0013 E  CTLX               0018 E  CTLZ               001A E
CTP.2SB            0008 E  CTP.BKM            0002 E  CTP.BKS            0080 E
CTP.FF             0040 E  CTP.HHS            0004 E  CTP.MLI            0020 E
CTP.MLO            0010 E  CTP.TAB            0001 E  CUNIT              2BEA
CURUNI             37C7    CUSTOM             0000 E  CVDD               3842 E
D.CON              2048    D.DLYHS            20A4    D.DLYMO            20A3
D.DRVTB            20A9    D.DVCTL            20A2    D.E.CHK            20B7
D.E.HCK            20B8    D.E.HSY            20B6    D.E.MDS            20B5
D.E.TRK            20BA    D.E.VOL            20B9    D.ERR              20B5
D.ERRL             20BB    D.ERTS             2056    D.HECNT            20B1
D.LPSA             204E    D.MAIA             204D    D.OECNT            20B4
D.OPR              20BB    D.OPW              20BD    D.RAM              20A0
D.RAML             001F E  D.SDPA             204F    D.SDPB             2050
D.SECNT            20B2    D.STSA             2051    D.STSB             2052
D.TRKPT            20A5    D.TS               20A1    D.TT               20A0
D.VEC              2058    D.VOLPT            20A7    D.WHDA             2053
D.WNHA             2054    D.WRITA            204A    D.WRITB            204B
D.WRITC            204C    D.WSCA             2055    D.XITA             2048
DAD1               4583    DAD1.              4584 E  DAD1X              4582
DAD2               458C    DAD3               458F    DADB               4595
DADC               45B9    DADCL              0009 E  DADCX              45C2
DADEV              22AB    DATE               302E    DATE2              3041
DATE3              304D    DBUF               44E9    DC.ABT             0007
DC.CLO             0006    DC.DSF             000E    DC.INT             000D
DC.LOD             0009    DC.MAX             000F    DC.MOU             0008
DC.OPR             0003    DC.OPU             0005    DC.OPW             0004
DC.RDY             000A    DC.REA             0000    DC.RER             0002
DC.SET             000B    DC.UNL             000C    DC.WRI             0001
DDF.BOL            0009 E  DDF.BOO            0000    DDF.LAB            0009
DDF.USR            000A    DEF2               37E9    DEF2.0             3801
DEF2.1             380D    DEF3               3811    DEF4               382B
DEF5               3835    DEF6               383E    DEFA               2283
DEFAL              0006 E  DEFAULT            37D1    DEL                007F E
DELA               2B84    DELAL              0005 E  DELETE             2B69
DEV.DDA            0004    DEV.DVG            000D    DEV.DVL            000B
DEV.FLG            0006    DEV.JMP            0003    DEV.MNU            0008
DEV.MUM            0007    DEV.NAM            0000    DEV.RES            0002
DEV.UNT            0009    DEVADD             3769 E  DEVELEN            000E E
DEVFRE             3742    DEVICE             3645    DEVLP              3665
DEVNA              3662    DEVNAM             36A5    DEVPTR             37C5
DEVUNI             36A7    DF.CLR             00FE E  DF.EMP             00FF E
DIF.ARC            0008 E  DIF.BAD            0004 E  DIF.CNT            0010 E
DIF.DL             0002 E  DIF.LOC            0040 E  DIF.SYS            0080 E
DIF.USR            0001 E  DIF.WP             0020 E  DIR                2BB4
DIR.ACD            0015    DIR.CRD            0013    DIR.CTH            000B
DIR.CTM            000C    DIR.EXT            0008    DIR.FGN            0010
DIR.FLG            000E    DIR.LGN            0011    DIR.LSI            0012
DIR.NAM            0000    DIR.NOA            000D    DIR.USR            000F
DIRA               2BC6    DIRAL              0003 E  DIRELEN            0017 E
DIRIDL             000B E  DIS.ENL            01FB    DIS.ENT            0000 E
DIS.LNK            01FE    DIS.SEC            01FC    DISA               2E44
DISAL              0005 E  DISPL              312C    DISPLA             30FD
DISPLA.            3114    DISTIM             3122    DM.MR              0000 E
DM.MW              0001 E  DM.RR              0002 E  DM.RW              0003 E
DMM                3292    DMM.Y              33F2    DMMVF              337E
DMMVFF             338E E  DMMVFK             338B E  DMMVG              33A3
DMMVGF             33B3 E  DMMVGK             33B0 E  DMMVH              33C6
DMMVHF             33D6 E  DMMVHK             33D3 E  DMOUNT             2C9D E
DN                 2CB7 E  DPDEV              22A9    DPRINT             3779
DPROM              22BC    DPROML             0010 E  DR.FX              0004 E
DR.IM              0001 E  DR.PR              0002 E  DR.SPL             00E0 E
DR.UNL             0008 E  DT.CH              0010 E  DT.CR              0002 E
DT.CW              0004 E  DT.DD              0001 E  DT.FX              0020 E
DT.P3              0040 E  DT.RN              0008 E  DT.UL              0080 E
DV.EL              0000 E  DV.NU              0001 E  EC.8KL             00C8 E
EC.CNA             0004    EC.CNR             0034    EC.CUI             0037
EC.DDA             0017    EC.DFM             0031    EC.DIF             000F
EC.DIW             001D    EC.DNI             0025    EC.DNL             002F
EC.DNP             0030    EC.DNR             0026    EC.DNS             0005
EC.DSC             0027    EC.EOF             0001    EC.EOM             0002
EC.FAO             0019    EC.FAP             0016    EC.FIX             002D
EC.FL              0018    EC.FNF             000C    EC.FNO             0009
EC.FNR             001C    EC.FOD             0023    EC.FUC             000B
EC.ICN             000E    EC.IDF             0032    EC.IDN             0006
EC.IFC             0010    EC.IFN             0007    EC.ILA             002E
EC.ILC             0003    EC.ILO             0020    EC.ILR             000A
EC.ILV             001F    EC.IOI             002A    EC.IS              001A
EC.ITF             00C0 E  EC.ITS             0033    EC.LAD             002C
EC.LBO             0036    EC.NCV             0028    EC.NEM             0011
EC.NOS             0029    EC.NPM             0024    EC.NRD             0008
EC.NTF             00C9 E  EC.NTM             0003 E  EC.NVM             0022
EC.OTL             002B    EC.RF              0012    EC.SDR             0035
EC.TAA             00C1 E  EC.TCA             00C5 E  EC.TIF             00C4 E
EC.TNA             00C2 E  EC.TNF             00C7 E  EC.TSN             00C6 E
EC.TUN             00C3 E  EC.UNA             001E    EC.UND             000D
EC.UUN             001B    EC.VPM             0021    EC.WF              0013
EC.WP              0015    EC.WPV             0014    ECHO               3BE2
ECHO.              3C13    ECHOFF             3C0E    ECHON              3C06
ECHOTT             3C02    ECHOX              3C17    ECOFLG             22A2
EDLINE             3F93 E  EL0                3FA2    EL1                3FB3
EL3                3FC8    EL4                4037    ELBS               415A E
ELBS0              4161    ELBS1              4175    ELBUFL             0065 E
ELC                403E E  ELC0               403E    ELC1               4041
ELC2               4046    ELC3               406F    ELCD               4138
ELCHR              41C3    ELCNT              4209    ELD                4079 E
ELD0               4079    ELD1               4089    ELD2               409B
ELDEL              417B E  ELDEL0             4182    ELDEL3             4192
ELFC               41B5 E  ELFC0              41C1    ELH                40A2 E
ELH0               40A5    ELI                40B6 E  ELI0               40B9
ELI1               40DA    ELI2               40E1    ELI3               40EE
ELI4               40FC    ELI5               4101    ELIBS              4107
ELIDEL             411A    ELK                4076 E  ELL                4129 E
ELNL               4198 E  ELNL0              41A1    ELPL               41FD
ELPL0              4200    ELPTR              420A    ELQ                413D E
ELRC               3FC4    ELS                413E E  ELSHL              41C9
ELSHL.             41CF    ELSHL1             41D0    ELSP               4141 E
ELSP0              4141    ELSP1              4148    ELSP2              4154
ELT2               41E9    ELT3               41F8    ELTRGT             41DC
ELX                40B0 E  END                3F8F    ENDTIM             312A
ENL                008A E  EOL                0080 E  ERROR              255A
ERROR1             255E    ESC                001B E  F.2MHZ             0000 E
F.4MHZ             0001 E  F.6MHZ             0002 E  F.8080             0000 E
F.8085             0040 E  F.CLK              0003 E  F.CPU              00C0 E
F.H19              0010 E  F.H8               0000 E  F.H89              0004 E
F.MACH             000C E  F.OCPU             00C0 E  F.OMACH            000C E
F.TERM             0030 E  F.TTY              0000 E  F.Z100             0008 E
F.Z80              0080 E  FALSE              0001 E  FB.CHA             0000
FB.FLG             0001    FB.FWA             0002    FB.LIM             0006
FB.LWA             0008    FB.NAM             000A    FB.NAML            0011 E
FB.PTR             0004    FBENL              001B E  FEC                420C
FEC1               420E    FF                 000C E  FLOADD             2F17
FNST               3F21    FST1               45EA    FST1A              45EC
FST2               45FF    FST2A              4608    FST2B              4621
FST3               4626    FST4               4637    FST4A              463C
FT.ABS             0000 E  FT.BAC             0003 E  FT.DD              0001 E
FT.OC              0010 E  FT.OR              0002 E  FT.OU              0008 E
FT.OW              0004 E  FT.PIC             0001 E  FT.REL             0002 E
GETDEV             2DBE    GOTO               3D1E    GOTO1              3D67
GOTO2              3D72    GOTOFB             3DCA    GOTOJ              3D46
GOTOL              3D36    GOTOX              3DA4    GOTUNT             370F E
GRPCNT             371D    GUN                2DCA    GUN1               2DCE
GUN2               2DE2    H17TBLS            0000 E  H19FLG             22BB
HELP               2ACF    HELPA              2ADF    HELPAL             0016 E
HLDSCR2            4686    HLDSCRN            467A    HOSBASE            0000 E
HOURS              30F5    I.ASK              0027 E  I.BIT              0028 E
I.BYE              001B E  I.CHK              0009 E  I.CLR              0022 E
I.CLS              0004 E  I.CN               0016 E  I.CONFL            0004 E
I.CONTY            0001 E  I.CONWI            0003 E  I.COP              001A E
I.COU              0029 E  I.CRC              0002 E  I.CSLMD            0000 E
I.CUSOR            0002 E  I.DAT              0014 E  I.DEF              0021 E
I.DEL              0005 E  I.DEV              0018 E  I.DIR              0015 E
I.DMM              0019 E  I.DMO              000D E  I.DN               000E E
I.ECH              002A E  I.END              002B E  I.ERR              0003 E
I.EXI              0004 E  I.FLO              001F E  I.GOT              002C E
I.HEL              0001 E  I.IF               002E E  I.IFB              0000 E
I.IFC              0001 E  I.JMP              002D E  I.LOA              001E E
I.LOG              0007 E  I.MD               0013 E  I.MM               0012 E
I.MN               000C E  I.MOU              000B E  I.NOT              0005 E
I.PAU              002F E  I.PCN              0017 E  I.PIP              0023 E
I.PLO              0006 E  I.PRM              0025 E  I.PRN              0002 E
I.PTH              0026 E  I.QM               0011 E  I.REM              0030 E
I.REN              000A E  I.RES              000F E  I.RN               0010 E
I.RUN              0000 E  I.SHF              0031 E  I.SI               0034 E
I.TIM              0008 E  I.TYP              0003 E  I.UNL              0020 E
I.VER              001C E  I.VERX             001D E  I.VFY              0024 E
I.WAIT             0032 E  I.XYZZY            0033 E  IF                 3DCB
IF0                3DD1    IFBIT              3E6A    IFCNT              3EA2
IFCRAK             3F32    IFCRC              3E8C    IFDATA             3ED7 E
IFEQ               3E0C    IFER               3EA8    IFER1              3EAB
IFER2              3EC8    IFER3              3ED3    IFEX               3E42
IFEX1              3E66    IFNDX              3DFE    IFNOT              3E31
IFPTR              3EDE E  IFTAB              3EEE E  IFXX               3EDA
IFXXL              3EE3    ILDEHL             4691    ILLCMD             259E
ILLCOM             2579    ILLSYN             258E    IMEML              4875 E
IOC.CGN            0008    IOC.CSI            0009    IOC.DDA            0002
IOC.DES            000E    IOC.DEV            0010    IOC.DIL            0011 E
IOC.DIR            0013    IOC.DRL            0008 E  IOC.DTA            000C
IOC.FLG            0004    IOC.GRT            0005    IOC.LGN            000A
IOC.LNK            0000    IOC.LSI            000B    IOC.SPG            0007
IOC.SQL            0003 E  IOC.UNI            0012    IOCCTD             0001 E
IOCELEN            002A E  IP.CON             00F2 E  IP.PAD             00F0 E
ISDEHL             46D3    JUMP               3D21    L.ORI              3024 E
LAB.AUX            004F E  LAB.AXL            0001 E  LAB.DAT            0000 E
LAB.DIS            0003    LAB.GRT            0005    LAB.IND            0001
LAB.LAB            0011    LAB.LBL            003C E  LAB.LVN            0050
LAB.NOD            0002 E  LAB.PSS            000E    LAB.RGT            000A
LAB.SER            0000    LAB.SIZ            000C    LAB.SPG            0007
LAB.SPT            004F    LAB.SYS            0001 E  LAB.VER            0009
LAB.VFL            0010    LAB.VLT            0008    LAB.VPL            0005 E
LAB.VPR            000C E  LABEL              80E4 E  LAD                2FEA
LAD.               2FEF    LAD..              2FF5    LAD1               2FFB
LAD2               302A    LF                 000A E  LINE               807F E
LISTA              2B29    LISTAL             0008 E  LOADD              2F14
LOG..              328A    LOGON              328D    LSTADR             23C8 E
LSTDEV             22B5    LSTJMP             23C7    M$SOB              4753
M.CSL              0002    M.FOX              00C3 E  M.PAM8             0011 E
M.SUNI             0004    M.SYDD             0005    M.SYSM             0000
M2MHZ              3612    M4MHZ              3618    M6MHZ              361E
M8080              35D0    M8085              35CB    MAXUNI             37C8
MDEVIC             2DE6    MDEVL              0004 E  MDR0               2CD0
MDRN               2CBE    MDRSC              2CD6 E  MDRX               2CA4
MEML               47E6 E  MH19               35E8    MH8                35F9
MH89               35FC    MI.LXIH            0021 E  MINUTES            30F6
MN                 2CB2 E  MOUNT              2C98 E  MSG1               3585
MSG1A              359D    MSG1B              35A7    MSG1C              35B4
MSG1D              35B9    MSG1V              3594    MSG2               35D5
MSG3               35EC    MSG4               3605    MSG5               3624
MSG6               3632    MTAB               3575    MTTY               35DF
MUNIT              2DE8    MZ100              3600    MZ80               35C7
NEWTIM             30F5 E  NIBL               47B5    NL                 000A E
NO                 0000 E  NOLST              2C5A    NOLSTA             2C74
NUL                0000 E  NUL2               0000 E  NULFLG             22BA
NULL               0080 E  NXTUNI             37A7    ODDPIP             42AC
OKK                34B7    OP.CTL             00F0 E  OP.DIG             00F0 E
OP.SEG             00F1 E  OP2.CTL            00F2 E  OURDEV             2D2A E
OURDVD             24CF E  PARSE              268F    PARSE1             26C0
PARSE2             26E1    PAT1               3970    PAT2               398C
PAT3               3997    PATCH              2366    PATCHL             0040 E
PATCLR             399C    PATH               395C    PATH..             285C
PATH.0             28AB    PATH.1             28BE    PATH.X             2887
PATSHOW            397F    PAUSE              3C30    PAUSE0             3C5B
PAUSE1             3C75    PAUSEX             3C7A    PBCL               283E
PCA                2C4F    PCAL               000B E  PCDEV              2C56
PCF                2C3C    PCL                4215    PCL1               422A
PCL2               4233    PCLA               4237 E  PCLN               2C3A
PCN                2BEC    PCT                2C3E    PCUNIT             2C58
PIC.COD            0006    PIC.ID             0000    PIC.LEN            0002
PIC.PTR            0004    PICLD              31DF    PICLOA             31C5
PICLOA0            31F6    PICLOA1            320A    PICLOA3            3220
PIP                423A    PIP.               425B    PIP.WS             4800 E
PIP1               4251    PIP2               4256    PIP3               42D5
PIPA               4269    PIPCHK             4292    PIPERR             4293
PIPJMP             42A1    PIPMEM             4291    PIPX               4239
PR.B               43B5    PR.C               43B2    PR.CR              43A9
PR.CS              3064    PR.D               4362    PR.E               43A3
PR.FF              43AC    PR.H               43BA    PR.N               437F
PR.NL              43A6    PR.P               43C5    PR.P.              43C3
PR.PL              43C8    PR.S               43AF    PR.T               436A
PR.TK              43D3    PR.U               4387    PR.V               4375
PR.X               438D    PR.XXU             4398    PRIDEV             22AD
PRINT              2AF5    PRM1               392D    PRM2               394B
PRMCLR             3956    PRMSHOW            393C    PROCMGR            0001 E
PROLOG             483D    PROM$$             42F0    PROM1              266D
PROM2              2680    PROML              42F8    PROMPT             3919
PROMPT$            42F8 E  PROMT              4392    PROMX              43DC
PROMY              43DE    PROMZ              264A    PROMZL             265A
PROMZZ             2662    PRSCL              254B    PTHPTR             28C3
QUOTE              0027 E  REM                3C2E    RENA               2BA4
RENAL              0003 E  RENAME             2B89    REPCNT             3BD8
RES.               36D1    RESA               2E3F    RESAL              0005 E
RESET              2CA2 E  RMEML              A0E4 E  RN                 2CBC E
RUBOUT             007F E  RUN                2AAE    RUNA               228F
S.BATCH            0008 E  S.BAUD             20E4    S.BDA              2150
S.BITS             0062    S.BOOTF            211C    S.BREAK            0020 E
S.CAADR            20DB    S.CACC             2106    S.CCTAB            20DD
S.CDB              20E3    S.CFWA             20EA    S.CLKTR            20CD
S.CMD              2609    S.CMD.             25FB    S.CODE             2107
S.CONFL            20DA    S.CONTY            20D7    S.CONWI            20D9
S.COUNT            0060    S.CSLMD            20D6    S.CUSOR            20D8
S.CVEC             0070    S.DATC             20C8    S.DATE             20BF
S.DDDTA            20F6    S.DDGRP            20F4    S.DDLDA            20F0
S.DDLEN            20F2    S.DDOPC            20F8    S.DFBLK            006A
S.DFWA             20EC    S.DIREA            210E    S.DLINK            20E6
S.DLY              002B    S.ECHO             0004 E  S.EDLIN            005E
S.EXITA            2040    S.EXITC            0010 E  S.FASER            210B
S.FCI              2111    S.FLAG             007F    S.FMASK            0005
S.GUP              2117    S.HIMEM            20CE    S.INIT             0080 E
S.INT              20E3    S.JUMPS            2108    S.LABEL            0003
S.LWA              0006    S.MOUNT            211A    S.OSI              2156
S.OSO              2157    S.OSZ              2158    S.PATH             005A
S.PRMT             005C    S.REV              000B    S.RFWA             20EE
S.SCI              2114    S.SCR              2151    S.SDD              2108
S.SHIFT            0061    S.SOVR             2176    S.SYSCM            0001 E
S.SYSM             20D0    S.TABUF            0040 E  S.TFWA             20E8
S.TIME             20CA    S.USRM             20D2    S.VAL              20BF
S.VFLG             0002 E  SAYTYPE            355B    SCGONE             42B2
SECONDS            30F7    SETDEV             388D E  SETDV0             38C5
SETTIM             30CA    SHIFT              3C7E    SHO.0              3797
SHO.1              379F    SHO.F              37C9    SHOCAP             3784 E
SHODEV             367C E  SI                 3400    SI.C               34F5
SI.C.              3517    SI.D               354B    SI.D.              3551
SI.M               34EB    SI.T0              3448    SI.T1              344E
SI0                4802    SI1                4811    SI2                4820
SKPD               288A    SKPD1              288B    SSM                23D1 E
SSM1               23DB    SSM2               240A    SSM3               2428
SSM4               242A    STAB               357D    STACK              2280 E
STACKL             010A E  STLOOP             30CF    STRCNT             3D93 E
STRCNT1            3DBF E  SUBBUF             0058    SUBPTR             3B0F
SY0CHK             2DEE E  SY0CK              2E0C    SY0CK0             2E1A
SY0CK1             2E25    SY0CK2             2E36    SYDD               2058 E
SYSBLK             8000 E  SYSC0              268D    SYSC1              26E8
SYSC12             27E5    SYSC2              26FF    SYSC20             2829
SYSC3              270E    SYSC5              2796    SYSC5.             279F
SYSC6              27AC    SYSC9              27D0    SYSCA              2728
SYSCALL            00FF E  SYSCB              2289    SYSCC              28C5 E
SYSCMD             0000 E  SYSCMD.            25A4 E  SYSCX              2705 E
SYSINIT            47E6 E  SYSX1              23BD    SYSX2              23BF
SYSXEC             2304    SYSXIT             22CD E  SYSXIT.            22DA E
SYSXIT0            2326    SYSXIT1            23A6 E  SYSXITA            23C6
SYSXITC            2322    SYSXITH            22ED    TAB                0009 E
TAS.DEA            0002    TAS.ID             0000    TAS.INQ            0001
TAS.MAX            0005    TAS.REA            0003    TAS.RIS            0004
TASKID             00CF E  TASKID.            00D7 E  TASMAX             0010 E
TIME               3078    TIMSYN             30F8    TOGLOG             326D
TRUE               0000 E  TSB.END            0010    TSB.ID             0009
TSB.LEN            0014 E  TSB.NAM            0000    TSB.PRC            0012
TSB.STA            000D    TSB.STR            000E    TSB.VER            0008
TSKBLK             229B    TSKBUF             80E4 E  TSKSIZ             0020 E
TSS.ACT            0001 E  TSS.DEA            0000 E  TSS.MEM            0008 E
TSS.TCA            0080 E  TSS.UFP            0002 E  TT.CCM             2AA7
TT.CE              2AA0    TTAB               356D    TYPE               2B31
TYPEA              2B5D    TYPEAL             0004 E  TYPEB              2B61
TYPEBL             0004 E  UDDPAD             47A3 E  UDDX1              4780
UDDX1.5            479A    UDDX2              479C    UDDX3              479D
ULTRA              22A8    UNIT0              3889    UNITS              3691 E
UNITX              387D    UNKNOWN            363D    UNL.OK             2F56
UNL0               2FB1    UNL1               2FE2    UNLALL             2FAE
UNLDN              2F98    UNLOAD             2F3B    UNLPND             2F94
UNT$LP             3700    UNT.DIS            0006    UNT.FLG            0000
UNT.GRT            0002    UNT.GTS            0004    UNT.SIZ            0008 E
UNT.SPG            0001    UO.CLK             0001 E  UO.DDU             0002 E
UO.HLT             0080 E  UO.NFR             0040 E  UOD                47D6
UOW1               47CE    USER               0001 E  USERFWA            2280 E
VERB               8007 E  VERB.              8006 E  VERIFY             38C9
VERS               0030 E  VERSN              2E69    VERSN0             2EBA
VERSN1             2EED    VERSN2             2EFD    VERSNX             2E6D
VERSV0             2E94    VERSV1             2EA2    VERSV2             2EB1
VFL.80T            0002 E  VFL.DTD            0002 E  VFL.FIX            0004 E
VFL.NSD            0001 E  VFY..              38F2    VFYFLG             22A1
VFYOFF             3912    VFYON              38ED    VFYX               38F6
VFYXON             390C    WAIT               3F5E    WAIT0              3F7B
WAIT1              3F80    WARM               2280    XCHGBC             47E2
XDMNT              2D50 E  XMD1               2D5E    XMD2               2D61
XMD3               2D7F    XMD3.              2D9D    XMD4               2DAA
XMD5               2DAD E  XMDERR             2DB2    XMM1               2CF1
XMM2               2CF4    XMM3               2D20    XMM3A              2D3F E
XMM4               2D48    XMM5               2D4B E  XMNT               2CDE E
XQMNT              2CDB E  XYZZY              39FC    XYZZYF             22A4
YES                0001 E  Z80                0001 E  ZROFLG             22A3
