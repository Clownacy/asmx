0000                    	TITLE	'HDOS, Version 3.0'
                        ***	SYSTEM I/O HANDLER.
                        *
                        *	JG LETWIN, 10/77
                        *
                        *	COPYRIGHT HEATH COMPANY.
                        *
                        *	G. Chandler,	78/10	Maintenence Release
                        *			79/04\
                        *			79/05 > Release  #50.04.00
                        *			79/06/
                        *			79/10	Release  #50.05.00
                        *			80	Release  #50.06.00
                        *				 /2.0a/ = /80.09.gc/
                        *				 /2.0b/	= /80.10.gc/
                        *				 /2.0c/ = /80.11.gc/
                        *			85-86	Release  #50.07.00
                        *				 /3.0a/ = /86.08.bp/
                        *
                        *			86	Released into Public Domain
                        *				 by Heath Company,
                        *				 August 16, 1986.

                        *	Boolean constants

      = 0000            FALSE	equ	0
      = 0001            TRUE	equ	!FALSE

      = 0000            REV	EQU	0			; revision level

                        *	Conditional Assembly

      = 0000            DEBUG	EQU	FALSE
0000                    	LON	LCH
0000                    	SPACE	4,10
                        ***	THE SYSTEM I/O HANDLER HANDLES SYSTEM REQUESTS FOR
                        *	READS AND WRITES.
                        *
                        *	IF A MASS STORAGE DEVICE, THIS DOES THE CORRECT STORAGE
                        *	MANAGEMENT. IF A SERIAL DEVICE, THE COMMAND IS PASSED
                        *	ONTO THE DEVICE DRIVER.
0000                    	STL	'Symbol Definitions'
0000                    	EJECT
                        **	MACHINE INSTRUCTIONS

      = 00C3            MI.JMP	EQU	303Q
      = 0011            MI.LXID equ	021Q

                        **	SYSTEM SYMBOLS

0000                    	XTEXT	ASCII
0000                    	SPACE	3,10
                        **	ASCII CHARACTER EQUIVALENCES.

      = 0000            NUL	EQU	000Q			; null
      = 0007            BELL	EQU	007Q			; bell
      = 0008            BKSP	EQU	010Q			; backspace
      = 0008            BS	EQU	BKSP
      = 0009            TAB	EQU	011Q			; horizontal tab
      = 000A            LF	EQU	012Q			; line feed
      = 000A            NL	EQU	012Q			; new line (HDOS)
      = 000C            FF	EQU	014Q			; form feed
      = 000D            CR	EQU	015Q			; carriage return
      = 001B            ESC	EQU	033Q			; escape
      = 007F            DEL	EQU	177Q			; delete

                        *	Specials

      = 0080            EOL	EQU	200Q			; end of line flag
      = 0080            NULL	EQU	200Q			; pad character
      = 0000            NUL2	EQU	0			; ditto
      = 007F            RUBOUT	EQU	DEL			; rubout/delete
      = 0016            C.SYN	EQU	026Q			; SYNC
      = 0002            C.STX	EQU	002Q			; STX
      = 0027            QUOTE	EQU	047Q			; quote character (")
      = 008A            ENL	EQU	NL+EOL			; NL + end-of-line flag

                        *	Control keys

      = 0001            CTLA	EQU	'A'-'@' 		; CTRL/A
      = 0002            CTLB	EQU	'B'-'@' 		; CTRL/B
      = 0003            CTLC	EQU	'C'-'@' 		; CTRL/C
      = 0004            CTLD	EQU	'D'-'@' 		; CTRL/D
      = 0005            CTLE	EQU	'E'-'@' 		; CTRL/E
      = 000F            CTLO	EQU	'O'-'@' 		; CTRL/O
      = 0010            CTLP	EQU	'P'-'@' 		; CTRL/P
      = 0011            CTLQ	EQU	'Q'-'@' 		; CTRL/Q
      = 0012            CTLR	EQU	'R'-'@' 		; CTRL/R
      = 0013            CTLS	EQU	'S'-'@' 		; CTRL/S
      = 0018            CTLX	EQU	'X'-'@' 		; CTRL/X
      = 001A            CTLZ	EQU	'Z'-'@' 		; CTRL/Z
0000                    	XTEXT	MTR
0000                    MTR	SPACE	4,10
                        **	MTR - PAM/8 EQUIVALENCES.
                        *
                        *	THIS DECK CONTAINS SYMBOLIC DEFINITIONS USED TO
                        *	MAKE USE OF THE PAM/8 CODE.
0000                    	SPACE	3,10
                        **	IO PORTS

      = 00F0            IP.PAD	EQU	360Q			; PAD INPUT PORT
      = 00F0            OP.CTL	EQU	360Q			; CONTROL OUTPUT PORT
      = 00F0            OP.DIG	EQU	360Q			; DIGIT SELECT OUTPUT PORT
      = 00F1            OP.SEG	EQU	361Q			; SEGMENT SELECT OUTPUT PORT
      = 00F2            IP.CON	EQU	362Q			; H-88/H-89/HA-8-8 Configuration
      = 00F2            OP2.CTL EQU	362Q			; H-88/H-89/HA-8-8 Control Port
0000                    	SPACE	3,10
                        **	MONITOR IDENTIFICATION FLAGS
                        *
                        *	THESE BYTES IDENTIFY THE ROM MONITOR.
                        *	THEY ARE THE VARIOUS VALUES OF LOCATION .IDENT

      = 0011            M.PAM8	EQU	021Q			; 'LXI' INSTRUCTION AT 0 IN PAM-8
      = 00C3            M.FOX	EQU	303Q			; 'JMP' INSTRUCTION AT 0 IN FOX ROM
0000                    	SPACE	4,10
                        **	Configuration Flags
                        *
                        *	These bits are read in IP.CON.
                        *

      = 0003            CN.174M EQU	00000011B		; Port 174Q Device-Type Mask
      = 000C            CN.170M EQU	00001100B		; Port 170Q Device-Type Mask
      = 0010            CN.PRI	EQU	00010000B		; Primary/Secondary:  1=>primary == 170Q
      = 0020            CN.MEM	EQU	00100000B		; Memory Test/Normal Switch:  0=>Test; 1=>Normal
      = 0040            CN.BAU	EQU	01000000B		; Baud Rate:  0=>9600; 1=>19,200
      = 0080            CN.ABO	EQU	10000000B		; Auto-Boot:  1=>Auto-Boot

      = 0000            CND.H17 EQU	00B			; H-17 Disk, Valid only in CN.174M
      = 0000            CND.NDI EQU	00B			; No Device Installed
      = 0001            CND.H47 EQU	01B			; H-47 Disk
0000                    	SPACE	4,10
                        **	ROUTINE ENTRY POINTS.
                        *

      = 002B            .DLY	EQU	000053A 		; DELAY

                        *	All following entry points are unavailable under HDOS 3.0

                        *.IDENT EQU	000000A 		; IDENTIFICATION LOCATION
                        *.LOAD	EQU	001267A 		; TAPE LOAD
                        *.DUMP	EQU	001374A 		; TAPE DUMP
                        *.ALARM	EQU	002136A 		; ALARM ROUTINE
                        *.HORN	EQU	002140A 		; HORN
                        *.CTC	EQU	002172A 		; CHECK TAPE CHECKSUM
                        *.TPERR	EQU	002205A 		; TAPE ERROR ROUTINE
                        *.PCHL	EQU	002264A 		; PCHL INSTRUCTION
                        *.SRS	EQU	002265A 		; SCAN RECORD START
                        *.RNP	EQU	002325A 		; READ NEXT PAIR
                        *.RNB	EQU	002331A 		; READ NEXT BYTE
                        *.CRC	EQU	002347A 		; CRC-16 CALCULATOR
                        *.WNP	EQU	003017A 		; WRITE NEXT PAIR
                        *.WNB	EQU	003024A 		; WRITE NEXT BYTE
                        *.DOD	EQU	003122A 		; DECODE FOR OCTAL DISPLAY
                        *.RCK	EQU	003260A 		; READ CONSOLE KEYSET
                        *.DODA	EQU	003356A 		; SEGMENT CODE TABLE
0000                    	XTEXT	MTRRAM
0000                    MTRRAM	SPACE	4,10
                        **	MTR - PAM/8 EQUIVALENCES.
                        *
                        *	THIS DECK CONTAINS SYMBOLIC DEFINITIONS USED TO
                        *	MAKE USE OF THE PAM-8 CONTROL BYTES.
0000                    	SPACE	3,10
                        **	FRONT PANEL CONTROL BITS.
                        *
                        *	CB.*  set in OP.CTL
                        *	CB2.* set in OP2.CTL
                        *

      = 0010            CB.SSI	EQU	00010000B		; SINGLE STEP INTERRUPT
      = 0020            CB.MTL	EQU	00100000B		; MONITOR LIGHT
      = 0040            CB.CLI	EQU	01000000B		; CLOCK INTERRUPT ENABLE
      = 0080            CB.SPK	EQU	10000000B		; SPEAKER ENABLE

      = 0001            CB2.SSI EQU	00000001B		; Single Step Interrupt
      = 0002            CB2.CLI EQU	00000010B		; Clock Interrupt Enable
      = 0020            CB2.ORG EQU	00100000B		; ORG 0 Select
      = 0040            CB2.SID EQU	01000000B		; Side 1 Select
0000                    	SPACE	3,10
                        **	Secondary Control Bits
                        *

                        **	MONITOR MODE FLAGS.

      = 0000            DM.MR	EQU	0			; MEMORY READ
      = 0001            DM.MW	EQU	1			; MEMORY WRITE
      = 0002            DM.RR	EQU	2			; REGISTER READ
      = 0003            DM.RW	EQU	3			; REGISTER WRITE
0000                    	SPACE	3,10
                        **	USER OPTION BITS.
                        *
                        *	THESE BITS ARE SET IN CELL .MFLAG.

      = 0080            UO.HLT	EQU	10000000B		; DISABLE HALT PROCESSING
      = 0040            UO.NFR	EQU	CB.CLI			; NO REFRESH OF FRONT PANEL
      = 0002            UO.DDU	EQU	00000010B		; DISABLE DISPLAY UPDATE
      = 0001            UO.CLK	EQU	00000001B		; ALLOW PRIVATE INTERRUPT PROCESSING
0000                    	SPACE	3,10
                        **	RAM CELLS USED BY H8MTR.
                        *

      = 2000            .START	EQU	040000A 		; START DUMP ADDRESS
      = 2002            .IOWRK	EQU	040002A 		; IN OR OUT INSTRUCTION
      = 2005            .REGI	EQU	040005A 		; DISPLAYED REGISTER INDEX
      = 2006            .DSPROT EQU	040006A 		; PERIOD FLAG BYTE
      = 2007            .DSPMOD EQU	040007A 		; DISPLAY MODE
      = 2008            .MFLAG	EQU	040010A 		; USER OPTION BYTE
      = 2009            .CTLFLG EQU	040011A 		; PANEL CONTROL BYTE
      = 200B            .ALEDS	EQU	040013A 		; ABUSS LEDS
      = 2011            .DLEDS	EQU	040021A 		; DBUSS LEDS
      = 2014            .ABUSS	EQU	040024A 		; ABUSS REGISTER
      = 2017            .CRCSUM EQU	040027A 		; CRCSUM WORD
      = 2019            .TPERRX EQU	040031A 		; TAPE ERROR EXIT VECTOR
      = 201B            .TICCNT EQU	040033A 		; CLOCK TICK COUNTER
      = 201D            .REGPTR EQU	040035A 		; REGISTER POINTER
      = 201F            .UIVEC	EQU	040037A 		; USER INTERRUPT VECTORS
      = 2034            .NMIRET EQU	040064A 		; H88/H89 NMI Return Address
      = 2036            .CTL2FL EQU	040066A 		; OP2.CTL Control Byte
0000                    	XTEXT	HDSROM
0000                    HSDROM	SPACE	3,10
                        **	HDOS H17 ROM ENTRY POINTS.

      = 19BD            S.READ	EQU	031275A 		; Read from system disk
      = 19D8            S.WRITE EQU	031330A 		; Write to system disk
      = 19E4            ERR.FNO EQU	031344A 		; Error: File not open
      = 19E8            ERR.ILR EQU	031350A 		; Error: Illegal request
      = 19EC            CFF	EQU	031354A 		; Chain free block to file
      = 1A02            DCA	EQU	032002A 		; Determine contiguous area
      = 1A5B            FFB	EQU	032133A 		; Find free block
      = 1A85            FFL	EQU	032205A 		; Follow forward link
                        *LDO	EQU	033012A 		; Load overlay code
      = 1B65            PDI	EQU	033145A 		; Prepare for device I/O
      = 1B7D            REL.	EQU	033175A 		; Relocate code
      = 1B7F            REL	EQU	033177A 		; ditto
      = 1B9B            TFE	EQU	033233A 		; Test for end-of-file
                        *RUC	EQU	033257A 		; Restore user code

      = 1F5A            BOOTA	EQU	037132A 		; Boot Vectors
      = 0058            BOOTAL	EQU	000130A 		; Length of boot vectors

      = 1C19            CLOCK	EQU	034031A 		; Clock vector
0000                    	XTEXT	FILDEF
0000                    	SPACE	4,10
                        **	FILDEF - FILE TYPE DEFINITIONS.
                        *
                        *	DB	377Q,FT.XXX

      = 0000            FT.ABS	EQU	0			; ABSOLUTE BINARY
      = 0001            FT.PIC	EQU	1			; POSITION INDEPENDANT CODE
      = 0002            FT.REL	EQU	2			; RELOCATABLE CODE
      = 0003            FT.BAC	EQU	3			; COMPILED BASIC CODE
0000                    	XTEXT	HOSDEF
0000                    	SPACE	3,10
                        **	HOSDEF - Define HOS Parameters.
                        *

      = 0030            VERS	equ	3*16+0			; VERSION 3.0			/3.0a/

      = 00FF            SYSCALL equ	377Q			; SYSCALL INSTRUCTION

0000                    	org	0

                        *	Resident Functions

0000   (0001)           .EXIT	ds	1			; EXIT (MUST BE FIRST)
0001   (0001)           .SCIN	ds	1			; SCIN
0002   (0001)           .SCOUT	ds	1			; SCOUT
0003   (0001)           .PRINT	ds	1			; PRINT
0004   (0001)           .READ	ds	1			; READ
0005   (0001)           .WRITE	ds	1			; WRITE
0006   (0001)           .CONSL	ds	1			; SET/CLEAR CONSOLE OPTIONS
0007   (0001)           .CLRCO	ds	1			; CLEAR CONSOLE BUFFER
0008   (0001)           .LOADO	ds	1			; LOAD AN OVERLAY (obsolete)	/3.0a/
0009   (0001)           .VERS	ds	1			; RETURN HDOS VERSION NUMBER
000A   (0001)           .GDA	ds	1			; Get Device Driver Address	/3.0a/
000B   (0001)           .CRC16	ds	1			; CRC a block of memory 	/3.0a/
000C   (0001)           .SYSRES ds	1			; PRECEDING FUNCTIONS ARE RESIDENT


                        *	*HDOSOVL0.SYS*  FUNCTIONS

0020                    	org	40Q

0020   (0001)           .LINK	ds	1			; LINK	(MUST BE FIRST)
0021   (0001)           .CTLC	ds	1			; CTL-C
0022   (0001)           .OPENR	ds	1			; OPENR
0023   (0001)           .OPENW	ds	1			; OPENW
0024   (0001)           .OPENU	ds	1			; OPENU
0025   (0001)           .OPENC	ds	1			; OPENC
0026   (0001)           .CLOSE	ds	1			; CLOSE
0027   (0001)           .POSIT	ds	1			; POSITION
0028   (0001)           .DELET	ds	1			; DELETE
      = 0028            .DELETE equ	.DELET
0029   (0001)           .RENAM	ds	1			; RENAME
      = 0029            .RENAME equ	.RENAM
002A   (0001)           .SETTP	ds	1			; SETTOP
      = 002A            .SETTOP equ	.SETTP
002B   (0001)           .DECODE ds	1			; NAME DECODE
002C   (0001)           .NAME	ds	1			; GET FILE NAME FROM CHANNEL
002D   (0001)           .CLEAR	ds	1			; CLEAR CHAN
002E   (0001)           .CLEARA ds	1			; CLEAR ALL CHANS
002F   (0001)           .ERROR	ds	1			; LOOKUP ERROR
0030   (0001)           .CHFLG	ds	1			; CHANGE FLAGS
0031   (0001)           .DISMT	ds	1			; FLAG SYSTEM DISK DISMOUNTED
0032   (0001)           .LOADD	ds	1			; LOAD DEVICE DRIVER

                        *	*HDOSOVL1.SYS*  FUNCTIONS

0080                    	org	200Q

0080   (0001)           .MOUNT	ds	1			; MOUNT  (MUST BE FIRST)
0081   (0001)           .DMOUN	ds	1			; DISMOUNT
      = 0081            .DMOUNT equ	.DMOUN
0082   (0001)           .MONMS	ds	1			; MOUNT/NO MESSAGE
0083   (0001)           .DMNMS	ds	1			; DISMOUNT/NO MESSAGE
0084   (0001)           .RESET	ds	1			; RESET = DISMOUNT/MOUNT OF UNIT
0085   (0001)           .RESNMS ds	1			; RESET/NO (OR USER) MESSAGE
0086   (0001)           .DAD	ds	1			; Dismount All Disks
0087                    	XTEXT	DEVDEF
0087                    	SPACE	4,10
                        ***	DEVICE TABLE ENTRYS.

0000                    	ORG	0

0000   (0002)           DEV.NAM DS	2			; DEVICE NAME
      = 0000            DV.EL	EQU	00000000B		; END OF DEVICE LIST FLAG
      = 0001            DV.NU	EQU	00000001B		; DEVICE ENTRY NOT IN USE

0002   (0001)           DEV.RES DS	1			; DRIVER RESIDENSE CODE
      = 0001            DR.IM	EQU	00000001B		; DRIVER IN MEMORY
      = 0002            DR.PR	EQU	00000010B		; DRIVER PERMANENTLY RESIDENT
      = 0004            DR.FX	equ	00000100b		; Driver FIXED in memory	/3.0a/
      = 0008            DR.UNL	equ	00001000b		; Driver unload pending 	/3.0a/
                        *	equ	00010000b		; Reserved			/3.0a/
      = 00E0            DR.SPL	equ	11100000b		; SET preamble size mask	/3.0a/

0003   (0001)           DEV.JMP DS	1			; JMP TO PROCESSOR
0004   (0002)           DEV.DDA DS	2			; DRIVER ADDRESS
0006   (0001)           DEV.FLG DS	1			; FLAG BYTE
      = 0001            DT.DD	EQU	00000001B		; DIRECTORY DEVICE
      = 0002            DT.CR	EQU	00000010B		; CAPABLE OF READ OPERATION
      = 0004            DT.CW	EQU	00000100B		; CAPABLE OF WRITE OPERATION
      = 0008            DT.RN	EQU	00001000B		; Capable of random access
      = 0010            DT.CH	EQU	00010000B		; Capable of Character mode
      = 0020            DT.FX	EQU	00100000B		; Fixed Media			/3.0a/
      = 0040            DT.P3	EQU	01000000B		; pre-3.0 media 		/3.0a/
      = 0080            DT.UL	EQU	10000000B		; requires unload notification	/3.0a/

0007   (0001)           DEV.MUM DS	1			; MOUNTED UNIT MASK
0008   (0001)           DEV.MNU DS	1			; MAXIMUM NUMBER OF UNITS
0009   (0002)           DEV.UNT DS	2			; ADDRESS OF UNIT SPECIFIC DATA TABLE

000B   (0002)           DEV.DVL DS	2			; DRIVER BYTE LENGTH
000D   (0001)           DEV.DVG DS	1			; DRIVER ROUTINE GROUP ADDRESS

      = 000E            DEVELEN EQU	*			; DEVICE TABLE ENTRY LENGTH
000E                    UNT.TAB	SPACE	4,10
                        **	UNIT SPECIFIC DEVICE DATA TABLE ENTRIES

0000                    	ORG	0

0000   (0001)           UNT.FLG DS	1			; UNIT SPECIFIC  *DEV.FLG*
0001   (0001)           UNT.SPG DS	1			; Sectors Per Group
0002   (0002)           UNT.GRT DS	2			; ADDRESS OF GRT (IF DT.DD)
0004   (0002)           UNT.GTS DS	2			; GRT SECTOR NUMBER
0006   (0002)           UNT.DIS DS	2			; DIRECTORY FIRST SECTOR NUMBER

      = 0008            UNT.SIZ EQU	*			; SIZE OF UNIT SPECIFIC DATA ENTRY
0008                    	XTEXT	DIRDEF
0008                    	SPACE	3,10
                        **	DIRECTORY ENTRY FORMAT.

0000                    	ORG	0

      = 00FF            DF.EMP	EQU	377Q			; ENTRY EMPTY
      = 00FE            DF.CLR	EQU	376Q			; ENTRY EMPTY, REMAINDER ALSO CLEAR

0000   (0008)           DIR.NAM DS	8			; NAME
0008   (0003)           DIR.EXT DS	3			; EXTENSION
      = 000B            DIRIDL	equ	*			; file identification length	/3.0a/

000B   (0001)           DIR.CTH DS	1			; creation time (BCD hours)	/3.0a/
000C   (0001)           DIR.CTM DS	1			; creation date (BCD minutes)	/3.0a/

000D   (0001)           DIR.NOA DS	1			; number of accesses		/3.0a/
000E   (0001)           DIR.FLG DS	1			; FLAGS
000F   (0001)           DIR.USR DS	1			; user area mask		/3.0a/
0010   (0001)           DIR.FGN DS	1			; FIRST GROUP NUMBER
0011   (0001)           DIR.LGN DS	1			; LAST GROUP NUMBER
0012   (0001)           DIR.LSI DS	1			; LAST SECTOR INDEX (IN LAST GROUP)
0013   (0002)           DIR.CRD DS	2			; CREATION DATE
0015   (0002)           DIR.ACD DS	2			; last access date		/3.0a/

      = 0017            DIRELEN EQU	*			; DIRECTORY ENTRY LENGTH
0017                    	XTEXT	DISDEF
0017                    DISDEF	SPACE	3,10
                        **	DIRECTORY BLOCK FORMAT.

0000                    	ORG	0

      = 0000            DIS.ENT EQU	*			; FIRST ENTRY ADDRESS

0000   (01FA)           	DS	22*DIRELEN		; 22 DIRECTORY ENTRYS PER BLOCK
01FA   (0001)           	DS	1			; 0 BYTE = END OF ENTRYS IN THIS BLOCK

01FB                    	ORG	512-5			; AT END OF BLOCK

01FB   (0001)           DIS.ENL DS	1			; LENGTH OF EACH ENTRY (=DIRELEN)
01FC   (0002)           DIS.SEC DS	2			; BLOCK # OF THIS BLOCK,
01FE   (0002)           DIS.LNK DS	2			; BLOCK # OF NEXT BLOCK, =0 IF LAST
0200                    	XTEXT	IOCDEF
0200                    IOCDEF	SPACE	3,10
                        **	I/O CHANNEL DEFINITIONS.

0000                    	ORG	0

0000   (0002)           IOC.LNK DS	2			; ADDRESS OF NEXT CHANNEL, =0 IF LAST
0002   (0002)           IOC.DDA DS	2			; THREAD JUMP TO DEVICE DRIVER (VIA DEV TABLE)

0004   (0001)           IOC.FLG DS	1			; FILE TYPE FLAGS
      = 0001            FT.DD	EQU	00000001B		;  =1 IF DIRECTORY DEVICE
      = 0002            FT.OR	EQU	00000010B		;  =1 IF OPEN FOR READ
      = 0004            FT.OW	EQU	00000100B		;  =1 IF OPEN FOR WRITE
      = 0008            FT.OU	EQU	00001000B		;  =1 IF OPEN FOR UPDATE
      = 0010            FT.OC	EQU	00010000B		;  =1 IF OPEN FOR CHARACTER MODE
      = 0003            IOC.SQL EQU	*-IOC.DDA		; LENGTH OF INFO FOR SEQUENTIAL FILE

0005   (0002)           IOC.GRT DS	2			; ADDRESS OF GROUP RESERVATION TABLE
0007   (0001)           IOC.SPG DS	1			; SECTORS PER GROUP, THIS DEVICE
0008   (0001)           IOC.CGN DS	1			; CURRENT GROUP NUMBER
0009   (0001)           IOC.CSI DS	1			; CURRENT SECTOR INDEX (IN CURRENT GROUP)
000A   (0001)           IOC.LGN DS	1			; LAST GROUP NUMBER
000B   (0001)           IOC.LSI DS	1			; LAST SECTOR INDEX (IN LAST GROUP)
      = 0008            IOC.DRL EQU	*-IOC.FLG		; LENGTH OF INFO NORMALLY COPIED BACK TO
                        *					; THE CHANNEL TABLE
000C   (0002)           IOC.DTA DS	2			; DEVICE TABLE ADDRESS FOR THIS DEVICE
000E   (0002)           IOC.DES DS	2			; SECTOR NUMBER OF DIRECTORY ENTRY
0010   (0002)           IOC.DEV DS	2			; DEVICE CODE
0012   (0001)           IOC.UNI DS	1			; UNIT NUMBER (0-9)
      = 0011            IOC.DIL EQU	*-IOC.DDA		; LENGTH OF INFO FOR DIRECTORY FILE

0013   (0017)           IOC.DIR DS	DIRELEN 		; DIRECTORY ENTRY

      = 002A            IOCELEN EQU	*			; IOC ENTRY LENGTH

      = 0001            IOCCTD	EQU	1			; INDEX OF USER CHANNEL #0 IN CHANTAB (FIRST = 0)
002A                    	XTEXT	DDDEF
002A                    	SPACE	3,10
                        **	DEVICE DRIVER COMMUNICATION FLAGS.
                        *

0000                    	ORG	0

0000   (0001)           DC.REA	DS	1			; READ
0001   (0001)           DC.WRI	DS	1			; WRITE
0002   (0001)           DC.RER	DS	1			; READ REGARDLESS
0003   (0001)           DC.OPR	DS	1			; OPEN FOR READ
0004   (0001)           DC.OPW	DS	1			; OPEN FOR WRITE
0005   (0001)           DC.OPU	DS	1			; OPEN FOR UPDATE
0006   (0001)           DC.CLO	DS	1			; CLOSE
0007   (0001)           DC.ABT	DS	1			; ABORT
0008   (0001)           DC.MOU	DS	1			; MOUNT DEVICE
0009   (0001)           DC.LOD	DS	1			; LOAD DEVICE DRIVER
000A   (0001)           DC.RDY	DS	1			; Device Ready
000B   (0001)           DC.SET	DS	1			; Update SET parameters 	/3.0a/
000C   (0001)           DC.UNL	DS	1			; Unload device driver		/3.0a/
000D   (0001)           DC.INT	DS	1			; Interrupt			/3.0a/
000E   (0001)           DC.DSF	DS	1			; Device-specific function	/3.0a/
000F   (0001)           DC.MAX	DS	1			; MAXIMUM ENTRY INDEX
0010                    	XTEXT	ECDEF
0010                    	SPACE	4,10
                        **	ERROR CODE DEFINITIONS.

0000                    	ORG	0

0000   (0001)           	DS	1		; NO ERROR #0
0001   (0001)           EC.EOF	DS	1		; END OF FILE
0002   (0001)           EC.EOM	DS	1		; END OF MEDIA
0003   (0001)           EC.ILC	DS	1		; ILLEGAL SCALL CODE
0004   (0001)           EC.CNA	DS	1		; CHANNEL NOT AVAILABLE
0005   (0001)           EC.DNS	DS	1		; DEVICE NOT SUITABLE
0006   (0001)           EC.IDN	DS	1		; ILLEGAL DEVICE NAME
0007   (0001)           EC.IFN	DS	1		; ILLEGAL FILE NAME
0008   (0001)           EC.NRD	DS	1		; NO ROOM FOR DEVICE DRIVER
0009   (0001)           EC.FNO	DS	1		; CHANNEL NOT OPEN
000A   (0001)           EC.ILR	DS	1		; ILLEGAL REQUEST
000B   (0001)           EC.FUC	DS	1		; FILE USAGE CONFLICT
000C   (0001)           EC.FNF	DS	1		; FILE NAME NOT FOUND
000D   (0001)           EC.UND	DS	1		; UNKNOWN DEVICE
000E   (0001)           EC.ICN	DS	1		; ILLEGAL CHANNEL NUMBER
000F   (0001)           EC.DIF	DS	1		; DIRECTORY FULL
0010   (0001)           EC.IFC	DS	1		; ILLEGAL FILE CONTENTS
0011   (0001)           EC.NEM	DS	1		; NOT ENOUGH MEMORY
0012   (0001)           EC.RF	DS	1		; READ FAILURE
0013   (0001)           EC.WF	DS	1		; WRITE FAILURE
0014   (0001)           EC.WPV	DS	1		; WRITE PROTECTION VIOLATION
0015   (0001)           EC.WP	DS	1		; DISK WRITE PROTECTED
0016   (0001)           EC.FAP	DS	1		; FILE ALREADY PRESENT
0017   (0001)           EC.DDA	DS	1		; DEVICE DRIVER ABORT
0018   (0001)           EC.FL	DS	1		; FILE LOCKED
0019   (0001)           EC.FAO	DS	1		; FILE ALREADY OPEN
001A   (0001)           EC.IS	DS	1		; ILLEGAL SWITCH
001B   (0001)           EC.UUN	DS	1		; UNKNOWN UNIT NUMBER
001C   (0001)           EC.FNR	DS	1		; FILE NAME REQUIRED
001D   (0001)           EC.DIW	DS	1		; DEVICE IS NOT WRITABLE (OR WRITE LOCKED)
001E   (0001)           EC.UNA	DS	1		; UNIT NOT AVAILABLE
001F   (0001)           EC.ILV	DS	1		; ILLEGAL VALUE
0020   (0001)           EC.ILO	DS	1		; ILLEGAL OPTION
0021   (0001)           EC.VPM	DS	1		; VOLUME PRESENTLY MOUNTED ON DEVICE
0022   (0001)           EC.NVM	DS	1		; NO VOLUME PRESENTLY MOUNTED
0023   (0001)           EC.FOD	DS	1		; FILE OPEN ON DEVICE
0024   (0001)           EC.NPM	DS	1		; NO PROVISIONS MADE FOR REMOUNTING MORE DISKS
0025   (0001)           EC.DNI	DS	1		; DISK NOT INITIALIZED
0026   (0001)           EC.DNR	DS	1		; DISK IS NOT READABLE
0027   (0001)           EC.DSC	DS	1		; DISK STRUCTURE IS CORRUPT
0028   (0001)           EC.NCV	DS	1		; NOT CORRECT VERSION OF HDOS
0029   (0001)           EC.NOS	DS	1		; NO OPERATING SYSTEM MOUNTED
002A   (0001)           EC.IOI	DS	1		; ILLEGAL OVERLAY INDEX
002B   (0001)           EC.OTL	DS	1		; OVERLAY TOO LARGE
002C   (0001)           EC.LAD	DS	1		; File is locked against delete 	/3.0a/
002D   (0001)           EC.FIX	DS	1		; Device media is fixed 		/3.0a/
002E   (0001)           EC.ILA	DS	1		; Illegal Load Address			/3.0a/
002F   (0001)           EC.DNL	DS	1		; Device Not Loaded			/3.0a/
0030   (0001)           EC.DNP	DS	1		; Device Not Locked in Memory		/3.0a/
0031   (0001)           EC.DFM	DS	1		; Device is Fixed in Memory		/3.0a/
0032   (0001)           EC.IDF	DS	1		; Illegal Date Format			/3.0a/
0033   (0001)           EC.ITS	DS	1		; Illegal Time Format			/3.0a/
0034   (0001)           EC.CNR	DS	1		; System Clock Not Resident		/3.0a/
0035   (0001)           EC.SDR	DS	1		; System Disk is Reset			/3.0a/
0036   (0001)           EC.LBO	DS	1		; Line Buffer Overflow			/3.0a/
0037   (0001)           EC.CUI	DS	1		; Can't Unlink from Interrupt Vector	/3.0a/
0038                    	XTEXT	DDFDEF
0038                    	SPACE	3,10
                        **	DIRECTORY DEVICE FORMAT DEFINITION.
                        *

0000                    	ORG	0

0000   (0009)           DDF.BOO DS	9			; 2K BOOT PROGRAM
      = 0009            DDF.BOL EQU	*			; LENGTH OF BOOT
0009   (0001)           DDF.LAB DS	1			; LABEL SECTOR
000A   (0000)           DDF.USR DS	0			; BEGINNING OF OPEN SPACE
000A                    	XTEXT	LABDEF
000A                    	SPACE	3,10
                        **	DISK LABEL SECTOR FORMATS.

0000                    	ORG	0

0000   (0001)           LAB.SER DS	1			; SERIAL NUMBER OF VOLUME
0001   (0002)           LAB.IND DS	2			; INITIALIZATION DATE
0003   (0002)           LAB.DIS DS	2			; SECTOR NUMBER OF 1ST DIRECTORY SECTOR
0005   (0002)           LAB.GRT DS	2			; INDEX OF GRT SECTOR
0007   (0001)           LAB.SPG DS	1			; SECTORS PER GROUP

      = 0000            LAB.DAT EQU	0			; DATA VOLUME ONLY
      = 0001            LAB.SYS EQU	1			; SYSTEM VOLUME
      = 0002            LAB.NOD EQU	2			; VOLUME HAS NO DIRECTORY

0008   (0001)           LAB.VLT DS	1			; VOLUME TYPE
0009   (0001)           LAB.VER DS	1			; VERSION OF INIT17 THAT INITED DISK

000A   (0002)           LAB.RGT DS	2			; RGT sector number

      = 000C            LAB.VPR EQU	*			; Volume dependant data
000C   (0002)           LAB.SIZ DS	2			;  Volume Size (Bytes/256)
000E   (0002)           LAB.PSS DS	2			;  Physical Sector Size
0010   (0001)           LAB.VFL DS	1			;  Volume dependant Flags
      = 0001            VFL.NSD EQU	00000001B		;   Number of Sides:  1 => 2
      = 0002            VFL.DTD EQU	00000010b		;   96 tracks per inch		/3.0a/
      = 0002            VFL.80T EQU	VFL.DTD 		;   (ditto)
      = 0004            VFL.FIX EQU	00000100b		;   Media is fixed		/3.0a/
      = 0005            LAB.VPL EQU	*-LAB.VPR		; Length of volume dependant data

                        	ERRMI	5-LAB.VPL
0011   (0000)           	DS	5-LAB.VPL		; Reserved

0011   (003C)           LAB.LAB DS	60			; LABEL
      = 003C            LAB.LBL EQU	*-LAB.LAB		; LABEL LENGTH
004D   (0002)           	DS	2			; Reserved for 0 bytes

      = 004F            LAB.AUX EQU	*			; Auxiliary Data
004F   (0001)           LAB.SPT DS	1			;  Sectors per Track
      = 0001            LAB.AXL EQU	*-LAB.AUX		; Length of Aux. Data

0050   (0002)           LAB.LVN DS	2			; Long volume number		/3.0a/
0052                    	XTEXT	ABSDEF
0052                    ABSDEF	SPACE	3,10
                        **	ABS FORMAT EQUIVALENCES.

0000                    	ORG	0

0000   (0001)           ABS.ID	DS	1	;377Q = BINARY FILE FLAG
0001   (0001)           	DS	1	;FILE TYPE (FT.ABS)
0002   (0002)           ABS.LDA	DS	2	;LOAD ADDRESS
0004   (0002)           ABS.LEN	DS	2	;LENGTH OF ENTIRE RECORD
0006   (0002)           ABS.ENT	DS	2	;ENTRY POINT

0008   (0000)           ABS.COD	DS	0	;CODE STARTS HERE
0008                    	XTEXT	PICDEF
0008                    PICDEF	SPACE	3,10
                        **	PIC FORMAT EQUIVALENCES.

0000                    	ORG	0

0000   (0001)           PIC.ID	DS	1			; 377Q = BINARY FILE FLAG
0001   (0001)           	DS	1			; FILE TYPE (FT.PIC)
0002   (0002)           PIC.LEN DS	2			; LENGTH OF ENTIRE RECORD
0004   (0002)           PIC.PTR DS	2			; INDEX OF START OF PIC TABLE

0006   (0000)           PIC.COD DS	0			; CODE STARTS HERE
0006                    	XTEXT	DVDDEF
0006                    	SPACE	4,10
                        **	DEVICE DRIVER EQUIVALENCES.

      = 00C7            DVDFLV	EQU	307Q			; DEVICE DRIVER FLAG VALUE

0006                    	ORG	PIC.COD 		; STARTS AT PIC CODE AREA

0006   (0001)           DVD.DVD DS	1			; MUST BE DVDFLV, IDENTIFIES AS DRIVER
0007   (0001)           DVD.CAP DS	1			; DEVICE CAPABILITY FLAG
0008   (0001)           DVD.MUM DS	1			; MOUNTED UNIT MASK
0009   (0001)           DVD.MNU DS	1			; MAXIMUM NUMBER OF UNITS
000A   (0008)           DVD.UFL DS	8			; UNIT CAPABILITY FLAGS FOR UNITS 0-7
0012   (0001)           DVD.SET DS	1			; = DVDFLV IFF DRIVER WILL TAKE SET OPTIONS
0013   (0002)           DVD.INP DS	2			; Pointer to Init Code
0015   (0001)           DVD.V30 DS	1			; = DVDFLV IFF HDOS 3.0 Driver	/3.0a/
0016   (0001)           DVD.SPL DS	1			; SET preamble size (pages/2)	/3.0a/
0017   (0014)           	DS	20			; RESERVED, MUST BE 0		/3.0a/
      = 002B            DVD.STE EQU	*			; ENTRY FOR 'SET' INVOCATION

      = 0200            DVD.ENT EQU	002000A 		; DRIVER ENTRY POINT (MULT OF 512)
002B                    	XTEXT	DIFDEF
002B                    DIFDEF	SPACE	4,10
                        **	DIRECTORY FILE FLAGS.

      = 0080            DIF.SYS EQU	10000000B		; System file
      = 0040            DIF.LOC EQU	01000000B		; Locked from flag changes
      = 0020            DIF.WP	EQU	00100000B		; Write protected
      = 0010            DIF.CNT EQU	00010000B		; Contiguous file
      = 0008            DIF.ARC EQU	00001000B		; File archive attribute	/3.0a/
      = 0004            DIF.BAD EQU	00000100B		; File is damaged		/3.0a/
      = 0002            DIF.DL	EQU	00000010B		; Locked against delete 	/3.0a/
      = 0001            DIF.USR EQU	00000001B		; User-defined			/3.0a/
002B                    	XTEXT	NAMDEF
002B                    NAMDEF	SPACE	4,10
                        **	SYSTEM FILE NAME CONVENTIONS
                        *
                        *	HDOS30	.SYS		SYSTEM IMAGE PROGRAM FOR SYSTEM 	/3.0a/
                        *	TT	.DVD		Console Device Driver			/3.0a/
                        *	SY	.DVD		System Disk Device Drivecr		/3.0a/
                        *
                        *	RGT	.SYS		RESERVED GROUP TABLE (1 SECTOR)
                        *	GRT	.SYS		GROUP RESERVATION TABLE (1 SECTOR)
                        *	DIRECT	.SYS		DIRECTORY
002B                    	XTEXT	MTRDEF
002B                    	SPACE	4,10
                        **	HDOS MONITOR PRIVATE RAM AREA DEFINITIONS.

0000                    	ORG	0

0000   (0001)           M.SYSM	DS	1			; SYSCALL ITTERATION COUNT
0001   (0001)           	DS	1			; STAND-ALONE FLAG (obsolete)	/3.0a/

0002   (0002)           M.CSL	DS	2			; Address of console data area	/3.0a/

0004   (0001)           M.SUNI	DS	1			; System Unit Number
0005   (0002)           M.SYDD	DS	2			; Address of Raw System Driver
0007                    	XTEXT	HOSBASE
0007                    	SPACE	4,10
                        **	HDOS BASE PAGE DEFINITION
                        *

0000                    	ORG	0

      = 0000            HOSBASE EQU	*

                        	ERRNZ	*-000000A
0000   (0003)           B.INT0	DS	3

0003   (0002)           S.LABEL DS	2			; address of label buffer

0005   (0001)           S.FMASK DS	1			; feature mask

      = 0003            F.CLK	EQU	00000011B		; system clock speed
      = 0000            F.2MHZ	EQU	00000000B		;  2 MHz
      = 0001            F.4MHZ	EQU	00000001B		;  4 MHz
      = 0002            F.6MHZ	EQU	00000010B		;  6 MHz

      = 000C            F.MACH	EQU	00001100B		; System type
      = 0000            F.H8	EQU	00000000B		;  H8
      = 0004            F.H89	EQU	00000100B		;  H89
      = 0008            F.Z100	EQU	00001000B		;  Z-100
      = 000C            F.OMACH EQU	00001100B		;  PC, ETC.

      = 0030            F.TERM	EQU	00110000B		; Terminal type
      = 0000            F.TTY	EQU	00000000B		;  Dumb TTY
      = 0010            F.H19	EQU	00010000B		;  H19

      = 00C0            F.CPU	EQU	11000000B		; CPU type
      = 0000            F.8080	EQU	00000000B		;  8080
      = 0040            F.8085	EQU	01000000B		;  8085
      = 0080            F.Z80	EQU	10000000B		;  Z-80
      = 00C0            F.OCPU	EQU	11000000B		;  HD64180, V20, ETC.

0006   (0002)           S.LWA	DS	2			; lwa of HDOS

                        	ERRNZ	*-000010A
0008   (0003)           B.INT1	DS	3			; clock interrupt

000B   (0005)           S.REV	DS	5			; rev, date, time of HDOS

                        	ERRNZ	*-000020A
0010   (0003)           B.INT2	DS	3			; available

0013   (0005)           	DS	5

                        	ERRNZ	*-000030A
0018   (0003)           B.INT3	DS	3			; available

001B   (0005)           	DS	5

                        	ERRNZ	*-000040A
0020   (0003)           B.INT4	DS	3			; available

0023   (0005)           	DS	5

                        	ERRNZ	*-000050A
0028   (0003)           B.INT5	DS	3			; available

                        	ERRNZ	*-000053A		; same as .DLY
002B   (0003)           S.DLY	DS	3

002E   (0002)           	DS	2

                        	ERRNZ	*-000060A
0030   (0003)           B.INT6	DS	3			; available

0033   (0005)           	DS	5

                        	ERRNZ	*-000070A
0038   (0003)           B.INT7	DS	3			; SCALL interrupt

003B   (0003)           B.SCALL DS	3			; JMP directly to SCALL processor

003E   (0002)           CSLIBUF DS	2			; FWA of console type-ahead buffer

0040   (0011)           BATNAME DS	17			; complete batch file name
0051   (0001)           BATSEC	DS	1			; current sector index in batch file
0052   (0002)           BATGNS	DS	2			; batch file group numbers

0054   (0002)           BATBUF	DS	2			; address of batch buffer
0056   (0002)           BATPTR	DS	2			; address of next char. in BATBUF

0058   (0002)           SUBBUF	DS	2			; address of substitution buffer

005A   (0002)           S.PATH	DS	2			; address of path buffer
005C   (0002)           S.PRMT	DS	2			; address of prompt buffer
005E   (0002)           S.EDLIN DS	2			; adderss of line buffer

0060   (0001)           S.COUNT DS	1			; counter
0061   (0001)           S.SHIFT DS	1			; shift count
0062   (0001)           S.BITS	DS	1			; bit flags

0063   (0003)           	DS	3

                        	ERRNZ	*-66H
0066   (0003)           B.NMI	DS	3			; NMI handler vector
0069   (0001)           B.NMIFL DS	1			; NMI flag (0=no NMI's occured)

006A   (0006)           S.DFBLK DS	6			; system wide default block

0070   (000F)           S.CVEC	DS	5*3			; console SCALL vectors

007F   (0001)           S.FLAG	DS	1			; system flags

      = 0001            S.SYSCM equ	00000001b		; SYSCMD.SYS in memory
      = 0002            S.VFLG	equ	00000010b		; Verify is on
      = 0004            S.ECHO	equ	00000100b		; Echo is off
      = 0008            S.BATCH equ	00001000b		; Batch is active
      = 0010            S.EXITC equ	00010000b		; SYSCMD prints exit code
      = 0020            S.BREAK equ	00100000b		; used by PIP
      = 0040            S.TABUF equ	01000000b		; type-ahead is stuffed
      = 0080            S.INIT	equ	10000000b		; set 1st time SYSCMD.SYS runs

                        	ERRNZ	*-80H			; MAKE SURE GOT EM' ALL
      = 0080            B.END	EQU	*
0080                    	XTEXT	HOSEQU
0080                    	SPACE	4,10
                        **	HDOS SYSTEM EQUIVALENCES.					/3.0a/
                        *

2040                    	ORG	040100A

2040   (0008)           S.EXITA DS	8			; Jump to System Exit

2048   (0010)           D.CON	DS	16			; Disk Constants

      = 2058            SYDD	EQU	*			; System Disk Entry Point

2058   (0048)           D.VEC	DS	24*3			; H17 Disk Vectors
20A0   (001F)           D.RAM	DS	31			; H17 Disk Work Area

20BF   (0024)           S.VAL	DS	36			; SYSTEM VALUES
20E3   (0093)           S.INT	DS	147			; SYSTEM INTERNAL WORK AREAS

2176   (0002)           S.SOVR	DS	2			; STACK OVERFLOW WARNING
2178   (0108)           	DS	042200A-*		; SYSTEM STACK
      = 010A            STACKL	EQU	*-S.SOVR		; STACK SIZE

      = 2280            STACK	EQU	*			; LWA+1 SYSTEM STACK
      = 2280            USERFWA EQU	*			; USER FWA

                        *	Ensure Compatibility

                        	ERRNZ	040130A-SYDD
                        	ERRNZ	040277A-S.VAL
                        	ERRNZ	040343A-S.INT
                        	ERRNZ	042200A-USERFWA
2280                    	XTEXT	ECVEC
2280                    EDVEC	SPACE	4,10
                        **	JMP Vectors to TT.DVD
                        *
                        *	It is the responsibility of TT.DVD to initialize this
                        *	vector table when it is loaded.

0070                    	ORG	S.CVEC

0070   (0003)           ..SCIN	DS	3			; JMP to .SCIN
0073   (0003)           ..SCOUT DS	3			; JMP to .SCOUT
0076   (0003)           ..PRINT DS	3			; JMP to .PRINT
0079   (0003)           ..CONSL DS	3			; JMP to .CONSL
007C   (0003)           ..CLRCO DS	3			; JMP to .CLRCO

      = 000F            S.CVECL EQU	*-S.CVEC
007F                    	XTEXT	ESVAL
007F                    	SPACE	4,10
                        **	S.VAL - SYSTEM VALUE DEFINTIONS.
                        *
                        *	THESE VALUES ARE SET AND MAINTAINED BY THE SYSTEM.
                        *
                        *	THE DECK HOSEQU MUST BE MODIFIED WHEN THIS IS MODIFIED.

20BF                    	ORG	S.VAL

20BF   (0009)           S.DATE	DS	9			; SYSTEM DATE (IN ASCII)
20C8   (0002)           S.DATC	DS	2			; CODED DATE
20CA   (0003)           S.TIME	DS	3			; TIME (BCD HH MM SS)		/3.0a/
20CD   (0001)           S.CLKTR DS	1			; 0 if no clock task resident	/3.0a/
20CE   (0002)           S.HIMEM DS	2			; HARDWARE HIGH MEMORY ADRESS+1

20D0   (0002)           S.SYSM	DS	2			; FWA RESIDENT SYSTEM

20D2   (0002)           S.USRM	DS	2			; LWA USER MEMORY

20D4   (0002)           	DS	2			; obsolete (must be zero!!)	/3.0a/
20D6                    	SPACE	3,10
                        **	THE FOLLOWING CELLS SHOULD BE MODIFIED/READ ONLY VIA THE .CONSL SCALL

      = 0080            CSL.ECH EQU	10000000B		; SUPPRESS ECHO
      = 0004            CSL.RAW EQU	00000100B		; Raw Mode I/O
      = 0002            CSL.WRP EQU	00000010B		; WRAP LINES AT WIDTH
      = 0001            CSL.CHR EQU	00000001B		; OPERATE IN CHARACTER MODE

      = 0000            I.CSLMD EQU	0			; S.CSLMD IS FIRST BYTE
20D6   (0001)           S.CSLMD DS	1			; CONSOLE MODE


      = 0080            CTP.BKS EQU	10000000B		; TERMINAL PROCESSES BACKSPACES
      = 0040            CTP.FF	EQU	01000000B		; Terminal Processes Form-Feed
      = 0020            CTP.MLI EQU	00100000B		; MAP LOWER CASE TO UPPER ON INPUT
      = 0010            CTP.MLO EQU	00010000B		; MAP LOWER CASE TO UPPER ON OUTPUT
      = 0008            CTP.2SB EQU	00001000B		; TERMINAL NEEDS TWO STOP BITS
      = 0004            CTP.HHS EQU	00000100B		; Terminal uses hdwr handshake	/3.0a/
      = 0002            CTP.BKM EQU	00000010B		; MAP BKSP (UPON INPUT) TO RUBOUT
      = 0001            CTP.TAB EQU	00000001B		; TERMINAL SUPPORTS TAB CHARACTERS

      = 0001            I.CONTY EQU	1			; S.CONTY IS 2ND BYTE
                        	ERRNZ	*-S.CSLMD-I.CONTY
20D7   (0001)           S.CONTY DS	1			; CONSOLE TYPE FLAGS


      = 0002            I.CUSOR EQU	2			; S.CUSOR IS 3RD BYTE
                        	ERRNZ	*-S.CSLMD-I.CUSOR
20D8   (0001)           S.CUSOR DS	1			; CURRENT CURSOR POSITION


      = 0003            I.CONWI EQU	3			; S.CONWI IS 4TH BYTE
                        	ERRNZ	*-S.CSLMD-I.CONWI
20D9   (0001)           S.CONWI DS	1			; CONSOLE WIDTH


      = 0001            CO.FLG	EQU	00000001B		; CTL-O FLAG
      = 0080            CS.FLG	EQU	10000000B		; CTL-S FLAG

      = 0004            I.CONFL EQU	4			; S.CONFL IS 5TH BYTE
                        	ERRNZ	*-S.CSLMD-I.CONFL
20DA   (0001)           S.CONFL DS	1			; CONSOLE FLAGS


20DB   (0002)           S.CAADR DS	2			; ADDRESS FOR ABORT PROCESSING (>256 IF VALID)
20DD   (0006)           S.CCTAB DS	6			; ADDR FOR CTL-A, CTL-B, CTL-C PROCESSING
20E3                    	XTEXT	ESINT
20E3                    	SPACE	4,10
                        **	S.INT - SYSTEM INTERNAL WORKAREA DEFINITIONS.
                        *
                        *	THESE CELLS ARE REFERENCED BY OVERLAYS AND MAIN CODE, AND
                        *	MUST THEREFORE RESIDE IN FIXED LOW MEMORY.

20E3                    	ORG	S.INT

                        **	CONSOLE STATUS FLAGS

20E3   (0001)           S.CDB	DS	1			; CONSOLE DESCRIPTOR BYTE
      = 0000            CDB.H85	EQU	00000000B
      = 0001            CDB.H84 EQU	00000001B		; =0 IF H8-5, =1 IF H8-4
20E4   (0002)           S.BAUD	DS	2			; [0-14]  H8-4 BAUD RATE, =0 IF H8-5
                        *					; [15]	  =1 IF BAUD RATE => 2 STOP BITS

                        **	TABLE ADDRESS WORDS

20E6   (0002)           S.DLINK DS	2			; ADDRESS OF DATA IN HDOS CODE
20E8   (0002)           S.TFWA	DS	2			; FWA Task Table		/3.1a/
20EA   (0002)           S.CFWA	DS	2			; FWA CHANNEL TABLE
20EC   (0002)           S.DFWA	DS	2			; FWA DEVICE TABLE
20EE   (0002)           S.RFWA	DS	2			; FWA RESIDENT HDOS CODE

                        **	DEVICE DRIVER DELAYED LOAD FLAGS

20F0   (0002)           S.DDLDA DS	2			; DRIVER LOAD ADDRESS (HIGH BYTE=0 IF NO LOAD PENDING)
20F2   (0002)           S.DDLEN DS	2			; CODE LENGTH IN BYTES
20F4   (0001)           S.DDGRP DS	1			; GROUP NUMBER FOR DRIVER
20F5   (0001)           	DS	1			; HOLD PLACE
20F6   (0002)           S.DDDTA DS	2			; DEVICE'S ADDRESS IN DEVLST +DEV.RES
20F8   (0001)           S.DDOPC DS	1			; OPEN OPCODE PENDEDING

20F9   (000D)           	DS	13			; reserved

                        *	SYSCALL PROCESSING WORK AREAS

                        	ERRNZ	*-041006A
2106   (0001)           S.CACC	DS	1			; (ACC) UPON SYSCALL
2107   (0001)           S.CODE	DS	1			; SYSCALL INDEX IN PROGRESS

                        *	JUMPS TO ROUTINES IN RESIDENT HDOS CODE

2108   (0000)           S.JUMPS DS	0			; START OF DUMP VECTORS
2108   (0003)           S.SDD	DS	3			; JUMP TO STAND-IN DEVICE DRIVER
210B   (0003)           S.FASER DS	3			; JUMP TO FATSERR (FATAL SYSTEM ERROR)
210E   (0003)           S.DIREA DS	3			; JUMP TO DIREAD (DISK FILE READ)
2111   (0003)           S.FCI	DS	3			; JUMP TO FCI (FETCH CHANNEL INFO)
2114   (0003)           S.SCI	DS	3			; JUMP TO SCI (STORE CHANNEL INFO)
2117   (0003)           S.GUP	DS	3			; JUMP TO GUP (GET UNIT POINTER)

211A   (0001)           S.MOUNT DS	1			; <>0 IF THE SYSTEM DISK IS MOUNTED
211B   (0001)           	DS	1			; reserved			/3.0a/

211C   (0001)           S.BOOTF DS	1			; BOOT FLAGS
      = 0001            BOOT.P	EQU	00000001B		; EXECUTE PROLOGUE UPON BOOTUP

211D   (0003)           	DS	3			; reserved
2120                    	SPACE	4,10
                        **	ACTIVE I/O AREA.
                        *
                        *	THE AIO.XXX AREA CONTAINS INFORMATION ABOUT THE I/O OPERATION
                        *	CURRENTLY BEING PERFORMED. THE INFORMATION IS OBTAINED FROM
                        *	THE CHANNEL TABLE, AND WILL BE RESTORED THERE WHEN DONE.
                        *
                        *	NORMALLY, THE AIO.XXX INFORMATION WOULD BE OBTAINED DIRECTLY
                        *	FROM VARIOUS SYSTEM TABLES VIA POINTER REGISTERS. SINCE THE
                        *	8080 HAS NO GOOD INDEXED ADDRESSING, THE DATA IS MANUALLY
                        *	COPIED INTO THE AIO.XXX CELLS BEFORE PROCESSING, AND
                        *	BACKDATED AFTER PROCESSING.

                        	ERRNZ	*-041040A
2120   (0003)           AIO.VEC DS	3			; JUMP INSTRUCTION
      = 2121            AIO.DDA EQU	*-2			; DEVICE DRIVER ADDRESS
2123   (0001)           AIO.FLG DS	1			; FLAG BYTE
2124   (0002)           AIO.GRT DS	2			; ADDRESS OF GROUP RESERV TABLE
2126   (0001)           AIO.SPG DS	1			; SECTORS PER GROUP
2127   (0001)           AIO.CGN DS	1			; CURRENT GROUP NUMBER
2128   (0001)           AIO.CSI DS	1			; CURRENT SECTOR INDEX
2129   (0001)           AIO.LGN DS	1			; LAST GROUP NUMBER
212A   (0001)           AIO.LSI DS	1			; LAST SECTOR INDEX
212B   (0002)           AIO.DTA DS	2			; DEVICE TABLE ADDRESS
212D   (0002)           AIO.DES DS	2			; DIRECTORY SECTOR
212F   (0002)           AIO.DEV DS	2			; DEVICE CODE
2131   (0001)           AIO.UNI DS	1			; UNIT NUMBER (0-9)

2132   (0017)           AIO.DIR DS	DIRELEN 		; DIRECTORY ENTRY

2149   (0001)           AIO.CNT DS	1			; SECTOR COUNT
214A   (0001)           AIO.EOM DS	1			; END OF MEDIA FLAG
214B   (0001)           AIO.EOF DS	1			; END OF FILE FLAG
214C   (0002)           AIO.TFP DS	2			; TEMP FILE POINTERS
214E   (0002)           AIO.CHA DS	2			; ADDRESS OF CHANNEL BLOCK (IOC.DDA)
2150                    	SPACE	4,10
                        *	these cells set by monitor boot code

2150   (0001)           S.BDA	DS	1			; Boot Device Address (Setup by ROM)
2151   (0002)           S.SCR	DS	2			; SYSTEM SCRATCH AREA ADDRESS
2153   (0003)           	DS	3
2156   (0001)           S.OSI	DS	1			; Operating system index	/3.0a/
2157   (0001)           S.OSO	DS	1			; Operating system occurance	/3.0a/
2158   (0003)           S.OSZ	DS	3			; Operating system sector zero	/3.0a/
215B                    	XTEXT	FLTDEF
215B                    	SPACE	4,10
                        **	FLTDEF - DEFAULT SECTOR DEFINITIONS

0000                    	ORG	0

0000   (0001)           FLT.MNC DS	1			; MAXIMUM NUMBER OF I/O CHANNELS

0001   (0001)           FLT.OPT DS	1			; System Options

                        	ERRNZ	F.TERM-00110000B
      = 0000            OPT.TTY EQU	F.TTY
      = 0010            OPT.H19 EQU	F.H19

0002   (0001)           FLT.PBO DS	1			; Permanent Boot Options

      = 0001            PBO.DAT EQU	00000001B		;  No-Date (0=>No-date)
      = 0002            PBO.MNT EQU	00000010B		;  Auto mount (1=>Auto mount)	/3.0a/
0003                    	XTEXT	BOODEF
0003                    	SPACE	4,10
                        **	BOODEF - SPECIAL BOOT-HDOS INTERFACE DEFINTIONS.

      = 3000            SB.ORG	EQU	060000A 		; ORG FOR LOAD OF INITIAL HDOS	/3.0a/

2280                    	ORG	042200A

2280   (0003)           SB.BOO	DS	3			; Jump to Boot routine
2283   (0001)           SB.VER	DS	1			; Version of INIT that built disk
2284   (0001)           SB.FLG	DS	1			; Boot Flags
      = 0001            BFLG.A	EQU	00000001B		; Auto-Boot:  1 => Boot
2285   (0002)           SB.BAU	DS	2			; Baud Rate Divisor (0=>ignore)
2287   (0002)           SB.DAT	DS	2			; Default Date
                        	ERRMI	SB.BOO+32-*
2289   (0017)           	DS	SB.BOO+32-*		; Reserved
      = 22A0            SB.BPE	EQU	*			; End of BOOT-parameters

22A0   (01E0)           SB.DRV	DS	SB.BOO+512-*		; Primary Boot

      = 2480            SB.SDB	EQU	*			; Secondary Boot
2480                    	TITLE	'HDOS System Boot Code'
2480                    	STL	'Boot Mainline'
2480                    	EJECT
                        **	TEMP INITIALIZE

2480  = 3006            	CODE	P,SB.ORG+PIC.COD	; POSITION INDEPENDENT CODE
                        	CODE	-R			; THIS CODE WILL NOT BE RELOCATED

3006  C3 0C30           HOSBOOT JMP	HOSBOO1 		; PERFORM BOOT


                        *	DEFAULT VALUES FOR SYSTEM

      = 3009            HOSTAB	EQU	*			; DEFAULT VALUE TABLE

                        	ERRNZ	*-HOSTAB-FLT.MNC
3009  07                	DB	7			; Total number of channels	

                        	ERRNZ	*-HOSTAB-FLT.OPT
300A  00                	DB	0			; System Options

                        	ERRNZ	*-HOSTAB-FLT.PBO
300B  01                	DB	PBO.DAT 		; Permanent Boot Options
300C                    	SPACE	3
                        *	START OF BOOT CODE.
                        *
                        *	(HL) = FWA OF SY.DVD
                        *	(DE) = FWA OF TT.DVD

      = 300C            HOSBOO1	EQU	*

300C  31 8022           	LXI	SP,STACK		; SET UP THE NEW STACK

                        *	SAVE DRIVER ADDRESSES

300F  22 3E32           	SHLD	SYFWA
3012  EB                	XCHG
3013  22 1D32           	SHLD	TTFWA

                        *	CLEAR MEMORY

3016  CD 7430           	CALL	SBD			; save boot data

3019  21 CA20           	LXI	H,S.TIME
301C  06 84             	MVI	B,AIO.CHA-S.TIME
301E  CD 8A19           	CALL	$ZERO			; ZERO OUT LOTS OF MEMORY

3021  CD 9830           	CALL	RBD			; restore boot data

                        *	PLACES, EVERYONE!

3024  F3                	DI				; SAFE

3025  CD B730           	CALL	GO0			; GO ORG-0 (RETURN WITH DI)

3028  CD 0531           	CALL	RRH			; RELOCATE RESIDENT HDOS CODE

302B  CD 6F31           	CALL	SLR			; SET LOW MEMORY REFERENCES
302E  CD DF31           	CALL	ADB			; ALLOCATE DYNAMIC BUFFERS

3031  FB                	EI				; EVERYONE IN PLACE

3032  CD B732           	CALL	SFM			; SET FEATURE MASK

3035  CD 1132           	CALL	RTT			; RUN TT.DVD
3038  CD 1F32           	CALL	RSY			; RUN SY.DVD

303B  CD EE32           	CALL	GVM			; SHOW A SIGN OF LIFE

303E  CD 2E35           	CALL	FSM			; FAKE SYSTEM MOUNT

3041  CD 6635           	CALL	SDT			; SETUP DEVICE TABLES

3044  CD 9F37           	CALL	ACT			; Allocate Channel Table

3047  CD 7437           	CALL	ASG			; Allocate system GRTs

304A  CD 9738           	CALL	SSD			; Set System Date

304D  CD D737           	CALL	MSD			; Mount System Diskette

3050  CD 6C39           	CALL	UBP			; Update Boot Parameters

                        *	want prologue.sys?

3053  3A 1C21           	LDA	S.BOOTF
3056  E6 01             	ANI	BOOT.P
3058  CA 6030           	JZ	HOSB2			; IGNORE PROLOGUE FILE

305B  21 6330           	LXI	H,HOSBA
305E  FF 20             	SCALL	.LINK			; TRY TO LINK TO PROLOGUE

3060  AF                HOSB2	XRA	A			; COULDN'T FIND PROLOGUE,
3061  FF 00             	SCALL	.EXIT			;  SO TRY NORMAL EXIT

3063  5359303A 50524F4C HOSBA	DB	'SY0:PROLOGUE.SYS',0	; PROLOGUE FILE
306B  4F475545 2E535953
3073  00
3074                    	STL	'SBD - Save Boot Data'
3074                    	EJECT
                        ***	SBD - Save Boot Data
                        *

      = 3074            SBD	equ	*

3074  3A E320           	LDA	S.CDB			; console descriptor
3077  32 9330           	STA	SBDA

307A  2A E420           	LHLD	S.BAUD			; 8250 baud rate
307D  22 9430           	SHLD	SBDB

3080  3A D720           	LDA	S.CONTY 		; console type
3083  32 9630           	STA	SBDC

3086  3A 1C21           	LDA	S.BOOTF 		; boot flags
3089  32 9730           	STA	SBDD

308C  3A 3121           	LDA	AIO.UNI 		; boot device unit
308F  32 BD52           	STA	SUNIT

3092  C9                	RET

3093  00                SBDA	DC	1,#0
3094  0000              SBDB	DC	2,#0
3096  00                SBDC	DC	1,#0
3097  00                SBDD	DC	1,#0
3098                    	STL	'RBD - Restore Boot Data'
3098                    	EJECT
                        ***	RBD - Restore Boot Data
                        *

      = 3098            RBD	equ	*

3098  3A 9330           	LDA	SBDA
309B  32 E320           	STA	S.CDB			; console descriptor

309E  2A 9430           	LHLD	SBDB
30A1  22 E420           	SHLD	S.BAUD			; 8250 baud rate

30A4  3A 9630           	LDA	SBDC
30A7  32 D720           	STA	S.CONTY 		; console type

30AA  3A 9730           	LDA	SBDD
30AD  32 1C21           	STA	S.BOOTF 		; boot flags

30B0  3A BD52           	LDA	SUNIT
30B3  32 3121           	STA	AIO.UNI 		; boot device unit

30B6  C9                	RET
30B7                    	STL	'GO0 - GO ORG-0'
30B7                    	EJECT
                        ***	GO0 - GO ORG-0
                        *
                        *	GO0 IS CALLED TO SET THE SYSTEM UP FOR ORG-0 OPERATION.
                        *	THIS INCLUDES COPYING THE H17 ROM INTO RAM, ENABLING RAM
                        *	FROM 000000A THRU 037377A, COPYING THE H17 ROM IMAGE BACK
                        *	INTO PLACE IN RAM, AND SETTING CERTAIN BASE PAGE VALUES.
                        *
                        *	ENTRY:	INTERRUPTS OFF
                        *	EXIT:	NONE
                        *	USES:	ALL

      = 1800            H17ROM	EQU	030000A 		; FWA OF H17 ROM
      = 0800            H17ROML EQU	010000A 		; LENGTH OF H17 ROM

      = 2380            ROMBUF	EQU	USERFWA+256		; PLACE TO SAVE H17 ROM

      = 30B7            GO0	EQU	*

                        *	COPY THE ROM

30B7  AF                	XRA	A
30B8  D3 F2             	OUT	OP2.CTL 		; GET REAL ROM

                        	ERRMI	SB.ORG-ROMBUF-H17ROML	; MAKE SURE DON'T SQUISH BOOT CODE

30BA  11 0018           	LXI	D,H17ROM
30BD  21 8023           	LXI	H,ROMBUF
30C0  01 0008           	LXI	B,H17ROML
30C3  CD AA18           	CALL	$MOVE			; COPY THE IMAGE

                        *	ENABLE RAM AND DETERMINE MACHINE TYPE

30C6  3E 22             	MVI	A,CB2.ORG+CB2.CLI
30C8  D3 F2             	OUT	OP2.CTL 		; TURN ON LOW RAM
30CA  32 3620           	STA	.CTL2FL 		; SET CONTROL VALUE

30CD  21 6600           	LXI	H,B.NMI 		; POINT TO NMI VECTOR
30D0  7E                	MOV	A,M			; GET BYTE
30D1  34                	INR	M			; DOES IT
30D2  BE                	CMP	M			;  CHANGE?
30D3  CA D330           	JZ	*			; NO, STOP RIGHT HERE!

30D6  36 C3             	MVI	M,MI.JMP
30D8  23                	INX	H
30D9  11 0131           	LXI	D,GO0NMI		; SERVICE CODE
30DC  73                	MOV	M,E
30DD  23                	INX	H
30DE  72                	MOV	M,D			; VECTOR INSTALLED

30DF  0E D0             	MVI	C,CB.SPK+CB.CLI+CB.SSI	; INITIAL .CTLFLG (ASSUMES H8)
30E1  DB F0             	IN	IP.PAD			; TRY AN H8 PORT, CAUSES NMI IN H89

30E3  79                	MOV	A,C			; GET FLAG
30E4  A7                	ANA	A			; IS H89?
30E5  CA EA30           	JZ	GO0.1			; YES.

30E8  D3 F0             	OUT	OP.CTL			; ARM H8 CLOCK

30EA  32 0920           GO0.1	STA	.CTLFLG 		; =0 IF H89

                        *	COPY THE "ROM" BACK

30ED  21 8023           	LXI	H,ROMBUF		; WHERE WE PUT IT
30F0  11 0018           	LXI	D,H17ROM
30F3  01 0008           	LXI	B,H17ROML

30F6  7E                GO0.2	MOV	A,M
30F7  12                	STAX	D			; COPY A BYTE
30F8  23                	INX	H
30F9  13                	INX	D
30FA  0B                	DCX	B
30FB  78                	MOV	A,B
30FC  B1                	ORA	C			; DONE?
30FD  C2 F630           	JNZ	GO0.2			; NEGATORY, GOOD BUDDY.

                        *	FIN

3100  C9                	RET
3101                    	SPACE	4,10
                        *	NMI vector for hardware test

3101  0E 00             GO0NMI	MVI	C,0			; set new .CTLFLG

3103  ED45              	DB	0EDH,045H		; <RETN>
3105                    	STL	'RRH - Relocate HDOS Resident Code'
3105                    	EJECT
                        **	RRH - RELOCATE CODE.
                        *
                        *	RRH IS CALLED TO RELOCATE THE HOS CODE INTO HIGH MEMORY.
                        *
                        *	Modified:	Aug-80
                        *			 64K RAM System support
                        *
                        *	ENTRY	NONE
                        *	EXIT	(DE) = DISPLACEMENT FACTOR
                        *	USES	ALL

      = 3105            RRH	EQU	*

                        *	DETERMINE HIGH MEMORY

3105  21 1532           	LXI	H,RRH2+255		; START AT RRH2
3108  2E 00             	MVI	L,0			; START AT NEXT 256 BOUNDARY
310A  24                RRH1	INR	H			; TRY NEXT BLOCK
310B  CA 1531           	JZ	RRH1.5			; Wrap through high memory
310E  7E                	MOV	A,M
310F  34                	INR	M
3110  BE                	CMP	M
3111  77                	MOV	M,A			; RESTORE
3112  C2 0A31           	JNE	RRH1			; WAS RAM
3115  2B                RRH1.5	DCX	H			; (HL) = HIGHMEM

                        *	(HL) = HIGHMEM ADDRESS

      = 3116            RRH2	EQU	*

3116  22 CE20           	SHLD	S.HIMEM 		; SET HARDWARE HIGH MEM

                        *	set up for signon

3119  01 0100           	LXI	B,1
311C  09                	DAD	B
311D  7C                	MOV	A,H			; (h) = # pages, 'C' if 256.
311E  1F                	RAR
311F  1F                	RAR
3120  E6 7F             	ANI	01111111B
3122  4F                	MOV	C,A
3123  3E 02             	MVI	A,2
3125  21 2135           	LXI	H,GVMA
3128  CD 6F19           	CALL	$UDD

                        *	move the system

312B  21 0000           RRH3	LXI	H,HOSBASE		; Destination of HDOS
312E  11 8E3C           	LXI	D,FWAREL
3131  7D                	MOV	A,L
3132  93                	SUB	E
3133  4F                	MOV	C,A
3134  7C                	MOV	A,H
3135  9A                	SBB	D
3136  47                	MOV	B,A			; (BC) = DISPLACEMENT
3137  C5                	PUSH	B			; SAVE
3138  01 6F16           	LXI	B,LENSYS		; (BC) = SYSTEM RESIDENCE LENGTH
313B  CD AA18           	CALL	$MOVE			; MOVE INTO PLACE

                        *	RELOCATE REFERENCEES

313E  D1                	POP	D			; (DE) = RELOCATION FACTOR
313F  2A 0430           	LHLD	SB.ORG+PIC.PTR
3142  01 0030           	LXI	B,SB.ORG
3145  09                	DAD	B			; (HL) = REL TABLE ADDRESS

                        *	RELOCATE CELLS IN BOOT CODE ITSELF

3146  D5                RRH4	PUSH	D			; SAVE RELOCATION FACTOR
3147  5E                	MOV	E,M
3148  23                	INX	H
3149  56                	MOV	D,M
314A  23                	INX	H			; (DE) = REL ADDRESS OF WORD TO RELOCATE
314B  7A                	MOV	A,D
314C  B3                	ORA	E
314D  CA 5A31           	JZ	RRH6			; ALL DONE

                        *	SEE IF ADDRESS IS BEYOND FWAREL

3150  01 8E3C           	LXI	B,FWAREL		; (BC) = BREAK BETWEEN ABS PRESET AND REL HDOS
3153  7B                	MOV	A,E
3154  91                	SUB	C
3155  7A                	MOV	A,D
3156  98                	SBB	B
3157  DA 6231           	JC	RRH5			; NOT BEYOND

                        *	LET REL ROUTINE RELOCATE REST OF CODE

315A  01 FEFF           RRH6	LXI	B,-2
315D  09                	DAD	B			; BACKUP (HL)
315E  C1                	POP	B			; (BC) = REL FACTOR
315F  C3 7D1B           	JMP	REL.			; RELOCATE AND EXIT

                        *	(DE) = INDEX OF WORD TO RELOCATE
                        *	(HL) = RELOCATION TABLE ADDRESS
                        *	(BC) = CODE DISPLACEMENT FACTOR
                        *	((SP)) = CODE RELOCATION FACTOR

3162  E3                RRH5	XTHL				; (HL) = CODE REL FACTOR
3163  1A                	LDAX	D
3164  85                	ADD	L			; RELOCATE WORD OF CODE
3165  12                	STAX	D
3166  13                	INX	D
3167  1A                	LDAX	D
3168  8C                	ADC	H
3169  12                	STAX	D			; RELOCATE
316A  EB                	XCHG				; (DE) = RELOCATION FACTOR
316B  E1                	POP	H			; (HL) = RELOCATION TABLE ENTRY ADDRESS
316C  C3 4631           	JMP	RRH4			; DO IT AGAIN
316F                    	STL	'SLR - Set Low Memory References'
316F                    	EJECT
                        **	SLR - SETUP LOW MEMORY REFERENCES.
                        *

      = 316F            SLR	EQU	*

                        *	SETUP EXIT VECTOR AT 40100A

316F  CD 013A           	CALL	$MOVEL
3172  0800B031 4020     	DW	SLRAL,SLRA,040100A

                        *	SETUP LOW-MEMORY STUFF

3178  2A CE20           	LHLD	S.HIMEM 		; LAST BYTE
317B  23                	INX	H
317C  22 D020           	SHLD	S.SYSM			; SET SYSTEM FWA
317F  22 EE20           	SHLD	S.RFWA			; SET RESIDENT CODE FWA
3182  21 8022           	LXI	H,USERFWA
3185  22 D220           	SHLD	S.USRM			; SET LWA USER MEMORY

3188  21 B952           	LXI	H,HIGHDAT
318B  22 E620           	SHLD	S.DLINK 		; SET DATA LINK

                        *	SETUP JUMP VECTORS

318E  3E C3             	MVI	A,MI.JMP
3190  32 2021           	STA	AIO.VEC
3193  CD 013A           	CALL	$MOVEL
3196  1200B831 0821     	DW	SLRBL,SLRB,S.JUMPS	; SETUP JUMP VECTORS

                        *	SETUP .UIVEC TABLE

319C  CD 013A           	CALL	$MOVEL
319F  1500CA31 1F20     	DW	SLRCL,SLRC,.UIVEC

                        *	No reentry via H17

31A5  21 0B21           	LXI	H,S.FASER
31A8  22 0118           	SHLD	030001A 		; fix vector

                        *	CLEAR CLOCK PROCESSING

31AB  AF                	XRA	A
31AC  32 0820           	STA	.MFLAG

31AF  C9                	RET
31B0                    	SPACE	3,10
                        *	Exit Vector Routine

      = 31B0            SLRA	EQU	*			; CODE FOR 040100A

31B0  AF                	XRA	A
31B1  32 B952           	STA	SYSMODE
31B4  3E 01             	MVI	A,1			; FLAG RESET
31B6  FF 00             	SCALL	.EXIT

      = 0008            SLRAL	EQU	*-SLRA
                        	ERRMI	8-SLRAL 		; ONLY ROOM FOR 8 BYTES
31B8                    	SPACE	3,10
                        *	S.JUMPS Vectors

      = 31B8            SLRB	EQU	*			; JUMP VECTOR CONTENTS

                        	ERRNZ	*-SLRB+S.JUMPS-S.SDD
31B8  C3 0549           	JMP	SDD			; S.SDD

                        	ERRNZ	*-SLRB+S.JUMPS-S.FASER
31BB  C3 EC3D           	JMP	FATSERR 		; S.FASER

                        	ERRNZ	*-SLRB+S.JUMPS-S.DIREA
31BE  C3 CA46           	JMP	DIREAD			; S.DIREA

                        	ERRNZ	*-SLRB+S.JUMPS-S.FCI
31C1  C3 B347           	JMP	FCI			; S.FCI

                        	ERRNZ	*-SLRB+S.JUMPS-S.SCI
31C4  C3 F148           	JMP	SCI			; S.SCI

                        	ERRNZ	*-SLRB+S.JUMPS-S.GUP
31C7  C3 BD51           	JMP	GUP			; S.GUP

      = 0012            SLRBL	EQU	*-SLRB
31CA                    	SPACE	3,10
                        *	.UIVEC Vectors

      = 31CA            SLRC	EQU	*

31CA  C3 5C3D           	JMP	EIRET
31CD  C3 5C3D           	JMP	EIRET
31D0  C3 5C3D           	JMP	EIRET
31D3  C3 5C3D           	JMP	EIRET
31D6  C3 5C3D           	JMP	EIRET
31D9  C3 5C3D           	JMP	EIRET
31DC  C3 0E3D           	JMP	SYSCAL

      = 0015            SLRCL	EQU	*-SLRC
31DF                    	STL	'ADB - Allocate Dynamic Buffers'
31DF                    	EJECT
                        ***	ADB - Allocate Dynamic Buffers
                        *

      = 31DF            ADB	equ	*

31DF  2A 3E32           	LHLD	SYFWA			; system driver address
31E2  11 0900           	LXI	D,DVD.MNU
31E5  19                	DAD	D			; offset to # of units
31E6  7E                	MOV	A,M			; get
31E7  2F                	CMA
31E8  3C                	INR	A			; make negative
31E9  57                	MOV	D,A
31EA  1E 00             	MVI	E,0			; (de) = space req'd for GRTs

31EC  2A EE20           	LHLD	S.RFWA
31EF  19                	DAD	D			; (hl) = SY: GRTs
31F0  22 9D37           	SHLD	ASGA			; save

31F3  11 00FE           	LXI	D,-512
31F6  19                	DAD	D
31F7  22 5121           	SHLD	S.SCR			; system scratch (must page align!)

31FA  22 EE20           	SHLD	S.RFWA			; fix
31FD  22 D020           	SHLD	S.SYSM			;  pointers

                        *	clear prompt

3200  2A 5C00           	LHLD	S.PRMT
3203  36 00             	MVI	M,0			; clear prompt buffer

                        *	Copy default search path

3205  11 5838           	LXI	D,MSDA
3208  01 0500           	LXI	B,MSDAL
320B  2A 5A00           	LHLD	S.PATH
320E  C3 AA18           	JMP	$MOVE
3211                    	STL	'RTT - Relocate TT.DVD'
3211                    	EJECT
                        ***	RTT - Relocate TT.DVD
                        *

      = 3211            RTT	equ	*

3211  2A 1D32           	LHLD	TTFWA			; location of driver
3214  CD 4032           	CALL	RDD			; set it up

3217  22 1D32           	SHLD	TTFWA

321A  3E 09             	MVI	A,DC.LOD
321C  E9                	PCHL				; load device driver

321D  5454              TTFWA	DB	'TT'
321F                    	STL	'RSY - Relocate SY.DVD'
321F                    	EJECT
                        ***	RSY - Relocate SY.DVD
                        *

      = 321F            RSY	equ	*

321F  2A 3E32           	LHLD	SYFWA			; location of driver
3222  CD 4032           	CALL	RDD			; set it up

3225  22 3E32           	SHLD	SYFWA

3228  3E 09             	MVI	A,DC.LOD
322A  CD 9A48           	CALL	THRUHL			; load device driver

322D  AF                	XRA	A			; System Unit
322E  32 3121           	STA	AIO.UNI 		; Set the Boot Unit

3231  21 3852           	LXI	H,ISY
3234  22 5920           	SHLD	SYDD+1			; Stuff new SYDD

3237  2A 3E32           	LHLD	SYFWA
323A  22 BE52           	SHLD	MSYDD			; install system vector

323D  C9                	RET

323E  5359              SYFWA	DB	'SY'
3240                    	STL	'RDD - Relocate Device Driver'
3240                    	EJECT
                        ***	RDD - RELOCATE DEVICE DRIVER
                        *
                        *	ENTRY:	(HL) = FWA OF DRIVER IMAGE
                        *	EXIT:	(HL) = ADDRESS OF DRIVER CODE
                        *		(DE) = LENGTH OF DRIVER CODE
                        *	USES:	ALL

      = 3240            RDD	EQU	*

3240  22 AD32           	SHLD	RDDA			; save file FWA

3243  E5                	PUSH	H
3244  E5                	PUSH	H
3245  E5                	PUSH	H

                        *	calculate locations and offsets

3246  11 1500           	LXI	D,DVD.V30
3249  19                	DAD	D
324A  3E C7             	MVI	A,DVDFLV
324C  BE                	CMP	M			; is 3.0+?
324D  3E 00             	MVI	A,0			; assume default
324F  C2 5432           	JNZ	RDD0			; pre 3.0
                        	ERRNZ	DVD.SPL-DVD.V30-1
3252  23                	INX	H
3253  7E                	MOV	A,M			; preamble length (sectors/2-1)
3254  3C                RDD0	INR	A			; bump
3255  87                	ADD	A			; *2 makes sectors
3256  32 B532           	STA	RDDE			; save
3259  57                	MOV	D,A
325A  1E 00             	MVI	E,0			; (de) = length of SET preamble
325C  E1                	POP	H
325D  19                	DAD	D
325E  22 AF32           	SHLD	RDDB			; save address of code

3261  E1                	POP	H
3262  11 0400           	LXI	D,PIC.PTR
3265  19                	DAD	D
3266  CD 8918           	CALL	$HLIHL			; (hl) = offset to PIC table
3269  D1                	POP	D
326A  19                	DAD	D			; (hl) = address of PIC table
326B  22 B132           	SHLD	RDDC

326E  EB                	XCHG				; (de) = address of PIC table
326F  2A AF32           	LHLD	RDDB			; (hl) = address of driver
3272  CD 9418           	CALL	$CHL
3275  19                	DAD	D			; (hl) = length of driver
3276  22 B332           	SHLD	RDDD			; save

3279  CD 9418           	CALL	$CHL
327C  EB                	XCHG				; (de) = -length
327D  2A EE20           	LHLD	S.RFWA			; top of memory
3280  19                	DAD	D			; (hl) = load address for driver
3281  22 EE20           	SHLD	S.RFWA			; save system
3284  22 D020           	SHLD	S.SYSM			;  values

                        *	relocate the driver image in place

3287  EB                	XCHG				; (de) = destination address
3288  3A B532           	LDA	RDDE			; (a) = preamble length (pages)
328B  92                	SUB	D
328C  2F                	CMA
328D  3C                	INR	A
328E  57                	MOV	D,A			; adjusted location in (de)
328F  2A AD32           	LHLD	RDDA
3292  44                	MOV	B,H
3293  4D                	MOV	C,L			; (bc) = FWA of driver
3294  2A B132           	LHLD	RDDC			; (hl) = PIC table address
3297  CD 7F1B           	CALL	REL

                        *	have relocated driver, now move it to final destination

329A  2A AF32           	LHLD	RDDB
329D  EB                	XCHG				; (de) = driver address
329E  2A B332           	LHLD	RDDD
32A1  44                	MOV	B,H
32A2  4D                	MOV	C,L			; (bc) = driver length (code)
32A3  2A EE20           	LHLD	S.RFWA			; (hl) = final resting place
32A6  CD AA18           	CALL	$MOVE			; copy it up.

                        *	return

32A9  2A EE20           	LHLD	S.RFWA

32AC  C9                	RET
32AD                    	SPACE	3,7
                        *	work cells

32AD  0000              RDDA	DC	2,#0			; file FWA
32AF  0000              RDDB	DC	2,#0			; start of driver code
32B1  0000              RDDC	DC	2,#0			; start of PIC table
32B3  0000              RDDD	DC	2,#0			; length of driver code (less SET)
32B5  0000              RDDE	DC	2,#0			; length of SET preamble (sectors)
32B7                    	STL	'SFM - Set Feature Mask'
32B7                    	EJECT
                        ***	SFM - Set Feature Mask
                        *

      = 32B7            SFM	equ	*

                        *	find machine type

32B7  3A 0920           	LDA	.CTLFLG
32BA  A7                	ANA	A			; 0 if H89
32BB  3E 04             	MVI	A,F.H89 		; assume is
32BD  CA C132           	JZ	SFM1

                        	ERRNZ	F.H8
32C0  AF                	XRA	A			; is H8

32C1  47                SFM1	MOV	B,A			; (b) = feature mask

                        *	find CPU type

32C2  3E 7F             	MVI	A,01111111B
32C4  3C                	INR	A			; test for Z80
32C5  3E 80             	MVI	A,F.Z80 		; assume Z80
32C7  EA D232           	JPE	SFM2			; yep.

32CA  AF                	XRA	A
32CB  A7                	ANA	A			; test for 8085
32CC  27                	DAA
                        	ERRNZ	F.8080			; assume is 8080
32CD  CA D232           	JZ	SFM2			; is 8080

32D0  3E 40             	MVI	A,F.8085		;  else must be 8085

32D2  B0                SFM2	ORA	B
32D3  47                	MOV	B,A			; (b) = updated mask

                        *	find clock speed

32D4  21 1B20           	LXI	H,.TICCNT		; point to clock

32D7  CD E432           	CALL	SFM9			; wait for start of interval
32DA  CD E432           	CALL	SFM9			; now time it, (de) = counter

32DD  7A                	MOV	A,D			; (a) = 0 if 2MHz, 1 if 4MHz, 2 if 6 MHz
                        	ERRNZ	F.2MHZ
                        	ERRNZ	F.4MHZ-1
                        	ERRNZ	F.6MHZ-2

32DE  B0                	ORA	B			; combine clock speed
32DF  47                	MOV	B,A

                        	IFT	0
                        	ENDIF

32E0  32 0500           	STA	S.FMASK 		; set mask
32E3  C9                	RET
32E4                    	SPACE	4,10
                        *	clock timing routine
                        *
                        *	This loop runs approximately 525 times in 2 ms at 6 MHz,
                        *	342 times at 4 MHz, and 164 times at 2 MHz. Speeds other
                        *	than these are not tested. Behavior in systems where the
                        *	clock is turned up and down on the fly is not guaranteed.
                        *	In other words, pick a speed and stay with it!

32E4  11 0000           SFM9	LXI	D,0			; clear counter
32E7  7E                	MOV	A,M			; get #.TICCNT
32E8  BE                SFM9.5	CMP	M			; ticked yet?
32E9  13                	INX	D			; count a loop
32EA  CA E832           	JZ	SFM9.5			; no change
32ED  C9                	RET
32EE                    	STL	'GVM - Give Version Message'
32EE                    	EJECT
                        ***	GVM - Give Version Message
                        *
                        *	if we see an H19, do a little Hollywood.

      = 32EE            GVM	equ	*

32EE  CD 9651           	CALL	$CRLF

32F1  3A 0500           	LDA	S.FMASK
32F4  E6 30             	ANI	F.TERM			; terminal type
32F6  FE 10             	CPI	F.H19			; is H19?
32F8  C2 EB34           	JNZ	GVM1

32FB  CD 5E19           	CALL	$TYPTX

32FE  1B45              	DB	ESC,'E' 		; clear the screen
3300  1B46              	DB	ESC,'F' 		; enter graphics mode

3302  66616366 61636661 	DB	'facfacfaaaacfaaaacfaaaac     faaaac  faaaac',NL
330A  61616163 66616161
3312  61636661 61616163
331A  20202020 20666161
3322  61616320 20666161
332A  6161630A
332E  60206564 20606020 	DB	'` ed `` vc `` fc `` aaat     esaa `  ` fc `',NL
3336  76632060 60206663
333E  20606020 61616174
3346  20202020 20657361
334E  61206020 20602066
3356  6320600A
335A  60206663 20606020 	DB	'` fc `` vd `` ed `vaaa `     fuaa `fc` ed `',NL
3362  76642060 60206564
336A  20607661 61612060
3372  20202020 20667561
337A  61206066 63602065
3382  6420600A
3386  65616465 61646561 	DB	'eadeadeaaaadeaaaadeaaaad     eaaaadedeaaaad',NL
338E  61616164 65616161
3396  61646561 61616164
339E  20202020 20656161
33A6  61616465 64656161
33AE  6161640A
33B2  20206661 61616366 	DB	'  faaacfaaaacfaaaacfacfacfaaaac     '
33BA  61616161 63666161
33C2  61616366 61636661
33CA  63666161 61616320
33D2  20202020
33D6  66616161 63206661 	DB	'faaac faaaac  faaaacfaaaac  faaaacfaaaac',NL
33DE  61616163 20206661
33E6  61616163 66616161
33EE  61632020 66616161
33F6  61636661 61616163
33FE  0A
33FF  20206563 20666460 	DB	'  ec fd` aaat` aaat` `` `` aasd     '
3407  20616161 74602061
340F  61617460 20606020
3417  60602061 61736420
341F  20202020
3423  60206161 75636020 	DB	'` aauc` fc `  ` fc `eaac `  ` fc `` fc `',NL
342B  66632060 20206020
3433  66632060 65616163
343B  20602020 60206663
3443  20606020 66632060
344B  0A
344C  20206664 20656376 	DB	'  fd ecvaaa `vaaa `` ed `` aauc     '
3454  61616120 60766161
345C  61206060 20656420
3464  60602061 61756320
346C  20202020
3470  76616161 20606020 	DB	'vaaa `` ed `fc` ed `   ` `fc` ed `` ed `',NL
3478  65642060 66636020
3480  65642060 20202060
3488  20606663 60206564
3490  20606020 65642060
3498  0A
3499  20206561 61616465 	DB	'  eaaadeaaaadeaaaadeaaaadeaaaad     '
34A1  61616161 64656161
34A9  61616465 61616161
34B1  64656161 61616420
34B9  20202020
34BD  65616161 61646561 	DB	'eaaaadeaaaadedeaaaad   eadedeaaaadeaaaad',NL
34C5  61616164 65646561
34CD  61616164 20202065
34D5  61646564 65616161
34DD  61646561 61616164
34E5  0A

34E6  1BC7              	DB	ESC,'G'+EOL		; exit graphics mode

34E8  C3 1235           	JMP	GVM2

34EB  CD 5E19           GVM1	CALL	$TYPTX
34EE  48444F53 2C205665 	db	'HDOS, Version ',VERS/16+'0','.',VERS%16+'0',NL
34F6  7273696F 6E20332E
34FE  300A
3500  20497373 75652023 	db	' Issue # 50.07.00',ENL
3508  2035302E 30372E30
3510  308A

3512  CD 5E19           GVM2	CALL	$TYPTX
3515  0A                	db	NL
3516  53797374 656D2068 	db	'System has '
351E  617320
3521  78784B20 6F662052 GVMA	db	'xxK of RAM',NL
3529  414D0A
352C  8A                	db	ENL

352D  C9                	RET
352E                    	STL	'FSM - Fake System Mount'
352E                    	EJECT
                        ***	FSM - Fake System Mount
                        *

      = 352E            FSM	EQU	*

352E  3E 07             	MVI	A,DC.ABT
3530  CD 5820           	CALL	SYDD

                        *	read volume label

3533  21 0000           	LXI	H,0			; Mount as
3536  3E 08             	MVI	A,DC.MOU		;  volume
3538  CD 5820           	CALL	SYDD			;   zero

353B  01 0001           	LXI	B,256
353E  11 002E           	LXI	D,SYSLAB
3541  21 0900           	LXI	H,DDF.LAB
                        	ERRNZ	DC.REA
3544  AF                	XRA	A
3545  CD 5820           	CALL	SYDD			; READ LABEL
3548  DC 5D38           	CC	BOOTERR

                        *	mount the device so volume parameters are set up

354B  3A 002E           	LDA	SYSLAB+LAB.SER
354E  6F                	MOV	L,A
354F  26 00             	MVI	H,0			; (HL) = VOLUME SERIAL
3551  3E 08             	MVI	A,DC.MOU
3553  CD 5820           	CALL	SYDD			; mount
3556  DC 5D38           	CC	BOOTERR

                        *	save parameters

3559  2A 052E           	LHLD	SYSLAB+LAB.GRT
355C  22 2421           	SHLD	AIO.GRT 		; GRT sector

355F  3A 072E           	LDA	SYSLAB+LAB.SPG
3562  32 2621           	STA	AIO.SPG 		; sectors/group

3565  C9                	RET
3566                    	STL	'SDT - Setup Device Table'
3566                    	EJECT
                        **	SDT - SETUP DEVICE TABLE.
                        *
                        *	SDT SCANS THE SYSTEM DISK DIRECTORY LOOKING FOR FILES IN
                        *	THE FORM:
                        *
                        *	XX	.DVD
                        *
                        *	THESE ENTRYS ARE BUILT INTO THE DEVICE TABLE
                        *
                        *	Modified to dynamically allocate the device table and
                        *	to provide an audit trail as drivers are found.

      = 3566            SDT	EQU	*

3566  CD 5E19           	CALL	$TYPTX
3569  44726976 65727320 	DB	'Drivers found ','-'+EOL
3571  666F756E 6420AD

3578  AF                	XRA	A			; do count only the first time
3579  CD AC35           	CALL	SDT0

                        *	allocate the table

357C  3A 1C36           	LDA	SDTD			; get count			
357F  11 0E00           	LXI	D,DEVELEN		; entry length
3582  CD 0719           	CALL	$MU86			;  times number of entries
3585  23                	INX	H			;   plus terminating byte

3586  CD 9418           	CALL	$CHL			; negate it
3589  EB                	XCHG
358A  2A EE20           	LHLD	S.RFWA			; system start
358D  19                	DAD	D			; subtract
358E  22 EE20           	SHLD	S.RFWA			; new start
3591  22 D020           	SHLD	S.SYSM
3594  22 EC20           	SHLD	S.DFWA			; set device table address

                        *	clear the table

                        	ERRNZ	DV.EL

3597  3A 1C36           	LDA	SDTD			; number of entries
359A  4F                	MOV	C,A
359B  2A EC20           	LHLD	S.DFWA			; start of table
359E  06 0E             SDT0.5	MVI	B,DEVELEN
35A0  CD 8A19           	CALL	$ZERO
35A3  0D                	DCR	C
35A4  C2 9E35           	JNZ	SDT0.5

35A7  CD 9651           	CALL	$CRLF

                        *	done with allocation. build it for real.

35AA  3E FF             	MVI	A,-1							
                        	ERRNZ	*-SDT0

      = 35AC            SDT0	EQU	*

35AC  32 1B36           	STA	SDTC			; remember what we're doing

35AF  2A 032E           	LHLD	SYSLAB+LAB.DIS
35B2  22 FE2D           	SHLD	SDTA+DIS.LNK		; SET SECTOR NUMBER TO READ

                        *	READ NEXT SECTOR

35B5  2A FE2D           SDT1	LHLD	SDTA+DIS.LNK
35B8  7C                	MOV	A,H
35B9  B5                	ORA	L
35BA  C8                	RZ				; NO MORE DIRECTORY, AM DONE
35BB  11 002C           	LXI	D,SDTA
35BE  01 0002           	LXI	B,512
35C1  CD BD19           	CALL	S.READ			; READ DIRECTORY

                        *	RUN DOWN THROUGH ENTRYS LOOKING FOR XX.DVD

35C4  21 002C           	LXI	H,SDTA
35C7  7E                SDT2	MOV	A,M
35C8  A7                	ANA	A
35C9  CA B535           	JZ	SDT1			; END OF SECTOR
                        	ERRNZ	DF.EMP-377Q
35CC  3C                	INR	A
35CD  CA 0936           	JZ	SDT4			; ENTRY IS EMPTY
                        	ERRNZ	DF.CLR-376Q
35D0  3C                	INR	A
35D1  C8                	RZ				; NO MORE IN DIRECTORY
35D2  E5                	PUSH	H
35D3  23                	INX	H
35D4  7E                	MOV	A,M
35D5  A7                	ANA	A
35D6  CA 0836           	JZ	SDT3			; IS ONE-CHARACTER NAME
35D9  23                	INX	H
35DA  11 1236           	LXI	D,SDTB
35DD  01 0900           	LXI	B,SDTBL
35E0  CD 3018           	CALL	$COMP			; COMPARE
35E3  C2 0836           	JNE	SDT3			; NOT MATCH

                        *	got one. see what we should do with it.

35E6  3A 1B36           	LDA	SDTC			; operation			
35E9  A7                	ANA	A
35EA  CA F535           	JZ	SDT2.5			; count only

                        *	enter a device into the table

35ED  E1                	POP	H
35EE  E5                	PUSH	H			; (HL) = ENTRY FWA
35EF  CD 1D36           	CALL	EDL			; ENTER DRIVER IN LIST

35F2  C3 0836           	JMP	SDT3			; skip

                        *	count the device

35F5  21 1C36           SDT2.5	LXI	H,SDTD							
35F8  34                	INR	M

35F9  E1                	POP	H			; entry FWA
35FA  E5                	PUSH	H
35FB  CD 8918           	CALL	$HLIHL			; (HL) = device name
35FE  22 0536           	SHLD	SDTE

3601  CD 5E19           	CALL	$TYPTX
3604  20                	DB	' '
3605  5858BA            SDTE	DB	'XX',':'+EOL

                        *	TRY ANOTHER ENTRY

3608  E1                SDT3	POP	H			; (HL) = ENTRY FWA
3609  3A FB2D           SDT4	LDA	SDTA+DIS.ENL
360C  CD 4118           	CALL	$DADA.			; ADVANCE
360F  C3 C735           	JMP	SDT2			; TRY NEXT
3612                    	SPACE	3
3612  00000000 00004456 SDTB	DB	0,0,0,0,0,0,'DVD'	; REQUIRED EXTENSION
361A  44
      = 0009            SDTBL	EQU	*-SDTB			; LENGTH OF PATTERN

361B  00                SDTC	DB	0			; operation (0=count only)	
361C  00                SDTD	DB	0			; number of devices found
361D                    	SPACE	4,10
                        **	EDL - ENTER DEVICE IN DEVICE LIST.
                        *
                        *	EDL ENTERS DEVICE DRIVER INFORMATION INTO THE
                        *	DEVLST.
                        *
                        *	THE FILE IS READ TO SETUP THE DEVICE TABLE ENTRY.
                        *
                        *	ENTRY	(HL) = FWA DIRECTROY ENTRY FOR DRIVER
                        *	EXIT	DRIVER IN DEVLST IF ALL OK
                        *		DRIVER IGNORED IF PROBLEMS
                        *	USES	ALL

      = 361D            EDL	EQU	*

361D  5E                	MOV	E,M
361E  23                	INX	H
361F  56                	MOV	D,M			; (DE) = NAME
3620  EB                	XCHG
3621  22 6637           	SHLD	EDLNAM			; SET NAME FIELD IN DEVLST ENTRY
3624  22 5F37           	SHLD	EDLD			; SET NAME FOR MESSAGE

                        *	SETUP SECTOR ADDRESS FOR DRIVER

3627  21 0F00           	LXI	H,DIR.FGN-1
362A  19                	DAD	D			; (HL) = #DIR.FGN
362B  7E                	MOV	A,M			; (A) = FIRST GROUP
362C  32 7337           	STA	EDLDVG			; SET DRIVER FIRST GROUP

                        *	READ FIRST SECTOR OF DRIVER FILE

362F  5F                	MOV	E,A
3630  16 00             	MVI	D,0			; (DE) = GROUP
3632  3A 072E           	LDA	SYSLAB+LAB.SPG		; A  = Sectors/Group
3635  CD 0719           	CALL	$MU86			; (HL) = SECTOR ADDRESS OF 1ST GROUP
3638  11 002F           	LXI	D,BUFF
363B  01 0001           	LXI	B,256
363E  CD BD19           	CALL	S.READ			; READ IT

                        *	SEE IF PIC FILE

3641  2A 002F           	LHLD	BUFF
3644  2C                	INR	L
3645  C2 3737           	JNZ	EDL5			; NOT BINARY
3648  3E 01             	MVI	A,FT.PIC
364A  BC                	CMP	H
364B  C2 3737           	JNE	EDL5			; NOT PIC

                        *	SET DEVICE CAPABILITY BYTE

364E  3A 062F           	LDA	BUFF+DVD.DVD		; (A) = DRIVER FLAG
3651  FE C7             	CPI	DVDFLV			; SEE IF DRIVER
3653  C2 3737           	JNE	EDL5			; NOT DRIVER
3656  3A 072F           	LDA	BUFF+DVD.CAP
3659  32 6C37           	STA	EDLCAP			; SET DEVICE CAPABILITY FLAGS
365C  3A 082F           	LDA	BUFF+DVD.MUM
365F  32 6D37           	STA	EDLMUM			; SET UP MOUNTED UNITS MASK
3662  3A 092F           	LDA	BUFF+DVD.MNU
3665  32 6E37           	STA	EDLMNU			; SET MAXIMUM NUMBER OF UNITS

                        *	set SET preamble length

3668  3A 152F           	LDA	BUFF+DVD.V30
366B  FE C7             	CPI	DVDFLV			; is 3.0+ driver?
366D  3E 00             	MVI	A,0
366F  C2 7536           	JNZ	EDL.0			; no. use default.

3672  3A 162F           	LDA	BUFF+DVD.SPL		; preamble length

                        	ERRNZ	DR.SPL-11100000B
3675  0F                EDL.0	RRC				; rotate
3676  0F                	RRC				;  into
3677  0F                	RRC				;   place...
3678  E6 E0             	ANI	DR.SPL			; mask
367A  32 6837           	STA	EDLRES			;  and save

                        *	ALLOCATE UNIT DESCRIPTOR TABLES

367D  3A 092F           	LDA	BUFF+DVD.MNU		; A  = MAX. NUMBER OF UNITS
3680  11 0800           	LXI	D,UNT.SIZ
3683  CD 0719           	CALL	$MU86			; HL = MEMORY TO ALLOCATE
3686  CD 9418           	CALL	$CHL
3689  EB                	XCHG
368A  2A EE20           	LHLD	S.RFWA
368D  19                	DAD	D			; HL = NEW FWA

368E  22 EE20           	SHLD	S.RFWA
3691  22 D020           	SHLD	S.SYSM
3694  22 6F37           	SHLD	EDLPTR

3697  E5                	PUSH	H

3698  3A 092F           	LDA	BUFF+DVD.MNU		; NUMBER OF UNITS
369B  87                	ADD	A			; *2
369C  87                	ADD	A			; *4
369D  87                	ADD	A			; *8 - (A) = TOTAL SIZE OF TABLE
                        	ERRNZ	UNT.SIZ-8
369E  47                	MOV	B,A
369F  CD 8A19           	CALL	$ZERO			; CLEAR IT OUT

36A2  E1                	POP	H

                        *	INITIALIZE THE UNIT DESCRIPTOR TABLE

36A3  3A 072F           	LDA	BUFF+DVD.CAP
36A6  47                	MOV	B,A			; B  = DEVICE CAPABILITY FLAGS
36A7  11 0A2F           	LXI	D,BUFF+DVD.UFL
36AA  3A 092F           	LDA	BUFF+DVD.MNU

36AD  3D                EDL0	DCR	A
36AE  FA C436           	JM	EDL0.5			; FINISHED WITH THE UNITS

36B1  F5                	PUSH	PSW
36B2  1A                	LDAX	D			; A  = FLAG VALUE FOR THIS UNIT
36B3  A0                	ANA	B			; MAP OUT ILLEGAL BITS
36B4  CD FB51           	CALL	$INDSB
36B7  0000              	DW	UNT.FLG
36B9  D5                	PUSH	D
36BA  11 0800           	LXI	D,UNT.SIZ
36BD  19                	DAD	D			; HL = NEXT UNIT DESCRIPTOR
36BE  D1                	POP	D
36BF  13                	INX	D			; MOVE TO NEXT UNIT
36C0  F1                	POP	PSW
36C1  C3 AD36           	JMP	EDL0

      = 36C4            EDL0.5	EQU	*

                        *	SET LENGTH

36C4  3A 6837           	LDA	EDLRES			; get residence (and SPL)
36C7  E6 E0             	ANI	DR.SPL
                        	ERRNZ	DR.SPL-11100000B
36C9  07                	RLC				; shift
36CA  07                	RLC				;  to low
36CB  07                	RLC				;   order bits
36CC  3C                	INR	A			; adjust
36CD  87                	ADD	A			; *2
36CE  2F                	CMA
36CF  3C                	INR	A			; negate
36D0  47                	MOV	B,A
36D1  0E 00             	MVI	C,0			; (BC) = -LENGTH
36D3  2A 042F           	LHLD	BUFF+PIC.PTR
36D6  09                	DAD	B			; (HL) = DRIVER LENGTH
36D7  D2 3737           	JNC	EDL5			; huh???
36DA  22 7137           	SHLD	EDLDVL

                        *	HAVE BUILT ENTRY FOR DEVLST. INSERT.

36DD  2A EC20           	LHLD	S.DFWA
36E0  3A 1C36           	LDA	SDTD			; get size of table		
36E3  47                	MOV	B,A
36E4  11 0E00           	LXI	D,DEVELEN

36E7  7E                EDL1	MOV	A,M
36E8  A7                	ANA	A
                        	ERRNZ	DV.EL			; DEVICE END OF LIST FLAG
36E9  CA 2B37           	JZ	EDL3			; GOT ONE
36EC  19                	DAD	D			; next place
36ED  05                	DCR	B
36EE  C2 E736           	JNZ	EDL1			; TRY NEXT

                        *	NO ROOM FOR IT. (THIS SHOULD NEVER HAPPEN!!!)

36F1  CD 5E19           	CALL	$TYPTX
36F4  0A073F30 3120546F 	DB	NL,BELL,'?01 Too Many Device Drivers.',' '+EOL
36FC  6F204D61 6E792044
3704  65766963 65204472
370C  69766572 732EA0
3713  21 5F37           EDL2	LXI	H,EDLD			; TYPE NAME
3716  3E 0A             	MVI	A,10
3718  CD 2852           	CALL	$TYPCC			; TYPE NAME
371B  CD 5E19           	CALL	$TYPTX
371E  202D2049 676E6F72 	DB	' - Ignored.',ENL
3726  65642E8A
372A  C9                	RET

                        *	GOT SPOT. PUT IT IN.

372B  11 6637           EDL3	LXI	D,EDLDEV
372E  01 0E00           	LXI	B,DEVELEN
3731  CD AA18           	CALL	$MOVE			; COPY INTO TABLE
3734  36 00             	MVI	M,0			; CLEAR NEXT ENTRY
3736  C9                	RET				; RETURN

                        *	ERROR IN DRIVER FORMAT

3737  CD 5E19           EDL5	CALL	$TYPTX
373A  0A073F30 3120466F 	DB	NL,BELL,'?01 Format Error in Driver File',' '+EOL
3742  726D6174 20457272
374A  6F722069 6E204472
3752  69766572 2046696C
375A  65A0
375C  C3 1337           	JMP	EDL2

375F  58582E44 564400   EDLD	DB	'XX.DVD',0		; Device Name

      = 3766            EDLDEV	EQU	*
                        	ERRNZ	*-EDLDEV-DEV.NAM
3766  2020              EDLNAM	DB	'  '			; DEVICE NAME
                        	ERRNZ	*-EDLDEV-DEV.RES
3768  00                EDLRES	DB	0			; NOT RESIDENT
                        	ERRNZ	*-EDLDEV-DEV.JMP
3769  C3                	DB	MI.JMP			; JUMP OPCODE
                        	ERRNZ	*-EDLDEV-DEV.DDA
376A  0549              	DW	SDD			; DRIVER ADDRESS (STAND-IN DEVICE DRIVER)
                        	ERRNZ	*-EDLDEV-DEV.FLG
376C  00                EDLCAP	DB	0			; FLAGS
                        	ERRNZ	*-EDLDEV-DEV.MUM
376D  00                EDLMUM	DB	0			; MOUNTED UNIT MASK
                        	ERRNZ	*-EDLDEV-DEV.MNU
376E  01                EDLMNU	DB	1			; MAXIMUM NUMBER OF UNITS
                        	ERRNZ	*-EDLDEV-DEV.UNT
376F  0000              EDLPTR	DW	0			; UNIT POINTER
                        	ERRNZ	*-EDLDEV-DEV.DVL
3771  0000              EDLDVL	DW	0			; DRIVER LENGTH
                        	ERRNZ	*-EDLDEV-DEV.DVG
3773  00                EDLDVG	DB	0			; DRIVER SECTOR FIRST GROUP NUMBER
                        	ERRNZ	*-EDLDEV-DEVELEN
3774                    	STL	'ASG - Allocate System GRT Tables'
3774                    	EJECT
                        ***	ASG - Allocate System GRTs
                        *

                        *	allocate GRTs for SY: and update unit table

      = 3774            ASG	EQU	*

3774  2A 5838           	LHLD	MSDA
3777  EB                	XCHG				; DE = SYSTEM DEVICE NAME
3778  FF 0A             	SCALL	.GDA			; (BC) = TABLE ENTRY ADDRESS

377A  21 0900           	LXI	H,DEV.UNT
377D  09                	DAD	B
377E  CD 8918           	CALL	$HLIHL			; (HL) = UNIT TABLE ADDRESS
3781  EB                	XCHG				; UNIT TABLE ADDRESS IN (DE)

3782  21 0800           	LXI	H,DEV.MNU
3785  09                	DAD	B
3786  7E                	MOV	A,M			; (A) = NUMBER OF UNITS

3787  2A 9D37           	LHLD	ASGA			; base of GRTs (also SY0: GRT address)
378A  22 B645           	SHLD	DMOA			; save for dismount/mount

                        *	(DE) = Unit Specific Table Address
                        *	(HL) = Base of GRTs
                        *	 (A) = # of units

378D  EB                	XCHG				; (HL) = TABLE ADDRESS, (DE) = GRT
378E  01 0800           	LXI	B,UNT.SIZ		; size of table entry

3791  CD E051           ASG1	CALL	$INDS			; INSTALL IN TABLE
3794  0200              	DW	UNT.GRT
3796  09                	DAD	B
3797  14                	INR	D			; bump up GRT address by 256
3798  3D                	DCR	A
3799  C2 9137           	JNZ	ASG1

379C  C9                	RET

379D  0000              ASGA	DW	0			; address of SY: GRTs
379F                    	STL	'ACT - Allocate Channel Table'
379F                    	EJECT
                        ***	ACT - Allocate Channel Table					
                        *
                        *	ACT allocates a channel table of length determined by the
                        *	value contained at FLT.MNC.

      = 379F            ACT	EQU	*							

379F  3A 0930           	LDA	HOSTAB+FLT.MNC		; number of channels
37A2  11 2A00           	LXI	D,IOCELEN		; length of table entry
37A5  CD 0719           	CALL	$MU86			; (hl) = total length of table

37A8  CD 9418           	CALL	$CHL			; negate it
37AB  EB                	XCHG
37AC  2A EE20           	LHLD	S.RFWA			; old system FWA
37AF  19                	DAD	D			; subtract table size
37B0  22 EE20           	SHLD	S.RFWA			; new system FWA
37B3  22 D020           	SHLD	S.SYSM
37B6  22 EA20           	SHLD	S.CFWA			; set channel table FWA

                        *	connect the links

37B9  3A 0930           	LDA	HOSTAB+FLT.MNC		; number of channels
37BC  3D                	DCR	A			;  (only the first N-1)
37BD  01 2A00           	LXI	B,IOCELEN		; entry size

37C0  F5                ACT1	PUSH	PSW			; save loop counter
37C1  54                	MOV	D,H			; (de) = address of this entry
37C2  5D                	MOV	E,L
37C3  09                	DAD	B			; (hl) = address of next entry
37C4  EB                	XCHG				; swap
37C5  73                	MOV	M,E			; install
37C6  23                	INX	H			;  the link
37C7  72                	MOV	M,D
37C8  23                	INX	H
                        	ERRNZ	IOCELEN/256
37C9  06 28             	MVI	B,IOCELEN-2
37CB  CD 8A19           	CALL	$ZERO			; clear the rest of the entry
37CE  F1                	POP	PSW
37CF  3D                	DCR	A			; done?
37D0  C2 C037           	JNZ	ACT1			; no, loop.

                        *	clear the entry

                        	ERRNZ	IOCELEN/256
37D3  41                	MOV	B,C			; (b) = size of entire entry
37D4  C3 8A19           	JMP	$ZERO			; clear, including link.
37D7                    	STL	'MSD - Mount System Diskette'
37D7                    	EJECT
                        **	MSD - Mount System Diskette
                        *

      = 37D7            MSD	EQU	*

37D7  CD 9651           	CALL	$CRLF			; for aesthetics

                        *	Fix device table for SY: and TT:

37DA  11 5454           	LXI	D,'TT'
37DD  2A 1D32           	LHLD	TTFWA			; FWA of TT.DVD
37E0  CD 4438           	CALL	MSD1

37E3  2A 5838           	LHLD	MSDA
37E6  EB                	XCHG				; DE = DEVICE NAME
37E7  21 3852           	LXI	H,ISY
37EA  CD 4438           	CALL	MSD1

37ED  60                	MOV	H,B
37EE  69                	MOV	L,C
37EF  22 F847           	SHLD	GSPA			; save devtab address for SY:

                        *	Mount the volume

37F2  21 5838           	LXI	H,MSDA
37F5  FF 80             	SCALL	.MOUNT			; Mount the volume

37F7  F5                	PUSH	PSW

37F8  CD 9651           	CALL	$CRLF			; for aesthetics

37FB  3E 01             	MVI	A,1
37FD  32 1A21           	STA	S.MOUNT 		; flag system disk mounted

3800  F1                	POP	PSW
3801  DA 1C38           	JC	MSD0			; ERROR in mount

                        *	Setup work cells for LDD

3804  2A F847           	LHLD	GSPA			; find table entry for SY:
3807  11 0900           	LXI	D,DEV.UNT
380A  19                	DAD	D
380B  CD 8918           	CALL	$HLIHL			; (hl) = address of SY0: unit table
380E  23                	INX	H
                        	ERRNZ	UNT.SPG-1
380F  7E                	MOV	A,M			; (a) = sectors/group
3810  32 C648           	STA	LDD8B
3813  23                	INX	H
                        	ERRNZ	UNT.GRT-UNT.SPG-1
3814  CD 8918           	CALL	$HLIHL			; (hl) = GRT address for SY0:
3817  22 C448           	SHLD	LDD8A

381A  A7                	ANA	A
381B  C9                	RET

                        *	An error in mount

381C  CD 5E19           MSD0	CALL	$TYPTX
381F  0A                	DB	NL
3820  3F303120 556E6162 	DB	'?01 Unable To Mount System Disk.',ENL
3828  6C652054 6F204D6F
3830  756E7420 53797374
3838  656D2044 69736B2E
3840  8A
3841  C3 8238           	JMP	BOOTABT

                        *	fix system driver entry

3844  E5                MSD1	PUSH	H			; SAVE FWA

3845  FF 0A             	SCALL	.GDA			; (BC) = TABLE ENTRY ADDRESS

3847  21 0200           	LXI	H,DEV.RES		; RESIDENCE FLAG
384A  09                	DAD	B
384B  3E 07             	MVI	A,DR.IM+DR.PR+DR.FX	; IN/PERMANENT/FIXED
384D  B6                	ORA	M
384E  77                	MOV	M,A			; SET

384F  21 0400           	LXI	H,DEV.DDA		; DRIVER ENTRY
3852  09                	DAD	B
3853  D1                	POP	D			; (DE) = DRIVER FWA
3854  73                	MOV	M,E			; INSTALL
3855  23                	INX	H
3856  72                	MOV	M,D

3857  C9                	RET
3858                    	SPACE	3
3858  5359303A 00       MSDA	DB	'SY0:',0		; Device specification
      = 0005            MSDAL	EQU	*-MSDA
385D                    	SPACE	4,10
                        **	BOOTERR - ERROR DURING BOOT.
                        *
                        *	I/O ERRORS COME HERE

385D  CD 5E19           BOOTERR CALL	$TYPTX
3860  0A073F30 31204469 	DB	NL,BELL,'?01 Disk I/O Error During Boot.',ENL
3868  736B2049 2F4F2045
3870  72726F72 20447572
3878  696E6720 426F6F74
3880  2E8A
                        *	JMP	BOOTABT
                        	ERRNZ	*-BOOTABT
3882                    	SPACE	4,10
                        **	BOOTABT - ABORT BOOT.
                        *

3882  CD 5E19           BOOTABT	CALL	$TYPTX
3885  2020426F 6F742041 	DB	'  Boot Aborted','.'+EOL				
388D  626F7274 6564AE

3894  C3 9438           	JMP	*
3897                    	STL	'Boot Subroutines'
3897                    	EJECT
                        **	SSD - SET SYSTEM DATE.
                        *
                        *	SSD PROMPTS THE USER AS
                        *
                        *	Date <DD-MMM-YY> ?
                        *
                        *	THE 'DD-MMM-YY' FIELD IS REPLACED BY THE CURRENT
                        *	SYSTEM DATE, IF A VALID ONE IS IN MEMORY.
                        *
                        *	Modified:	If a valid date is not in memory, use
                        *			the default from the disk being booted.
                        *
                        *			If a valid date *IS* in memory, don't
                        *			even bother the user with it.			
                        *
                        *	ENTRY	NONE
                        *	EXIT	NONE
                        *	USES	ALL

      = 3897            SSD	EQU	*

3897  3A 0B30           	LDA	HOSTAB+FLT.PBO
389A  E6 01             	ANI	PBO.DAT
389C  C2 A538           	JNZ	SSD0			; User Wants the Date

389F  21 0000           	LXI	H,0
38A2  C3 6139           	JMP	SSD8			; Stuff the Date

38A5  AF                SSD0	XRA	A
38A6  32 6B39           	STA	SSDA			; Flag default legal
38A9  2A C820           	LHLD	S.DATC
38AC  EB                	XCHG				; DE = Compressed Date
38AD  21 802B           	LXI	H,SSDB			; HL = Date Field
38B0  7A                	MOV	A,D
38B1  B3                	ORA	E
38B2  CA C838           	JZ	SSD1			; No-Date is Illegal Here
38B5  CD 393B           	CALL	$DAD
38B8  DA C838           	JC	SSD1			; Illegal Coded Date

                        *	Compare Decoded date against RAM date

38BB  01 0900           	LXI	B,9
38BE  11 BF20           	LXI	D,S.DATE
38C1  21 802B           	LXI	H,SSDB
38C4  CD 3018           	CALL	$COMP
38C7  C8                	RZ				; Date field assumed legal	

                        *	Set a new default date

38C8  2A 8722           SSD1	LHLD	SB.DAT
38CB  22 C820           	SHLD	S.DATC			; Set new default date
38CE  EB                	XCHG				; DE = Compressed Date
38CF  21 BF20           	LXI	H,S.DATE		; HL = Date Field
38D2  7A                	MOV	A,D
38D3  B3                	ORA	E
38D4  CA DD38           	JZ	SSD1.5			; No-Date
38D7  CD 393B           	CALL	$DAD
38DA  D2 E238           	JNC	SSD1.7			; Legal default date
38DD  3E 01             SSD1.5	MVI	A,1
38DF  32 6B39           	STA	SSDA			; Set Default Illegal

38E2  CD 9651           SSD1.7	CALL	$CRLF			; for looks

                        *	Get date from user

38E5  CD 5E19           SSD2	CALL	$TYPTX
38E8  44617465 20BC     	DB	'Date ','<'+EOL
38EE  3A 6B39           	LDA	SSDA
38F1  A7                	ANA	A
38F2  CA 0439           	JZ	SSD3			; Legal Default Date

38F5  CD 5E19           	CALL	$TYPTX
38F8  64642D6D 6D6D2D79 	DB	'dd-mmm-y','y'+EOL
3900  F9
3901  C3 0C39           	JMP	SSD4

3904  3E 09             SSD3	MVI	A,9
3906  21 BF20           	LXI	H,S.DATE
3909  CD 2852           	CALL	$TYPCC			; Type a good date

                        *	GET REPLY

390C  CD 5E19           SSD4	CALL	$TYPTX
390F  3E203FA0          	DB	'> ?',' '+EOL
3913  21 802B           	LXI	H,SSDB
3916  CD 143A           	CALL	$RTL.			; READ TEXT LINE (UPPER CASE)
3919  DA E538           	JC	SSD2			; CTL-D STRUCK
391C  7E                	MOV	A,M
391D  A7                	ANA	A
391E  C2 2939           	JNZ	SSD5			; GIVEN REPLY

                        *	HE DEFAULTED. SEE IF DEFAULT ALLOWED

3921  3A 6B39           	LDA	SSDA	
3924  A7                	ANA	A
3925  C8                	rz				; default ok, exit
3926  C3 2F39           	JMP	SSD6			; MAKE IT CLEAR WHAT WE WANT

                        *	CRACK DATE

3929  CD 3B3A           SSD5	CALL	$CAD			; CONVERT AUGUSTAN DATE
392C  D2 6039           	JNC	SSD7			; DATE GOOD

                        *	HIS REPLY BAD. TRY AGAIN

392F  CD 5E19           SSD6	CALL	$TYPTX
3932  0720456E 74657220 	DB	BELL,' Enter date as dd-mmm-yy (eg., '
393A  64617465 20617320
3942  64642D6D 6D6D2D79
394A  79202865 672E2C20
3952  31 312D 4D61722D31	DATE
395A  35
395B  298A              	DB	')',ENL
395D  C3 E538           	JMP	SSD2			; TRY AGAIN

                        *	DATE IS GOOD. SETUP TWO DATE FIELDS FOR SYSTEM

3960  EB                SSD7	XCHG
3961  22 C820           SSD8	SHLD	S.DATC			; SET DATE CODE
3964  EB                	XCHG
3965  21 BF20           	LXI	H,S.DATE
3968  C3 393B           	jmp	$dad			; DECODE DATE INTO ASCII

396B  00                SSDA	DB	0			; =0 IFF DEFAULT DATE ALLOWED
396C                    	SPACE	4,10
                        **	UBP	- Update Boot Parameters
                        *
                        *	UBP updates the boot parameters by rewriting sector
                        *	zero.  Since track 0 is written as volume zero, the
                        *	volume number must be temporarily adjusted.
                        *
                        *	ENTRY:	S.DATC	= Current Compressed Date
                        *
                        *	EXIT:	None
                        *
                        *	USES:	ALL
                        *

      = 396C            UBP	EQU	*

396C  3A 8322           	LDA	SB.VER
396F  FE 30             	CPI	VERS
3971  C0                	RNZ				; Only Update if versions match

3972  01 1D00           	LXI	B,UBPAL
3975  11 8322           	LXI	D,SB.VER
3978  21 D439           	LXI	H,UBPA
397B  CD AA18           	CALL	$MOVE			; Get the original parameters

397E  2A C820           	LHLD	S.DATC
3981  22 D839           	SHLD	UBPA-SB.VER+SB.DAT	; Update Date
3984  2A E420           	LHLD	S.BAUD
3987  22 D639           	SHLD	UBPA-SB.VER+SB.BAU	; Update Baud-Rate

398A  0E 1D             	MVI	C,UBPAL
398C  11 8322           	LXI	D,SB.VER
398F  21 D439           	LXI	H,UBPA
3992  CD 3018           	CALL	$COMP
3995  C8                	RZ				; No change in parameters

3996  01 1D00           	LXI	B,UBPAL
3999  11 D439           	LXI	D,UBPA
399C  21 8322           	LXI	H,SB.VER
399F  CD AA18           	CALL	$MOVE			; Move the new data into parameter area

39A2  21 0000           	LXI	H,0
39A5  3E 08             	MVI	A,DC.MOU
39A7  CD 5820           	CALL	SYDD			; Mount the disk as volume zero
39AA  DC 0B21           	CC	S.FASER

39AD  01 0001           	LXI	B,256
39B0  11 8022           	LXI	D,SB.BOO
39B3  21 0000           	LXI	H,0
                        	ERRNZ	DC.WRI-1
39B6  78                	MOV	A,B
39B7  CD 5820           	CALL	SYDD			; Re-Write the Sector
39BA  D2 C539           	JNC	UBP1
39BD  FE 15             	CPI	EC.WP
39BF  CA C539           	JZ	UBP1			; Ignore Write-Protect Error

39C2  CD 0B21           	CALL	S.FASER 		; Other errors are fatal

39C5  3A 002E           UBP1	LDA	SYSLAB+LAB.SER
39C8  6F                	MOV	L,A
39C9  26 00             	MVI	H,0			; HL = Volume number
39CB  3E 08             	MVI	A,DC.MOU
39CD  CD 5820           	CALL	SYDD			; Re-Mount the disk
39D0  DC 0B21           	CC	S.FASER

39D3  C9                	RET

39D4  00000000 00000000 UBPA	DC	SB.BPE-SB.VER,#0	; Reserve Space for temporary	
39DC  00000000 00000000
39E4  00000000 00000000
39EC  00000000 00
      = 001D            UBPAL	EQU	*-UBPA
39F1                    	STL	'Boot Common Decks'
39F1                    	EJECT
39F1                    	LON	C
39F1                    	XTEXT	MLU
39F1                    	SPACE	4,10
                        **	MLU - MAP LOWER CASE LINE TO UPPER CASE.
                        *
                        *	MLU MAPS THE LOWER CASE ALPHABETICS IN A LINE TO UPPER CASE.
                        *
                        *	ENTRY	(HL)  = LINE FWA
                        *	EXIT	NONE
                        *	USES	NONE

39F1  F5                $MLU	PUSH	PSW	;SAVE (PSW)
39F2  E5                	PUSH	H	;SAVE FWA
39F3  2B                	DCX	H	;ANTICIPATE INX H
39F4  23                $MLU1	INX	H
39F5  7E                	MOV	A,M	;(A)= CHARACTER
39F6  CD 1152           	CALL	$MCU	;MAP CHAR TO UPPER
39F9  77                	MOV	M,A
39FA  A7                	ANA	A
39FB  C2 F439           	JNZ	$MLU1	;MORE TO GO
39FE  E1                	POP	H	;RESTORE (HL)
39FF  F1                	POP	PSW	;RESTORE (PSW)
3A00  C9                	RET
3A01                    	XTEXT	MOVEL
3A01                    	SPACE	4,10
                        **	$MOVEL - MOVE DATA
                        *
                        *	$MOVEL MOVES A BLOCK OF BYTES TO A NEW MEMORY ADDRESS.
                        *	IF THE MOVE IS TO A LOWER ADDRESS, THE BYTES ARE MOVED FROM
                        *	FIRST TO LAST.
                        *
                        *	IF THE MOVE IS TO A HIGHER ADDRESS, THE BYTES ARE MOVED FROM
                        *	LAST TO FIRST.
                        *
                        *	THIS IS DONE SO THAT AN OVERLAPED MOVE WILL NOT 'RIPPLE'.
                        *
                        *	CALL	$MOVEL
                        *	DW	COUNT
                        *	DW	FROM
                        *	DW	TO
                        *
                        *	ENTRY	((SP)) = RET
                        *		(RET+0) = COUNT (WORD VALUE)
                        *		(RET+2) = FROM
                        *		(RET+4) = TO
                        *	EXIT	TO (RET+6)
                        *		(DE) = ADDRESS OF NEXT FROM BYTE
                        *		(HL) = ADDRESS OF NEXT *TO* BYTE
                        *		'C' CLEAR
                        *	USES	ALL

3A01  E1                $MOVEL	POP	H			; (HL) = RET
3A02  4E                	MOV	C,M
3A03  23                	INX	H
3A04  46                	MOV	B,M			; (BC) = COUNT
3A05  23                	INX	H
3A06  5E                	MOV	E,M
3A07  23                	INX	H
3A08  56                	MOV	D,M			; (DE) = FROM
3A09  23                	INX	H
3A0A  D5                	PUSH	D			; ((SP)) = FROM
3A0B  5E                	MOV	E,M
3A0C  23                	INX	H
3A0D  56                	MOV	D,M			; (DE) = TO
3A0E  23                	INX	H
3A0F  E3                	XTHL				; ((SP)) = RET, (HL) = FROM
3A10  EB                	XCHG				; (DE) = FROM , (HL) = TO
3A11  C3 AA18           	JMP	$MOVE			; MOVE IT
3A14                    	XTEXT	RTL
3A14                    	SPACE	4,10
                        **	$RTL - READ TEXT LINE.
                        *
                        *	$RTL READS A LINE FROM THE TERMINAL.
                        *
                        *	CHARACTER ARE ACCEPTED FROM THE TERMINAL, RUBOUT AND BACKSPACE
                        *	CHARACTERS ARE PROCESSED. WHEN A CARRIAGE RETURN IS ENTERED,
                        *	$RTL RETURNS.
                        *
                        *	ENTRY	(HL) = BUFFER FWA
                        *	EXIT	'C' CLEAR IF OK
                        *		 DATA IN BUFFER
                        *		 (A) = TEXT LENGTH
                        *		'C' SET IF CTL-D STRUCK
                        *	USES	A,F

3A14  CD 1B3A           $RTL.	CALL	$RTL			; $RTL IN UPPER CASE
3A17  D8                	RC				; CTL-D
3A18  C3 F139           	JMP	$MLU			; MAP LINE TO UPPER CASE

      = 3A1B            $RTL	EQU	*

3A1B  E5                	PUSH	H			; SAVE FWA
3A1C  FF 01             $RTL1	SCALL	.SCIN
3A1E  DA 1C3A           	JC	$RTL1
3A21  FE 04             	CPI	CTLD
3A23  CA 383A           	JE	$RTL2			; CTL-D STRUCK
3A26  77                	MOV	M,A
3A27  23                	INX	H
3A28  FE 0A             	CPI	NL
3A2A  C2 1C3A           	JNE	$RTL1
3A2D  2B                	DCX	H
3A2E  36 00             	MVI	M,0
3A30  23                	INX	H

                        *	ALL DONE. COMPUTE LENGTH

3A31  EB                	XCHG				; (DE) = LWA+1
3A32  E3                	XTHL				; (HL) = FWA
3A33  7B                	MOV	A,E
3A34  95                	SUB	L			; (A) = LENGTH
3A35  A7                	ANA	A			; CLEAR CARRY
3A36  D1                	POP	D			; RESTORE (DE)
3A37  C9                	RET

                        *	CTL-D STRUCK

3A38  E1                $RTL2	POP	H			; (HL) = FWA
3A39  37                	STC
3A3A  C9                	RET
3A3B                    	XTEXT	CAD
3A3B                    	SPACE	4,10
                        **	$CAD - CODE AUGUSTAN DATE.
                        *
                        *	$CAD IS CALLED TO CODE AN AUGUSTAN DATE INTO THE FORM:
                        *
                        *
                        *	----------------------------------------
                        *	I  0  I  6 BITS  I  4 BITS  I  5 BITS  I
                        *	----------------------------------------
                        *		YEAR-70       MON       DAY
                        *		 1-63        1-12       1-31
                        *
                        *	FROM THE FORM:
                        *
                        *	DD-MMM-YY
                        *
                        *	Optional partial forms: 				/3.0a/
                        *
                        *	DD-MMM		If same year				/3.0a/
                        *	DD		If same month and year			/3.0a/
                        *
                        *	Rest of date is filled in from the S.DATE system area	/3.0a/
                        *
                        *	ENTRY	(HL) = ADDRESS OF STRING
                        *	EXIT	'C' CLEAR IF OK
                        *		 (DE) = 15 BIT VALUE
                        *		 (HL) ADVANCED PAST '-YY' or Short Form Date if Used
                        *		'C' SET IF ERROR
                        *	USES	ALL

3A3B  E5                $CAD	PUSH	H
3A3C  0E 07             	MVI	C,$CADBL
3A3E  11 2B3B           	LXI	D,$CADB
3A41  CD 3018           	CALL	$COMP
3A44  C2 4D3A           	JNZ	$CAD0	;Is not 'No-Date'
3A47  D1                	POP	D
3A48  11 0000           	LXI	D,0	;0  =>  No Date
3A4B  A7                	ANA	A	;Clear 'C'
3A4C  C9                	RET

3A4D  E1                $CAD0	POP	H
3A4E  CD D93B           	CALL	$DDD	;DECODE DECIMAL DIGITS
3A51  D8                	RC			ERROR
3A52  7A                	MOV	A,D
3A53  A7                	ANA	A
3A54  37                	STC			ASSUME;TOO LARGE
3A55  C0                	RNZ			TOO;LARGE
3A56  7B                	MOV	A,E
3A57  A7                	ANA	A
3A58  37                	STC
3A59  C8                	RZ			TOO;SMALL FOR DD
3A5A  FE 20             	CPI	32
3A5C  3F                	CMC	
3A5D  D8                	RC			TOO;LARGE
3A5E  EB                	XCHG			(HL);= DAY
3A5F  3E 20             	MVI	A,100000B
3A61  85                	ADD	L
3A62  6F                	MOV	L,A	;COUNT 1ST MONTH
3A63  EB                	XCHG			(DE);= DD*16+1, (HL) = ADDRESS

                        *	DECODE MONTH

3A64  D5                	PUSH	D	;SAVE DD*16+1
3A65  3E C9             	MVI	A,311Q	;RET Code			/3.0a/
3A67  32 F33A           	STA	CADR	;Assume whole DATE given 	/3.0a/
3A6A  7E                	MOV	A,M
3A6B  FE 2D             	CPI	'-'
3A6D  CA 953A           	JE	CAD.M	;OK so far			/3.0a/
3A70  CD F83A           	CALL	$CADD	;Is it end of entry ?		/3.0a/
3A73  C2 B53A           	JNZ	$CAD2	;FORMAT ERROR

3A76  22 F53A           	SHLD	CADHL	;Given ONLY day, save (HL)	/3.0a/
3A79  AF                	XRA	A	;and poke NULL at end so 	|
3A7A  32 F33A           	STA	CADR	;(HL) gets restored		|
3A7D  21 C220           	LXI	H,S.DATE+3;Point at MMM-YY in system	|
3A80  11 323B           	LXI	D,DBUF	;and copy it to buffer		|
3A83  0E 06             	MVI	C,6					;|
3A85  7E                CADL	MOV	A,M					;|
3A86  CD 1152           	CALL	$MCU	;Map to upper case		|
3A89  12                	STAX	D					;|
3A8A  23                	INX	H					;|
3A8B  13                	INX	D					;|
3A8C  0D                	DCR	C					;|
3A8D  C2 853A           	JNZ	CADL					;|
3A90  AF                	XRA	A	;Mark end of string		|
3A91  12                	STAX	D	;with a NULL byte		|
3A92  21 313B           	LXI	H,DBUF-1;Point to buffer 		|

3A95  23                CAD.M	INX	H	;Bump pointer			/3.0a/
3A96  11 063B           	LXI	D,$CADA ;(DE) = MONTH TABLE ADDRESS
3A99  01 0300           $CAD1	LXI	B,3
3A9C  E5                	PUSH	H	;SAVE TEXT ADDRESS, $CADA ADDRESS
3A9D  D5                	PUSH	D
3A9E  CD 3018           	CALL	$COMP	;COMPARE
3AA1  D1                	POP	D	;(DE) = *$CADA* ADDRESS
3AA2  CA B83A           	JE	$CAD3	;GOT MONTH
3AA5  E1                	POP	H	;(HL) = BUFFER ADDRESS OF MMM-YY
3AA6  13                	INX	D
3AA7  13                	INX	D
3AA8  13                	INX	D	;TRY NEXT MONTH
3AA9  E3                	XTHL
3AAA  3E 20             	MVI	A,100000B
3AAC  CD 4118           	CALL	$DADA.	;COUNT MONTH
3AAF  E3                	XTHL
3AB0  1A                	LDAX	D	;(A) = ENTRY IN $CADA
3AB1  A7                	ANA	A
3AB2  C2 993A           	JNZ	$CAD1	;MORE MONTHS TO GO

                        *	ERROR

3AB5  E1                $CAD2	POP	H	;CLEAR STACK
3AB6  37                	STC
3AB7  C9                	RET			FLAG;ERROR

                        *	CRACK -YY

3AB8  C1                $CAD3	POP	B	;DISCARD ADDRESS IF MMM-YY
3AB9  7E                	MOV	A,M
3ABA  FE 2D             	CPI	'-'
3ABC  CA D83A           	JE	CAD.Y	;OK So Far			/3.0a/
3ABF  CD F83A           	CALL	$CADD	;Is it end of entry ?		/3.0a/
3AC2  C2 B53A           	JNZ	$CAD2	;FORMAT ERROR

3AC5  22 F53A           	SHLD	CADHL	;Given all but year, save (HL)	/3.0a/
3AC8  AF                	XRA	A	;and poke NULL at end so (HL)	|
3AC9  32 F33A           	STA	CADR	;gets restored			|
3ACC  32 343B           	STA	DBUF+2	;Mark end of number with NULL	|
3ACF  2A C620           	LHLD	S.DATE+7;Get ascii year from system	|
3AD2  22 323B           	SHLD	DBUF	;and put it in buffer		|
3AD5  21 313B           	LXI	H,DBUF-1;Point to buffer 		|

3AD8  23                CAD.Y	INX	H	;Bump pointer			/3.0a/
3AD9  CD D93B           	CALL	$DDD	;DECODE DECIMAL DIGITS
3ADC  DA B53A           	JC	$CAD2	;IF ERROR
3ADF  7A                	MOV	A,D
3AE0  A7                	ANA	A
3AE1  C2 B53A           	JNZ	$CAD2	;ERROR
3AE4  7B                	MOV	A,E	;(A) = YEAR
3AE5  D6 46             	SUI	70	;SUBTRACT DISPLACEMENT
3AE7  DA B53A           	JC	$CAD2	;ERROR
3AEA  FE 3F             	CPI	63
3AEC  D2 B53A           	JNC	$CAD2	;TOO LARGE
3AEF  D1                	POP	D	;(DE) = MONTH AND DAY
3AF0  87                	ADD	A	;(A) = YEAR*2
3AF1  82                	ADD	D
3AF2  57                	MOV	D,A	;MERGE WITH REST OF IT

3AF3  C9                CADR	RET			or;NOP if we must restore (HL)	/3.0a/
3AF4  21 0000           	LXI	H,*-*					;|
      = 3AF5            CADHL	EQU	*-2					;/3.0a/
3AF7  C9                	RET

3AF8  A7                $CADD	ANA	A	;CHECK FOR A VALID DELIMITER	/3.0a/
3AF9  C8                	RZ			NULL			;|
3AFA  FE 2F             	CPI	'/'					;|
3AFC  C8                	RE			SLASH			;|
3AFD  FE 20             	CPI	' '					;|
3AFF  C8                	RE			SPACE			;|
3B00  FE 09             	CPI	TAB					;|
3B02  C8                	RE			TAB			;|
3B03  FE 2C             	CPI	','					;|
3B05  C9                	RET			COMMA			;/3.0a/

3B06   (0000)           $CADA	DS	0	;TABLE OF MONTHS
3B06  4A414E46 45424D41 	DB	'JAN','FEB','MAR','APR','MAY','JUN'
3B0E  52415052 4D41594A
3B16  554E
3B18  4A554C41 55475345 	DB	'JUL','AUG','SEP','OCT','NOV','DEC'
3B20  504F4354 4E4F5644
3B28  4543
3B2A  00                	DB	0

3B2B  4E4F2D44 415445   $CADB	DB	'NO-DATE'
      = 0007            $CADBL	EQU	*-$CADB

3B32  4D4D4D2D 595900   DBUF	DB	'MMM-YY',0	  ;Date Buffer for Partials	/3.0a/
3B39                    	XTEXT	DAD
3B39                    	SPACE	4,10
                        **	$DAD - DECODE AUGUSTAN DATE.
                        *
                        *	$DAD DECODES A 15 BIT DATE CODE OF THE FORMAT:
                        *
                        *	----------------------------------------
                        *	I  0  I  6 BITS  I  4 BITS  I  5 BITS  I
                        *	----------------------------------------
                        *		YEAR-70       MON       DAY
                        *		 1-63        1-12       1-31
                        *
                        *	TO THE FORM:
                        *
                        *	DD-MMM-YY
                        *
                        *	ENTRY	(DE) = 15 BIT VALUE
                        *		(HL) = ADDRESS FOR DECODE
                        *	EXIT	(HL) = (HL)+9
                        *	USES	ALL

3B39  7A                $DAD	MOV	A,D
3B3A  B3                	ORA	E
3B3B  CA 9A3B           	JZ	DAD2	;No-Date

3B3E  22 923B           	SHLD	DAD1.	;Save HL in case of bad data

3B41  42                	MOV	B,D
3B42  4B                	MOV	C,E
3B43  11 2000           	LXI	D,32
3B46  E5                	PUSH	H	;SAVE ADDRESS
3B47  CD 4618           	CALL	$DU66	;(DE) = DAY, (HL) = YEAR & MONTH
3B4A  E3                	XTHL			(HL);= ADDRESS
3B4B  42                	MOV	B,D
3B4C  4B                	MOV	C,E
3B4D  7B                	MOV	A,E
3B4E  A7                	ANA	A
3B4F  CA 903B           	JZ	DAD1X	;BAD VALUE
3B52  3E 02             	MVI	A,2
3B54  CD 6F19           	CALL	$UDD	;UNPACK DAY
3B57  36 2D             	MVI	M,'-'
3B59  23                	INX	H
3B5A  C1                	POP	B	;(BC) = YEAR & MONTH
3B5B  11 1000           	LXI	D,16
3B5E  E5                	PUSH	H	;SAVE ADDRESS
3B5F  CD 4618           	CALL	$DU66
3B62  E3                	XTHL			(HL);= ADDRESS, ((SP)) = YEAR
3B63  7B                	MOV	A,E
3B64  87                	ADD	A
3B65  83                	ADD	E	;(A) = 3*MONTH
3B66  CA 903B           	JZ	DAD1X	;BAD VALUE
3B69  FE 27             	CPI	13*3
3B6B  D2 903B           	JNC	DAD1X	;TOO LARGE
3B6E  EB                	XCHG			(DE);= ADDRESS
3B6F  21 A03B           	LXI	H,DADB-3
3B72  CD 4118           	CALL	$DADA.	;(HL) = ADDRESS OF MONTH
3B75  01 0300           	LXI	B,3
3B78  EB                	XCHG			(HL);= BUFFER ADDR, (DE) = ADDR IN 'DADB'
3B79  CD AA18           	CALL	$MOVE	;MOVE MONTH IN
3B7C  36 2D             	MVI	M,'-'
3B7E  23                	INX	H
3B7F  C1                	POP	B	;(BC) = YEAR
3B80  79                	MOV	A,C
3B81  C6 46             	ADI	70
3B83  FE 64             	CPI	100
3B85  D2 913B           	JNC	DAD1	;TOO LARGE
3B88  4F                	MOV	C,A	;(BC) = YEAR
3B89  3E 02             	MVI	A,2
3B8B  CD 6F19           	CALL	$UDD	;UNPACK YEAR
3B8E  A7                	ANA	A
3B8F  C9                	RET

                        *	ILLEGAL FORMAT

3B90  E1                DAD1X	POP	H	;RESTORE STACK
3B91  21 0000           DAD1	LXI	H,*-*
      = 3B92            DAD1.	EQU	*-2
3B94  11 D03B           	LXI	D,DADCX
3B97  C3 9D3B           	JMP	DAD3

                        *	No-Date

3B9A  11 C73B           DAD2	LXI	D,DADC
3B9D  01 0900           DAD3	LXI	B,DADCL
3BA0  C3 AA18           	JMP	$MOVE

3BA3  4A616E46 65624D61 DADB	DB	'Jan','Feb','Mar','Apr','May','Jun'
3BAB  72417072 4D61794A
3BB3  756E
3BB5  4A756C41 75675365 	DB	'Jul','Aug','Sep','Oct','Nov','Dec'
3BBD  704F6374 4E6F7644
3BC5  6563

3BC7  3C4E6F2D 44617465 DADC	DB	'<No-Date>'
3BCF  3E
      = 0009            DADCL	EQU	*-DADC

3BD0  3F3F2D3F 3F3F2D3F DADCX	DB	'??-???-??'
3BD8  3F
                        	ERRNZ	*-DADCX-DADCL
3BD9                    	XTEXT	DDD
3BD9                    	SPACE	4,10
                        **	$DDD - DECODE DECIMAL DIGITS.
                        *
                        *	$DDD DECODES A STRING OF DECIMAL DIGITS INTO A DECIMAL INTEGER.
                        *
                        *	THE CHARACTERS ARE TAKEN OUT OF MEMORY. CONVERSION STOPS WITH THE
                        *	FIRST NON-DIGIT CHARACTER FOUND.
                        *
                        *	ENTRY	(HL) = ADDRESS OF CHARACTERS
                        *	EXIT	'C' CLEAR IF OK
                        *		 (DE) = NUMBER
                        *		 (HL) = INDEX OF FIRST NON-DIGIT ENCOUNTERED
                        *		'C' SET IF ERROR
                        *	USES	A,F,D,E,H,L

3BD9  11 0000           $DDD	LXI	D,0			; (DE) = ACCUM

3BDC  7E                $DDD1	MOV	A,M
3BDD  D6 30             	SUI	'0'
3BDF  3F                	CMC
3BE0  D0                	RNC				; TOO SMALL
3BE1  FE 0A             	CPI	10
3BE3  D0                	RNC				; TOO LARGE
3BE4  23                	INX	H			; ADVANCE ADDRESS
3BE5  E5                	PUSH	H			; SAVE (HL)
3BE6  CD D418           	CALL	$MU10			; (HL) = ACCUM*10
3BE9  EB                	XCHG				; (DE) = ACCUM
3BEA  E1                	POP	H			; (HL) = ADDRESS OF STRING
3BEB  D8                	RC				; OVERFLOW
3BEC  83                	ADD	E
3BED  5F                	MOV	E,A
3BEE  3E 00             	MVI	A,0
3BF0  8A                	ADC	D
3BF1  57                	MOV	D,A
3BF2  D2 DC3B           	JNC	$DDD1			; NOT OVERFLOW
3BF5  C9                	RET
3BF6                    	XTEXT	UDDX
3BF6                    	SPACE	4,10
                        **	$UDDX - UNPACK DECIMAL DIGITS.					/3.0/
                        *
                        *	UDDX CONVERTS A 16 BIT VALUE INTO A SPECIFIED NUMBER OF DECIMAL
                        *	DIGITS.
                        *
                        *	$UDDN = PAD WITH NULLS
                        *
                        *	$UDDS = PAD WITH SPACES
                        *
                        *	ENTRY	(B,C) = ADDRESS VALUE
                        *		(A) = DIGIT COUNT
                        *		(H,L) = MEMORY ADDRESS
                        *	EXIT	(HL) = (HL) + (A)
                        *	USES	ALL

      = 3BF6            $UDDN	EQU	*

3BF6  57                	MOV	D,A	;SAVE (A)
3BF7  AF                	XRA	A	;(A) = NUL
3BF8  C3 FE3B           	JMP	$UDDX

      = 3BFB            $UDDS	EQU	*

3BFB  57                	MOV	D,A	;SAVE (A)
3BFC  3E 20             	MVI	A,' '	;(A) = SPACE

3BFE  32 293C           $UDDX	STA	UDDPAD	;SET PAD CHARACTER
3C01  7A                	MOV	A,D	;RESTORE (A)
3C02  CD 3A18           	CALL	$DADA
3C05  E5                	PUSH	H	;SAVE FINAL (H,L) VALUE

3C06  F5                UDDX1	PUSH	PSW
3C07  E5                	PUSH	H
3C08  11 0A00           	LXI	D,10
3C0B  CD 4618           	CALL	$DU66	;(H,L) = VALUE/10
3C0E  44                	MOV	B,H
3C0F  4D                	MOV	C,L	;(BC) = QUOTIENT
3C10  E1                	POP	H
3C11  3E 30             	MVI	A,'0'
3C13  83                	ADD	E	;ADD REMAINDER
3C14  2B                	DCX	H
3C15  77                	MOV	M,A	;STORE DIGIT
3C16  78                	MOV	A,B
3C17  B1                	ORA	C
3C18  CA 223C           	JZ	UDDX2	;ALL ZEROS
3C1B  F1                	POP	PSW
3C1C  3D                	DCR	A
3C1D  C2 063C           	JNZ	UDDX1	;IF MORE TO GO

                        *	ALL DONE. EXIT

3C20  E1                UDDX1.5	POP	H	;RESTORE H
3C21  C9                	RET			RETURN

                        *	DIGITS LEADING THIS ONE ARE ZERO. STORE NULLS INSTEAD.

3C22  F1                UDDX2	POP	PSW
3C23  3D                UDDX3	DCR	A
3C24  CA 203C           	JE	UDDX1.5 ;ALL DONE
3C27  2B                	DCX	H
3C28  36 00             	MVI	M,0
      = 3C29            UDDPAD	EQU	*-1
3C2A  C3 233C           	JMP	UDDX3
3C2D                    	STL	'Boot Patch Area and Buffer Definitions'
3C2D                    	EJECT
                        **	"what" identification

3C2D  40282329 48444F53 	db	'@(#)HDOS 3.0 by Bill Parrott',NL
3C35  20332E30 20627920
3C3D  42696C6C 20506172
3C45  726F7474 0A
3C4A  0100              	dw	.date.
3C4C  0200              	dw	.time.
3C4E                    	SPACE	3
                        **	PATCH - PATCH AREA

      = 3C4E            PATCH	EQU	*
3C4E  416E6F74 68657220 	DB	'Another fine Heath software product',NL
3C56  66696E65 20486561
3C5E  74682073 6F667477
3C66  61726520 70726F64
3C6E  7563740A
3C72  43726561 74656420 	DB	'Created by loyal HDOS users',ENL
3C7A  6279206C 6F79616C
3C82  2048444F 53207573
3C8A  6572738A

                        	ERRMI	64-*+PATCH
3C8E                    	DC	64-*+PATCH,#0AAH
3C8E                    	SPACE	4,10
                        ******************************************************************************
                        **									    **
                        **	BE VERY CAREFUL ABOUT THE PLACEMENT OF THESE BUFFERS.		    **
                        **									    **
                        ******************************************************************************

      = 2B80            SSDB	equ	DDF.BOL*256+USERFWA	; date buffer

      = 2C00            SDTA	equ	SSDB+128		; 512 byte buffer
                        	ERRNZ	#SDTA

      = 2E00            SYSLAB	equ	SDTA+512		; 256 byte buffer

      = 2F00            BUFF	equ	SYSLAB+256		; 256 byte buffer
      = 3000            BUFFE	equ	BUFF+256

                        	ERRMI	SB.ORG-BUFFE
3C8E                    	TITLE	'HDOS - Resident HDOS Code'
3C8E                    	STL	'Base Page Code'
3C8E                    	EJECT
                        **	Relocation begins here

      = 3C8E            FWAREL	EQU	*			; ABS ADDRESS TO START RELOCATION

                        	CODE	+R			; REMAINING CELLS ARE RELOCATED

      = 3C8E            FWASYS	EQU	*			; SYSTEM FWA

                        ***	Base Page Code
                        *

      = 00AA            .	set	252Q

      = 1C00            BUFFWA	SET	034000A 		; start of free buffer area

                        *	Interrupt vector table and base page
                        *
                        *	See HOSBASE.ACM for a more complete description of
                        *	each of these cells.

                        	ERRNZ	*-FWASYS-B.INT0

3C8E  C3 0B21           rst0	jmp	S.FASER 		; reserved (do not use!!)

                        	ERRNZ	*-FWASYS-S.LABEL
3C91  001C              slabel	dw	BUFFWA			; label buffer address
      = 1D00            BUFFWA	set	BUFFWA+256

                        	ERRNZ	*-FWASYS-S.FMASK
3C93  00                fmask	db	0			; feature mask

3C94  FD52              syslwa	dw	LWASYS			; lwa+1 of HDOS

                        	ERRNZ	*-FWASYS-B.INT1
3C96  C3 7A52           rst1	jmp	hostic

                        	ERRNZ	*-FWASYS-S.REV
hos3.h8a:1682: *** Error:  Symbol '.Z80.' undefined ***
3C99  00                	db	.Z80.&200Q+REV		; revision level (bit7=1 if .Z80.)
3C9A  0100              	dw	.DATE.			; date assembled
3C9C  0200              	dw	.TIME.			; time assembled

                        	ERRNZ	*-FWASYS-B.INT2
3C9E  C3 2220           rst2	jmp	.UIVEC+3

3CA1  AAAAAAAA AA       	dc	5,#.

                        	ERRNZ	*-FWASYS-B.INT3
3CA6  C3 2520           rst3	jmp	.UIVEC+6

3CA9  AAAAAAAA AA       	dc	5,#.

                        	ERRNZ	*-FWASYS-B.INT4
3CAE  C3 2820           rst4	jmp	.UIVEC+9

3CB1  AAAAAAAA AA       	dc	5,#.

                        	ERRNZ	*-FWASYS-B.INT5
3CB6  C3 2B20           rst5	jmp	.UIVEC+12

                        	ERRNZ	*-FWASYS-S.DLY
3CB9  C3 AE52           	jmp	hosdly

3CBC  AAAA              	dc	2,#.

                        	ERRNZ	*-FWASYS-B.INT6
3CBE  C3 2E20           rst6	jmp	.UIVEC+15

3CC1  AAAAAAAA AA       	dc	5,#.

                        	ERRNZ	*-FWASYS-B.INT7
3CC6  C3 3120           rst7	jmp	.UIVEC+18

                        	ERRNZ	*-FWASYS-B.SCALL
3CC9  C3 0E3D           	jmp	syscal			; vector directly to SYSCAL

                        	ERRNZ	*-FWASYS-CSLIBUF
3CCC  941F              	dw	BUFFWA. 		; console type-ahead buffer addr.

                        	ERRNZ	*-FWASYS-BATNAME
3CCE  5359303A 4155544F 	db	'SY0:AUTOEXEC.BAT',0	; complete batch file name
3CD6  45584543 2E424154
3CDE  00

                        	ERRNZ	*-FWASYS-BATSEC
3CDF  00                	db	0			; current sector index in batch file

                        	ERRNZ	*-FWASYS-BATGNS
3CE0  0000              	db	0,0			; batch file group numbers

                        	ERRNZ	*-FWASYS-BATBUF
3CE2  001D              	dw	BUFFWA			; address of batch buffer

                        	ERRNZ	*-FWASYS-BATPTR
3CE4  001D              	dw	BUFFWA			; address of next char. in BATBUF
      = 1E00            BUFFWA	set	BUFFWA+256

                        	ERRNZ	*-FWASYS-SUBBUF
3CE6  001E              	dw	BUFFWA			; address of substitution buffer
      = 1E65            BUFFWA	set	BUFFWA+101

                        	ERRNZ	*-FWASYS-S.PATH
3CE8  651E              	dw	BUFFWA			; address of path buffer
      = 1ECA            BUFFWA	set	BUFFWA+101

                        	ERRNZ	*-FWASYS-S.PRMT
3CEA  CA1E              	dw	BUFFWA			; address of prompt buffer
      = 1F2F            BUFFWA	set	BUFFWA+101

                        	ERRNZ	*-FWASYS-S.EDLIN
3CEC  2F1F              	dw	BUFFWA			; address of line buffer
      = 1F94            BUFFWA	set	BUFFWA+101

      = 1F94            BUFFWA. equ	BUFFWA

                        	ERRNZ	*-FWASYS-S.COUNT
3CEE  00                	db	0			; counter

                        	ERRNZ	*-FWASYS-S.SHIFT
3CEF  00                	db	0			; shift count

                        	ERRNZ	*-FWASYS-S.BITS
3CF0  00                	db	0			; bit flags

3CF1  AAAAAA            	dc	3,#.

                        	ERRNZ	*-FWASYS-B.NMI
3CF4  C3 7052           	jmp	hosnmi

                        	ERRNZ	*-FWASYS-B.NMIFL
3CF7  00                nmifl	db	0			; NMI flag (0=no NMI occured)

                        	ERRNZ	*-FWASYS-S.DFBLK
3CF8  53593041 4253     	db	'SY0ABS'		; system wide default block

                        	ERRNZ	*-FWASYS-S.CVEC

                        	ERRNZ	*-FWASYS-..SCIN
3CFE  C3 0000           .scin.	jmp	0			; vector to .SCIN

                        	ERRNZ	*-FWASYS-..SCOUT
3D01  C3 0000           .scout. jmp	0			; vector to .SCOUT

                        	ERRNZ	*-FWASYS-..PRINT
3D04  C3 0000           .print. jmp	0			; vector to .PRINT

                        	ERRNZ	*-FWASYS-..CONSL
3D07  C3 0000           .consl. jmp	0			; vector to .CONSL

                        	ERRNZ	*-FWASYS-..CLRCO
3D0A  C3 0000           .clrco. jmp	0			; vector to .CLRCO

                        	ERRNZ	*-FWASYS-S.FLAG
3D0D  00                	db	0			; system flags

                        	ERRNZ	*-FWASYS-B.END
3D0E                    	STL	'SCALL Dispatch'
3D0E                    	EJECT
                        ***	SYSCALL DISPATCH.
                        *
                        *	THE SYSCALL DISPATCH HANDLER IS ENTERED VIA A SYSCALL INSTRUCTION.
                        *
                        *	ENTRY	(SP) = RET
                        *		(RET) = SYSCALL INDEX
                        *	EXIT	'C' SET IF ILLEGAL CODE
                        *		 (A) = EC.ILC
                        *		TO PROCESSOR IF A GOOD LOAD
                        *		(SP) = PSW
                        *		(SP+2) = RETURN ADDRESS (ADVANCED PAST CODE)
                        *	USES	A,F

      = 3D0E            SYSCAL	EQU	*

3D0E  32 0621           	STA	S.CACC			; SAVE (A)
3D11  E3                	XTHL
3D12  7E                	MOV	A,M			; (A) = CODE
3D13  32 0721           	STA	S.CODE			; SET SYSTEM CODE
3D16  23                	INX	H			; ADVANCE RETURN ADDRESS
3D17  E3                	XTHL

                        *	Special case calls which may need mass storage device drivers

3D18  FE 80             	CPI	.MOUNT
3D1A  CA 2C3D           	JZ	SYS0
3D1D  FE 82             	CPI	.MONMS
3D1F  CA 2C3D           	JZ	SYS0
3D22  FE 84             	CPI	.RESET
3D24  CA 2C3D           	JZ	SYS0
3D27  FE 85             	CPI	.RESNMS
3D29  C2 463D           	JNZ	SYS3
3D2C  3A 0721           SYS0	LDA	S.CODE
3D2F  F5                	PUSH	PSW
3D30  3A 0621           	LDA	S.CACC
3D33  F5                	PUSH	PSW
3D34  E5                	PUSH	H
3D35  FF 32             	SCALL	.LOADD			; preface .MOUNT by .LOADD
3D37  E1                	POP	H			; restore device descriptor
3D38  D2 3E3D           	JNC	SYS1

                        *	Discard saved original parameters

3D3B  C1                	POP	B
3D3C  C1                	POP	B
3D3D  C9                	RET				; exit with error

                        *	Restore original parameters

3D3E  F1                SYS1	POP	PSW
3D3F  32 0621           	STA	S.CACC
3D42  F1                	POP	PSW
3D43  32 0721           	STA	S.CODE

3D46  CD 5E3D           SYS3	CALL	SYS6			; ALL SYSCALLS RETURN HERE	

                        *	ALL SYSCALLS RETURN HERE.

3D49  E5                	push	h
3D4A  F5                	push	psw

                        *	Check for and process any pending driver load

3D4B  3A F120           	lda	S.DDLDA+1		; load address
3D4E  A7                	ana	a			; well?
3D4F  C4 0448           	cnz	ldd			; load it.

                        *	Check for CTRL/C or CTRL/Z was struck.

3D52  F3                	di				; Interlock
3D53  21 B952           	LXI	H,SYSMODE
3D56  35                	DCR	M			; DECREMENT NESTED SYSCAL COUNT
3D57  CD 9D47           	CALL	CPA			; CHECK PENDING ABORT

                        *	Return to the caller

3D5A  F1                	POP	PSW
3D5B  E1                	POP	H			; RESTORE USER (HL)

3D5C  FB                EIRET	EI
3D5D  C9                	RET				; EXIT
3D5E                    	SPACE	3,10
                        *	Do the SYSCALL

3D5E  E5                SYS6	PUSH	H			; SAVE (HL)			
3D5F  21 B952           	LXI	H,SYSMODE
3D62  34                	INR	M			; COUNT NESTED SYSCALL

3D63  FE 0C             	CPI	.SYSRES 		; is resident?
3D65  DA 913D           	JC	SYS8			; yes

3D68  FE 20             	CPI	.LINK			; is in overlay?
3D6A  DA 8C3D           	JC	SYS7			; illegal.
3D6D  FE 33             	CPI	.LOADD+1		; in range?
3D6F  D2 7A3D           	JNC	SYS6A			; no, try other.
3D72  21 B83D           	LXI	H,SYSCALB		; point to 2nd dispatch table
3D75  D6 20             	SUI	.LINK			; adjust
3D77  C3 943D           	JMP	SYS9			;  and go.

3D7A  FE 80             SYS6A	CPI	.MOUNT			; is mount/dismount type?
3D7C  DA 8C3D           	JC	SYS7			; no, is illegal.
3D7F  FE 87             	CPI	.DAD+1			; in range?
3D81  D2 8C3D           	JNC	SYS7			; no, gong!
3D84  21 DE3D           	LXI	H,SYSCALC		; point to 3rd dispatch table
3D87  D6 80             	SUI	.MOUNT			; adjust
3D89  C3 943D           	JMP	SYS9			;  and go.

                        *	Illegal SCALL

3D8C  E1                SYS7	POP	H			; clear stack
3D8D  3E 03             ERRILC	MVI	A,EC.ILC
3D8F  37                	STC
3D90  C9                	RET				; ERROR

                        *	DISPATCH RESIDENT CALLS

3D91  21 A03D           SYS8	LXI	H,SYSCALA		; point to 1st dispatch table
3D94  87                SYS9	ADD	A			; (A) = CODE*2
3D95  CD 4118           	CALL	$DADA.			; (HL) = TABLE ADDRESS
3D98  CD 8918           	CALL	$HLIHL			; Get code address
3D9B  E3                	XTHL				; PUT ON STACK
3D9C  3A 0621           	LDA	S.CACC			; (A) = (ACC) UPON CALL
3D9F  C9                	RET				; ENTER PROCESSOR CODE
3DA0                    	EJECT
                        **	SCALL Dispatch Tables.
                        *
                        *	DW	ADDR		ENTRY ADDRESS

      = 3DA0            SYSCALA EQU	*

                        	ERRNZ	(*-SYSCALA)/2-.EXIT
3DA0  0F3E              	DW	EXIT			; RETURN TO MONITOR

                        	ERRNZ	(*-SYSCALA)/2-.SCIN
3DA2  FE3C              	DW	.SCIN.			; READ FROM SYSTEM CONSOLE

                        	ERRNZ	(*-SYSCALA)/2-.SCOUT
3DA4  013D              	DW	.SCOUT. 		; WRITE TO SYSTEM CONSOLE

                        	ERRNZ	(*-SYSCALA)/2-.PRINT
3DA6  043D              	DW	.PRINT. 		; WRITE LINE TO SYSTEM CONSOLE

                        	ERRNZ	(*-SYSCALA)/2-.READ
3DA8  173F              	DW	READ			; READ DATA

                        	ERRNZ	(*-SYSCALA)/2-.WRITE
3DAA  303F              	DW	WRITE			; WRITE DATA

                        	ERRNZ	(*-SYSCALA)/2-.CONSL
3DAC  073D              	DW	.CONSL. 		; SET/READ CONSOLE OPTIONS

                        	ERRNZ	(*-SYSCALA)/2-.CLRCO
3DAE  0A3D              	DW	.CLRCO. 		; CLEAR CONSOLE TYPE AHEAD

                        	ERRNZ	(*-SYSCALA)/2-.LOADO
3DB0  4B3F              	DW	LOADO			; LOAD SPECIFIED OVERLAY

                        	ERRNZ	(*-SYSCALA)/2-.VERS
3DB2  4B3F              	DW	VERSN			; RETURN HDOS VERSION

                        	ERRNZ	(*-SYSCALA)/2-.GDA
3DB4  4F3F              	DW	GDA			; GET DEVICE DRIVER ADDRESS

                        	ERRNZ	(*-SYSCALA)/2-.CRC16
3DB6  773F              	DW	CRC16			; CRC-16 A BLOCK OF MEMORY

                        	ERRNZ	(*-SYSCALA)/2-.SYSRES	; MAKE SURE WE GOT 'EM ALL
3DB8                    	SPACE	3,10
      = 3DB8            SYSCALB EQU	*

                        	ERRNZ	(*-SYSCALB)/2+.LINK-.LINK
3DB8  A13F              	DW	LINK

                        	ERRNZ	(*-SYSCALB)/2+.LINK-.CTLC
3DBA  5F40              	DW	SCTLC

                        	ERRNZ	(*-SYSCALB)/2+.LINK-.OPENR
3DBC  7540              	DW	OPENR

                        	ERRNZ	(*-SYSCALB)/2+.LINK-.OPENW
3DBE  D040              	DW	OPENW

                        	ERRNZ	(*-SYSCALB)/2+.LINK-.OPENU
3DC0  3141              	DW	OPENU

                        	ERRNZ	(*-SYSCALB)/2+.LINK-.OPENC
3DC2  6A41              	DW	OPENC

                        	ERRNZ	(*-SYSCALB)/2+.LINK-.CLOSE
3DC4  F141              	DW	CLOSE

                        	ERRNZ	(*-SYSCALB)/2+.LINK-.POSIT
3DC6  5942              	DW	POSIT

                        	ERRNZ	(*-SYSCALB)/2+.LINK-.DELET
3DC8  AA42              	DW	DELETE

                        	ERRNZ	(*-SYSCALB)/2+.LINK-.RENAM
3DCA  DA42              	DW	RENAME

                        	ERRNZ	(*-SYSCALB)/2+.LINK-.SETTP
3DCC  2443              	DW	SETTOP

                        	ERRNZ	(*-SYSCALB)/2+.LINK-.DECODE
3DCE  3643              	DW	DECODE

                        	ERRNZ	(*-SYSCALB)/2+.LINK-.NAME
3DD0  5743              	DW	NAME

                        	ERRNZ	(*-SYSCALB)/2+.LINK-.CLEAR
3DD2  8243              	DW	CLEAR

                        	ERRNZ	(*-SYSCALB)/2+.LINK-.CLEARA
3DD4  A443              	DW	CLRALL

                        	ERRNZ	(*-SYSCALB)/2+.LINK-.ERROR
3DD6  BA43              	DW	ERROR

                        	ERRNZ	(*-SYSCALB)/2+.LINK-.CHFLG
3DD8  5244              	DW	CHFLG

                        	ERRNZ	(*-SYSCALB)/2+.LINK-.DISMT
3DDA  C744              	DW	DMOUNT

                        	ERRNZ	(*-SYSCALB)/2+.LINK-.LOADD
3DDC  8344              	DW	LOADD

                        	ERRNZ	(*-SYSCALB)/2+.LINK-(.LOADD+1)
3DDE                    	SPACE	3,10
      = 3DDE            SYSCALC EQU	*

                        	ERRNZ	(*-SYSCALC)/2+.MOUNT-.MOUNT
3DDE  AD44              	DW	MOUNT			; Mount drive

                        	ERRNZ	(*-SYSCALC)/2+.MOUNT-.DMOUN
3DE0  C744              	DW	DMOUNT			; Dismount drive

                        	ERRNZ	(*-SYSCALC)/2+.MOUNT-.MONMS
3DE2  E144              	DW	MOUNMS			; Mount drive (no message)

                        	ERRNZ	(*-SYSCALC)/2+.MOUNT-.DMNMS
3DE4  3A45              	DW	DMONMS			; Dismount drive (no message)

                        	ERRNZ	(*-SYSCALC)/2+.MOUNT-.RESET
3DE6  BB45              	DW	RESET			; Reset (dismount/mount) drive

                        	ERRNZ	(*-SYSCALC)/2+.MOUNT-.RESNMS
3DE8  3946              	DW	RESNMS			; Reset drive (no message)

                        	ERRNZ	(*-SYSCALC)/2+.MOUNT-.DAD
3DEA  6246              	DW	DADD			; Dismount *all* drives

                        	ERRNZ	(*-SYSCALC)/2+.MOUNT-(.DAD+1)
3DEC                    	SPACE	4
                        *	FATAL SYSTEM ERROR

3DEC  CD 5E19           FATSERR	CALL	$TYPTX
3DEF  0A073F30 32204661 	DB	NL,BELL,'?02 Fatal system error!!',BELL,ENL
3DF7  74616C20 73797374
3DFF  656D2065 72726F72
3E07  2121078A

3E0B  F3                	DI
3E0C  C3 0C3E           	JMP	*			; stop the system
3E0F                    	STL	'EXIT - Process .EXIT SCALL'
3E0F                    	EJECT
                        ***	EXIT - EXIT USER PROGRAM.
                        *
                        *	EXIT IS CALLED TO RETURN CONTROL TO THE SYSTEM COMMAND
                        *	PROGRAM.
                        *
                        *	MVI	A,FLAG		=0 FOR NORMAL, =1 FOR ABORT
                        *	SCALL	.EXIT
                        *
                        *	FOR A NORMAL EXIT, THE CONTROL CHARACTER VECTORS ARE CLEARED,
                        *	AND SYSCMD IS ENTERED.
                        *
                        *	FOR AN ABORT EXIT, THE DISK DRIVER IS RESET.

      = 3E0F            EXIT	EQU	*

3E0F  31 8022           	LXI	SP,STACK		; RESET STACK
3E12  32 A03E           	STA	EXITD			; SAVE CODE FOR LINKED PROGRAM
3E15  A7                	ANA	A			; SET CONDITION CODES
3E16  CA 223E           	JZ	EXIT1			; NOT TO ABORT

3E19  AF                	XRA	A			; System unit
3E1A  32 3121           	STA	AIO.UNI 		; SET SYSTEM DISK
3E1D  3E 07             	MVI	A,DC.ABT
3E1F  CD 5820           	CALL	SYDD			; ABORT SYSTEM DISK

                        	ERRNZ	I.CSLMD
3E22  AF                EXIT1	XRA	A
3E23  47                	MOV	B,A
3E24  0E 81             	MVI	C,CSL.ECH|CSL.CHR
3E26  FF 06             	SCALL	.CONSL

3E28  FF 2E             	SCALL	.CLEARA 		; CLEAR ALL BUT THE LINK CHANNEL

                        *	LOAD EXIT PROGRAM (SYSCMD.SYS)

3E2A  3A A03E           EXIT2	LDA	EXITD			; RESTORE LINK CODE
3E2D  21 903E           	LXI	H,EXITA
3E30  31 8022           	LXI	SP,STACK		; RESET STACK
3E33  FF 20             	SCALL	.LINK			; LINK TO EXIT PROCESSOR

                        *	COULD NOT LINK

3E35  F5                	PUSH	PSW			; SAVE CODE
3E36  3A 1A21           	LDA	S.MOUNT
3E39  A7                	ANA	A
3E3A  C2 733E           	JNZ	EXIT4			; CONSIDERED FATAL BECAUSE SYSTEM DISK

                        *	See if SY0: is mounted at all

3E3D  F1                	POP	PSW
3E3E  FE 1B             	CPI	EC.UUN			; not mounted error?
3E40  CA 623E           	JZ	EXIT31			; yes, go mount and try again.

                        *	SYSCMD.SYS NOT FOUND - TRY ANOTHER DISK

3E43  3E FF             	MVI	A,-1
3E45  FF 2D             	SCALL	.CLEAR			; CLEAR THE LINK CHANNEL

                        *	RESET SY0:

3E47  21 A13E           	LXI	H,EXITE
3E4A  FF 81             	SCALL	.DMOUNT 		; dismount

3E4C  3E 07             EXIT30	MVI	A,DC.ABT
3E4E  CD 5820           	CALL	SYDD

3E51  21 A63E           	LXI	H,EXITF
3E54  FF 03             	SCALL	.PRINT			; SAY WE COULDN'T FIND IT

3E56  FF 07             	SCALL	.CLRCO			; zap type-ahead

3E58  FF 01             EXIT3	SCALL	.SCIN
3E5A  DA 583E           	JC	EXIT3
3E5D  FE 0A             	CPI	NL
3E5F  C2 583E           	JNZ	EXIT3

3E62  3E 0A             EXIT31	MVI	A,DC.RDY
3E64  CD 5820           	CALL	SYDD			; is device ready?
3E67  DA 4C3E           	JC	EXIT30			; no, go prompt (again)

3E6A  21 A13E           	LXI	H,EXITE
3E6D  FF 80             	SCALL	.MOUNT
3E6F  D2 2A3E           	JNC	EXIT2

3E72  F5                	PUSH	PSW

                        *	ERROR - COULD NOT LINK TO  *SY0:SYSCMD.SYS*

3E73  21 803E           EXIT4	LXI	H,EXITB
3E76  FF 03             	SCALL	.PRINT			; PRINT MESSAGE
3E78  F1                	POP	PSW			; (A) = CODE
3E79  26 07             	MVI	H,7
3E7B  FF 2F             	SCALL	.ERROR			; TYPE ERROR
3E7D  CD 0B21           	CALL	S.FASER 		; HALT

3E80  0A073F30 32204361 EXITB	DB	NL,BELL,'?02 Can''t Run '
3E88  6E277420 52756E20
3E90  5359303A 53595343 EXITA	DB	'SY0:SYSCMD.SYS',0,ENL	; command processor
3E98  4D442E53 5953008A
3EA0  00                EXITD	DB	0
3EA1  5359303A 00       EXITE	DB	'SY0:',0
3EA6  0A                EXITF	DB	NL
3EA7  53595343 4D442E53 	DB	'SYSCMD.SYS is not present on SY0:',NL
3EAF  59532069 73206E6F
3EB7  74207072 6573656E
3EBF  74206F6E 20535930
3EC7  3A0A
3EC9  0A                	DB	NL
3ECA  506C6163 6520616E 	DB	'Place an HDOS '
3ED2  2048444F 5320
3ED8  332E30            	DB	VERS/16+'0','.',VERS%16+'0'
3EDB  20737973 74656D20 	DB	' system disk into SY0: and press',NL
3EE3  6469736B 20696E74
3EEB  6F205359 303A2061
3EF3  6E642070 72657373
3EFB  0A
3EFC  74686520 52455455 	DB	'the RETURN key to continue','.'+EOL
3F04  524E206B 65792074
3F0C  6F20636F 6E74696E
3F14  7565AE
3F17                    	STL	'READ - Process .READ Command'
3F17                    	EJECT
                        ***	READ - PROCESS READ SYSCALL.
                        *
                        *	READ PROCESSES READ SYSCALLS. IF A SERIAL DEVICE, PASS TO
                        *	DRIVER. IF A STORAGE DEVICE, HANDLE STORAGE MAPPING.
                        *
                        *	MVI	A,CHAN
                        *	LXI	B,COUNT		MUST BE MULTIPLE OF 256
                        *	LXI	D,ADDR
                        *	SCALL	.READ		READ DATA FROM CHANNEL
                        *
                        *	ENTRY	(A) = I/O CHANNEL NUMBER
                        *		(BC) = DATA COUNT
                        *		(DE) = ADDRESS FOR DATA
                        *	EXIT	(BC) = COUNT LEFT
                        *		(DE) = NEXT UNUSED ADDRESS
                        *		'C' CLEAR IF ALL OK
                        *		'C' SET IF ERROR
                        *		 (A) = ERROR CODE
                        *	USES	ALL

3F17  CD B347           READ	CALL	FCI			; FETCH CHANNEL INFO
3F1A  D8                	RC				; ERROR
3F1B  A7                	ANA	A
3F1C  CA E419           	JZ	ERR.FNO 		; FILE NOT OPEN
                        	ERRNZ	FT.OR-2
3F1F  1F                	RAR
3F20  1F                	RAR
3F21  D2 E819           	JNC	ERR.ILR 		; ILLEGAL REQUEST
                        	ERRNZ	FT.DD-1
3F24  17                	RAL
3F25  3E 00             	MVI	A,DC.REA		; (A) = DEVICE CODE
3F27  D2 2021           	JNC	AIO.VEC 		; IF NOT DIRECTORY DEVICE, CALL DRIVER
3F2A  CD CA46           	CALL	DIREAD			; DIRECTORIED READ
3F2D  C3 F148           	JMP	SCI			; STORE CHANNEL INFORMATION AND EXIT
3F30                    	STL	'WRITE - Process .WRITE Command'
3F30                    	EJECT
                        ***	WRITE - PROCESS WRITE SYSCALL.
                        *
                        *	MVI	A,CHAN
                        *	LXI	B,COUNT		MUST BE MULTIPLE OF 256
                        *	LXI	D,ADDR
                        *	SCALL	.WRITE		WRITE DATA TO CHANNEL
                        *
                        *	ENTRY	(A) = CHANNEL #
                        *		(BC) = DATA COUNT
                        *		(DE) = ADDRESS
                        *	EXIT	(BC) = COUNT LEFT
                        *		(DE) = NEXT ADDRESS
                        *		'C' CLEAR IF OK
                        *		'C' SET IF ERROR
                        *		 (A) = ERROR CODE
                        *	USES	ALL

3F30  CD B347           WRITE	CALL	FCI			; FETCH CHANNEL INFORMATION
3F33  D8                	RC				; ERROR
3F34  A7                	ANA	A
3F35  CA E419           	JZ	ERR.FNO 		; FILE NOT OPEN
3F38  67                	MOV	H,A			; SAVE COPY IN H
3F39  E6 04             	ANI	FT.OW			; SEE IF OPEN FOR WRITE
3F3B  CA E819           	JZ	ERR.ILR 		; ILLEGAL REQUEST
3F3E  7C                	MOV	A,H
                        	ERRNZ	FT.DD-1
3F3F  1F                	RAR
3F40  3E 01             	MVI	A,DC.WRI		; REQUEST WRITE
3F42  D2 2021           	JNC	AIO.VEC 		; NOT DIRECTORY DEVICE
3F45  CD FA46           	CALL	DIWRITE 		; DIRECTOREID WRITE
3F48  C3 F148           	JMP	SCI			; STORE CHANNEL INFO
3F4B                    	STL	'LOADO - Load Specified Overlay'
3F4B                    	EJECT
                        ***	LOADO	- LOAD SPECIFIED OVERLAY
                        *
                        *	This performs no operation under HDOS 3.0 due to the
                        *	lack of overlays. Success is always returned for the
                        *	benefit of programs who use this SCALL.
                        *
                        *	Entry:	None
                        *	Exit:	'C' Clear
                        *	Uses:	a,f

      = 3F4B            LOADO	EQU	*

                        	ERRNZ	*-VERSN 		; no reason same code won't do
3F4B                    	STL	'VERSN - Return HDOS Version Number'
3F4B                    	EJECT
                        **	VERSN	- RETURN HDOS VERSION NUMBER'
                        *
                        *	VERSN RETURNS THE HDOS VERSION NUMBER AS A ONE BYTE BCD NUMBER.
                        *	A DECIMAL IS ASSUMED BETWEEN THE HIGH AND LOW ORDER NIBLES.
                        *
                        *
                        *	ENTRY:	NONE
                        *	EXIT:	(A) = VERSION NUMBER
                        *	USES:	A,F

3F4B  3E 30             VERSN	MVI	A,VERS
3F4D  A7                	ANA	A			; CLEAR CARRY
3F4E  C9                	RET
3F4F                    	STL	'GDA - GET DEVICE DRIVER ADDRESS'
3F4F                    	EJECT
                        ***	GDA - Get Device Driver Address
                        *
                        *	Entry:	(DE) = Device Name
                        *	Exit:	'C' Clear
                        *		 (HL) = Driver address
                        *		 (BC) = Table address for this device
                        *		'C' Set if error
                        *		 (A) = Error Code
                        *		 (HL) = (BC) = 0
                        *	Uses:	A,F,H,L,B,C

3F4F  2A EC20           GDA	LHLD	S.DFWA			; start of device table

3F52  7E                GDA1	MOV	A,M			; get 1st byte of name
3F53  A7                	ANA	A			; end of table?
3F54  CA 6F3F           	JZ	GDA3			; yep.

3F57  E5                	PUSH	H			; save this address
3F58  CD 8918           	CALL	$HLIHL			; (HL) = name of this entry
3F5B  CD 8E18           	CALL	$CDEHL			; ours?
3F5E  C1                	POP	B
3F5F  C2 683F           	JNE	GDA2			; no, try next.

3F62  21 0300           	LXI	H,DEV.JMP
3F65  09                	DAD	B			; (HL) = Vector to driver

3F66  AF                	XRA	A			; clear 'C'
3F67  C9                	RET

3F68  21 0E00           GDA2	LXI	H,DEVELEN
3F6B  09                	DAD	B			; find next
3F6C  C3 523F           	JMP	GDA1

                        *	When no device is found, return zeros instead of addresses

3F6F  67                GDA3	MOV	H,A
3F70  6F                	MOV	L,A
3F71  47                	MOV	B,A
3F72  4F                	MOV	C,A

3F73  3E 0D             	MVI	A,EC.UND		; unknown device
3F75  37                	STC
3F76  C9                	RET
3F77                    	STL	'CRC16 - CRC-16 A BLOCK OF MEMORY'
3F77                    	EJECT
                        ***	CRC16 - CRC-16 A BLOCK OF MEMORY
                        *
                        *	Entry:	(HL) = BUFFER ADDRESS
                        *		(DE) = INITIAL CRC-16
                        *		(BC) = LENGTH OF DATA
                        *	Exit:	(HL) = ADVANCED PAST BUFFER
                        *		(DE) = UPDATED CRC-16
                        *		(BC) = 0
                        *	Uses:	ALL

3F77  EB                CRC16	XCHG				; (HL) = CRC, (DE) = BUFFER

3F78  1A                CRC161	LDAX	D			; GET A BYTE
3F79  CD 853F           	CALL	CRC16.			; CRC IT
3F7C  13                	INX	D
3F7D  0B                	DCX	B			; COUNT
3F7E  78                	MOV	A,B
3F7F  B1                	ORA	C			; DONE?
3F80  C2 783F           	JNZ	CRC161			; NOT YET.

3F83  EB                	XCHG				; (DE) = FINAL CRC
3F84  C9                	RET
3F85                    	SPACE	3
                        ***	CRC16. - CRC-16 A BYTE
                        *
                        *	ENTRY:	(HL) = INITIAL CRC-16
                        *		 (A) = BYTE
                        *	EXIT:	(HL) = UPDATED CRC-16
                        *	USES:	A,F,H,L

3F85  C5                CRC16.	PUSH	B
3F86  06 08             	MVI	B,8			; BIT COUNT

3F88  07                CRC16.1 RLC
3F89  4F                	MOV	C,A			; (C) = BIT
3F8A  29                	DAD	H
3F8B  7C                	MOV	A,H
3F8C  17                	RAL
3F8D  A9                	XRA	C
3F8E  0F                	RRC
3F8F  D2 9A3F           	JNC	CRC16.2 		; IF NOT TO XOR
3F92  3E 80             	MVI	A,80H
3F94  AC                	XRA	H
3F95  67                	MOV	H,A
3F96  3E 05             	MVI	A,05H
3F98  AD                	XRA	L
3F99  6F                	MOV	L,A

3F9A  79                CRC16.2 MOV	A,C
3F9B  05                	DCR	B
3F9C  C2 883F           	JNZ	CRC16.1

3F9F  C1                	POP	B
3FA0  C9                	RET
3FA1                    	STL	'LINK - PROCESS LINK SYSCALL.'
3FA1                    	EJECT
                        ***	LINK - PROCESS LINK SYSCALL.
                        *
                        *	LINK LOADS IN AND RUNS ANOTHER PROGRAM. THE OPEN FILES,
                        *	SYSTEM TABLES, AND STACK ARE NOT DISTURBED.
                        *
                        *	ENTRY	(HL) = ADDRESS OF PROGRAM FILE DESCRIPTOR
                        *	EXIT	TO LINKED PROGRAM, IF OK
                        *		 (A) UNCHANGED
                        *		 (SP) = VALUE AT 'LINK' SYSCALL
                        *		TO CALLER IF ERROR
                        *		 'C' SET
                        *		 (A) = ERROR CODE
                        *	USES	ALL

      = 3FA1            LINK	EQU	*

3FA1  CD 7C4B           	CALL	DFA			; DECODE FILE INTO AIO.XXX
3FA4  D8                	RC				; ERROR
3FA5  2F                	CMA				; SEE IF DIRECTOR, FOR READ
3FA6  E6 03             	ANI	FT.DD+FT.OR
3FA8  3E 05             	MVI	A,EC.DNS		; ASSUME NOT SUITABLE
3FAA  37                	STC
3FAB  C0                	RNZ				; NOT SUITABLE
3FAC  36 03             	MVI	M,FT.DD+FT.OR		; SET OPEN FOR READ
3FAE  CD 944D           	CALL	LDE.			; LOCATE DIRECTORY ENTRY
3FB1  D8                	RC				; ERROR
3FB2  CD AD4A           	CALL	CFI			; COPY FILE INFO FROM DIRECTORY ENTRY

                        *	READ 1ST SECTOR TO GET LOAD ADDRESS AND LENGTH INFORMATION.

3FB5  01 0001           	LXI	B,256
3FB8  EB                	XCHG
3FB9  2A 5121           	LHLD	S.SCR
3FBC  EB                	XCHG				; DE = SECTOR SCRATCH AREA
3FBD  CD 0E21           	CALL	S.DIREA 		; READ IT
3FC0  D8                	RC				; ERROR

                        *	SEE IF ABS FILE

3FC1  2A 5121           	LHLD	S.SCR
3FC4  7E                	MOV	A,M
                        	ERRNZ	ABS.ID
3FC5  3C                	INR	A
3FC6  3E 10             	MVI	A,EC.IFC		; ILLEGAL FILE CONTENTS
3FC8  37                	STC
3FC9  C0                	RNZ				; FILE IS NOT BINARY TYPE

3FCA  23                	INX	H
3FCB  7E                	MOV	A,M
                        	ERRNZ	FT.ABS
3FCC  A7                	ANA	A
3FCD  3E 10             	MVI	A,EC.IFC
3FCF  37                	STC				; ASSUME NOT FT.ABS
3FD0  C0                	RNE				; NOT ABS

                        *	Don't allow load below USERFWA.

3FD1  23                	inx	h
                        	ERRNZ	ABS.LDA-ABS.ID-2
3FD2  CD CA51           	call	ildehl			; (de) = load address
3FD5  E5                	push	h			; remember			
3FD6  21 8022           	lxi	h,USERFWA		; base of program area
3FD9  EB                	xchg				; (hl) = load address, (de) = USERFWA
3FDA  CD 9051           	call	cpdehl			; 'C' if (hl) < (de)
3FDD  EB                	xchg
3FDE  E1                	pop	h
3FDF  3E 2E             	mvi	a,EC.ILA		; illegal load address
3FE1  D8                	rc				; gong!

                        *	see if enough room, (de) = load address

3FE2  D5                	PUSH	D
3FE3  CD CA51           	CALL	ILDEHL
                        	ERRNZ	ABS.LEN-ABS.LDA-2
3FE6  EB                	XCHG				; HL = LOAD LENGTH
3FE7  D1                	POP	D

3FE8  19                	DAD	D			; (HL) = LWA+1
3FE9  EB                	XCHG				; (DE) = LWA+1
3FEA  2A D020           	LHLD	S.SYSM			; (HL) = HIGHEST AVAILABLE ADDRESS
3FED  CD 9418           	CALL	$CHL			; COMPLEMENT (HL)
3FF0  19                	DAD	D
3FF1  3E 11             	MVI	A,EC.NEM		; ASSUME NOT ENOUGN MEM
3FF3  D8                	RC				; NOT ENOUGH MEM
3FF4  EB                	XCHG				; (HL) = LOAD LWA
3FF5  CD 2443           	CALL	SETTOP
3FF8  D8                	RC

                        *	ENOUGH MEMORY FOR LOAD. COPY 1ST PARTIAL SECTOR INTO PLACE

3FF9  01 F800           	LXI	B,256-ABS.COD
3FFC  2A 5121           	LHLD	S.SCR
3FFF  CD 9C18           	CALL	$INDL
4002  0200              	DW	ABS.LDA
4004  D5                	PUSH	D			; SAVE LOAD ADDRESS
4005  11 0800           	LXI	D,ABS.COD
4008  19                	DAD	D
4009  EB                	XCHG				; DE = FWA OF CODE
400A  E1                	POP	H			; HL = LOAD ADDRESS

400B  CD AA18           	CALL	$MOVE

                        *	COMPUTE SECTOR COUNT FOR REMAINDER OF LOAD

400E  E5                	PUSH	H			; SAVE LOAD ADDRESS
400F  2A 5121           	LHLD	S.SCR
4012  CD 9C18           	CALL	$INDL
4015  0400              	DW	ABS.LEN 		; DE = LENGTH
4017  21 0800           	LXI	H,ABS.COD
401A  19                	DAD	D			; ADD BYTES FOR ABS HEADER
401B  0E 00             	MVI	C,0
401D  7D                	MOV	A,L
401E  C6 FF             	ADI	377Q
4020  7C                	MOV	A,H
4021  89                	ADC	C
4022  47                	MOV	B,A			; (BC) = SECTOR COUNT*256
4023  05                	DCR	B			; COUNT SECTOR READ
4024  D1                	POP	D			; RESTORE LOAD ADDRESS
4025  CD 0E21           	CALL	S.DIREA 		; READ IT

                        *	update directory

4028  2A 5121           	lhld	S.SCR							
402B  CD 9C18           	call	$INDL
402E  0600              	dw	ABS.ENT
4030  EB                	xchg				; (hl) = program entry
4031  22 5D40           	shld	linka			; save it

4034  CD 0651           	call	uad.			; update last access date

                        *	UPDATE CHANNEL TABLE SO CHANNEL -1 IS THE FILE LOADED

4037  01 2800           	LXI	B,IOCELEN-IOC.DDA
403A  11 2121           	LXI	D,AIO.DDA
403D  2A EA20           	LHLD	S.CFWA
                        	ERRNZ	IOCCTD-1		; ASSUME FIRST IN CHANTAB IS 377Q
                        	ERRNZ	IOC.DDA-2
4040  23                	INX	H
4041  23                	INX	H			; (HL) = #IOC.DDA IN CHANNEL
4042  CD AA18           	CALL	$MOVE			; MOVE INFO INTO CHANNEL

                        *	SETUP SYSTEM FOR TRANSFER OF CONTROL.
                        *
                        *	1) CLEAR CONTROL CHARACTER PROCESS TABLE
                        *	2) CLEAR SYSMODE FLAG
                        *	3) CLEAR USER CODE SWAPPED FLAGS

4045  F3                	DI				; interlock while going to user mode
4046  21 DB20           	LXI	H,S.CAADR
4049  06 08             	MVI	B,8
404B  CD 8A19           	CALL	$ZERO			; CLEAR VECTOR TABLE, AND PENDING VECTOR
404E  2A E620           	LHLD	S.DLINK 		; (HL) = HIGHMEM POINTER
                        	ERRNZ	M.SYSM			; CLEAR SYSMODE
4051  36 00             	MVI	M,0
4053  21 0400           	lxi	h,4							
4056  39                	dad	sp			; fix the stack
4057  F9                	SPHL				;  and set it.

                        *	enter program

4058  3A 0621           	LDA	S.CACC			; RESTORE (A)
405B  FB                	EI
405C  C3 0000           	jmp	0			; enter code
      = 405D            linka	equ	*-2			;  (installed above)
405F                    	STL	'SCTLC - SET CONTROL CHARACTER ADDRESS'
405F                    	EJECT
                        ***	SCTLC - SET CONTROL CHARACTER ADDRESS
                        *
                        *	THE .CTLC SYSCALL IS USED TO SETUP HANDLING FOR
                        *	THE CONTROL CHARACTERS CTL-A, CTL-B, AND CTL-C.
                        *
                        *	A SEPERATE ADDRESS IS SPECIFIABLE FOR EACH CHARACTER. IF
                        *	AN ADDRESS OF 0 IS SPECIFIED, PROCESSING OF THAT CHARACTER
                        *	IS SUSPENDED.
                        *
                        *	THE PROCESS ADDRESS MUST BE > 255A.
                        *
                        *	ENTRY	(A) = CONTROL CHARACTER WHOSE PROCESS ADDRESS IS
                        *			TO CHANGE (CTL-A, CTL-B, OR CTL-C)
                        *		(HL) = NEW ADDRESS (=0 TO CLEAR PROCESSING)
                        *	EXIT	'C' CLEAR IF OK
                        *		'C' SET IF ERROR
                        *		 (A) = ERROR CODE
                        *	USES	A,F,H,L

      = 405F            SCTLC	EQU	*

405F  3D                	DCR	A
4060  FA 8D3D           	JM	ERRILC			; ILLEGAL CODE
4063  FE 03             	CPI	3
4065  D2 8D3D           	JNC	ERRILC			; ILLEGAL CODE
4068  EB                	XCHG				; (DE) = PROCESS ADDRESS
4069  21 DD20           	LXI	H,S.CCTAB
406C  87                	ADD	A			; (A) = 2*INDEX
406D  CD 4118           	CALL	$DADA.			; (HL) = ADDRESS FOR ADDRESS STORAGEE
4070  73                	MOV	M,E
4071  23                	INX	H
4072  72                	MOV	M,D
4073  A7                	ANA	A			; CLEAR CARRY
4074  C9                	RET
4075                    	STL	'OPEN SYSCALL PROCESSOR'
4075                    	EJECT
                        ***	OPENR - OPENR SYSCALL PROCESSOR.
                        *
                        *	OPENR IS CALLED TO OPEN A CHANNEL FOR READ.
                        *
                        *	THE CALLER SUPPLIES A FILE NAME, A DEFAULT BLOCK FOR THE DEVICE
                        *	AND EXTENSION, AND A CHANNEL NUMBER.
                        *
                        *	DEFAULT BLOCK FORMAT:
                        *
                        *	DB	'DDD'		DEFAULT DEVICE
                        *	DB	'XXX'		DEFAULT EXTENSION
                        *
                        *	ENTRY	(DE) = DEFAULT BLOCK ADDRESS
                        *		(HL) = NAME ADDRESS
                        *		(A) = CHANNEL NUMBER
                        *	EXIT	'C' CLEAR IF OK
                        *		(HL) = ADVANCED PAST FILE NAME
                        *		'C' SET IF ERROR
                        *		 (A) = ERROR CODE
                        *	USES	ALL

      = 4075            OPENR	EQU	*

4075  C5                	PUSH	B			; SAVE (BC)
4076  CD AB40           	CALL	OPENR1			; PROCESS OPEN

                        **	OPENR, OPENW, OPENU RETURN HERE
                        *
                        *	(A) = EXIT CODE.

4079  DA A640           OPENX	JC	OPENEX			; ERROR EXIT
407C  E5                	push	h
407D  CD 2021           	CALL	AIO.VEC 		; OPEN DEVICE CODE
4080  E1                	pop	h

                        *	update access date

4081  3A 2321           	lda	AIO.FLG 		; device flag			
4084  E6 01             	ani	FT.DD			; only do this for disks
4086  CA 9940           	jrz	openx2			; skip, is not disk.

4089  3A 0721           	lda	S.CODE			; what kind of open?
408C  FE 22             	cpi	.OPENR			; read?
408E  CA 9640           	jz	openx1			; yes, do update.
4091  FE 24             	cpi	.OPENU			; update?
4093  C2 9940           	jnz	openx2			; no, skip.

4096  CD 1251           openx1	call	uad			; update access date and count

4099  2A 4E21           openx2	LHLD	AIO.CHA
409C  11 2121           	LXI	D,AIO.DDA
409F  01 2800           	LXI	B,IOCELEN-IOC.DDA
40A2  CD AA18           	CALL	$MOVE			; RESTORE TO IO CHANNEL

40A5  A7                	ANA	A			; CLEAR CARRY
40A6  C1                OPENEX	POP	B
40A7  21 0000           	LXI	H,0			; (HL) POINTS TO NEXT FILE (SET BY DFA)
      = 40A8            OPENHL	EQU	*-2
40AA  C9                	RET

                        *	PROCESS OPENR

40AB  CD A14B           OPENR1	CALL	DFC			; DECODE FILE AND CHANNEL
40AE  D8                	RC				; ERROR
40AF  E6 02             	ANI	DT.CR			; SEE IF CAPABLE OF READING
40B1  3E 05             	MVI	A,EC.DNS
40B3  37                	STC
40B4  C8                	RZ				; DEVICE NOT READ TYPE

                        *	MUST FIND DIRECTORY ENTRY

40B5  7E                	MOV	A,M			; (A) = TYPE
40B6  E6 03             	ANI	FT.DD+FT.OR		; OPEN
40B8  77                	MOV	M,A			; SET TYPE
40B9  1F                	RAR
                        	ERRNZ	FT.DD-1
40BA  D2 CD40           	JNC	OPENR2			; NOT DIRECTORY DEVICE
40BD  CD 6A4A           	CALL	CFC			; CHECK FOR CONFLICT IF DIRECTORY
40C0  E6 04             	ANI	FT.OW			; CANT HAVE ANY WRITES
40C2  3E 0B             	MVI	A,EC.FUC		; FILE USAGE CONFLICT
40C4  37                	STC
40C5  C0                	RNZ				; HAVE CONFLICT
40C6  CD 944D           	CALL	LDE.			; LOCATE DIRECTORY ENTRY
40C9  D8                	RC				; IF ERROR
40CA  CD AD4A           	CALL	CFI			; COPY FILE INFO FROM DIRECTORY ENTRY
40CD  3E 03             OPENR2	MVI	A,DC.OPR		; SET CODE
40CF  C9                	RET
40D0                    	STL	'OPENW - OPEN FILE FOR WRITE'
40D0                    	EJECT
                        ***	OPENW - OPEN FILE FOR WRITE
                        *
                        *	OPENW IS CALLED TO OPEN A CHANNEL FOR WRITE.
                        *
                        *	THE FILE IS ENTERED IN THE CHANNEL TABLE, BUT NOT ON THE
                        *	DISK. IT WILL BE ENTERED IN THE DIRECTORY AT CLOSE TIME.
                        *
                        *	THE CALLER SUPPLIES A FILE NAME, A DEFAULT BLOCK FOR THE DEVICE
                        *	AND EXTENSION, AND A CHANNEL NUMBER.
                        *
                        *	DEFAULT BLOCK FORMAT:
                        *
                        *	DB	'DDD'		DEFAULT DEVICE
                        *	DB	'XXX'		DEFAULT EXTENSION
                        *
                        *	ENTRY	(DE) = DEFAULT BLOCK ADDRESS
                        *		(HL) = NAME ADDRESS
                        *		(A) = CHANNEL NUMBER
                        *	EXIT	'C' CLEAR IF OK
                        *		(HL) = ADVANCED PAST FILE NAME
                        *		'C' SET IF ERROR
                        *		 (A) = ERROR CODE
                        *	USES	ALL
                        *

      = 40D0            OPENW	EQU	*

40D0  C5                	PUSH	B			; SAVE (BC)
40D1  CD D740           	CALL	OPENW1			; PERFORM OPEN
40D4  C3 7940           	JMP	OPENX			; FINISH IN COMMON CODE

                        *	PROCESS OPENW

40D7  CD A14B           OPENW1	CALL	DFC			; DECODE FILE AND CHANNEL
40DA  D8                	RC				; ERROR
40DB  E6 04             	ANI	DT.CW
40DD  3E 1D             	MVI	A,EC.DIW		; DEVICE IS NOT WRITABLE
40DF  37                	STC
40E0  C8                	RZ				; NOT SUITABLE
40E1  7E                	MOV	A,M			; (A) = FLAG BYTE
40E2  E6 07             	ANI	FT.OW+FT.DD+FT.OR	; SET OPEN FOR WRITE (AND MAYBE READ)
40E4  77                	MOV	M,A
                        	ERRNZ	FT.DD-1
40E5  1F                	RAR
40E6  D2 2E41           	JNC	OPENW3			; NOT DIRECTORY TYPE
40E9  CD C84A           	CALL	CFP			; CHECK FOR POSESSION
40EC  D8                	RC				; IF ERROR
40ED  CD 944D           	CALL	LDE.			; LOCATE ENTRY IN DIRECTORY
40F0  DA 0641           	JC	OPENW2			; NO ENTRY IN DIRECTORY

                        *	HAVE EXISTING ENTRY IN DIRECTORY. SEE IF WE HAVE WRITE PERMISSION,
                        *	SINCE WE WILL DELETE THIS ENTRY WHEN WE CLOSE.

40F3  11 0E00           	LXI	D,DIR.FLG
40F6  19                	DAD	D			; (HL) = ADDRESS OF DIR.FLG IN ENTRY
40F7  7E                	MOV	A,M			; (A) = DIR.FLG
40F8  E6 22             	ANI	DIF.WP+DIF.DL		; Write-protect or delete lock	
40FA  CA 0641           	JZ	OPENW2			; have neither

                        *	A file we can't delete.

40FD  E6 20             	ANI	DIF.WP			; check for write-protect
40FF  3E 14             	MVI	A,EC.WPV		; ASSUME WRITE PROTECT VIOLATION
4101  37                	STC				; make an error
4102  C0                	RNZ				; is write-protect violation,

4103  3E 2C             	MVI	A,EC.LAD		;  else delete lock error
4105  C9                	RET

                        *	ALLOCATE AND LINK THE FILE'S FIRST GROUP

4106  0E 00             OPENW2	MVI	C,0			; NEEDENT BE CONTIGUOUS
4108  51                	MOV	D,C			; NO BLOCK PREFERENCES
4109  CD 5B1A           	CALL	FFB			; FIND FREE BLOCK

410C  3E 02             	MVI	A,EC.EOM
410E  D8                	RC				; NO FREE BLOCK TO HAVE
410F  7E                	MOV	A,M			; (A) = NEXT BLOCK IN FREE CHAIN
4110  36 00             	MVI	M,0			; THIS BLOCK IS LAST (AND FIRST) FOR THE FILE
4112  55                	MOV	D,L			; (D) = INDEX OF NEW BLOCK
4113  6B                	MOV	L,E			; (HL) = ADDRESS OF PREVIOUS BLOCK
4114  77                	MOV	M,A			; UNCHAIN ALLOCATED BLOCK FROM FREE LIST
4115  6A                	MOV	L,D			; (L) = GROUP INDEX
4116  26 00             	MVI	H,0			; (H) = SECTOR INDEX
4118  22 2721           	SHLD	AIO.CGN
                        	ERRNZ	AIO.CSI-AIO.CGN-1
411B  22 2921           	SHLD	AIO.LGN 		; SET FIRST=LAST
                        	ERRNZ	AIO.LSI-AIO.LGN-1
411E  7D                	MOV	A,L
411F  32 4221           	STA	AIO.DIR+DIR.FGN 	; SET FIRST GROUP NUMBER

4122  2A C820           OPENW2A LHLD	S.DATC
4125  22 4521           	SHLD	AIO.DIR+DIR.CRD 	; SET CREATION DATE
4128  2A CA20           	lhld	S.TIME							
412B  22 3D21           	shld	AIO.DIR+DIR.CTH 	; also time
                        	ERRNZ	DIR.CTM-DIR.CTH-1

412E  3E 04             OPENW3	MVI	A,DC.OPW		; SET OPENW OPERATION
4130  C9                	RET				; EXIT
4131                    	STL	'OPENU - OPEN FILE FOR UPDATE.'
4131                    	EJECT
                        ***	OPENU - OPEN FILE FOR UPDATE.
                        *
                        *	OPENU IS CALLED TO OPEN A CHANNEL FOR UPDATE.
                        *
                        *	UPDATE IS JUST LIKE READ, BUT THE FILE MAY BE WRITTEN ALSO.
                        *
                        *	THE CALLER SUPPLIES A FILE NAME, A DEFAULT BLOCK FOR THE DEVICE
                        *	AND EXTENSION, AND A CHANNEL NUMBER.
                        *
                        *	DEFAULT BLOCK FORMAT:
                        *
                        *	DB	'DDD'		DEFAULT DEVICE
                        *	DB	'XXX'		DEFAULT EXTENSION
                        *
                        *	ENTRY	(DE) = DEFAULT BLOCK ADDRESS
                        *		(HL) = NAME ADDRESS
                        *		(A) = CHANNEL NUMBER
                        *	EXIT	'C' CLEAR IF OK
                        *		(HL) = ADVANCED PAST FILE NAME
                        *		'C' SET IF ERROR
                        *		 (A) = ERROR CODE
                        *	USES	ALL

      = 4131            OPENU	EQU	*

4131  C5                	PUSH	B			; SAVE (BC)
4132  CD 3841           	CALL	OPENU1			; PROCESS OPEN
4135  C3 7940           	JMP	OPENX			; FINISH IN COMMON CODE

                        *	PROCESS OPENU

4138  CD A14B           OPENU1	CALL	DFC			; DECODE FILE AND CHANNEL
413B  D8                	RC				; ERROR
413C  2F                	CMA
413D  E6 07             	ANI	DT.DD+DT.CR+DT.CW	; MUST BE DIRECTORY/READ/WRITE
413F  37                	STC
4140  3E 05             	MVI	A,EC.DNS
4142  C0                	RNZ				; DEVICE DOSENT MEET ALL REQUIREMENTS

                        *	FIND DIRECTORY ENTRY

4143  7E                	MOV	A,M
4144  E6 07             	ANI	FT.OR+FT.OW+FT.DD
4146  F6 08             	ORI	FT.OU			; SET OPEN FOR UPDATE
4148  77                	MOV	M,A
4149  CD C84A           	CALL	CFP			; CHECK FOR POSESSION
414C  D8                	RC				; FILE USAGE CONFLICT
414D  CD 944D           	CALL	LDE.			; FIND ENTRY
4150  D8                	RC				; ERROR
4151  CD AD4A           	CALL	CFI			; COPY FILE INFO FROM DIRECTORY ENTRY

                        *	SEE IF WE HAVE WRITE PERMISSION

4154  3A 4021           	LDA	AIO.DIR+DIR.FLG
4157  E6 20             	ANI	DIF.WP
4159  3E 14             	MVI	A,EC.WPV		; ASSUME WRITE PERMISSION VIOLATION
415B  37                	STC
415C  C0                	RNZ				; IN ERROR

                        *	clear the 'A' flag

415D  EB                	XCHG				; (de) = address in SECSCR
415E  21 0E00           	LXI	H,DIR.FLG
4161  19                	DAD	D
4162  3E F7             	MVI	A,~DIF.ARC
4164  A6                	ANA	M			; mask off 'A'
4165  77                	MOV	M,A
4166  EB                	XCHG

                        *	finish in common code

4167  3E 05             	MVI	A,DC.OPU
4169  C9                	RET				; EXIT TO COMMON CODE
416A                    	STL	'OPENC - OPEN CONTIGUOUS FILE'
416A                    	EJECT
                        ***	OPENC - OPEN CONTIGUOUS FILE FOR WRITE
                        *
                        *	OPENC IS CALLED TO OPEN A CHANNEL FOR WRITE.
                        *
                        *	THE FILE IS ENTERED IN THE CHANNEL TABLE, BUT NOT ON THE
                        *	DISK. IT WILL BE ENTERED IN THE DIRECTORY AT CLOSE TIME.
                        *
                        *	THE CALLER SUPPLIES A FILE NAME, A DEFAULT BLOCK FOR THE DEVICE
                        *	AND EXTENSION, AND A CHANNEL NUMBER.
                        *
                        *	DEFAULT BLOCK FORMAT:
                        *
                        *	DB	'DDD'		DEFAULT DEVICE
                        *	DB	'XXX'		DEFAULT EXTENSION
                        *
                        *	ENTRY	(BC) = SECTOR COUNT
                        *		(DE) = DEFAULT BLOCK ADDRESS
                        *		(HL) = NAME ADDRESS
                        *		(A) = CHANNEL NUMBER
                        *	EXIT	'C' CLEAR IF OK
                        *		(HL) = ADVANCED PAST FILE NAME
                        *		'C' SET IF ERROR
                        *		 (A) = ERROR CODE
                        *	USES	ALL
                        *

      = 416A            OPENC	EQU	*

416A  C5                	PUSH	B			; SAVE (BC)
416B  CD 7141           	CALL	OPENC1			; PERFORM OPEN
416E  C3 7940           	JMP	OPENX			; FINISH IN COMMON CODE

                        *	PROCESS OPENC

4171  C5                OPENC1	PUSH	B			; SAVE COUNT
4172  CD A14B           	CALL	DFC			; DECODE FILE AND CHANNEL
4175  C1                	POP	B
4176  D8                	RC				; ERROR

4177  E6 04             	ANI	DT.CW
4179  3E 1D             	MVI	A,EC.DIW		; DEVICE IS NOT WRITABLE
417B  37                	STC
417C  C8                	RZ				; NOT SUITABLE

417D  7E                	MOV	A,M			; (A) = FLAG BYTE
417E  E6 07             	ANI	FT.OW+FT.DD+FT.OR	; SET OPEN FOR READ AND WRITE
4180  77                	MOV	M,A
                        	ERRNZ	FT.DD-1
4181  1F                	RAR
4182  D2 ED41           	JNC	OPENC9			; NOT DIRECTORY TYPE

                        *	Compute the number of groups required

4185  3A 2621           	LDA	AIO.SPG
4188  32 F041           	STA	OPENCB			; Initialize Sector Index
418B  5F                	MOV	E,A
418C  16 00             	MVI	D,0			; DE = SPG
418E  CD 4618           	CALL	$DU66			; HL = BC / DE

4191  7B                	MOV	A,E			; A  = Remainder
4192  A7                	ANA	A
4193  CA 9A41           	JZ	OPENC2
4196  32 F041           	STA	OPENCB			; Set the sector index
4199  2C                	INR	L			; Round up sector count
419A  7D                OPENC2	MOV	A,L			; A = Sector Count
419B  32 B641           	STA	OPENCA

419E  CD C84A           	CALL	CFP			; CHECK FOR POSESSION
41A1  D8                	RC				; IF ERROR

41A2  CD 944D           	CALL	LDE.			; LOCATE ENTRY IN DIRECTORY
41A5  3E 16             	MVI	A,EC.FAP		; FILE ALREADY PRESENT
41A7  3F                	CMC
41A8  D8                	RC				; IF PRESENT

                        *	READY TO TRY TO FIND THE CONTINUOUS AREA.

41A9  2A 2421           	LHLD	AIO.GRT
41AC  55                	MOV	D,L			; (D) = PREVIOUS BLOCK INDEX
41AD  6E                	MOV	L,M			; (HL) = ADDRESS IF FIRST FREE BLOCK

                        *	AM AT HEAD OF A NEW CONTIGUOUS GROUP OF FREE BLOCKS
                        *	(MAY BE ONLY 1 BLOCK, CONTIGUOUS WITH ITSELF!)

41AE  7D                OPENC3	MOV	A,L			; SEE IF NO MORE BLOCKS
41AF  A7                	ANA	A
41B0  3E 02             	MVI	A,EC.EOM		; ASSUME EOM
41B2  37                	STC
41B3  C8                	RZ				; EOM
41B4  D5                	PUSH	D			; SAVE INDEX OF GROUP BEFORE THIS ONE
41B5  06 00             	MVI	B,0			; (B) = GROUP COUNT
      = 41B6            OPENCA	EQU	*-1

                        *	FOLLOW BLOCKS IN CHAIN, LOOKING FOR GAP

41B7  05                OPENC4	DCR	B
41B8  CA C741           	JZ	OPENC5			; GOTEM
41BB  7D                	MOV	A,L
41BC  55                	MOV	D,L			; (D) = INDEX OF LAST BLOCK
41BD  6E                	MOV	L,M			; FOLLOW LINK
41BE  3C                	INR	A
41BF  BD                	CMP	L
41C0  CA B741           	JE	OPENC4			; STILL CONTIGOUS

                        *	BREAK IN CONTINUITY. START COUNTING OVER AGAIN

41C3  C1                	POP	B			; DISCARD OLD ADDRESS
41C4  C3 AE41           	JMP	OPENC3			; TRY AGAIN

                        *	GOT THE BLOCKS WE NEED.
                        *
                        *	(L) = LAST BLOCK
                        *	((SP)) = INDEX OF BLOCK BEFORE FIRST
                        *
                        *	WE MUST
                        *
                        *	1) REMOVE THIS BLOCK OF GROUPS BY LINKING
                        *	   THE GROUP BEFORE IT TO THE GROUP AFTER IT
                        *	2) TERMINATE THIS CHAIN OF GROUPS BY ZEROING THE LAST LINK
                        *	3) SETUP THE FILE POINTERS IN THE AIO.XXX FIELD

41C7  D1                OPENC5	POP	D			; (D) = INDEX OF GROUP BEFORE FIRST IN BLOCK
41C8  46                	MOV	B,M			; (B) = FIRST FREE GROUP AFTER BLOCK
41C9  36 00             	MVI	M,0			; CLEAR CHAIN IN LAST GROUP OF BLOCK
41CB  5D                	MOV	E,L			; (E) = LAST GROUP NUMBER IN BLOCK
41CC  6A                	MOV	L,D			; (L) = LAST FREE BLOCK BEFORE GROUP
41CD  7E                	MOV	A,M			; (A) = FIRST GROUP OF BLOCK
41CE  70                	MOV	M,B			; CHAIN FREE AROUND GROUP
41CF  32 4221           	STA	AIO.DIR+DIR.FGN 	; SET FIRST GROUP
41D2  2E 01             	MVI	L,1
41D4  75                	MOV	M,L			; FLAG CHANGE IN GRT
41D5  6F                	MOV	L,A
41D6  26 00             	MVI	H,0
41D8  22 2721           	SHLD	AIO.CGN 		; SET CURRENT GROUP AND INDEX
41DB  6B                	MOV	L,E			; (L) = LAST GROUP IN BLOCK
41DC  3A F041           	LDA	OPENCB			; A = Last Group Sector Index
41DF  67                	MOV	H,A
41E0  22 2921           	SHLD	AIO.LGN 		; SET LAST GROUP AND SECTOR
41E3  22 4321           	SHLD	AIO.DIR+DIR.LGN
41E6  21 4021           	LXI	H,AIO.DIR+DIR.FLG
41E9  7E                	MOV	A,M			; (A) = FLAG
41EA  F6 10             	ORI	DIF.CNT 		; FLAG CONTIGUOUS
41EC  77                	MOV	M,A			; REPLACE

                        *	OPEN COMPLETE. SET CODE AND EXIT

41ED  C3 2241           OPENC9	JMP	OPENW2A 		; finish like .OPENW

41F0  00                OPENCB	DB	0			; Last Group Sector Index
41F1                    	STL	'CLOSE - PROCESS CLOSE SYSCALL'
41F1                    	EJECT
                        ***	CLOSE - PROCESS CLOSE SYSCALL.
                        *
                        *	CLOSE PROCESSING DEPENDS UPON THE FILE AND DEVICE TYPE.
                        *
                        *	FOR A WRITE/DIRECTORY TYPE, THE DIRECTORY IS SEARCHED FOR A
                        *	PREVIOUS ENTRY. IF FOUND, IT IS DELETED. THE NEW ENTRY IS THEN
                        *	INSERTED
                        *
                        *	FOR A UPDATE/DIRECTORY TYPE, THE PREVIOUS ENTRY IS UPDATED.
                        *
                        *	FOR ALL FILES, THE DRIVER IS CALLED WITH THE DC.CLO FUNCTION.
                        *	THE CHANNEL IS RELEASED.
                        *
                        *	ENTRY	(A) = CHANNEL #
                        *	EXIT	'C' CLEAR IF OK
                        *		'C' SET IF ERROR
                        *		 (A) = CODE
                        *	USES	ALL

      = 41F1            CLOSE	EQU	*

41F1  CD 964C           	CALL	FCC			; FETCH COMPLETE CHANNEL
41F4  D8                	RC				; ERROR
41F5  A7                	ANA	A
41F6  CA E419           	JZ	ERR.FNO 		; FILE NOT OPEN

41F9  2F                	CMA
41FA  E6 05             	ANI	FT.DD+FT.OW		; Check for Directory and Open for Write
41FC  CC 0C42           	CZ	CLOSE0			; Extra processing for DIR and WRITE
41FF  D8                	RC

                        *	CLOSE I/O CHANNEL

4200  2A 4E21           	LHLD	AIO.CHA
                        	ERRNZ	IOC.FLG-IOC.DDA-2
4203  23                	INX	H
4204  23                	INX	H			; (HL) = ADDRESS OF IOC.FLG
4205  36 00             	MVI	M,0			; CLEAR

                        *	CALL CLOSE IN DEVICE DRIVER

4207  3E 06             	MVI	A,DC.CLO
4209  C3 2021           	JMP	AIO.VEC 		; CLOSE AND RETURN
420C                    	SPACE	4,10
                        *	FILE IS DIRECTORY FILE, AND WAS WRITTEN TO

420C  7E                CLOSE0	MOV	A,M			; (A) = AIO.FLG
420D  E6 08             	ANI	FT.OU
420F  21 2642           	LXI	H,CLOSE2		; ASSUME WAS UPDATE TYPE
4212  C2 1842           	JNZ	CLOSE1			; IS UPDATE
4215  21 2E42           	LXI	H,CLOSE3		; IS OPEN FOR WRITE
4218  E5                CLOSE1	PUSH	H			; SAVE PROCESS AS RETURN ADDRESS
4219  2A 2D21           	LHLD	AIO.DES 		; (HL) = DIRECTORY SECTOR #
421C  01 0B00           	LXI	B,DIRIDL		; (BC) = DIRECTORY NAME LENGTH
421F  7C                	MOV	A,H
4220  B5                	ORA	L
4221  37                	STC				; ASSUME NO PREVIOUS ENTRY
4222  C2 A24D           	JNZ	LDE..			; HAVE PREVIOUS ENTRY
4225  C9                	RET				; EXIT TO CLOSE2 OR CLOSE3

                        *	AM OPEN FOR UPDATE

4226  DC 0B21           CLOSE2	CC	S.FASER 		; FATAL ERROR: COULDNT FIND IT
4229  EB                	XCHG				; (DE) = ENTRY ADDRESS
422A  AF                	XRA	A			; No blocks to return to GRT
422B  C3 3F42           	JMP	CLOSE7			; UPDATE DIRECTORY ENTRY

                        *	AM OPEN FOR WRITE. DELETE ANY EXISTING FILE OF THAT NAME

422E  DA 3942           CLOSE3	JC	CLOSE4			; NONE YET EXIST
4231  CD CF51           	CALL	$INDLB			; A = Head of list to return
4234  1000              	DW	DIR.FGN
4236  C3 3E42           	JMP	CLOSE6			; SET CREATION DATE AND UPDATE DIRECTORY

                        *	FIND EMPTY SPOT FOR THE FILE NAME

4239  CD E14C           CLOSE4	CALL	FOE			; FIND OPEN ENTRY
423C  D8                	RC				; DIRECTORY FULL UP
423D  AF                	XRA	A			; No blocks to return to GRT

423E  EB                CLOSE6	XCHG

                        *	UPDATE DIRECTORY ENTRY FOR WRITTEN FILE
                        *
                        *	A	= Head of block list to return to free pool, 0 if none
                        *	(DE) = ADDRESS OF ENTRY IN DIRECTORY SECTOR
                        *
                        *	NOTE:	This code has been modified in an effort to catch
                        *		users who play with write protect switches.
                        *

423F  47                CLOSE7	MOV	B,A
4240  C5                	PUSH	B			; Save head of return list
4241  EB                	XCHG				; (HL) = ADDRESS		
4242  CD 4251           	CALL	UDE			; UPDATE DIRECTORY ENTRY
4245  CD 6351           	CALL	UDS			; UPDATE DIRECTORY SECTOR
4248  C1                	POP	B			; Restore head of list
4249  D8                	RC				; Hopefully only Write-Protect

424A  CD 5042           	CALL	CLOSE8
424D  C3 E150           	JMP	SGT			; SAVE GRT TABLE
4250                    	SPACE	4,10
                        **	CLOSE8
                        *
                        *	Free any blocks which may have been freed by the deletion of
                        *	an old file

4250  78                CLOSE8	MOV	A,B			; A  = Head of list to free
4251  A7                	ANA	A
4252  C8                	RZ				; Nothing to update

4253  2A 2421           	LHLD	AIO.GRT 		; HL = GRT Address
4256  C3 C34C           	JMP	FGC			; Free the Group Chain
4259                    	STL	'POSIT - POSITION FILE.'
4259                    	EJECT
                        ***	POSIT - POSITION FILE.
                        *
                        *	LXI	B,POSITION
                        *	MVI	A,CHANNEL
                        *	SCALL	.POSIT
                        *
                        *	ENTRY	(A) = CHANNEL NUMBER
                        *		(BC) = SECTOR NUMBER TO POSITION BEFORE
                        *	EXIT	'C' CLEAR IF OK
                        *		'C' SET IF ERROR
                        *		 (A) = ERROR CODE
                        *		 (A) = EC.EOF IF OFF END
                        *		 (BC) = SECTORS UNSKIPPED (REMAINDER OF COUNT)
                        *		 FILE POSITIONED AT EOF
                        *	USES	ALL

      = 4259            POSIT	EQU	*

4259  C5                	PUSH	B			; SAVE SECTOR #
425A  CD 964C           	CALL	FCC			; FETCH COMPLETE CHANNEL INFORMATION
425D  DA 8542           	JC	POSIT3			; ERROR
4260  A7                	ANA	A
4261  CA E419           	JZ	ERR.FNO 		; FILE NOT OPEN
                        	ERRNZ	FT.DD-1
4264  1F                	RAR
4265  3F                	CMC				; 'C' SET IF NOT DIRECTORY DEVICE
4266  3E 05             	MVI	A,EC.DNS
4268  DA 8542           	JC	POSIT3			; DEVICE NOT SUITABLE
426B  2A 4221           	LHLD	AIO.DIR+DIR.FGN
426E  26 00             	MVI	H,0
4270  22 2721           	SHLD	AIO.CGN 		; REWIND
                        	ERRNZ	AIO.CSI-AIO.CGN-1
4273  C1                	POP	B			; (BC) = SECTOR COUNT

4274  78                POSIT2	MOV	A,B
4275  B1                	ORA	C
4276  CA 1421           	JZ	S.SCI			; ALL DONE
4279  CD 8A42           	CALL	AFP			; ADVANCE FILE POINTER
427C  EB                	XCHG
427D  DA 1421           	JC	S.SCI			; AT EOF
4280  EB                	XCHG
4281  0B                	DCX	B			; MORE TO GO
4282  C3 7442           	JMP	POSIT2			; ADVANCE ANOTHER ONE

4285  C1                POSIT3	POP	B
4286  C9                	RET
4287                    	SPACE	4,10
                        **	AFP - ADVANCE FILE POINTER.
                        *
                        *	AFP ADVANCES THE ACTIVE I/O POINTER ONE SECTOR.
                        *
                        *	ENTRY	NONE
                        *	EXIT	'C' CLEAR IF ADVANCED
                        *		'C' SET IF EOF
                        *		 (A) = EC.EOF
                        *	USES	A,F,H,L

4287  CD 851A           AFP1	CALL	FFL			; FOLLOW FORWARD LINK

428A  21 2721           AFP	LXI	H,AIO.CGN
428D  3A 2921           	LDA	AIO.LGN
4290  BE                	CMP	M			; SEE IF AM ON LAST GROUP
                        	ERRNZ	AIO.CSI-AIO.CGN-1
4291  23                	INX	H			; (HL) = #AIO.CSI
4292  C2 A042           	JNE	AFP2			; NOT YET
4295  3A 2A21           	LDA	AIO.LSI
4298  BE                	CMP	M			; SEE IF ALSO ON LAST SECTOR
4299  C2 A042           	JNE	AFP2			; NOT YET
429C  37                	STC
429D  3E 01             	MVI	A,EC.EOF
429F  C9                	RET				; AT END OF FILE

                        *	NOT AT END OF FILE

42A0  3A 2621           AFP2	LDA	AIO.SPG
42A3  BE                	CMP	M
42A4  CA 8742           	JE	AFP1			; AT END OF GROUP
42A7  34                	INR	M			; ADVANCE
42A8  A7                	ANA	A			; CLEAR CARRY
42A9  C9                	RET
42AA                    	STL	'DELETE - PROCESS DELETE FUNCTION'
42AA                    	EJECT
                        **	DELETE - PROCESS DELETE COMMAND.
                        *
                        *	This routine was modified to return the free blocks only
                        *	if the directory sector was successfully written back.
                        *	This avoids any doubly allocated blocks as may be the case
                        *	for a disk that is mounted with the drive write-enabled
                        *	which is subsequently changed to write-disabled.
                        *
                        *	ENTRY	(HL) = NAME STRING
                        *		(DE) = DEFAULT BLOCK
                        *	EXIT	'C' CLEAR IF OK
                        *		'C' SET IF ERROR
                        *		 (A) = CODE
                        *	USES	ALL

      = 42AA            DELETE	EQU	*

42AA  CD 794E           	CALL	LFD			; LOCATE FILE IN DIRECTORY
42AD  D8                	RC				; ERROR OF SOME KIND

                        *	SEE IF FILE IS WRITE PROTECTED OR LOCKED FROM DELETE

42AE  EB                	XCHG				; (DE) = DIRECTORY ENTRY ADDRESS
42AF  21 0E00           	LXI	H,DIR.FLG
42B2  19                	DAD	D			; (HL) = #DIR.FLG
42B3  7E                	MOV	A,M
42B4  E6 22             	ANI	DIF.WP+DIF.DL		; SEE IF DELETE ALLOWED 	
42B6  CA C242           	JZ	DELETE0 		; 'sok

                        *	Return correct error for locked file

42B9  E6 20             	ANI	DIF.WP			; CHECK WRITE PROTECT
42BB  3E 14             	MVI	A,EC.WPV		; ASSUME WRITE PROTECT VIOLATION
42BD  37                	STC				; make an error
42BE  C0                	RNZ				; IS PROTECTED
42BF  3E 2C             	MVI	A,EC.LAD		;  else is delete locked
42C1  C9                	RET

                        *	File is not locked

42C2  3A 2321           DELETE0 LDA	AIO.FLG
42C5  E6 04             	ANI	FT.OW
42C7  3E 1D             	MVI	A,EC.DIW		; DEVICE IS NOT WRITABLE
42C9  37                	STC
42CA  C8                	RZ
42CB  EB                	XCHG				; (HL) = ADDRESS OF DIR ENTRY

                        *	DELETE FILE, write directory, then return free blocks

42CC  36 FF             	MVI	M,DF.EMP		; FLAG EMPTY
42CE  E5                	PUSH	H			; Save entry pointer
42CF  CD 6351           	CALL	UDS			; Update Directory Sector
42D2  E1                	POP	H
42D3  D8                	RC
42D4  CD 6350           	CALL	RBF			; RETURN BLOCKS TO FREE POOL
42D7  C3 E150           	JMP	SGT			; SAVE GRT TABLE, AND EXIT
42DA                    	STL	'RENAME - PROCESS RENAME FUNCTION'
42DA                    	EJECT
                        ***	RENAME - PROCESS RENAME FUNCTION.
                        *
                        *	RENAME RENAMES A FILE ON A DIRECTORY DEVICE.
                        *
                        *	* NOTE * RENAME DOES NOT CHECK TO SEE IF THE NEW NAME ALREADY
                        *	EXISTS, THIS IS CURRENTLY THE RESPONSIBILITY OF THE CALLER !
                        *
                        *	ENTRY	(HL) = NAME STRING
                        *		(DE) = DEFAULT BLOCK
                        *		(BC) = NEW NAME STRING
                        *	EXIT	'C' CLEAR IF OK
                        *		'C' SET IF ERROR
                        *		 (A) = CODE
                        *	USES	ALL

      = 42DA            RENAME	EQU	*

42DA  CD 794E           	CALL	LFD			; LOCATE FILE IN DIRECTORY
42DD  D8                	RC				; FILE NOT FOUND

                        *	SEE IF DEVICE IS READ AND WRITABLE

42DE  3A 2321           	LDA	AIO.FLG
42E1  2F                	CMA
42E2  E6 07             	ANI	DT.DD+DT.CR+DT.CW
42E4  3E 1D             	MVI	A,EC.DIW		; DEVICE NOT WRITABLE
42E6  37                	STC
42E7  C0                	RNZ				; WE KNOW IS DISK, MUST BE WRITE PROT

                        *	HAVE FOUND DIRECTORY ENTRY. CRACK NEW NAME.

42E8  E5                	PUSH	H			; SAVE ENTRY ADDRESS
42E9  11 0E00           	LXI	D,DIR.FLG
42EC  19                	DAD	D			; (HL) = ADDRESS OF FLAG BYTE
42ED  7E                	MOV	A,M
42EE  E6 60             	ANI	DIF.LOC+DIF.WP		; DONT RENAME IF LOCKED OR WRITE PROTECT
42F0  CA FD42           	JZ	RENAME1 		; NOT LOCKED OR WRITE PROTECT
42F3  E1                	POP	H			; clear stack			
42F4  E6 20             	ANI	DIF.WP			; check for write protect
42F6  3E 14             	MVI	A,EC.WPV		; ASSUME FILE WRITE PROTECTED
42F8  37                	STC
42F9  C0                	RNZ				; is write protect
42FA  3E 18             	MVI	A,EC.FL 		;  else file is locked
42FC  C9                	RET

42FD  3E F7             RENAME1 MVI	A,~DIF.ARC
42FF  A6                	ANA	M			; mask off 'A' flag
4300  77                	MOV	M,A

4301  2A 3021           	LHLD	AIO.UNI-1		; (H) = AIO.UNI
4304  E5                	PUSH	H			; SAVE CURRENT UNIT
4305  60                	MOV	H,B
4306  69                	MOV	L,C			; (HL) = NEW NAME ADDRESS
4307  11 D019           	LXI	D,$ZEROS
430A  CD AF4B           	CALL	DFD			; DECODE FILE DESCRIPTOR
430D  C1                	POP	B			; (B) = UNIT NUMBER
430E  E1                	POP	H			; (HL) = ADDRESS OF ENTRY IN DIRECTORY
430F  D8                	RC				; ERROR
4310  3E 07             	MVI	A,EC.IFN		; ERROR CODE, ILLEGAL FILE NAME
4312  37                	STC
4313  C8                	RZ				; NULL FILE NAME
4314  78                	MOV	A,B			; (A) = UNIT NUMBER
4315  32 3121           	STA	AIO.UNI 		; SET ORIGINAL UNIT NUMBER
                        	ERRNZ	DIR.NAM 		; ASSUMED FIRST OFF
4318  11 3221           	LXI	D,AIO.DIR+DIR.NAM
431B  01 0B00           	LXI	B,DIRIDL
431E  CD AA18           	CALL	$MOVE			; MOVE IN NEW NAME
4321  C3 6351           	JMP	UDS			; UPDATE DIRECTORY SECTOR AND RETURN
4324                    	STL	'SETTOP - SET TOP OF USER MEMORY USE.'
4324                    	EJECT
                        ***	SETTOP - SET TOP OF USER MEMORY.
                        *
                        *	SETTOP IS CALLED TO NOTIFY THE SYSTEM OF A NEW MEMORY
                        *	LIMIT ADDRESS.
                        *
                        *	ENTRY	(HL) = NEW ADDRESS
                        *	EXIT	'C' CLEAR IF OK
                        *		'C' SET IF TOO HIGH
                        *		 (HL) = MAXIMUM HEIGHT
                        *	USES	ALL

      = 4324            SETTOP	EQU	*

4324  EB                	XCHG				; (DE) = NEW TOP
4325  2A D020           	LHLD	S.SYSM
4328  2B                	DCX	H
4329  2B                	DCX	H
432A  7D                	MOV	A,L			; COMPARE S.SYSM TO SETTUP
432B  93                	SUB	E
432C  7C                	MOV	A,H
432D  9A                	SBB	D
432E  3E 11             	MVI	A,EC.NEM		; ASSUME NOT ENOUGH
4330  D8                	RC				; CANT HAVE IT
4331  EB                	XCHG
4332  22 D220           	SHLD	S.USRM			; CAN HAVE IT
4335  C9                	RET								
4336                    	STL	'DECODE - PROCESS DECODE SYSCALL'
4336                    	EJECT
                        ***	DECODE - PROCESS DECODE SYSCALL.
                        *
                        *	DECODE DECODES THE SUPPLIED FILE NAME INTO A BLOCK IN THE FORM:
                        *
                        *	DB	FLAG		DEVICE FLAG
                        *	DS	2		DEVICE NAME
                        *	DS	1		DEVICE UNIT
                        *	DS	8		FILE NAME
                        *	DS	3		FILE EXTENSION
                        *	DS	1		not used
                        *	DS	1		not used
                        *	DS	2		DEVICE TABLE POINTER
                        *
                        *	ENTRY	(BC) = LIST FWA
                        *		(DE) = DEFAULT TABLE
                        *		(HL) = NAME ADDRESS
                        *	EXIT	NONE
                        *	USES	ALL

      = 4336            DECODE	EQU	*

4336  C5                	PUSH	B			; SAVE (BC)
4337  CD 7C4B           	CALL	DFA			; DECODE FILENAME INTO AIO.XXX
433A  C1                	POP	B
433B  D8                	RC				; ERROR
433C  60                	MOV	H,B
433D  69                	MOV	L,C			; (HL) = ADDRESS OF BLOCK
433E  3A 2321           	LDA	AIO.FLG
4341  77                	MOV	M,A			; STORE
4342  23                	INX	H
                        	ERRNZ	AIO.DIR-AIO.UNI-1
                        	ERRNZ	AIO.UNI-AIO.DEV-2
4343  01 0E00           	LXI	B,DIRIDL+3
4346  11 2F21           	LXI	D,AIO.DEV
4349  CD AA18           	CALL	$MOVE			; MOVE IN STUFF
434C  23                	inx	h			; skip				
434D  23                	inx	h			;  ''
434E  EB                	XCHG
434F  2A 2B21           	LHLD	AIO.DTA
4352  EB                	XCHG
4353  73                	MOV	M,E
4354  23                	INX	H
4355  72                	MOV	M,D			; SET DEV TABLE ADDRESS
4356  C9                	RET
4357                    	STL	'NAME - PROCESS NAME SYSCALL'
4357                    	EJECT
                        ***	NAME - PROCESS NAME SYSCALL.
                        *
                        *	THE NAME SYSCALL RETURNS THE DEVICE, FILE NAME, AND
                        *	FILE EXTENSION OF AN OPEN CHANNEL.
                        *
                        *	THE INFORMATION IS OBTAINED FROM THE CHANNEL TABLE, WHICH WAS
                        *	SETUP UPON FILE OPEN.
                        *
                        *	ENTRY	(A) = CHANNEL NUMBER
                        *		(DE) = ADDRESS FOR DEVICE AND EXTENSION (DEFAULT BLOCK FORMAT)
                        *		(HL) = ADDRESS FOR NAME (8 CHARACTERS, FOLLOWED BY 00)
                        *	EXIT	'C' CLEAR IF OK
                        *		'C' SET IF ERROR
                        *		 (A) = ERROR CODE
                        *	USES	ALL

4357  E5                NAME	PUSH	H
4358  D5                	PUSH	D
4359  CD 964C           	CALL	FCC			; FETCH COMPLETE CHANNEL
435C  D2 6243           	JNC	NAME1			; NO ERROR
435F  D1                	POP	D
4360  E1                	POP	H							
4361  C9                	RET				; RETURN WITH ERROR

4362  E1                NAME1	POP	H			; (HL) = ADDRESS FOR DEVICE, ETC
4363  11 2F21           	LXI	D,AIO.DEV
4366  01 0300           	LXI	B,3
4369  CD AA18           	CALL	$MOVE			; MOVE IN DEVICE CODE
436C  2B                	DCX	H
436D  7E                	MOV	A,M
436E  C6 30             	ADI	'0'			; MAKE INTO DIGIT
4370  77                	MOV	M,A
4371  23                	INX	H
4372  E3                	XTHL				; (HL) = ADDRESS FOR NAME
4373  01 0800           	LXI	B,8
                        	ERRNZ	AIO.DIR+DIR.NAM-AIO.DEV-3
4376  CD AA18           	CALL	$MOVE			; MOVE IN NAME
4379  36 00             	MVI	M,0			; FLAG END OF NAME
437B  E1                	POP	H			; (HL) = ADDRESS FOR EXTENSION
437C  01 0300           	LXI	B,3
                        	ERRNZ	DIR.EXT-DIR.NAM-8
437F  C3 AA18           	JMP	$MOVE			; MOVE EXTENSION, AND EXIT
4382                    	STL	'CLEAR - CLEAR I/O CHANNEL'
4382                    	EJECT
                        ***	CLEAR - CLEAR I/O CHANNEL.
                        *
                        *	CLEAR IS CALLED TO CLEAR AN I/O CHANNEL. IF THE CHANNEL IS CLOSED,
                        *	NO ACTION IS PERFORMED. IF THE CHANNEL IS OPEN, IT IS
                        *	FLAGGED CLOSED. THE RESULTS OF THIS OPERATION DEPEND UPON THE TYPE
                        *	OF FILE:
                        *
                        *	OPEN FOR		ACTION
                        *
                        *	READ		SAME AS .CLOSE
                        *	WRITE		FILE IS FORGOTTEN. ANY WRITTEN DISK BLOCKS
                        *			ARE RESTORED TO THE FREE POOL.
                        *	UPDATE		REPLACED SECTORS REMAIN REPLACED. APPENDED SECTORS
                        *			ARE LOST UNTIL NEXT BOOT. FILE STAYS AT PREVIOUS LENGTH.
                        *	WRITEC		SAME AS WRITE
                        *
                        *	THE DEVICE DRIVER IS NOT INFORMED OF THE CLOSING.
                        *
                        *	MVI	A,CHANNEL
                        *	SCALL	.CLEAR
                        *
                        *	ENTRY	(A) = CHANNEL NUMBER
                        *	EXIT	'C' CLEAR IF OK
                        *		'C' SET IF ERROR
                        *		 (A) = ERROR CODE
                        *	USES	ALL

      = 4382            CLEAR	EQU	*

4382  CD 1121           	CALL	S.FCI			; FETCH CHANNEL INFO
4385  D8                	RC				; ERROR
4386  2A 4E21           	LHLD	AIO.CHA
                        	ERRNZ	*-CLEAR1
4389                    	SPACE	3,10
                        **	CLEAR1 - CLEAR CHANNEL.
                        *
                        *	ENTRY	(HL) = IOC.DDA ADDRESS
                        *	EXIT	NONE
                        *	USES	ALL

                        	ERRNZ	IOC.FLG-IOC.DDA-2
4389  23                CLEAR1	INX	H
438A  23                	INX	H			; (HL) = #IOC.FLG ADDRESS
438B  7E                	MOV	A,M

                        *	IF FILE IS DIRECTORY DEVICE, OPEN FOR WRITE BUT NOT UPDATE, CLEAR BLOCKS

438C  EE 08             	XRI	FT.OU			; MUST NOT BE FOR UPDATE
438E  2F                	CMA
438F  E6 0F             	ANI	FT.OR+FT.OW+FT.DD+FT.OU ; FT.DD & FT.OW & FT.OR & FT.OU
4391  36 00             	MVI	M,0			; CLEAR FLAGS
4393  C0                	RNZ				; NOT WRITE-ONLY MASS STORAGE, EXIT

                        *	IS WRITE ONLY MASS STORAGE FILE. CLEAR SPACE

                        	ERRNZ	IOC.GRT-IOC.FLG-1
4394  23                	INX	H			; (HL) = #IOC.GRT
4395  54                	MOV	D,H
4396  5D                	MOV	E,L			; (DE) = #IOC.GRT
4397  CD 8918           	CALL	$HLIHL			; (HL) = GRT ADDRESS
439A  E5                	PUSH	H			; SAVE
439B  21 1E00           	LXI	H,IOC.DIR+DIR.FGN-IOC.GRT
439E  19                	DAD	D			; (HL) = ADDRESS OF FIRST GROUP NUMBER
439F  7E                	MOV	A,M			; (A) = FIRST GROUP INDEX
43A0  E1                	POP	H			; (HL) = GRT ADDRESS
43A1  C3 C34C           	JMP	FGC			; FREE GROUP CHAIN AND EXIT
43A4                    	STL	'CLRALL - CLEAR ALL CHANNELS'
43A4                    	EJECT
                        ***	CLRALL - CLEAR ALL CHANNELS.
                        *
                        *	CLRALL PERFORMS THE .CLEAR ACTION FOR ALL EXISTING CHANNELS,
                        *	EXCEPT CHANNEL 377Q, THE LOAD IMAGE CHANNEL.
                        *
                        *	SCALL	.CLEARA
                        *
                        *	ENTRY	NONE
                        *	EXIT	NONE
                        *	USES	ALL

      = 43A4            CLRALL	EQU	*

43A4  2A EA20           	LHLD	S.CFWA
                        	ERRNZ	IOCCTD-1		; NEED TO CHAIN PAST 1 CHANNEL
43A7  CD 8918           	CALL	$HLIHL			; POINT TO USER CHANNEL #0

43AA  7C                CLRALL1	MOV	A,H
43AB  B5                	ORA	L
43AC  C8                	RZ				; END OF CHANNELS
43AD  E5                	PUSH	H			; SAVE ADDRESS
                        	ERRNZ	IOC.DDA-IOC.LNK-2
43AE  23                	INX	H
43AF  23                	INX	H			; POINT TO IOC.DDA
43B0  CD 8943           	CALL	CLEAR1			; CLEAR IT
43B3  E1                	POP	H			; (HL) = CHANNEL LINK ADDRESS
43B4  CD 8918           	CALL	$HLIHL			; (HL) = ADDRESS OF NEXT ONE
43B7  C3 AA43           	JMP	CLRALL1
43BA                    	STL	'ERROR - PRINT ERROR MESSAGE'
43BA                    	EJECT
                        ***	ERROR - PRINT ERROR MESSAGE.
                        *
                        *	ERROR IS CALLED TO PRINT AN ERROR MESSAGE.
                        *
                        *	THE HDOS SYSTEM RETURNS ERROR CODE NUMBERS WHEN IT DETECTS
                        *	AN ERROR. THE ERROR FUNCTION MAY BE USED TO TYPE AN ALPHABETIC
                        *	EXPLANATION OF THE ERROR.
                        *
                        *	THE ERRORS ARE STORED IN THE FILE 'ERRORMSG.SYS' ON THE SYSTEM
                        *	DISK, ONE MESSAGE PER LINE. THE LINES LOOK LIKE:
                        *
                        *	NNNTEXT
                        *
                        *	FOR EXAMPLE,
                        *
                        *	001End of File
                        *
                        *	IF THE ERROR MESSAGE FILE CANNOT BE READ, OR THE MESSAGE DOES
                        *	NOT APPEAR, THE ERROR IS TYPED AS
                        *
                        *	'?02 Error # NNN'
                        *
                        *	ENTRY	(A) = ERROR CODE
                        *		(H) = TRAILING CHARACTER (TYPED AFTER MESSAGE)
                        *	EXIT	NONE
                        *	USES	ALL

      = 43BA            ERROR	EQU	*

43BA  E5                	PUSH	H			; SAVE FINAL CHARACTER

                        *	CRACK ERROR CODE

43BB  4F                	MOV	C,A
43BC  06 00             	MVI	B,0			; (BC) = C0DE
43BE  21 2844           	LXI	H,ERRORB
43C1  3E 03             	MVI	A,3
43C3  CD 6F19           	CALL	$UDD			; UNPACK DECIMAL DIGITS
43C6  CD D543           	CALL	ERR0.5
43C9  D2 D143           	JNC	ERR4			; CRACKED MESSAGE OK

                        *	COULDNT GET MESSAGE

43CC  21 1B44           	LXI	H,ERRORA
43CF  FF 03             	SCALL	.PRINT

                        *	PRINT FINAL CHARACTER

43D1  F1                ERR4	POP	PSW			; (A) = CODE
43D2  FF 02             	SCALL	.SCOUT
43D4  C9                	RET

                        *	OPEN ERROR MESSAGE FILE

      = 43D5            ERR0.5	EQU	*

43D5  21 2C44           	LXI	H,ERRORC
43D8  CD 7C4B           	CALL	DFA
43DB  D8                	RC				; FILE ERROR
43DC  CD 944D           	CALL	LDE.			; LOCATE DIRECTORY ENTRY
43DF  D8                	RC				; FILE ERROR
43E0  CD AD4A           	CALL	CFI			; COPY FILE INFO FROM DIRECTORY ENTRY

                        *	READ SECTORS FOR ERROR MESSAGE

43E3  2A 5121           	LHLD	S.SCR	;SECTOR SCRATCH AREA
43E6  2D                	DCR	L	;FORCE IMMEDIATE READ

43E7  06 03             ERR0	MVI	B,3
43E9  11 2844           	LXI	D,ERRORB

43EC  CD 3D44           ERR1	CALL	RTB			; READ TEXT BYTE
43EF  D8                	RC				; END OF FILE
43F0  1A                	LDAX	D
43F1  BE                	CMP	M
43F2  C2 0E44           	JNE	ERR2.5			; NOT RIGHT MESSAGE NUMBER
43F5  13                	INX	D
43F6  05                	DCR	B
43F7  C2 EC43           	JNZ	ERR1			; KEEP TRYING

                        *	GOT ERROR MESSAGE. TYPE IT

43FA  CD 5E19           	CALL	$TYPTX
43FD  3F3032A0          	DB	'?02',' '+EOL		; give a sign of message source

4401  CD 3D44           ERR2	CALL	RTB			; READ MESSAGE BYTE
4404  D8                	RC				; ERROR
4405  7E                	MOV	A,M
4406  FE 0A             	CPI	NL			; SEE IF NEW LINE
4408  C8                	RE				; END OF MESSAGE
4409  FF 02             	SCALL	.SCOUT
440B  C3 0144           	JMP	ERR2

                        *	THIS IS NOT THE RIGHT MESSAGE. READ THE NEXT

440E  CD 3D44           ERR2.5	CALL	RTB
4411  D8                	RC				; MESSAGE NOT FOUND
4412  7E                	MOV	A,M			; (A) = MESSAGE CHARACTER
4413  FE 0A             	CPI	NL
4415  C2 0E44           	JNE	ERR2.5			; READ TILL NEXT LINE
4418  C3 E743           	JMP	ERR0			; TRY THIS MESSAGE

441B  073F3032 20457272 ERRORA	DB	BELL,'?02 Error # '
4423  6F722023 20
4428  4A474C            ERRORB	DB	'JGL'	;MESSAGE NUMBER
442B  A0                	DB	' '+EOL

442C  5359303A 4552524F ERRORC	DB	'SY0:ERRORMSG.SYS',0
4434  524D5347 2E535953
443C  00
443D                    	SPACE	4,10
                        **	RTB - READ TEXT BYTE
                        *
                        *	RTB LOCATES THE NEXT BYTE OF THE FILE BEING READ.
                        *
                        *	ENTRY	(HL) = BUFFER POINTER
                        *	EXIT	'C' CLEAR IF GOT IT
                        *		 (HL) = ADDRESS
                        *		'C' SET IF ERROR
                        *	USES	A,F,L

443D  A7                RTB	ANA	A			; CLEAR CARRY
443E  2C                	INR	L
443F  C0                	RNZ				; GOT MORE
4440  C5                	PUSH	B
4441  D5                	PUSH	D
4442  01 0001           	LXI	B,256
4445  EB                	XCHG
4446  2A 5121           	LHLD	S.SCR
4449  EB                	XCHG				; DE = SCRATCH ADDRESS
444A  D5                	PUSH	D
444B  CD 0E21           	CALL	S.DIREA
444E  E1                	POP	H			; (HL) = POINTER
444F  D1                	POP	D
4450  C1                	POP	B
4451  C9                	RET
4452                    	STL	'CHFLG - CHANGE FILE FLAGS'
4452                    	EJECT
                        **	CHFLG - CHANGE FILE FLAGS.
                        *
                        *	CHFLG IS CALLED TO CHANGE THE FILE DESCRIPTION FLAGS
                        *	FOR A MASS STORAGE FILE. ONLY CERTAIN FLAGS MAY BE
                        *	CHANGED:
                        *
                        *	FLAG	BIT	MEANING
                        *
                        *	DIF.SYS	200Q	IS SYSTEM FILE
                        *	DIF.LOC	100Q	LOCKED FOR CHANGE (SETABLE ONLY)
                        *	DIF.WP	040Q	IS WRITE PROTECTED
                        *	DIF.ARC 010Q	Archive attribute				
                        *	DIF.BAD 004Q	File is damaged
                        *	DIF.DL	002Q	File is delete locked
                        *	DIF.USR 001Q	User defined
                        *
                        *	CHFLG WILL REFUSE THE OPERATION IF THE DIF.LOC BIT IS SET.
                        *
                        *	ENTRY	(B) = NEW BIT VALUES
                        *		(C) = CHANGE MASK (BIT SET FOR EVERY BIT TO REPLACE FROM (B))
                        *		(DE) = DEFAULT BLOCK ADDRESS
                        *		(HL) = FILE NAME
                        *	EXIT	'C' CLEAR, CHANGE DONE
                        *		'C' SET, ERROR
                        *		 (A) = ERROR CODE
                        *	USES	ALL

      = 4452            CHFLG	EQU	*

4452  CD 794E           	CALL	LFD			; LOCATE FILE IN DIRECTORY
4455  D8                	RC				; IF ERROR

4456  3A 2321           	LDA	AIO.FLG
4459  E6 04             	ANI	DT.CW
445B  3E 15             	MVI	A,EC.WP 		; ASSUME DISKETTE IS WRITE PROTECTED
445D  37                	STC
445E  C8                	RZ				; NOT CAPABLE OF WRITE

445F  79                	MOV	A,C
                        	ERRNZ	DIF.LOC-100Q						
                        	ERRNZ	DIF.CNT-020Q
4460  E6 AF             	ANI	257Q			; Allow all but 'L' and 'C'
4462  2F                	CMA
4463  4F                	MOV	C,A			; (C) = -MASK
4464  2F                	CMA
4465  F6 40             	ORI	DIF.LOC 		; ALLOW HIM TO LOCK
4467  A0                	ANA	B			; CLEAR UNWANTED BITS
4468  11 0E00           	LXI	D,DIR.FLG
446B  19                	DAD	D			; (HL) = ADDRESS OF DIR.FLG BYTE
446C  47                	MOV	B,A
446D  7E                	MOV	A,M			; (A) = FLAG BYTE
446E  E6 40             	ANI	DIF.LOC
4470  3E 18             	MVI	A,EC.FL 		; ASSUME FILE LOCKED
4472  37                	STC
4473  C0                	RNZ				; LOCKED
4474  7E                	MOV	A,M
4475  A1                	ANA	C			; CLEAR BITS
4476  B0                	ORA	B			; SET BITS
4477  77                	MOV	M,A			; REPLACE
4478  C3 6351           	JMP	UDS			; UPDATE DIRECTORY SECTOR
447B                    	STL	'DISMT - FLAG SYSTEM DISK DISMOUNTED'
447B                    	EJECT
                        ***	DISMT - FLAG SYSTEM DISK DISMOUNTED.
                        *
                        *	THE DISMT FUNCTION IS USED WHEN THE SYSTEM DISK IS ABOUT TO BE
                        *	DISMOUNTED. ANY HDOS FUNCTIONS WHICH REQUIRE SYSTEM FILES
                        *	WILL BE TREATED AS FATAL SYSTEM ERRORS.
                        *
                        *	ENTRY	None
                        *	EXIT	S.SYSM = LWA OF FREE SPACE FOR USER
                        *		(HL) = (S.SYSM)
                        *	USES	ALL

      = 447B            DISMT	EQU	*

447B  AF                	XRA	A
447C  32 1A21           	STA	S.MOUNT 		; FLAG DISK UNMOUNTED

447F  2A D020           	LHLD	S.SYSM			; (HL)	FOR EXIT
4482  C9                	RET
4483                    	STL	'LOADD - Load Device Driver'
4483                    	EJECT
                        ***	LOADD	-  LOAD DEVICE DRIVER
                        *
                        *	LOADD LOADS THE SPECIFIED DEVICE DRIVER.
                        *
                        *	ENTRY:	(HL)	=  DEVICE DRIVER DESCRIPTOR STRING
                        *
                        *	EXIT:	PSW	= 'C' set   if NO Error
                        *			    HL = device Table address
                        *			  'C' clear if	  Error
                        *			    A  = Error Code
                        *
                        *	USES:	ALL
                        *

      = 4483            LOADD	EQU	*

4483  11 D019           	LXI	D,$ZEROS		; default device descriptor
4486  CD 9A49           	CALL	CAC
4489  CD AF4B           	CALL	DFD			; decode file name
448C  D8                	RC
448D  CD 584A           	CALL	CDU
4490  D8                	RC				; check unit
4491  CD F34D           	CALL	LDI0
4494  D8                	RC
4495  CD 484E           	CALL	LDI5
4498  D8                	RC

4499  2A 2B21           	LHLD	AIO.DTA 		; HL = device table
449C  CD CF51           	CALL	$INDLB
449F  0200              	DW	DEV.RES
44A1  E6 01             	ANI	DR.IM
44A3  C0                	RNZ				; driver is in memory

44A4  3E 09             	MVI	A,DC.LOD
44A6  CD 2021           	CALL	AIO.VEC 		; call driver
44A9  2A 2B21           	LHLD	AIO.DTA 		; HL = device table address

44AC  C9                	ret				; exit with load pending
44AD                    	STL	'MOUNT - Mount Disk'
44AD                    	EJECT
                        ***	MOUNT	- MOUNT DISK
                        *
                        *	MOUNT DISK ON SPECIFIED UNIT OF SELECTED DEVICE
                        *
                        *
                        *	ENTRY:	(HL)	= ADDRESS OF DEVICE SPECIFICATION
                        *
                        *	EXIT:	(PSW)	= 'C' SET   IF ERROR
                        *			   (A)  = ERROR CODE
                        *			  'C' CLEAR IF NO ERROR
                        *			   'Z' CLEAR IF AN ABORT
                        *
                        *	USES:	ALL
                        *

      = 44AD            MOUNT	EQU	*

44AD  CD E144           	CALL	MOUNMS
44B0  D8                	RC
44B1  C0                	RNZ				; THERE WAS AN ABORT
44B2  CD 124D           	CALL	GETLAB			; GET LABEL FOR MESSAGE
44B5  D8                	RC
44B6  21 BC44           	LXI	H,MOUA
44B9  C3 294D           	JMP	IMM			; ISSUE MESSAGE

44BC  4D6F756E 74656420 MOUA	DB	'Mounted on',' '+EOL
44C4  6F6EA0
44C7                    	STL	'DMOUN - Dismount Disk'
44C7                    	EJECT
                        ***	DMOUN	- DISMOUNT DISK
                        *
                        *	DISMOUNT DISK ON SELECTED DRIVE
                        *
                        *
                        *	IF  AN ATTEMPT IS MADE TO DISMOUNT SY0:,  THEN
                        *	   FORCE OVERLAY IN IF THERE IS ROOM
                        *
                        *
                        *	ENTRY:	(HL)	= ADDRESS OF DEVICE SPECIFICATION
                        *
                        *	EXIT:	(PSW)	= 'C' SET   IF ERROR
                        *			   (A)  = ERROR CODE
                        *
                        *	USES:	ALL

      = 44C7            DMOUNT	EQU	*

44C7  CD 3A45           	CALL	DMONMS
44CA  D8                	RC
44CB  21 D144           	LXI	H,DMOUA
44CE  C3 294D           	JMP	IMM							

44D1  4469736D 6F756E74 DMOUA	DB	'Dismounted from',' '+EOL
44D9  65642066 726F6DA0
44E1                    	STL	'MOUNMS - Mount/No message'
44E1                    	EJECT
                        ***	MOUNMS	- MOUNT/NO MESSAGE
                        *
                        *	MOUNT SPECIFIED UNIT OF SELECTED DEVICE WITHOUT ISSUING MOUNT MESSAGE.
                        *
                        *	IF  AN ATTEMPT IS MADE TO MOUNT SY0:  AND  IT IS A SYSTEM DISK
                        *	  MOUNT A NEW SYSTEM DISK
                        *
                        *	ENTRY:	(HL)	= ADDRESS OF DEVICE SPECIFICATION
                        *
                        *	EXIT:	(PSW)	= 'C' SET   IF ERROR
                        *			   (A)  = ERROR CODE
                        *			  'C' CLEAR IF NO ERROR
                        *			   'Z' CLEAR IF THERE WAS AN ABORT
                        *
                        *	USES:	ALL
                        *

      = 44E1            MOUNMS	EQU	*

44E1  CD A749           	CALL	CDM
44E4  D8                	RC				; error
44E5  3E 21             	MVI	A,EC.VPM		; assume have volume
44E7  37                	STC
44E8  C0                	RNZ				; yep.

44E9  E5                	PUSH	H
44EA  C5                	PUSH	B

44EB  CD 9249           	CALL	CAB
44EE  C2 3745           	JNZ	MOU2.5			; THERE WAS AN ABORT
44F1  CD B74E           	CALL	MND			; MOUNT NEW DISK
44F4  DC 3145           	CC	MOU2			; IF ERROR
44F7  CD 6D4F           	CALL	PGT			; PROCESS GRT
44FA  DC 3145           	CC	MOU2			; ERROR
44FD  CD E249           	CALL	CDS			; CLEAR DIRECTORY SPACES
4500  DC 3145           	CC	MOU2			; ERROR

4503  C1                	POP	B
4504  E1                	POP	H
4505  78                	MOV	A,B
4506  B6                	ORA	M			; SET MOUNTED
4507  77                	MOV	M,A

                        *	see if system disk is back

4508  3A C652           	LDA	UNIT
450B  A7                	ANA	A			; is unit 0?
450C  C2 2F45           	JNZ	MOU2.

450F  2A C052           	LHLD	DEVNAME
4512  11 5359           	LXI	D,'YS'
4515  CD 8E18           	CALL	$CDEHL			; is 'SY'?
4518  C2 2F45           	JNZ	MOU2.			; nope.

                        *	is system device... see if is system disk

451B  CD 124D           	CALL	GETLAB			; get volume label

451E  CD A445           	CALL	DMO4			; do check
4521  2A B945           	LHLD	DMOC
4524  CD 8E18           	CALL	$CDEHL			; is same as was dismounted?
4527  C2 2F45           	JNZ	MOU2.			; no

452A  3E 01             	MVI	A,1
452C  32 1A21           	STA	S.MOUNT 		; system disk has come home.

452F  AF                MOU2.	XRA	A			; SET ZERO FLAG TO INDICATE NO ABORT
4530  C9                	RET

4531  FE 15             MOU2	CPI	EC.WP			; SEE IF ERROR WAS DUE TO WRITE PROTECT
4533  C8                	RZ				; YES, CONTINUE AS IF NO ERROR
4534  33                	INX	SP			; NO, THERE'S A REAL ERROR
4535  33                	INX	SP			; SO RESET THE STACK
4536  37                	STC				; SET THE CARRY AND FALL THROUGH

4537  C1                MOU2.5	POP	B			; ERROR RETURN
4538  E1                	POP	H
4539  C9                	RET
453A                    	STL	'DMONMS - Dismount/No message'
453A                    	EJECT
                        ***	DMONMS	- DISMOUNT DEVICE/NO MESSAGE
                        *
                        *	DISMOUNT SELECTED UNIT OF SPECIFIED DEVICE WITHOUT ISSUING DISMOUNT
                        *	MESSAGE
                        *
                        *	IF  AN ATTEMPT IS MADE TO DISMOUNT SY0:  THEN
                        *	    FORCE IN OVERLAY
                        *	    DISMOUNT OPERATING SYSTEM
                        *
                        *
                        *	ENTRY:	(HL)	= ADDRESS OF DEVICE SPECIFICATION
                        *
                        *	EXIT:	(PSW)	= 'C' SET IF ERROR
                        *			   (A)  = ERROR CODE
                        *
                        *	USES:	ALL
                        *

      = 453A            DMONMS	EQU	*

453A  CD A749           	CALL	CDM			; CHECK FOR DEVICE MOUNTED
453D  D8                	RC				; ERROR IN DEVICE SPECIFICATION
453E  C2 4545           	JNZ	DMO1			; MOUNTED
4541  3E 22             	MVI	A,EC.NVM		; NO VOLUME PRESENTLY MOUNTED
4543  37                	STC
4544  C9                	RET

                        *	OK TO DISMOUNT

4545  CD CF4A           DMO1	CALL	COF			; CHECK FOR OPEN FILES ON THE DEVICE
4548  D8                	RC				; SHOULD NOT DISMOUNT A DISK WITH OPEN FILES.
4549  C5                	PUSH	B			; SAVE INDEX
454A  E5                	PUSH	H			; SAVE DEV.MUM ADDRESS

454B  AF                	XRA	A
454C  32 B845           	STA	DMOB			; initialize system disk flag
454F  3A C652           	LDA	UNIT			; A  = current unit
4552  A7                	ANA	A
4553  C2 6645           	JNZ	DMO2			; NOT unit 0

4556  2A C052           	LHLD	DEVNAME 		; HL = device name
4559  11 5359           	LXI	D,'YS'			; SY:
                        	ERRNZ	IOC.UNI-IOC.DEV-2
455C  CD 8E18           	CALL	$CDEHL
455F  C2 6645           	JNZ	DMO2			; Not the system device

4562  21 B845           	lxi	h,dmob							
4565  34                	inr	m			; clear system flag

4566  2A CE52           DMO2	LHLD	UNTTAB
4569  CD CF51           	CALL	$INDLB			; A  = unit flag byte
456C  0000              	DW	UNT.FLG
456E  E6 04             	ANI	DT.CW
4570  CA 8645           	JZ	DMO3			; unit is write protected

4573  CD 9C18           	CALL	$INDL
4576  0400              	DW	UNT.GTS
4578  D5                	PUSH	D
4579  CD 9C18           	CALL	$INDL			; DE = GRT RAM ADDRESS
457C  0200              	DW	UNT.GRT
457E  E1                	POP	H			; HL = GRT SECTOR

457F  01 0001           	LXI	B,256			; (BC) = COUNT
                        	ERRNZ	DC.WRI-1
4582  78                	MOV	A,B
4583  CD 3047           	CALL	DRIVER			; WRITE GRT BACK TO DISK

4586  E1                DMO3	POP	H
4587  C1                	POP	B
4588  78                	MOV	A,B
4589  2F                	CMA	
458A  A6                	ANA	M
458B  77                	MOV	M,A			; CLEAR BIT SHOWING MOUNT
458C  CD 174D           	CALL	GETLAB.
458F  D8                	RC				; ERROR

4590  3A B845           	LDA	DMOB
4593  A7                	ANA	A
4594  C8                	RZ				; WAS NOT SY0:

                        *	FLAG SYSTEM DISMOUNTED

4595  3A 1A21           	LDA	S.MOUNT
4598  A7                	ANA	A
4599  C8                	RZ				; system already flagged gone

                        *	save vital statistics so we can re-mount system disk later

459A  CD A445           	CALL	DMO4			; (DE) = CRC-16 of label & GRT
459D  EB                	XCHG
459E  22 B945           	SHLD	DMOC			; save for later

45A1  C3 7B44           	JMP	DISMT			; flag system dismounted and exit
45A4                    	SPACE	3,10
                        *	calculate a CRC-16 on critical data

45A4  2A 0300           DMO4	LHLD	S.LABEL 		; label sector
45A7  01 0001           	LXI	B,256			; 256 bytes
45AA  51                	MOV	D,C
45AB  59                	MOV	E,C			; (de) = initial CRC
45AC  CD 773F           	CALL	CRC16

45AF  2A B645           	LHLD	DMOA			; SY0: GRT address
45B2  04                	INR	B
45B3  C3 773F           	JMP	CRC16			; do CRC and return

45B6  0000              DMOA	DW	0			; address of SY0: GRT
45B8  00                DMOB	DB	0			; Dismount system disk flag
45B9  0000              DMOC	DW	0			; calculated CRC of SY0: structures
45BB                    	STL	'RESET - Reset Device'
45BB                    	EJECT
                        ***	RESET	- RESET DEVICE
                        *
                        *	RESET THE SPECIFIED UNIT OF THE SELECTED DEVICE
                        *	BY ISSUING AND DISMOUNT FOLLOWED BY A MOUNT.
                        *	THE DEVICE NAME SHOULD BE IN THE SAME FORMAT AS
                        *	THAT EXPECTED BY MOUNT & DMOUN
                        *
                        *	ENTRY:	(HL)	=  ADDRESS OF DEVICE SPECIFICATION
                        *
                        *	EXIT:	(PSW)	=  'C' CLEAR IF NO ERROR
                        *			   'C' SET   IF    ERROR
                        *				(A)  = ERROR CODE
                        *
                        *	USES:	ALL
                        *

      = 45BB            RESET	EQU	*

45BB  11 C744           	LXI	D,DMOUNT
45BE  CD 0146           	CALL	CFM
45C1  D8                	RC				; if error
45C2  CA AD44           	JZ	MOUNT			;  else go mount it

45C5  E5                	PUSH	H

45C6  CD D145           	CALL	RESET1

45C9  CD 7B51           	CALL	WDO			; WAIT FOR DRIVE TO OPEN

45CC  E1                	POP	H
45CD  C0                	RNZ				; AN ABORT IS PENDING

45CE  C3 AD44           	JMP	MOUNT
45D1                    	SPACE	3,10
                        *	Give standard reset message

      = 45D1            RESET1	EQU	*

45D1  CD 5E19           	CALL	$TYPTX
45D4  0A07506C 65617365 	DB	NL,BELL,'Please replace disk in drive',' '+EOL
45DC  20726570 6C616365
45E4  20646973 6B20696E
45EC  20647269 7665A0

45F3  3E 04             	MVI	A,DEVNAML
45F5  21 C052           	LXI	H,DEVNAME
45F8  CD 2852           	CALL	$TYPCC

45FB  CD 9651           	CALL	$CRLF
45FE  C3 9651           	JMP	$CRLF
4601                    	SPACE	4,10
                        ***	Check for fixed media
                        *
                        *	Entry:	(hl) = device spec.
                        *		(de) = address of dismount routine
                        *	Exit:	'C' set if error
                        *		'Z' set if no disk mounted
                        *	Uses:	A,F

4601  E5                CFM	PUSH	H			; save
4602  D5                	PUSH	D			;  lots
4603  C5                	PUSH	B

4604  E5                	PUSH	H
4605  D5                	PUSH	D

4606  CD A749           	CALL	CDM			; is device mounted?
4609  DA 3346           	JC	CFM1			; error
460C  CA 3346           	JZ	CFM1			;  or not mounted.

460F  CD 8F4E           	CALL	LUD			; look up the device
4612  11 0900           	LXI	D,DEV.UNT
4615  19                	DAD	D
4616  3A C652           	LDA	UNIT
4619  CD BD51           	CALL	GUP			; (hl) = address of unit entry
                        	ERRNZ	UNT.FLG
461C  7E                	MOV	A,M			; get flag
461D  E6 20             	ANI	DT.FX			; is fixed media?
461F  3E 2D             	MVI	A,EC.FIX
4621  37                	STC
4622  C2 3346           	JNZ	CFM1			; yes.

4625  E1                	POP	H
4626  22 2B46           	SHLD	CFMA
4629  E1                	POP	H
462A  CD 0000           	CALL	0			; patched above
      = 462B            CFMA	EQU	*-2
462D  DA 3246           	JC	CFM0			; if error.

4630  AF                	XRA	A
4631  3C                	INR	A			; clear 'Z'

4632  11                CFM0	DB	MI.LXID 		; skip next two POPs

4633  E1                CFM1	POP	H
4634  E1                	POP	H

4635  C1                	POP	B
4636  D1                	POP	D
4637  E1                	POP	H
4638  C9                	RET
4639                    	STL	'RESNMS - Reset Disk (no message)'
4639                    	EJECT
                        ***	RESNMS - Reset Disk (no message)
                        *
                        *	Reset the specified unit of the selected device
                        *	by issuing a dismount followed by a mount. The device
                        *	name should be in the same format as that expected
                        *	by MOUNMS and DMONMS.
                        *
                        *	Entry:	(hl) = address of device specification
                        *		(bc) = address of user message
                        *		  0 = no message
                        *		 -1 = use standard message
                        *	Exit:	'C' set if error
                        *		 (a) = error code
                        *	Uses:	All

      = 4639            RESNMS	EQU	*

4639  11 3A45           	LXI	D,DMONMS
463C  CD 0146           	CALL	CFM			; check for fixed media
463F  D8                	RC				; error.
4640  CA E144           	JZ	MOUNMS			; no disk mounted.

4643  E5                	PUSH	H

4644  78                	MOV	A,B
4645  B1                	ORA	C
4646  CA 5A46           	JZ	RESN2B			; no message

4649  03                	INX	B
464A  78                	MOV	A,B
464B  B1                	ORA	C			; use standard?
464C  CA 5746           	JZ	RESN2A			; yes.

464F  0B                	DCX	B			; start of message
4650  60                	MOV	H,B
4651  69                	MOV	L,C
4652  FF 03             	SCALL	.PRINT			;  and display it

4654  C3 5A46           	JMP	RESN2B

4657  CD D145           RESN2A	CALL	RESET1			; give standard reset message

465A  CD 7B51           RESN2B	CALL	WDO			; WAIT FOR DRIVE TO OPEN

465D  E1                	POP	H
465E  C0                	RNZ				; AN ABORT IS PENDING

465F  C3 E144           	JMP	MOUNMS
4662                    	STL	'DADD - Dismount All Disks'
4662                    	EJECT
                        ***	DADD	- Dismount All Disks
                        *
                        *	DADD dismounts all disks, that is, all mounted volumes of
                        *	all currently mounted disks.  This is usually used in
                        *	preparation for dismounting the system disk.
                        *
                        *	This is included as a system call since the .EXIT call
                        *	needs this code.  Everyone else might as well have access
                        *	to it.
                        *
                        *	ENTRY:	NONE
                        *	EXIT:	PSW	= 'NC'	if NO Error
                        *			  'C'	if    ERROR
                        *			   A  = Error Code
                        *	USES:	ALL
                        *

      = 4662            DADD	EQU	*							

4662  2A EC20           	LHLD	S.DFWA			; HL = address of device table

4665  7E                DADD1	MOV	A,M
                        	ERRNZ	DEV.NAM
4666  A7                	ANA	A
                        	ERRNZ	DV.EL
4667  C8                	RZ				; at the end of the list

4668  CD CF51           	CALL	$INDLB
466B  0600              	DW	DEV.FLG
466D  E6 01             	ANI	DT.DD
466F  01 0E00           	LXI	B,DEVELEN		; BC = entry size
4672  CA 8E46           	JZ	DADD2			; Not a directory device

                        *	Check for mounted units

4675  CD CF51           	CALL	$INDLB			; mounted units mask
4678  0700              	DW	DEV.MUM
467A  A7                	ANA	A			; any mounted?
467B  CA 8E46           	JZ	DADD2			; no, skip over it.

467E  7E                	MOV	A,M
                        	ERRNZ	DEV.NAM
467F  FE 01             	CPI	DV.NU
4681  CA 8E46           	JZ	DADD2			; entry is not in use

                        *	Dismount a directory device

4684  E5                	PUSH	H
4685  09                	DAD	B			; HL = address of next one
4686  CD 6546           	CALL	DADD1			; recurse to the end of the list
4689  E1                	POP	H			; restore stacked device pointer
468A  D8                	RC				; ERROR

468B  C3 9246           	JMP	DADD3			; dismount all units of device

                        *	Advance to the next device

468E  09                DADD2	DAD	B
468F  C3 6546           	JMP	DADD1			; try the next unit
4692                    	SPACE	4,10
                        **	DADD3
                        *
                        *	Dismount all units of a directory device
                        *

4692  CD 9C18           DADD3	CALL	$INDL
4695  0000              	DW	DEV.NAM
4697  EB                	XCHG				; HL = device name
4698  22 C546           	SHLD	DADDA			; initialize device name
469B  EB                	XCHG

469C  CD CF51           	CALL	$INDLB			; A  = maximum number of units
469F  0800              	DW	DEV.MNU
46A1  C6 2F             	ADI	'0'-1
46A3  32 C746           	STA	DADDB			; initialize device unit number

46A6  FE 30             DADD4	CPI	'0'
46A8  3F                	CMC
46A9  D0                	RNC				; all done with this device

46AA  CD B846           	CALL	DADD5			; dismount the device
46AD  D8                	RC				; ERROR
46AE  3A C746           	LDA	DADDB
46B1  3D                	DCR	A
46B2  32 C746           	STA	DADDB
46B5  C3 A646           	JMP	DADD4

46B8  E5                DADD5	PUSH	H
46B9  21 C546           	LXI	H,DADDA
46BC  FF 81             	SCALL	.DMOUN			; dismount device
46BE  E1                	POP	H
46BF  D0                	RNC

46C0  FE 22             	CPI	EC.NVM
46C2  C8                	RZ				; ignore no volume errors
46C3  37                	STC				; set error flag
46C4  C9                	RET

46C5  5359              DADDA	DB	'SY'			; device name
46C7  303A00            DADDB	DB	'0:',0			; device unit
46CA                    	STL	'Disk I/O Subroutines'
46CA                    	EJECT
                        **	DIREAD - DIRECTORIED READ.
                        *
                        *	DIREAD READS THE SPECIFIED NUMBER OF SECTORS FROM A
                        *	DIRECTORIED DEVICE. THE DATA IS READ FROM THE CURRENT
                        *	FILE POSITION.
                        *
                        *	ENTRY	(B) = SECTOR COUNT
                        *		(C) = 0
                        *		(DE) = ADDRESS FOR DATA
                        *		AIO.XXX SETUP
                        *	EXIT	(BC) = COUNT LEFT
                        *		(DE) = NEXT FREE ADDRESS
                        *		'C' CLEAR IF OK
                        *		'C' SET IF ERROR
                        *		 (A) = CODE
                        *	USES	ALL

      = 46CA            DIREAD	EQU	*

46CA  78                	MOV	A,B
46CB  A7                	ANA	A
46CC  C8                	RZ				; NOTHING TO READ
46CD  D5                	PUSH	D			; SAVE (DE)
46CE  CD 021A           	CALL	DCA			; DETERMINE CONTINUOUS AREA
46D1  D1                	POP	D
46D2  3A 4B21           	LDA	AIO.EOF
46D5  1F                	RAR
46D6  D8                	RC				; EXIT IF EOF
46D7  C5                	PUSH	B
46D8  CD 651B           	CALL	PDI			; PREPARE DEVICE I/O
                        	ERRNZ	DC.REA
46DB  CD E346           	CALL	DIREAD1 		; PERFORM I/O
46DE  C1                	POP	B
46DF  D2 CA46           	JNC	DIREAD			; IF NOT ERROR
46E2  C9                	RET
46E3                    	SPACE	3,10
                        **	DIREAD1 - PERFORM I/O
                        *
                        *	DIREAD1 CALLS THE I/O DRIVER, AFTER COMPUTING THE COMPLETION ADDRESS
                        *	(WHICH THE DRIVER WILL NOT RETURN)
                        *
                        *	ENTRY	(A) = OPERATION CODE
                        *		(BC) = COUNT
                        *		(DE) = ADDRESS
                        *		(HL) = SECTOR NUMBER
                        *	EXIT	(PSW) AS FROM DRIVER
                        *		(BC) AS FROM DRIVER
                        *		(DE) = (BC ON ENTRY) + (DE ON ENTRY)
                        *		(HL) AS FROM DRIVER
                        *	USES	ALL

46E3  EB                DIREAD1 XCHG				; (HL) = I/O ADDRESS
46E4  E5                	PUSH	H			; SAVE
46E5  09                	DAD	B			; (HL) = NEW ADDRESS
46E6  E3                	XTHL				; (HL) = I/O ADDRESS ((SP)) = NEW ADDRESS
46E7  EB                	XCHG				; RESTORE AS UPON ENTRY
46E8  CD 2021           	CALL	AIO.VEC 		; CALL DRIVER
46EB  D1                	POP	D			; (DE) = NEW ADDRESS
46EC  C9                	RET
46ED                    	SPACE	4,10
                        **	DIWRITE - DIRECTORY DEVICE WRITE.
                        *
                        *	DIWRITE WRITES THE SPECIFIED NUMBER OF SECTORS TO A DIRECTORIED
                        *	DEVICE.
                        *
                        *	ENTRY	(B) = COUNT
                        *		(C) = 0
                        *		(DE) = TEXT ADDRESS
                        *		AIO.XXX SETUP
                        *	EXIT	(BC) = COUNT LEFT
                        *		(DE) = ADDRESS
                        *		'C' CLEAR, IF OK
                        *		'C' SET IF ERROR
                        *		 (A) = ERROR CODE
                        *	USES	ALL

46ED  C5                DWRIT1	PUSH	B			; SAVE COUNT
46EE  CD 651B           	CALL	PDI			; PREPARE FOR DEVICE I/O
46F1  3E 01             	MVI	A,DC.WRI
46F3  CD E346           	CALL	DIREAD1 		; PERFORM I/O
46F6  C1                	POP	B			; (BC) = COUNT LEFT
46F7  3E 13             	MVI	A,EC.WF 		; WRITE FAIL (IF CARRY SET)
46F9  D8                	RC				; RETURN IF ERROR

      = 46FA            DIWRITE	EQU	*
46FA  78                	MOV	A,B
46FB  A7                	ANA	A
46FC  C8                	RZ				; NO MORE
46FD  D5                	PUSH	D
46FE  CD 021A           	CALL	DCA			; DETERMINE CONTIGUOUS AREA
4701  D1                	POP	D
4702  3A 4B21           	LDA	AIO.EOF
4705  1F                	RAR
4706  D2 ED46           	JNC	DWRIT1			; IF NOT EOF

                        *	MUST APPEND SECTORS TO END OF THE FILE.
                        *	ALLOCATE THE SPACE.

4709  78                DWRIT2	MOV	A,B
470A  A7                	ANA	A
470B  C8                	RZ				; NO MORE
470C  2A 4E21           	LHLD	AIO.CHA
470F  3E 1F             	MVI	A,IOC.DIR+DIR.FLG-IOC.DDA
4711  CD 4118           	CALL	$DADA.			; (HL) = #DIR.FLG IN CHANNEL
4714  7E                	MOV	A,M
4715  E6 EF             	ANI	377Q-DIF.CNT		; IS NOT CONTIGUOUS ANY MORE (IF IT EVER WAS)
4717  77                	MOV	M,A
4718  D5                	PUSH	D
4719  CD 4447           	CALL	ACA			; ALLOCATE CONTINUOUS AREA
471C  D1                	POP	D
471D  3A 4A21           	LDA	AIO.EOM
4720  1F                	RAR	
4721  D8                	RC				; EXIT IF EOM

                        *	NOT OUT OF SPACE. WRITE IT

4722  C5                	PUSH	B
4723  CD 651B           	CALL	PDI			; PREPARE DEVICE I/O
4726  3E 01             	MVI	A,DC.WRI
4728  CD E346           	CALL	DIREAD1 		; PERFORM I/O
472B  C1                	POP	B
472C  D2 0947           	JNC	DWRIT2			; GO AGAIN
472F  C9                	RET				; RETURN WITH ERROR CODE
4730                    	SPACE	4,10
                        **	DRIVER	-  Call Device Driver
                        *
                        *	DRIVER calls the device driver whos information has
                        *	been decoded.
                        *
                        *
                        *	ENTRY:	DEVTAB set up
                        *
                        *	EXIT:	NONE
                        *
                        *	USES:	NONE
                        *

4730  F5                DRIVER	PUSH	PSW
4731  3A C652           	LDA	UNIT
4734  32 3121           	STA	AIO.UNI 		; initialize device unit

4737  3A CD52           	LDA	SPG
473A  32 2621           	STA	AIO.SPG 		; initialize sectors/group
473D  F1                	POP	PSW

473E  E5                	PUSH	H
473F  2A C952           	LHLD	DEVENT
4742  E3                	XTHL				; PUT DRIVER ADDRESS ON STACK, RESTORE HL
4743  C9                	RET
4744                    	STL	'Resident Subroutines'
4744                    	EJECT
                        **	ACA - ALLOCATE CONTINUOUS AREA.
                        *
                        *	ACA IS CALLED TO APPEND SECTORS TO THE END OF A FILE.
                        *	IT ALLOCATES AS MANY CONTINUOUS SECTORS AS IT CAN UNTIL
                        *	ENOUGH ARE ALLOCATED, OR A BREAK IN THE CONTINUITY IS REQUIRED.
                        *
                        *	FIRST, THE REMAINING SECTORS IN THE GROUP ARE USED.
                        *	2ND, ACA ATTEMPTS TO OBTAIN THE IMMEDIATELY FOLLOWING GROUP.
                        *	3RD, ACA TRYS TO LOCATE A VIRGIN CLUSTER
                        *	4TH, ACA TAKES ANY FREE GROUPS.
                        *
                        *	ENTRY	(B) = SECTOR COUNT
                        *		AIO.XXX SETUP
                        *	EXIT	(B) = SECTORS NOT ALLOCATED
                        *		AIO.CNT = AMOUNT ALLOCATED
                        *		AIO.EOM = EC.EOM*2+1 IF END OF MEDIA
                        *		AIO.LGN, AIO.LSI UPDATED FOR ADDITIONS
                        *		AIO.CGN, AIO.CSI = AIO.LGN, AIO.LSI
                        *		AIO.TFP = SETUP WITH GROUP AND INDEX OF START OF AREA
                        *	USES	ALL

4744  0E 00             ACA	MVI	C,0			; (C) = COUNT ALLOCATED

4746  2A 2921           ACA0	LHLD	AIO.LGN 		; (L) = AIO.LGN, (H) = AIO.LSI
                        	ERRNZ	AIO.LSI-AIO.LGN-1
4749  22 4C21           	SHLD	AIO.TFP 		; SAVE WRITE ADDRESS

474C  21 2A21           ACA1	LXI	H,AIO.LSI		; (M) = LAST SECTOR INDEX
474F  3A 2621           	LDA	AIO.SPG 		; (A) = SECTORS PER GROUP
4752  96                	SUB	M			; (A) = SECTORS LEFT IN GROUP
4753  CA 6747           	JZ	ACA3			; NONE LEFT
4756  B8                	CMP	B
4757  DA 5B47           	JC	ACA2			; NOT TOO MANY IN GROUP FOR NEED
475A  78                	MOV	A,B			; DONT TAKE MORE THAN WE NEED
475B  57                ACA2	MOV	D,A			; (D) = AMOUNT IN GROUP
475C  86                	ADD	M
475D  77                	MOV	M,A			; ADVANCE AIO.LSI
475E  7A                	MOV	A,D			; (A) = AMOUNT ALLOCATED FROM GROUP
475F  81                	ADD	C
4760  4F                	MOV	C,A			; ADVANCE TOTAL ALLOCATED COUNT
4761  78                	MOV	A,B
4762  92                	SUB	D			; DECREMENT NEEDED COUNT
4763  47                	MOV	B,A
4764  CA 8947           	JZ	ACA9			; GOT ALL WE NEED

                        *	FINISHING THE GROUP WASENT ENOUGH. TRY TO GET THE FOLLOWING
                        *	GROUP.

4767  2E 29             ACA3	MVI	L,#AIO.LGN		; (HL) = #AIO.LGN
      = 0021            .	SET	AIO.LGN/256
                        	ERRNZ	AIO.LSI/256-.		; MUST BE IN SAME PAGE
4769  56                	MOV	D,M			; (D) = AIO.LGN
476A  14                	INR	D			; (D) = FOLLOWING GROUP #
476B  CD 5B1A           	CALL	FFB			; FIND FREE BLOCK
476E  DA 7F47           	JC	ACA8			; END OF MEDIA
4771  C2 8947           	JNZ	ACA9			; COULDNT GET ONE CONTIGUOUS

                        *	GOT A BLOCK. CHAIN IT TO THE FILE

4774  CD EC19           	CALL	CFF			; CHAIN FREE BLOCK TO FILE
4777  79                	MOV	A,C
4778  A7                	ANA	A
4779  CA 4647           	JZ	ACA0			; AM STILL LOOKING FOR THE START
477C  C3 4C47           	JMP	ACA1			; GO SOME MORE


                        **	END OF MEDIA EXIT. FLAG EOM IF COULDNT ALLOCATE ANY

477F  79                ACA8	MOV	A,C
4780  A7                	ANA	A
4781  C2 8947           	JNZ	ACA9			; GIVE HIM WHAT WE DID GET, ANYWAY...
4784  3E 05             	MVI	A,EC.EOM*2+1
4786  32 4A21           	STA	AIO.EOM 		; SET EOM

                        **	NORMAL EXIT. (C) = AMOUNT ALLOCATED

4789  79                ACA9	MOV	A,C
478A  32 4921           	STA	AIO.CNT 		; SET COUNT
478D  2A 2921           	LHLD	AIO.LGN
4790  22 2721           	SHLD	AIO.CGN 		; UPDATE CURRENT=LAST
                        	ERRNZ	AIO.LSI-AIO.LGN-1
                        	ERRNZ	AIO.CSI-AIO.CGN-1
4793  C9                	RET
4794                    	SPACE	4,10
                        **	BTS	- Block to Sector
                        *
                        *	Convert a block number to the corresponding sector
                        *	number.
                        *
                        *	ENTRY:	A	= Sectors Per Group
                        *		HL	= Block Number
                        *
                        *	EXIT:	HL	= Sector Number
                        *
                        *	USES:	HL
                        *

4794  F5                BTS	PUSH	PSW
4795  D5                	PUSH	D
4796  EB                	XCHG				; DE = Block Number
4797  CD 0719           	CALL	$MU86			; HL = A * DE
479A  D1                	POP	D
479B  F1                	POP	PSW
479C  C9                	RET
479D                    	SPACE	4,10
      = 0001            HOSRES	equ	TRUE
479D                    	XTEXT	CPA
                        **	CPA - CHECK FOR PENDING ABORT.
                        *
                        *	CPA IS CALLED WHEN A CONSOLE ABORT MAY BE PROCESSED.
                        *	IF THE SYSTEM IS READY, AND AND ABORT IS PENDING, PROCESS IT.
                        *
                        *	CPA SHOULD BE CALLED WITH INTERRUPTS DISABLED, SO THAT
                        *	ANOTHER INTERRUPT CHARACTER CANNOT OCCUR DURING CPA PROCESSING.
                        *	THIS GUARANTEES THAT A USER PROGRAM WILL BE 'INTERRUPTED' WITH
                        *	THE PROGRAM COUNTER IN THE USER CODE, NEVER IN HDOS CODE.
                        *
                        *	UPON ENTRY TO THE USER INTERRUPT ROUTINE,
                        *
                        *	((SP)+0) = RETURN ADDRESS (IF USER WISHES TO RESUME NORMAL PROCESSING)
                        *	((SP)+2) = USER PSW
                        *	((SP)+4) = USER INTERRUPTED ADDRESS
                        *
                        *	THE USER REGISTER VALUES FOR B,C,D,E,H, AND L ARE STILL
                        *	IN THE REGISTERS.
                        *
                        *	ENTRY	((SP)+0) = RETURN ADDRESS
                        *		((SP)+2) = USER PSW
                        *		((SP)+4) = USER INTERRUPTED ADDRESS
                        *	EXIT	TO *RET* IF NONE, OR DISABLED
                        *		TO PROCESSOR IF READY AND OK
                        *	USES	A,F

      = 479D            CPA	equ	*

                        	IFT	HOSRES
479D  3A B952                   LDA     SYSMODE
                        	ELSE
                        	ENDIF

47A0  A7                	ANA	A
47A1  C0                	RNZ				; IN SCALL MODE

                        *	WILL ALLOW PROCESSING

47A2  3A DC20           	LDA	S.CAADR+1		; (A) = HIGH BYTE ABORT ADDRESS
47A5  A7                	ANA	A
47A6  C8                	RZ				; NO ABORT PENDING

                        *	HAVE ABORT. PROCESS IT

47A7  E5                	PUSH	H
47A8  2A DB20           	LHLD	S.CAADR 		; (HL) = ADDRESS FOR JUMP
47AB  AF                	XRA	A
47AC  32 DC20           	STA	S.CAADR+1		; CLEAR
47AF  3C                	INR	A			; SET (A) <>0
47B0  E3                	XTHL				; RESTORE (HL), SET PROCESSOR
47B1  FB                	EI
47B2  C9                	RET				; ENTER ROUTINE
47B3                    	SPACE	4,10
                        **	FCI - FETCH CHANNEL INFORMATION.
                        *
                        *	FCI COPIES THE CHANNEL INFORMATION FROM THE
                        *	CHANNEL TABLE INTO THE ACTIVE I/O TABLE.
                        *
                        *	AIO.VEC = DRIVER ADDRESS
                        *	AIO.XXX SETUP IF DIRECTORY DEVICE
                        *	AIO.CTA = ADDRESS OF CHANNEL AREA
                        *
                        *	ENTRY	(A) = CHANNEL NUMBER
                        *	EXIT	(A) = CHANNEL STATUS BYTE
                        *		(HL) = ADDRESS OF FILE STATUS BYTE
                        *		'C' SET IF ERROR
                        *		 (A) = ERROR CODE
                        *	USES	A,F,H,L

47B3  2A EA20           FCI	LHLD	S.CFWA			; (HL) = CHANNEL TABLE FWA
                        	ERRNZ	IOCCTD-1		; CHANNEL 377Q IS FIRST IN LIST
47B6  3C                	INR	A			; (A) = INDEX OF CHANNEL IN CHANTAB
47B7  F5                	PUSH	PSW			; SAVE INDEX
47B8  F1                FCI1	POP	PSW			; (A) = INDEX
47B9  A7                	ANA	A
47BA  CA CC47           	JZ	FCI2			; GOT IT
47BD  3D                	DCR	A			; DECREMENT COUNT
47BE  F5                	PUSH	PSW			; SAVE INDEX
47BF  7E                	MOV	A,M
47C0  23                	INX	H
47C1  66                	MOV	H,M
47C2  6F                	MOV	L,A			; FOLLOW LINK
47C3  B4                	ORA	H
47C4  C2 B847           	JNZ	FCI1			; MORE TO FOLLOW

                        *	CHANNEL DOES NOT EXIST. FLAG ERROR

47C7  F1                	POP	PSW
47C8  3E 0E             	MVI	A,EC.ICN		; ILLEGAL CHANNEL NUMBER
47CA  37                	STC
47CB  C9                	RET

                        *	GOT CHANNEL

47CC  C5                FCI2	PUSH	B
47CD  D5                	PUSH	D			; SAVE REGISTERS
47CE  CD CF51           	CALL	$INDLB			; A  = UNIT CODE
47D1  1200              	DW	IOC.UNI
47D3  32 3121           	STA	AIO.UNI 		; INSURE UNIT SET UP FOR SEQ.
47D6  23                	INX	H
47D7  23                	INX	H			; MOVE PAST LINK
                        	ERRNZ	IOC.DDA-2		; POINT TO DDA
47D8  22 4E21           	SHLD	AIO.CHA 		; SET BLOCK ADDRESS
47DB  23                	INX	H
47DC  23                	INX	H
                        	ERRNZ	IOC.FLG-IOC.DDA-2	; (HL) = #IOC.FLG
47DD  E5                	PUSH	H			; SAVE ADDRESS
47DE  7E                	MOV	A,M			; (A) = TYPE
47DF  E6 01             	ANI	FT.DD			; SEE IF DIRECTORY TYPE
47E1  2B                	DCX	H
47E2  2B                	DCX	H
                        	ERRNZ	IOC.DDA-IOC.FLG+2	; (HL) = #IOC.DDA
47E3  EB                	XCHG
47E4  21 2121           	LXI	H,AIO.DDA
47E7  01 0300           	LXI	B,IOC.SQL
47EA  CA EF47           	JZ	FCI3			; IS SEQUENTIAL
47ED  0E 11             	MVI	C,IOC.DIL		; IS DIRECTORY
47EF  CD AA18           FCI3	CALL	$MOVE			; MOVE DATA
47F2  E1                	POP	H
47F3  7E                	MOV	A,M			; (A) = FLAG
47F4  D1                	POP	D
47F5  C1                	POP	B
47F6  C9                	RET
47F7                    	SPACE	4,10
                        **	GSP	- GET SYSTEM POINTER
                        *
                        *	GET THE SYSTEM POINTER
                        *
                        *
                        *	ENTRY:	GSPA	= SY: device table entry address
                        *
                        *	EXIT:	HL	= SYSTEM DEVICE UNIT POINTER
                        *
                        *	USES:	PSW,HL
                        *

47F7  21 0000           GSP	LXI	H,0			; HL = SY: device table entry
      = 47F8            GSPA	EQU	*-2			;  (filled by boot code)
47FA  D5                	PUSH	D
47FB  11 0900           	LXI	D,DEV.UNT		; HL = POINTER TO UNIT TABLE POINTER
47FE  19                	DAD	D
47FF  D1                	POP	D
4800  AF                	XRA	A
4801  C3 BD51           	JMP	GUP
4804                    	SPACE	4,10
                        **	LDD - LOAD DEVICE DRIVER.
                        *
                        *	LDD IS CALLED TO PERFORM THE LOAD OF A DEVICE DRIVER.
                        *
                        *	This code has been modified to reduce the dependencies
                        *	on a cluster size of 2.  The GRT address and SPG are
                        *	not dynamically computed so that the mount of SY0: may
                        *	be kludged by pre-stuffing them.
                        *					G. Chandler	80.06.19
                        *
                        *	ENTRY	S.DDIOC = POINTER TO IOC.DDA
                        *		S.DDLDA = LOAD ADDRESS
                        *		S.DDLEN = LOAD LENGTH
                        *		S.DDGRP = SECTOR INDEX ON SYSTEM DEVICE
                        *		S.DDDTA = DEV.RES ADDRESS
                        *		S.DDOPE = OPEN CODE (DC.OPR, DC.OPW, DC.OPU)
                        *
                        *		LDD8A	= system GRT address
                        *		LDD8B	= system SPG
                        *
                        *	EXIT	OVL CODE DESTROYED
                        *	USES	NONE

4804  CD 2C19           LDD	CALL	$SAVALL 		; SAVE REGS

                        *	find and save SET preamble length

4807  2A 2B21           	LHLD	AIO.DTA
480A  11 0200           	LXI	D,DEV.RES		; residence flag
480D  19                	DAD	D
480E  7E                	MOV	A,M			; in (a)
                        	ERRNZ	DR.SPL-11100000B
480F  E6 E0             	ANI	DR.SPL			; mask
4811  07                	RLC
4812  07                	RLC
4813  07                	RLC				; rotate
4814  3C                	INR	A			;  and adjust
4815  32 9B48           	STA	LDDA			; save for rainy day.

                        *	LOAD DRIVER

4818  3A C648           	LDA	LDD8B			; LDD8B = System SPG
481B  E6 FE             	ANI	376Q
481D  0F                	RRC				; A  = 512 byte reads/group
481E  32 F048           	STA	LDD9B			; Initialize Current Set Index
4821  32 EF48           	STA	LDD9A			; Initialize Sets/group
4824  2A F420           	LHLD	S.DDGRP
4827  26 00             	MVI	H,0			; HL = driver group number
4829  3A C648           	LDA	LDD8B			; A  = SPG
482C  CD 9447           	CALL	BTS			; HL = sector number
482F  3A 9B48           	LDA	LDDA			; (a) = blocks in preamble
4832  47                	MOV	B,A
4833  CD C948           LDD1	CALL	LDD9			; skip a block
4836  05                	DCR	B			; count
4837  C2 3348           	JNZ	LDD1			;  to end of preamble
                        	ERRNZ	DVD.ENT-2000A
483A  22 C748           	SHLD	LDD8C			; Save it for later

483D  2A F220           	LHLD	S.DDLEN 		; (HL) = LENGTH
4840  44                	MOV	B,H
4841  4D                	MOV	C,L			; (BC) = LENGTH
4842  2A F020           	LHLD	S.DDLDA 		; (HL) = LOAD ADDRESS
4845  E5                	PUSH	H			; SAVE FOR LATER
4846  EB                	XCHG
4847  2A 5121           	LHLD	S.SCR
484A  24                	INR	H
484B  24                	INR	H
484C  2B                	DCX	H			; (HL) = S.SCR+511

                        *	LOAD BINARY

484D  CD 9C48           LDD2	CALL	LDD8			; FIND NEXT BYTE
4850  7E                	MOV	A,M			; (A) = NEXT BYTE
4851  12                	STAX	D			; COPY
4852  13                	INX	D
4853  0B                	DCX	B
4854  78                	MOV	A,B
4855  B1                	ORA	C
4856  C2 4D48           	JNZ	LDD2			; MORE TO GO

                        *	CODE ALL LOADED. RELOCATE IT

4859  C1                	POP	B			; (BC) = REL FACTOR
485A  3A 9B48           	LDA	LDDA			; preamble size
485D  87                	ADD	A			; *2
485E  90                	SUB	B			; subtract
485F  2F                	CMA				; make it
4860  3C                	INR	A			;  positive
4861  47                	MOV	B,A			; adjusted
                        	ERRNZ	DVD.ENT%2000A		; assume entry is multiple of 512
4862  CD 9C48           LDD3	CALL	LDD8
4865  5E                	MOV	E,M
4866  CD 9C48           	CALL	LDD8
4869  56                	MOV	D,M			; (DE) = REL ADDRESS OF WORD TO RELOCATE
486A  7A                	MOV	A,D
486B  B3                	ORA	E
486C  CA 7C48           	JZ	LDD4			; ALL DONE
486F  EB                	XCHG				; (HL) = REL ADDRESS OF WORD TO RELOCATE
4870  09                	DAD	B			; (HL) = ABS ADDRESS OF WORD TO RELOCATE
4871  7E                	MOV	A,M
4872  81                	ADD	C
4873  77                	MOV	M,A
4874  23                	INX	H
4875  7E                	MOV	A,M
4876  88                	ADC	B
4877  77                	MOV	M,A
4878  EB                	XCHG				; RESTORE (HL)
4879  C3 6248           	JMP	LDD3

                        *	Set up entry addresses in tables

487C  2A F020           ldd4	lhld	S.DDLDA 						
487F  EB                	xchg				; (de) = entry address
4880  2A F620           	lhld	S.DDDTA 		; (hl) = device table address
4883  7E                	mov	a,m
4884  F6 01             	ori	DR.IM			; set "in memory"
4886  77                	mov	m,a			; fix
4887  23                	inx	h
4888  23                	inx	h
                        	ERRNZ	DEV.DDA-DEV.RES-2
4889  73                	mov	m,e
488A  23                	inx	h
488B  72                	mov	m,d			; set entry address
488C  EB                	xchg				; (hl) = entry address
488D  AF                	xra	a
488E  32 F120           	sta	S.DDLDA+1		; clear load flag
4891  3A F820           	lda	S.DDOPC 		; "open" code
4894  CD 9A48           	call	thruhl			; call driver
4897  C3 2719           	jmp	$rstall 		;  and exit.

489A  E9                thruhl	pchl

489B  00                ldda	db	0			; length of SET preamble
489C                    	SPACE	3,10
                        **	LDD8 - READ A BYTE FROM THE FILE.
                        *
                        *	This code has been modified to read device drivers off of
                        *	system volumes with many differant SPG factors.  Unfortunately,
                        *	if a new volume is mounted, the system volume stuff will not
                        *	be updated.
                        *
                        *	If the sector pointer were not on an even boundary, or
                        *	the cluster factor were not a multiple of 2, this code
                        *	would not work well.  Therefore, it is up to INIT to
                        *	enforce even clusters.
                        *
                        *	ENTRY	(HL) = S.SCR POINTER OF CURRENT BYTE
                        *
                        *		LDD8A	= address of system device GRT
                        *		LDD8B	= Sectors/Group on system volume
                        *		LDD8C	= current sector number
                        *		LDD9A and LDD9B as required by LDD9
                        *
                        *	EXIT	(HL) = ADDRESS OF NEXT BYTE
                        *
                        *	USES	A,F,H,L
                        *

489C  2C                LDD8	INR	L			; POINT TO NEXT BYTE
489D  C0                	RNZ				; GOT IT

489E  24                	INR	H			; MAYBE IN NEXT GROUP
489F  E5                	PUSH	H
48A0  2A 5121           	LHLD	S.SCR
48A3  24                	INR	H
48A4  7C                	MOV	A,H
48A5  E1                	POP	H
48A6  BC                	CMP	H
48A7  C8                	RE				; OK, IN SECOND SECTOR NOW

                        *	MUST READ ANOTHER

48A8  C5                	PUSH	B
48A9  D5                	PUSH	D
48AA  2A 5121           	LHLD	S.SCR
48AD  EB                	XCHG				; DE = address
48AE  01 0002           	LXI	B,512			; (BC) = COUNT
48B1  2A C748           	LHLD	LDD8C			; HL = Sector Number
48B4  D5                	PUSH	D			; SAVE #S.SCR
48B5  E5                	PUSH	H
48B6  CD BD19           	CALL	S.READ			; READ IT
48B9  E1                	POP	H			; HL = sector number
48BA  CD C948           	CALL	LDD9
48BD  22 C748           	SHLD	LDD8C			; Update Sector Number
48C0  E1                	POP	H			; HL = S.SCR
48C1  D1                	POP	D			; RESTORE (DE) AND (BC)
48C2  C1                	POP	B
48C3  C9                	RET

48C4  0000              LDD8A	DW	0			; System GRT address
48C6  00                LDD8B	DB	0			; System Sectors/Group
48C7  0000              LDD8C	DW	0			; Current Sector Number
48C9                    	SPACE	4,10
                        **	LDD9
                        *
                        *	LDD9 advances the current driver sector pointer
                        *	to the next multiple of 2 sectors.  Not this routine
                        *	will not work if the cluster is odd, or the *set*
                        *	code is not a multiple of 512.
                        *
                        *	ENTRY:	HL	= Current Sector Number
                        *		LDD8A, LDD8B, and LDD8C as required by LDD8
                        *		LDD9A	= 512 bytes reads per group
                        *		LDD9B	= read index current group
                        *
                        *	EXIT:	HL	= Next Sector Number
                        *
                        *	USES:	a,f,h,l

                        	ERRNZ	DVD.ENT%512		; Must be a multiple of 512

48C9  3A F048           LDD9	LDA	LDD9B
48CC  3D                	DCR	A			; Count these sectors
48CD  32 F048           	STA	LDD9B
48D0  CA D648           	JZ	LDD10			; At the end of this group

                        *	More available sectors in this group

48D3  23                	INX	H
48D4  23                	INX	H
48D5  C9                	RET

                        *	Need to find the next Group

48D6  3A EF48           LDD10	LDA	LDD9A
48D9  32 F048           	STA	LDD9B			; Reset Counter
48DC  3A C648           	LDA	LDD8B			; A  = SPG
48DF  CD 1849           	CALL	STB			; HL = Block Number
48E2  3A C548           	LDA	LDD8A+1
48E5  67                	MOV	H,A			; HL = GRT address
48E6  6E                	MOV	L,M			; L  = Next Block Number
48E7  26 00             	MVI	H,0
48E9  3A C648           	LDA	LDD8B			; A  = SPG
48EC  C3 9447           	JMP	BTS			; HL = sector Number

48EF  00                LDD9A	DB	0			; Number of 512 byte reads per group
48F0  00                LDD9B	DB	0			; Current read index
48F1                    	SPACE	4,10
                        **	SCI - STORE CHANNEL INFORMATION.
                        *
                        *	SCI SAVES THE ACTIVE CHANNEL INFORMATION BACK
                        *	INTO THE CHANNEL BLOCK.
                        *
                        *	ENTRY	NONE
                        *	EXIT	NONE
                        *	USES	NONE

48F1  CD 2C19           SCI	CALL	$SAVALL
48F4  2A 4E21           	LHLD	AIO.CHA
                        	ERRNZ	IOC.FLG-IOC.DDA-2
48F7  23                	INX	H
48F8  23                	INX	H			; (HL) = IOB.FLG ADDRESS
48F9  01 0800           	LXI	B,IOC.DRL		; (BC) = LEN
48FC  11 2321           	LXI	D,AIO.FLG
48FF  CD AA18           	CALL	$MOVE			; MOVE DATA
4902  C3 2719           	JMP	$RSTALL 		; RESTORE ALL REGS
4905                    	SPACE	4,10
                        **	SDD - STAND-IN DEVICE DRIVER.
                        *
                        *	SDD IS SETUP AS THE DEVICE DRIVER ADDRESS FOR DRIVERS WHICH
                        *	ARE NOT IN MEMORY. IF THE REQUEST IS AN OPEN, POSTPONE IT
                        *	UNTIL 'LDD' LOADS THE OVERLAY. OTHERWISE, IS A FATAL
                        *	SYSTEM ERROR.
                        *
                        *	ENTRY	(A) = CODE
                        *	EXIT	NONE
                        *	USES	A,F

4905  FE 09             SDD	CPI	DC.LOD			; check for load
4907  CA 1449           	JZ	SDD1

490A  FE 03             	CPI	DC.OPR
490C  DC EC3D           	CC	FATSERR
490F  FE 06             	CPI	DC.OPU+1
4911  D4 EC3D           	CNC	FATSERR

4914  32 F820           SDD1	STA	S.DDOPC 		; SET CODE
4917  C9                	RET
4918                    	SPACE	4,10
                        **	STB - Sector to Block
                        *
                        *	STB converts a sector number to the corresponding
                        *	block number
                        *
                        *	ENTRY:	A	= Sectors Per Group
                        *		HL	= Sector Number
                        *
                        *	EXIT:	HL	= Block Number
                        *
                        *	USES:	HL
                        *

4918  F5                STB	PUSH	PSW
4919  C5                	PUSH	B
491A  D5                	PUSH	D
491B  44                	MOV	B,H
491C  4D                	MOV	C,L			; BC = sector number
491D  16 00             	MVI	D,0
491F  5F                	MOV	E,A			; DE = sectors/group
4920  CD 4618           	CALL	$DU66			; HL = BC / DE
4923  D1                	POP	D
4924  C1                	POP	B
4925  F1                	POP	PSW
4926  C9                	RET
4927                    	XTEXT	AGT
4927                            SPACE   4,10
                        **	AGT	-  Allocate GRT Table
                        *
                        *	AGT allocates enough space for each of the GRT's
                        *	required by a device driver.
                        *
                        *	********
                        *	* Note *
                        *	********
                        *
                        *		This problem should be addressed more aggressively
                        *		in that GRT's should not necessarily be on page
                        *		boudaries, however, this would necessitate replacing
                        *		much code and sacrificing the efficiency of the
                        *		allocation algorithim.	For now, we will waste
                        *		the extra memory, however, at some time this
                        *		restriction should be removed.
                        *					G. Chandler 80.04.29
                        *
                        *	ENTRY:	AIO.DTA initialized
                        *		DE	= device driver length
                        *		HL	= DEV.DVG for this device
                        *
                        *	EXIT:	HL	= device load address
                        *		PSW	= 'C' clear if no errors
                        *			   unit GRT pointers initialized
                        *			= 'C' set   if not enough room
                        *
                        *	USES:	A,F,H,L
                        *

4927  D5                AGT	PUSH	D			; save driver length

4928  CD CF51           	CALL	$INDLB
492B  F9FF              	DW	DEV.FLG-DEV.DVG
492D  E6 01             	ANI	DT.DD
492F  32 8249           	STA	AGTA			; save directory device flag
4932  CA 3F49           	JZ	AGT1			; Not a directory device

                        *	Compute total load length

4935  CD CF51           	CALL	$INDLB
4938  FBFF              	DW	DEV.MNU-DEV.DVG
493A  32 8349           	STA	AGTB			; save the maximum number of units
493D  82                	ADD	D			; add the tables to the end of the driver
493E  57                	MOV	D,A

                        *	Compute load address

493F  2A D020           AGT1	LHLD	S.SYSM

4942  7D                	MOV	A,L
4943  93                	SUB	E
4944  6F                	MOV	L,A
4945  7C                	MOV	A,H
4946  9A                	SBB	D
4947  67                	MOV	H,A			; HL = HL - DE

4948  D1                	POP	D
4949  D8                	RC				; error

494A  3A 8249           	LDA	AGTA
494D  A7                	ANA	A
494E  C8                	RZ				; Not a directory device

                        *	Kludge the load address to force GRT's on page boundaries

494F  7B                	MOV	A,E
4950  85                	ADD	L
4951  2F                	CMA	A
4952  C5                	PUSH	B
4953  06 FF             	MVI	B,377Q			; sign extend offset !
4955  4F                	MOV	C,A
4956  09                	DAD	B			; Adjust HL to force GRT's on page boundaries
4957  C1                	POP	B
4958  23                	INX	H

4959  3A 8349           	LDA	AGTB			; A  = maximum number of units
495C  A7                	ANA	A
495D  C8                	RZ				; No units for some reason?

                        *	Initialize the unit pointers

495E  D5                	PUSH	D			; save load length
495F  E5                	PUSH	H			; save load address
4960  19                	DAD	D
4961  EB                	XCHG				; DE = address of first GRT to allocate

4962  D5                	PUSH	D
4963  2A 2B21           	LHLD	AIO.DTA
4966  11 0900           	LXI	D,DEV.UNT
4969  19                	DAD	D			; HL = address of UNIT table pointer
496A  D1                	POP	D

496B  3D                AGT2	DCR	A
496C  FA 7F49           	JM	AGT3			; all finished

496F  F5                	PUSH	PSW
4970  E5                	PUSH	H
4971  CD 1721           	CALL	S.GUP			; HL = unit table pointer
4974  CD E051           	CALL	$INDS
4977  0200              	DW	UNT.GRT 		; initialize the GRT pointer
4979  E1                	POP	H
497A  F1                	POP	PSW

497B  14                	INR	D			; advance to the next GRT pointer
497C  C3 6B49           	JMP	AGT2

497F  E1                AGT3	POP	H			; restore load address
4980  D1                	POP	D			; restore load length
4981  C9                	RET

4982  00                AGTA	DB	0			; Directory Device flag
4983  00                AGTB	DB	0			; Maximum Number of Units
4984                    	XTEXT	ALP
4984                    	SPACE	4,10
                        **	ALP	-  ALPHA
                        *
                        *	ALP determines if a character is alphabetic.
                        *
                        *
                        *	ENTRY:	A	=  character to test
                        *	EXIT:	PSW	=  'C' clear if     alphabetic
                        *			   'C' set   if not alphabetic
                        *	USES:	F
                        *

4984  FE 41             ALP	CPI	'A'
4986  D8                	RC				; NOT VALID
4987  FE 5B             	CPI	'Z'+1
4989  3F                	CMC
498A  D0                	RNC				; VALID
498B  FE 61             	CPI	'a'
498D  D8                	RC				; NOT VALID
498E  FE 7B             	CPI	'z'+1
4990  3F                	CMC
4991  C9                	RET
4992                    	XTEXT	CAB
4992                    	SPACE	4,10
                        **	CAB	-  CHECK ABORT
                        *
                        *	CAB WAITS FOR A REVOLUTION OF THE DISK WHILE MONITORING THE
                        *	ABORT FLAG.  AFTER ONE COMPLETE RPM, ANY ATTEMPTS TO ABORT
                        *	ARE FUTILE.
                        *
                        *
                        *	ENTRY	NONE
                        *	EXIT	(PSW)	=  'Z' CLEAR IF     TO ABORT
                        *			=  'Z' SET   IF NOT TO ABORT
                        *	USES	A,F,D
                        *

4992  CD B350           CAB	CALL	READY

                        	ERRNZ	*-CAB.						;/3.0a/
                        *	CALL	CAB.							/3.0a/
                        *	RET								/3.0a/

4995  3A DC20           CAB.	LDA	S.CAADR+1
4998  A7                	ANA	A	;Non-Zero => abort
4999  C9                	RET
499A                    	XTEXT	CAC
499A                    	SPACE	4,10
                        **	CAC - CLEAR ACTIVE CHANNEL.
                        *
                        *	CAC CLEARS OUT THE ACTIVE I/O BLOCK.
                        *
                        *	BYTES AIO.DDA TO AND ENCLUDING AIO.TFP ARE ZEROED.
                        *
                        *	AIO.CHA IS LEFT AS IT IS.
                        *
                        *	ENTRY	NONE
                        *	EXIT	NONE
                        *	USES	A

499A  E5                CAC	PUSH	H
499B  21 2121           	LXI	H,AIO.DDA
499E  C5                	PUSH	B
499F  06 2D             	MVI	B,AIO.CHA-AIO.DDA	; (B) = LEN
49A1  CD 8A19           	CALL	$ZERO
49A4  C1                	POP	B
49A5  E1                	POP	H			; RESTORE (HL)
49A6  C9                	RET
49A7                    	XTEXT	CDM
49A7                    	SPACE	4,10
                        **	CDM - CHECK FOR DEVICE MOUNTED.
                        *
                        *	CDM REFORMATS THE SUPPLIED DEVICE SPECIFICATION
                        *	INTO A 6 CHARACTER FIELD OF THE FORMAT
                        *
                        *	D E V : <00> <ENL>
                        *
                        *	IN 'DEVNAME'
                        *
                        *
                        *	ENTRY:	HL	=  ADDRESS FOR DEVICE SPECIFICATION
                        *
                        *	EXIT	(PSW)	= 'C' CLEAR IF NO ERROR
                        *			   (B) = BIT INDEX FOR THE SPECIFIED UNIT
                        *			   (HL) = ADDREESS OF DEV.MUM CELL
                        *			   'Z' SET IF NOT MOUNTED
                        *			   'Z' CLEAR IF MOUNTED
                        *			= 'C' SET IF ERROR
                        *			   (A) = ERROR CODE
                        *
                        *	USES	ALL
                        *

49A7  11 D019           CDM	LXI	D,$ZEROS

49AA  CD 224B           CDM.	CALL	DDS.			; REQUIRE NULL TERMINATOR
49AD  D8                	RC

                        *	GOT VALID DEVICE.

49AE  CD 8F4E           	CALL	LUD			; HL = DEVICE TABLE ENTRY ADDR. /3.0a/
49B1  D8                	RC				; ERROR LOOKING FOR DEVICE

49B2  CD C750           	CALL	RVD
49B5  D8                	RC				; NOT A VALID DEVICE

49B6  CD 9C18           	CALL	$INDL
49B9  0400              	DW	DEV.DDA
49BB  EB                	XCHG
49BC  22 C952           	SHLD	DEVENT
49BF  EB                	XCHG

49C0  22 C752           	SHLD	DEVTAB
49C3  11 0900           	LXI	D,DEV.UNT
49C6  19                	DAD	D
49C7  3A C652           	LDA	UNIT
49CA  CD 1721           	CALL	S.GUP
49CD  22 CE52           	SHLD	UNTTAB

49D0  2A C752           	LHLD	DEVTAB
49D3  11 0700           	LXI	D,DEV.MUM
49D6  19                	DAD	D
49D7  3A C652           	LDA	UNIT
49DA  47                	MOV	B,A
49DB  AF                	XRA	A
49DC  CD 8151           	CALL	BITS			; SET THE UNIT BIT
49DF  47                	MOV	B,A
49E0  A6                	ANA	M			; SET FLAGS
49E1  C9                	RET
49E2                    	XTEXT	CDS
49E2                    	SPACE	3,10
                        **	CDS - CLEAR DIRECTORY SPACES.
                        *
                        *	CDS IS CALLED TO FLAG THE UNUSED ENTRYS AT THE
                        *	END OF THE DIRECTORY AS CLEAR.
                        *
                        *	WHEN A FILE IS DELETED, ITS ENTRY IS FLAGED EMPTY. CDS LOCATES
                        *	EMPTY SPOTS WHICH ARE AFTER THE LAST FILE IN THE DIRECTORY,
                        *	AND FLAGS THEM CLEAER.
                        *
                        *	ENTRY	(HL) = SECTOR NUMBER OF LAST DIRECTORY BLOCK WITH FILES
                        *	EXIT	NONE
                        *	USES	ALL

49E2  01 0002           CDS	LXI	B,512
49E5  CD 5550           	CALL	PGT12.			; DE = SECTOR SCRATCH
49E8  D5                	PUSH	D			; SAVE #SECSCR
49E9  AF                	XRA	A
                        	ERRNZ	DC.REA
49EA  CD 3047           	CALL	DRIVER			; READ DIRECTORY BLOCK
49ED  D1                	POP	D						;/3.0a/
49EE  D8                	RC				; ERROR 			/3.0a/
49EF  62                	MOV	H,D
49F0  6B                	MOV	L,E			; (DE) = (HL) = #SECSCR

                        *	FIND LAST FILE NAME IN THIS BLOCK

49F1  7E                CDS1	MOV	A,M
49F2  A7                	ANA	A
49F3  CA 044A           	JZ	CDS3			; END OF BLOCK
49F6  FA FB49           	JM	CDS2			; EMPTY OR CLEAR
49F9  54                	MOV	D,H
49FA  5D                	MOV	E,L			; (DE) = ADDRESS OF THAT FILE NAME

49FB  CD 4D4A           CDS2	CALL	CDS6.			; A  = DIRECTORY ENTRY LENGTH
49FE  CD 4118           	CALL	$DADA.
4A01  C3 F149           	JMP	CDS1			; TRY NEXT ONE

                        *	ALL EMPTY SPOTS FOLLOWING THAT LAST NAME TO BE FLAGGED CLEAR

4A04  EB                CDS3	XCHG				; (HL) = ADDRESS OF LAST FILE ENTRY

4A05  7E                CDS4	MOV	A,M			; (A) = ENTRY FIRST BYTE
4A06  A7                	ANA	A
4A07  CA 194A           	JZ	CDS5			; END OF BLOCK
4A0A  47                	MOV	B,A			; SAVE ENTRY FLAG
4A0B  F2 104A           	JP	CDS4.5			; IS NOT EMPTY OR CLEAR
4A0E  36 FE             	MVI	M,DF.CLR		; IS CLEAR NOW
4A10  CD 4D4A           CDS4.5	CALL	CDS6.			; A  = DIRECTORY ENTRY LENGTH
4A13  CD 4118           	CALL	$DADA.
4A16  C3 054A           	JMP	CDS4

                        *	BLOCK IS CORRECTED. WRITE BACK TO DISK

4A19  C5                CDS5	PUSH	B			; SAVE (B) FLAG
4A1A  01 0002           	LXI	B,512
4A1D  2A 5121           	LHLD	S.SCR
4A20  EB                	XCHG				; DE = SCRATCH POINTER
4A21  21 FC01           	LXI	H,DIS.SEC
4A24  19                	DAD	D			; HL = POINTER TO DIS.SEC
4A25  CD 8918           	CALL	$HLIHL			; HL = SECTOR
4A28  3E 01             	MVI	A,DC.WRI
4A2A  CD 3047           	CALL	DRIVER			; WRITE BLOCK BACK
4A2D  C1                	POP	B
4A2E  D8                	RC				; CAN'T WRITE IT, FORGET IT

                        *	IF THE LAST ENTRY IN THIS BLOCK IS NOT CLEAR, MUST CONTINUE
                        *	CORRECTIONS TO NEXT BLOCK

4A2F  3E FE             	MVI	A,DF.CLR
4A31  B8                	CMP	B
4A32  C8                	RE				; ALL CLEAR

4A33  2A 5121           	LHLD	S.SCR
4A36  CD 9C18           	CALL	$INDL
4A39  FE01              	DW	DIS.LNK
4A3B  EB                	XCHG				; HL = LINK SECTOR; DE = SCR.

4A3C  7C                	MOV	A,H
4A3D  B5                	ORA	L
4A3E  C8                	RZ				; NO MORE TO CORRECT

4A3F  01 0002           	LXI	B,512
4A42  AF                	XRA	A
                        	ERRNZ	DC.REA
4A43  CD 3047           	CALL	DRIVER			; READ NEXT BLOCK
4A46  D8                	RC				; ERROR

4A47  2A 5121           	LHLD	S.SCR			; HL = SCRATCH POINTER
4A4A  C3 054A           	JMP	CDS4			; TRY THIS ONE
4A4D                    	SPACE	4,10
                        **	CDS6.	-  GET DIRECTORY ENTRY LENGTH

4A4D  E5                CDS6.	PUSH	H
4A4E  2A 5121           	LHLD	S.SCR
4A51  CD CF51           	CALL	$INDLB
4A54  FB01              	DW	DIS.ENL
4A56  E1                	POP	H
4A57  C9                	RET
4A58                    	XTEXT	CDU
4A58                    	SPACE	4,10
                        **	CDU - CHECK DEVICE UNIT.
                        *
                        *	CDU CHECKS THE THIRD DEVICE SPECIFICATION CHARACTER. IF IT IS NULL,
                        *	THE DEVICE UNIT IS 0. IF IT IS NON-NULL, IT MUST BE
                        *	A DIGIT SPECIFING THE DEVICE UNIT.
                        *
                        *	ENTRY	AIO.UNI = UNIT CODE
                        *	EXIT	'C' CLEAR IF OK
                        *		 AIO.UNI = UNIT NUMBER
                        *		'C' SET IF ERROR
                        *		 (A) = ERROR CODE
                        *	USES	A,F,H,L

4A58  21 3121           CDU	LXI	H,AIO.UNI
4A5B  7E                	MOV	A,M
4A5C  A7                	ANA	A
4A5D  C8                	RZ				; IS 0
4A5E  D6 30             	SUI	'0'
4A60  DA 674A           	JC	CDU1			; ERROR
4A63  77                	MOV	M,A
4A64  FE 08             	CPI	8
4A66  3F                	CMC				; 'C' IF TOO LARGE
4A67  3E 06             CDU1	MVI	A,EC.IDN		; ERROR CODE FOR ILLEGAL DEVICE NAME
4A69  C9                	RET				; 'C' SET IF ERROR
4A6A                    	XTEXT	CFC
4A6A                    	SPACE	4,10
                        **	CFC - CHECK FILE CONFLICTS.
                        *
                        *	CFC CHECKS TO SEE IF A FILE TO BE OPENED CONFLICTS WITH ANOTHER
                        *	FILE CURRENTLY OPEN.
                        *
                        *	A FILE OPEN FOR READ MAY HAVE MANY READERS,
                        *	A FILE OPEN FOR WRITE (OR UPDATE) MAY ONLY HAVE ONE
                        *	USER.
                        *
                        *	ENTRY	NONE
                        *	EXIT	(A) = LOGICAL OR OF IOC.FLG OF ALL FILES WITH
                        *		 THE SAME NAME AND DEVICE
                        *	USES	ALL

4A6A  06 00             CFC	MVI	B,0			; (B) = FLAG ACCUMULATOR
4A6C  2A EA20           	LHLD	S.CFWA			; (HL) = FWA CHANNEL TABLE

                        *	SEE IF THIS CHANNEL USES SAME NAME AND DEVICE.

4A6F  5E                CFC1	MOV	E,M
4A70  23                	INX	H
4A71  56                	MOV	D,M
4A72  23                	INX	H
                        	ERRNZ	IOC.DDA-IOC.LNK-2	; (HL) = #IOC.DDA
4A73  D5                	PUSH	D			; SAVE NEXT ADDRESS
4A74  11 2121           	LXI	D,AIO.DDA
                        	ERRNZ	IOC.DDA-2		; (HL) = #IOC.DDA OF ENTRY
4A77  0E 02             	MVI	C,2
4A79  CD 3018           	CALL	$COMP			; COMPARE
4A7C  C2 934A           	JNE	CFC2			; NO MATCH
                        	ERRNZ	IOC.FLG-IOC.DDA-2	; (HL) = IOC.FLG OF ENTRY
4A7F  E5                	PUSH	H			; SAVE
4A80  11 0E00           	LXI	D,IOC.UNI-IOC.DDA-2
                        	ERRNZ	IOC.DIR-IOC.UNI-1
                        	ERRNZ	AIO.DIR-AIO.UNI-1	; COMPARE UNIT #'S AND NAMES
4A83  19                	DAD	D			; (HL) = IOC.DIR POINTER
4A84  11 3121           	LXI	D,AIO.UNI
4A87  0E 0C             	MVI	C,DIRIDL+1
4A89  CD 3018           	CALL	$COMP			; COMPARE UNIT NUMBERS AND NAMES
4A8C  E1                	POP	H
4A8D  C2 934A           	JNE	CFC2			; NO MATCH

                        *	HAVE MATCH

4A90  78                	MOV	A,B
4A91  B6                	ORA	M			; OR FLAG
4A92  47                	MOV	B,A

4A93  E1                CFC2	POP	H			; (HL) = NEXT ADDRESS
4A94  7C                	MOV	A,H
4A95  B5                	ORA	L			; SEE IF MORE CHANNELS
4A96  C2 6F4A           	JNZ	CFC1			; MORE
4A99  78                	MOV	A,B			; (A) = FLAGS
4A9A  C9                	RET
4A9B                    	XTEXT	CFD
4A9B                    	SPACE	4,10
                        **	$CFD - CHECK FILE DELIMITER.
                        *
                        *	$CFD CHECKS AN ASCII CHARACTER TO SEE IF IT IS A LEGAL FILE
                        *	NAME DELIMITER. LEGAL DELIMITERS ARE
                        *
                        *	, = / <BLANK>  <00>
                        *
                        *	ENTRY	(A) = CHARACTER
                        *	EXIT	'C' CLEAR IF OK
                        *		'C' SET IF ERROR
                        *		 (A) = ERROR CODE
                        *	USES	A,F

4A9B  A7                $CFD	ANA	A
4A9C  C8                	RZ				; IS 00
4A9D  FE 2C             	CPI	','
4A9F  C8                	RE				; IS ,
4AA0  FE 3D             	CPI	'='
4AA2  C8                	RE				; IS =
4AA3  FE 2F             	CPI	'/'
4AA5  C8                	RE				; IS /
4AA6  FE 20             	CPI	' '
4AA8  C8                	RE				; IS ' '
4AA9  3E 07             	MVI	A,EC.IFN		; ILLEGAL FILE NAME
4AAB  37                	STC
4AAC  C9                	RET
4AAD                    	XTEXT	CFI
4AAD                    	SPACE	4,10
                        **	CFI - COPY FILE INFORMATION FROM DIRECTORY ENTRY.
                        *
                        *	CFI COPIES A DIRECTORY ENTRY INTO THE AIO.DIR FIELD.
                        *
                        *	THE FILE POINTERS (AIO.CGN, AIO.CSI, AIO.LGN, AIO.LSI)
                        *	ARE SETUP.
                        *
                        *	ENTRY	(HL) = ADDRESS OF ENTRY IN SECSCR
                        *	EXIT	(HL) = ADDRESS OF ENTRY IN SECSCR
                        *	USES	ALL

4AAD  E5                CFI	PUSH	H			; SAVE (HL)
4AAE  EB                	XCHG				; (DE) = ADDRESS OF ENTRY
4AAF  21 3221           	LXI	H,AIO.DIR
4AB2  01 1700           	LXI	B,DIRELEN
4AB5  CD AA18           	CALL	$MOVE			; MOVE INTO LIST
4AB8  2A 4321           	LHLD	AIO.DIR+DIR.LGN
4ABB  22 2921           	SHLD	AIO.LGN 		; SET LGN, LSI
4ABE  2A 4221           	LHLD	AIO.DIR+DIR.FGN
4AC1  AF                	XRA	A			; CLEAR 'C'
4AC2  67                	MOV	H,A			; SET AIO.CSI=0
4AC3  22 2721           	SHLD	AIO.CGN 		; STORE
4AC6  E1                	POP	H			; RESTORE (HL)
4AC7  C9                	RET
4AC8                    	XTEXT	CFP
4AC8                    	SPACE	4,10
                        **	CFP - CHECK FOR POSESSION.
                        *
                        *	CFP IS CALLED TO SEE IF THE ACTIVE I/O TABLE IS THE SOLE USER
                        *	OF THE SPECIFIED FILE. IF THE FILE IS OPENED UNDER ANY CHANNEL,
                        *	AN ERROR IS FLAGGED.
                        *
                        *	ENTRY	NONE
                        *	EXIT	'C' CLEAR IF NO USERS
                        *		'C' SET IF USERS
                        *		 (A) = CODE
                        *	USES	ALL

4AC8  CD 6A4A           CFP	CALL	CFC			; CHECK FOR CONFLICT
                        	ERRNZ	FT.DD-1
4ACB  1F                	RAR				; 'C' SET IF ANY DIRECTORY USERS
4ACC  3E 0B             	MVI	A,EC.FUC		; FILE USAGE CONFLICT
4ACE  C9                	RET
4ACF                    	XTEXT	COF
4ACF                    	SPACE	4,10
                        **	COF	- CHECK OUTPUT FILE
                        *
                        *	CHECK THE SPECIFIED DEVICE FOR ANY OPEN FILES.
                        *
                        *
                        *	ENTRY:	DEVICE and UNIT initialized
                        *
                        *	EXIT:	(PSW)	= 'C' CLEAR IF NO OPEN FILES
                        *			= 'C' SET   IF    OPEN FILES
                        *			   A  = ERROR MESSAGE
                        *
                        *	USES:	(PSW),(DE)
                        *

4ACF  C5                COF	PUSH	B
4AD0  E5                	PUSH	H

                        *	INITIALIZE COMPARE STRING

4AD1  2A C052           	LHLD	DEVNAME
4AD4  22 0D4B           	SHLD	COFA			; STUFF DEVICE
4AD7  3A C652           	LDA	UNIT
4ADA  32 0F4B           	STA	COFB			; STUFF UNIT
                        	ERRNZ	IOC.UNI-IOC.DEV-2

4ADD  2A EA20           	LHLD	S.CFWA			; FIRST WORD OF CHANNEL TABLE

4AE0  E5                COF1	PUSH	H
4AE1  11 0400           	LXI	D,IOC.FLG
4AE4  19                	DAD	D
4AE5  7E                	MOV	A,M
4AE6  A7                	ANA	A
4AE7  CA FA4A           	JZ	COF2			; FILE NOT OPEN
4AEA  3E 0C             	MVI	A,IOC.DEV-IOC.FLG
4AEC  CD 4118           	CALL	$DADA.			; (HL) = ENTRY OF CHANNEL AND UNIT IN TABLE
4AEF  0E 03             	MVI	C,3
4AF1  11 0D4B           	LXI	D,COFA			; (DE) = COMPARISON STRING ADDRESS
4AF4  CD 3018           	CALL	$COMP
4AF7  CA 064B           	JZ	COF3			; HAVE A MATCH

4AFA  E1                COF2	POP	H			; (HL) = IOC.LNK
                        	ERRNZ	IOC.LNK
4AFB  CD 8918           	CALL	$HLIHL
4AFE  7D                	MOV	A,L
4AFF  B4                	ORA	H
4B00  C2 E04A           	JNZ	COF1
4B03  E1                	POP	H
4B04  C1                	POP	B
4B05  C9                	RET

4B06  E1                COF3	POP	H
4B07  37                	STC
4B08  3E 23             	MVI	A,EC.FOD		; FILE OPEN ON DEVICE
4B0A  E1                	POP	H
4B0B  C1                	POP	B
4B0C  C9                	RET

4B0D  0000              COFA	DC	2,#0			; TEMPORARY COMPARISON STRING	/3.0a/
4B0F  00                COFB	DC	1,#0						;/3.0a/
4B10                    	XTEXT	DCF
4B10                    	SPACE	4,10
                        ***	determine contiguous file					/3.0a/
                        *
                        *	Entry:	AIO area set up
                        *	Exit:	'C' clear if contiguous
                        *	Uses:	a,f,h,l

4B10  2A 2421           dcf	lhld	AIO.GRT 		; GRT address for this file
4B13  3A 4221           	lda	AIO.DIR+DIR.FGN 	; first group number
4B16  6F                	mov	l,a			; set 1st link

4B17  7E                dcf1	mov	a,m			; get forward link
4B18  A7                	ana	a			; is last?
4B19  C8                	rz				; yes, file is contiguous.
4B1A  3D                	dcr	a			; compare to previous
4B1B  BD                	cmp	l			; is right?
4B1C  37                	stc				; assume not
4B1D  C0                	rnz				; no, not contiguous.
4B1E  2C                	inr	l			; next group
4B1F  C3 174B           	jmp	dcf1
4B22                    	XTEXT	DDS2
4B22                    	SPACE	4,10
                        **	DDS	-  Decode Device Specification
                        *
                        *	DDS decodes the device specification into:
                        *		DEVNAME	= device name
                        *		UNIT	= binary unit number
                        *
                        *
                        *	ENTRY:	DE	=  default block
                        *		HL	=  device specification
                        *
                        *	EXIT:	HL	=  HL advanced past the device specification
                        *
                        *	USES:	ALL
                        *

4B22  CD 2F4B           DDS.	CALL	DDS
4B25  D8                	RC
4B26  7E                	MOV	A,M
4B27  23                	INX	H
4B28  A7                	ANA	A
4B29  3E 06             	MVI	A,EC.IDN		; ASSUME ILLEGAL DEVICE NAME
4B2B  37                	STC
4B2C  C0                	RNZ				; FORCE ZERO BYTE TERMINATION

4B2D  A7                	ANA	A			; CLEAR ERROR FLAG
4B2E  C9                	RET

      = 4B2F            DDS	EQU	*

                        *	Initialize defaults

4B2F  E5                	PUSH	H
4B30  21 C052           	LXI	H,DEVNAME
4B33  01 0300           	LXI	B,3
4B36  CD AA18           	CALL	$MOVE			; INITIALIZE DEVICE SPECIFICATION
4B39  E1                	POP	H			; IGNORE DEFAULT EXTENSION
4B3A  AF                	XRA	A
4B3B  32 C652           	STA	UNIT			; INITIALIZE UNIT
4B3E  3E 30             	MVI	A,'0'
4B40  32 C252           	STA	DEVNAME+2		; INITIALIZE ASCII UNIT

                        *	GET THE REAL DEVICE SPECIFICATION

4B43  11 C052           	LXI	D,DEVNAME
4B46  CD 1A52           	CALL	$SOB
4B49  06 02             	MVI	B,2
4B4B  7E                	MOV	A,M
4B4C  A7                	ANA	A
4B4D  C8                	RZ				; ACCEPT DEFAULT

4B4E  7E                DDS1	MOV	A,M
4B4F  CD 1152           	CALL	$MCU
4B52  CD 8449           	CALL	ALP
4B55  DA 784B           	JC	DDS5			; INVALID DEVICE SPECIFICATION
4B58  12                	STAX	D
4B59  23                	INX	H
4B5A  13                	INX	D
4B5B  05                	DCR	B
4B5C  C2 4E4B           	JNZ	DDS1

4B5F  7E                DDS2	MOV	A,M
4B60  FE 3A             	CPI	':'
4B62  CA 734B           	JZ	DDS3			; NO UNIT SPECIFIED, ASSUME 0

4B65  CD 7451           	CALL	UNUM
4B68  DA 784B           	JC	DDS5			; INVALID DEVICE SPECIFICATION
4B6B  12                	STAX	D			; SAVE ASCII
4B6C  13                	INX	D
4B6D  23                	INX	H
4B6E  D6 30             	SUI	'0'
4B70  32 C652           	STA	UNIT			; SET UP UNIT

4B73  7E                DDS3	MOV	A,M
4B74  23                	INX	H
4B75  FE 3A             	CPI	':'
4B77  C8                	RZ				; VALID TERMINATION WITH ':'

4B78  3E 06             DDS5	MVI	A,EC.IDN		; ILLEGAL DEVICE NAME
4B7A  37                	STC
4B7B  C9                	RET
4B7C                    	XTEXT	DFA
4B7C                    	SPACE	3,10
                        **	DFA - DECODE FILE INFORMATION INTO ACTIVE CHANNEL.
                        *
                        *	IT CRACKS THE FILE NAME INTO THE AIO.DIR FIELDS, AND
                        *	DECODES DEVICE INFORMATION, AND LOADS THE DEVICE DRIVER.
                        *
                        *	ENTRY	(DE) = DEFAULT BLOCK ADDRESS
                        *		(HL) = FILE NAME IN ASCII
                        *	EXIT	'C' CLEAR IF OK
                        *		 (HL) = #AIO.FLG
                        *		 (A) = AIO.FLG
                        *		'C' SET IF ERROR
                        *		 (A) = ERROR CODE
                        *	USES	ALL
                        *

4B7C  CD 9A49           DFA	CALL	CAC			; CLEAR ACTIVE CHANNEL
4B7F  CD AF4B           	CALL	DFD			; DECODE FILE DESCRIPTOR
4B82  D8                	RC				; ERROR
4B83  22 A840           	SHLD	OPENHL			; SAVE POINTER
4B86  CD 584A           	CALL	CDU			; CHECK DEVICE UNIT
4B89  D8                	RC				; ERROR
4B8A  CD E84D           	CALL	LDI			; LOCATE DEVICE INFORMATION
4B8D  D8                	RC				; IF ERROR

                        *	GOT NAME, DEVICE INFO, ETC. POINT TO FLAG BYTE.

4B8E  21 2321           	LXI	H,AIO.FLG
4B91  7E                	MOV	A,M

                        *	Check directory devices for null file name

4B92  E6 01             	ANI	DT.DD
4B94  7E                	MOV	A,M
4B95  C8                	RZ				; not a directory device

4B96  3A 3221           	LDA	AIO.DIR+DIR.NAM
4B99  A7                	ANA	A
4B9A  3E 07             	MVI	A,EC.IFN
4B9C  37                	STC
4B9D  C8                	RZ				; was a null file name

4B9E  7E                	MOV	A,M			; restore AIO.FLG
4B9F  A7                	ANA	A			; clear carry
4BA0  C9                	RET
4BA1                    	XTEXT	DFC
4BA1                    	SPACE	4,10
                        **	DFC - DECODE FILE AND CHANNEL
                        *
                        *	DFC LOCATES THE SPECIFIED CHANNEL TABLE ENTRY, AND PREPARES
                        *	THE ACTIVE CHANNEL WITH FILE NAME AND DEVICE INFORMATION.
                        *
                        *	THE SPECIFIED CHANNEL NUMBER IS CHECKED FOR AVAILABILITY,
                        *	THE FILE NAME IS CRACKED INTO THE AIO.XXX FIELDS, AND
                        *	THE DEVICE DRIVER INFORMATION IS LOCATED.
                        *
                        *	ENTRY	(A) = CHANNEL NUMBER TO OPEN
                        *		(DE) = DEFAULT BLOCK ADDRESS
                        *		(HL) = FILE NAME IN ASCII
                        *	EXIT	'C' CLEAR IF OK
                        *		 AIO.FLG = DEVICE TYPE FLAGS
                        *		 (HL) = #AIO.FLG
                        *		 (A) = (AIO.FLG)
                        *		'C' SET IF ERROR
                        *		 (A) = ERROR CODE
                        *	USES	ALL

4BA1  E5                DFC	PUSH	H			; SAVE TEXT ADDRESS
4BA2  CD 1121           	CALL	S.FCI			; FETCH CHANNEL INFORMATION
4BA5  E1                	POP	H			; (HL) = TEXT ADDRESS
4BA6  D8                	RC				; ERROR IN CHANNEL NUMBER
4BA7  A7                	ANA	A			; 'Z' CLEAR IF IN USE
4BA8  3E 04             	MVI	A,EC.CNA
4BAA  37                	STC
4BAB  C0                	RNZ				; CHANNEL NOT AVAILABLE
4BAC  C3 7C4B           	JMP	DFA			; DECODE FILE INFO INTO ACTIVE CHANNEL
4BAF                    	XTEXT	DFD
4BAF                    	SPACE	4,10
                        **	DFD - DECODE FILE DESCRIPTION.
                        *
                        *	DFD CRACKS AN ALPHANUMERIC FILE DESCRIPTION, OF THE FORM
                        *
                        *	DEV:NAME.EXT
                        *
                        *	ENTRY	(DE) = POINT TO DEFAULT BLOCK
                        *		(HL) = POINTER TO TEXT
                        *	EXIT	'C' SET IF ERROR
                        *		 (A) = ERROR CODE
                        *		'C' CLEAR IF OK
                        *		 (HL) = POINTS PAST FILE NAME
                        *		 'Z' SET IF NULL NAME
                        *		 'Z' CLEAR IF NON-NULL
                        *		  AIO.DIR.NAM = NAME
                        *		  AIO.DIR.EXT = EXTENSION
                        *		  AIO.DEV = DEVICE CODE
                        *		  AIO.UNI = UNIT NUMBER (ASCII DIGIT)
                        *	USES	ALL

4BAF  E5                DFD	PUSH	H

                        *	SET DEFAULTS IN AIO.xxx

4BB0  21 2F21           	LXI	H,AIO.DEV
4BB3  01 0300           	LXI	B,3
4BB6  CD AA18           	CALL	$MOVE			; SET DEFALUT DEVICE
4BB9  01 0300           	LXI	B,3
4BBC  21 3A21           	LXI	H,AIO.DIR+DIR.EXT
4BBF  CD AA18           	CALL	$MOVE			; SET DEFAULT EXTENSION
4BC2  E1                	POP	H
4BC3  CD 1A52           	CALL	$SOB			; SKIP BLANKS
4BC6  CD 1152           	CALL	$MCU			; MAP CHARACTER TO UPPER CASE
4BC9  06 00             	MVI	B,0
4BCB  FE 2E             	CPI	'.'
4BCD  CA DA4B           	JE	DFD1			; HAVE NAME
4BD0  FE 41             	CPI	'A'
4BD2  DA 284C           	JC	DFD4			; NOT NAME
4BD5  FE 5B             	CPI	'Z'+1
4BD7  D2 284C           	JNC	DFD4			; NOT NAME

                        *	HAVE ALPHA STRING. CRACK IT

4BDA  CD 4D4C           DFD1	CALL	DNT			; DECODE NEXT TOKEN
4BDD  DA 494C           	JC	DFD5			; ERROR
4BE0  FE 3A             	CPI	':'
4BE2  C2 FD4B           	JNE	DFD2			; NOT DEVICE

                        *	HAVE EXPLICIT DEVICE

4BE5  23                	INX	H			; SKIP ':'
4BE6  3E 03             	MVI	A,3
4BE8  B9                	CMP	C
4BE9  DA 494C           	JC	DFD5			; TOO MANY CHARACTERS
4BEC  01 0300           	LXI	B,3
4BEF  E5                	PUSH	H			; SAVE (HL)
4BF0  21 2F21           	LXI	H,AIO.DEV
4BF3  CD AA18           	CALL	$MOVE			; SET EXPLICIT DEVICE
4BF6  E1                	POP	H
4BF7  CD 4D4C           	CALL	DNT			; DECODE NEXT TOKEN
4BFA  DA 494C           	JC	DFD5			; ERROR

                        *	DECODE NAME

4BFD  01 0800           DFD2	LXI	B,8			; (BC) = COUNT
4C00  E5                	PUSH	H			; SAVE TEXT ADDR
4C01  21 3221           	LXI	H,AIO.DIR+DIR.NAM
4C04  CD AA18           	CALL	$MOVE			; MOVE IN NAME
4C07  E1                	POP	H
4C08  7E                	MOV	A,M			; (A) = DELIMITER
4C09  FE 2E             	CPI	'.'
4C0B  C2 264C           	JNE	DFD3			; NOT EXTENSION

                        *	HAVE EXPLICIT EXTENSION

4C0E  23                	INX	H
4C0F  CD 4D4C           	CALL	DNT
4C12  DA 494C           	JC	DFD5			; ERROR
4C15  3E 03             	MVI	A,3
4C17  B9                	CMP	C
4C18  DA 494C           	JC	DFD5			; TOO LONG
4C1B  01 0300           	LXI	B,3
4C1E  E5                	PUSH	H			; SAVE TEXT POINTER
4C1F  21 3A21           	LXI	H,AIO.DIR+DIR.EXT
4C22  CD AA18           	CALL	$MOVE			; MOVE EXTENSION
4C25  E1                	POP	H

                        *	DONE WITH NAME. MUST HAVE LEGIT DELIMITER

4C26  06 01             DFD3	MVI	B,1			; (B) = NAME PRESENT FLAG

                        *	END OF NAME. EXIT
                        *	(B) = 0 IF NULL, (B) <> 0 IF NON-NULL

4C28  4D                DFD4	MOV	C,L			; (C) = #ADDR
4C29  CD 1A52           	CALL	$SOB			; SKIP BLANKS
4C2C  79                	MOV	A,C
4C2D  95                	SUB	L			; SEE IF ANY BLANKS
4C2E  A7                	ANA	A			; 'Z' CLEAR IF BLANKS
4C2F  7E                	MOV	A,M			; (A) = CHARACTER
4C30  CC 9B4A           	CZ	$CFD			; CHECK FOR LEGAL DELIMITER
4C33  D8                	RC				; ERROR
4C34  78                	MOV	A,B
4C35  A7                	ANA	A			; SET 'Z' IF NULL
4C36  C8                	RZ				; IF NULL FILE NAME

4C37  3A 3221           	LDA	AIO.DIR+DIR.NAM
4C3A  A7                	ANA	A						;/3.0a/
4C3B  C8                	RZ				; IF NULL FILE NAME
4C3C  FE 41             	CPI	'A'
4C3E  DA 494C           	JC	DFD5			; NOT ALPHA CHAR.
4C41  FE 5B             	CPI	'Z'+1
4C43  D2 494C           	JNC	DFD5			; NOT ALPHA CHAR.

4C46  AF                	XRA	A						;/3.0a/
4C47  3C                	INR	A			; CLEAR 'Z' AND 'C' FLAG	/3.0a/

4C48  C9                	RET

                        *	ERROR

4C49  3E 07             DFD5	MVI	A,EC.IFN		; ILLEGAL FILE NAME
4C4B  37                	STC
4C4C  C9                	RET
4C4D                    	XTEXT	DNT
4C4D                    	SPACE	4,10
                        **	DNT - DECODE NEXT TOKEN.
                        *
                        *	DNT COPIES THE NEXT ALPHANUMERIC FIELD INTO A ZERO-FILLED WORK AREA.
                        *	THE CHARACTERS ARE ALL MAPPED TO UPPER CASE.
                        *
                        *	ENTRY	(HL) = TEXT POINTER
                        *	EXIT	'C' SET IF ERROR
                        *		'C' CLEAR IF OK
                        *		(A) = DELIMTER CHARACTER
                        *		(HL) UPDATED TO DELIMITER CHARACTER
                        *		(DNTA) = STRING
                        *		(C) = LENGTH
                        *		(DE) = #DNTA
                        *	USES	ALL

4C4D  11 844C           DNT	LXI	D,DNTA
4C50  0E 09             	MVI	C,9			; (C) = SIZE OF DNTA
4C52  41                	MOV	B,C			; (B) = MAX ALLOWED +1
4C53  AF                	XRA	A
4C54  12                DNT1	STAX	D			; ZERO BUFFER
4C55  13                	INX	D
4C56  0D                	DCR	C
4C57  C2 544C           	JNZ	DNT1
4C5A  11 844C           	LXI	D,DNTA

                        *	COPY CHARACTERS

4C5D  7E                DNT2	MOV	A,M
4C5E  CD 1152           	CALL	$MCU			; MAP CHARACTER TO UPPER CASE
4C61  FE 30             	CPI	'0'
4C63  DA 7F4C           	JC	DNT4			; NOT ALPHANUMERIC
4C66  FE 3A             	CPI	'9'+1
4C68  DA 754C           	JC	DNT3			; NUMERIC
4C6B  FE 41             	CPI	'A'
4C6D  DA 7F4C           	JC	DNT4			; DELIMITER
4C70  FE 5B             	CPI	'Z'+1
4C72  D2 7F4C           	JNC	DNT4			; DELIMITER

                        *	HAVE GOOD CHARACTER

4C75  12                DNT3	STAX	D			; STORE CHAR
4C76  13                	INX	D
4C77  23                	INX	H
4C78  0C                	INR	C			; COUNT
4C79  05                	DCR	B			; LIMIT DECREMENT
4C7A  C2 5D4C           	JNZ	DNT2			; NOT OVERFLOW

                        *	OVERFLOW

4C7D  37                	STC				; FLAG ERR
4C7E  C9                	RET

                        *	END OF STRING

4C7F  A7                DNT4	ANA	A			; CLEAR 'C'
4C80  11 844C           	LXI	D,DNTA			; SET POINTER
4C83  C9                	RET

4C84  00000000 00000000 DNTA	dc	9,#0			; WORK AREA
4C8C  00
4C8D                    	XTEXT	DREAD
4C8D                    DREAD	SPACE	4,10
                        **	DREAD	-  Device Driver Read Code
                        *
                        *	DREAD replaces the H17 rom code of the same name.
                        *
                        *	NOTE:	The previous version of this routine halted
                        *		as a fatal system error for device 0, because
                        *		it assumed that it was the system device.
                        *		Since this is a more general routine, that
                        *		error condition is no longer flagged that
                        *		way.  For 'system' device calls,  *S.READ*
                        *		and  *S.WRITE*  should be used.
                        *
                        *
                        *	ENTRY:	(BC) = count
                        *		(DE) = address
                        *		(HL) = sector
                        *	EXIT:	'C' SET if errors
                        *	USES:	ALL
                        *

                        	ERRNZ	DC.REA
4C8D  AF                DREAD	XRA	A
4C8E  C3 2021           	JMP	AIO.VEC 		; call device driver		/3.0a/
4C91                    	SPACE	2
4C91  3E 01             DWRITE	MVI	A,DC.WRI
4C93  C3 2021           	JMP	AIO.VEC 					;/3.0a/
4C96                    	XTEXT	FCC
4C96                    	SPACE	4,10
                        **	FCC - FETCH COMPLETE CHANNEL INFORMATION.
                        *
                        *	FCC FETCHES THE ENTIRE CHANNEL AREA INTO THE AIO. FIELD.
                        *
                        *	ENTRY	(A) = CHANNEL #
                        *	EXIT	'C' CLEAR IF OK
                        *		 (HL) = #AIO.FLG
                        *		 (A) = AIO.FLG
                        *		'C' SET IF ERROR
                        *		 (A) = CODE
                        *	USES	ALL

4C96  CD 1121           FCC	CALL	S.FCI			; FETCH CHANNEL INFO
4C99  D8                	RC				; ERROR
4C9A  E5                	PUSH	H			; SAVE (HL)
4C9B  01 1700           	LXI	B,DIRELEN
4C9E  2A 4E21           	LHLD	AIO.CHA
4CA1  11 1100           	LXI	D,IOC.DIR-IOC.DDA
4CA4  19                	DAD	D
4CA5  EB                	XCHG				; (HL) = ADDRESS OF IOC.DIR
4CA6  21 3221           	LXI	H,AIO.DIR
4CA9  CD AA18           	CALL	$MOVE			; COPY
4CAC  E1                	POP	H
4CAD  7E                	MOV	A,M			; (A) = (AIO.FLG)
4CAE  C9                	RET
4CAF                    	XTEXT	FDB
4CAF                    	SPACE	4,10
                        **	FDB - FIND DIRECTORY FIRST BLOCK.
                        *
                        *	FDB RETURNS THE SECTOR NUMBER OF THE DIRECTORY'S FIRST BLOCK
                        *	ON THIS DEVICE.
                        *
                        *
                        *	ENTRY	AIO.UNI = UNIT NUMBER
                        *
                        *	EXIT	(HL) = SECTOR ADDRESS
                        *
                        *	USES	A,F,D,E,H,L
                        *

4CAF  2A 2B21           FDB	LHLD	AIO.DTA
4CB2  11 0900           	LXI	D,DEV.UNT
4CB5  19                	DAD	D			; HL = UNIT TABLE
4CB6  3A 3121           	LDA	AIO.UNI
4CB9  CD 1721           	CALL	S.GUP
4CBC  CD 9C18           	CALL	$INDL			; DE = FIRST DIRECTORY SECTOR
4CBF  0600              	DW	UNT.DIS
4CC1  EB                	XCHG
4CC2  C9                	RET
4CC3                    	XTEXT	FGC
4CC3                    	SPACE	4,10
                        **	FGC - FREE GROUP CHAIN.
                        *
                        *	FGC UNCHAINS A LIST OF GROUPS AND ENTERS THEM INTO THE
                        *	FREE CHAIN. THIS CAUSES THE SPACE TO BE RETURNED TO THE FREE
                        *	POOL. NOTE THAT THE FREE CHAIN IS KEPT IN ORDER.
                        *
                        *	ENTRY	(A) = 1ST GROUP NUMBER
                        *		(HL) = GRT ADDRESS
                        *	EXIT	NONE
                        *	USES	A,F,D,E,H,L

4CC3  23                FGC	INX	H
4CC4  36 01             	MVI	M,1			; FLAG CHANGE
4CC6  A7                FGC0	ANA	A
4CC7  C8                	RZ				; NO MORE IN CHAIN
4CC8  6F                	MOV	L,A
4CC9  7E                	MOV	A,M			; (A) = 2ND GROUP IN CHAIN TO FREE
4CCA  F5                	PUSH	PSW			; SAVE FOR NEXT PASS
4CCB  55                	MOV	D,L			; (D) = # OF GROUP TO FREE

                        *	SCAN FREE CHAIN FOR THE RIGHT SPOT

4CCC  AF                	XRA	A			; (A) = 0
4CCD  6F                FGC1	MOV	L,A			; (L) = INDEX OF NEXT GROUP
4CCE  7E                	MOV	A,M			; FOLLOW FREE CHAIN
4CCF  A7                	ANA	A
4CD0  CA DA4C           	JZ	FGC2			; AT END, MUST PUT NEW ONE HERE
4CD3  BA                	CMP	D
4CD4  CC 0B21           	CE	S.FASER 		; GROUP IS ALREADY FREE!
4CD7  DA CD4C           	JC	FGC1			; NOT FAR ENOUGH YET

                        *	FOUND THE PROPER SPOT.
                        *
                        *	(L) = PRECEDING GROUP #
                        *	(D) = INDEX OF GROUP TO FREE

4CDA  72                FGC2	MOV	M,D			; POINT TO FREED BYTE
4CDB  6A                	MOV	L,D
4CDC  77                	MOV	M,A			; FREE POINTS TO NEXT
4CDD  F1                	POP	PSW
4CDE  C3 C64C           	JMP	FGC0			; DO NEXT
4CE1                    	XTEXT	FOE
4CE1                    	SPACE	4,10
                        **	FOE - FIND OPEN DIRECTORY ENTRY.
                        *
                        *	FOE IS CALLED TO LOCATE AN OPEN DIRECTORY ENTRY.
                        *
                        *	ENTRY	AIO.XXX SETUP
                        *	EXIT	'C' CLEAR, ENTRY FOUND
                        *		 SEC.SCR = DIRECTORY SECTOR
                        *		 (HL) = ADDRESS OF SEC.SCR LOCATION
                        *		'C' SET, DIRECTORY FULL
                        *		 (A) = ERROR CODE
                        *	USES	ALL

4CE1  CD AF4C           FOE	CALL	FDB			; FIND DIRECTORY BLOCK

                        *	READ ANOTHER SECTOR

4CE4  01 0002           FOE1	LXI	B,512
4CE7  EB                	XCHG
4CE8  2A 5121           	LHLD	S.SCR
4CEB  EB                	XCHG				; DE = SECTOR SCRATCH ADDRESS
4CEC  CD 8D4C           	CALL	DREAD			; READ SECTOR
4CEF  D8                	RC				; RETURN IF ERROR

                        *	SCAN SECTOR FOR EMPTY SPOT

4CF0  2A 5121           	LHLD	S.SCR
                        	ERRNZ	DIS.ENT

4CF3  7E                FOE2	MOV	A,M
4CF4  A7                	ANA	A
4CF5  F8                	RM				; GOT EMPTY SPOT
4CF6  CA 004D           	JZ	FOE3			; END OF CONTENTS
4CF9  11 1700           	LXI	D,DIRELEN
4CFC  19                	DAD	D
4CFD  C3 F34C           	JMP	FOE2			; TRY NEXT ENTRY

                        *	SECTOR IS FULL UP. READ ANOTHER

4D00  2A 5121           FOE3	LHLD	S.SCR
4D03  CD 9C18           	CALL	$INDL
4D06  FE01              	DW	DIS.LNK
4D08  EB                	XCHG				; HL = NEXT SECTOR OF DIR.
4D09  7C                	MOV	A,H
4D0A  B5                	ORA	L
4D0B  C2 E44C           	JNZ	FOE1			; READ ANOTHER

4D0E  3E 0F             	MVI	A,EC.DIF		; DIRECTORY FULL
4D10  37                	STC				; FLAG ERROR
4D11  C9                	RET
4D12                    	XTEXT	GETLAB
4D12                    	SPACE	4,10
                        **	GETLAB	- GET LABEL
                        *
                        *	READ DISKETTE LABEL, AND STORE IN RAM.
                        *
                        *
                        *	ENTRY:	UNIT = DEVICE UNIT NO.
                        *
                        *	EXIT:	(PSW)	= 'C' CLEAR IF NO ERROR
                        *			  'C' SET   IF    ERROR
                        *			   (A)  = ERROR CODE
                        *
                        *	USES:	ALL
                        *

4D12  3E 07             GETLAB	MVI	A,DC.ABT
4D14  CD 3047           	CALL	DRIVER			; DRIVER ABORT

4D17  01 0001           GETLAB.	LXI	B,256
4D1A  2A 0300           	LHLD	S.LABEL
4D1D  EB                	XCHG
4D1E  21 0900           	LXI	H,DDF.LAB
4D21  3E 02             	MVI	A,DC.RER
4D23  CD 3047           	CALL	DRIVER
4D26  3E 26             	MVI	A,EC.DNR		; COULD NOT READ LABEL, NOT PROPERLY INITIALIZED
4D28  C9                	RET
4D29                    	XTEXT	IMM
4D29                    	SPACE	4,10
                        **	IMM - ISSUE MOUNT MESSAGE.
                        *
                        *	IMM TYPES THE MOUNTING MESSAGE:
                        *
                        *	VOLUME NNNNN, MOUNTED ON DEV:
                        *	LABEL: XXXX ... XXX
                        *
                        *	ENTRY	LABEL SECTOR READ
                        *		(HL) = ADDRESS OF MESSAGE VERB STRING (.PRINT FORMAT)
                        *	EXIT	NONE
                        *	USES	ALL

4D29  E5                IMM	push	h			; save verb

4D2A  2A 0300           	LHLD	S.LABEL
4D2D  CD CF51           	CALL	$INDLB
4D30  0900              	DW	LAB.VER
4D32  FE 30             	cpi	3*16+0			; version 3.0
4D34  DA 414D           	jc	imm1			; is previous

4D37  CD 9C18           	CALL	$INDL
4D3A  5000              	DW	LAB.LVN
4D3C  42                	mov	b,d
4D3D  4B                	mov	c,e			; (bc) = volume number
4D3E  C3 494D           	jmp	imm2							

4D41  CD CF51           imm1	CALL	$INDLB			; (a) = volume #
4D44  0000              	DW	LAB.SER
4D46  4F                	MOV	C,A
4D47  06 00             	MVI	B,0

4D49  21 814D           imm2	LXI	H,IMMB
4D4C  3E 05             	mvi	a,5			; 5 digit maximum
4D4E  CD 6F19           	CALL	$UDD			; UNPACK VOLUME NUMBER

4D51  01 0400           	LXI	B,4
4D54  11 C052           	LXI	D,DEVNAME
4D57  21 884D           	LXI	H,IMMC
4D5A  CD AA18           	CALL	$MOVE

4D5D  21 7A4D           	LXI	H,IMMA
4D60  FF 03             	SCALL	.PRINT			; PRINT MESSAGE
4D62  E1                	POP	H
4D63  FF 03             	SCALL	.PRINT			; PRINT VERB
4D65  21 884D           	LXI	H,IMMC
4D68  FF 03             	SCALL	.PRINT			; PRINT THE REST OF IT
4D6A  2A 0300           	LHLD	S.LABEL
4D6D  11 1100           	LXI	D,LAB.LAB
4D70  19                	DAD	D
4D71  CD 9C51           	CALL	$DTB			; DELETE TRAILING BLANKS
4D74  CD 2852           	CALL	$TYPCC			; TYPE LABEL
4D77  C3 9651           	JMP	$CRLF			; CRLF AND EXIT

4D7A  566F6C75 6D6520   IMMA	DB	'Volume '
4D81  78787878 782CA0   IMMB	DB	'xxxxx,',' '+EOL					
4D88  4445563A 0A4C6162 IMMC	DB	'DEV:',NL,'Label:',' '+EOL
4D90  656C3AA0
4D94                    	XTEXT	LDE
4D94                    	SPACE	4,10
                        **	LDE - LOCATE DIRECTORY ENTRY.
                        *
                        *	LDE LOCATES A DIRECTORY ENTRY CORRESPONDING TO THE AIO.DIR ENTRY.
                        *
                        *	ENTRY	(BC) = NUMBER OF CHARACTERS TO MATCH ON
                        *	EXIT	'C' CLEAR IF FOUND
                        *		 AIO.DES SETUP
                        *		 (HL) = ADDRESS OF DIRECTORY ENTRY IN SECSCR
                        *		'C' SET IF NOT FOUND
                        *		 (A) = CODE
                        *	USES	ALL

4D94  01 0B00           LDE.	LXI	B,DIRIDL		; ENTRY FOR FULL NAME COMPARE
4D97  3A 3221           LDE	LDA	AIO.DIR+DIR.NAM
4D9A  A7                	ANA	A
4D9B  3E 1C             	MVI	A,EC.FNR		; ASSUME FILE NAME MISSING
4D9D  37                	STC
4D9E  C8                	RZ				; FILE NAME REQUIRED
4D9F  CD AF4C           	CALL	FDB			; FIND DIRECTORY BLOCK SECTOR NUMBER

                        **	ENTRY FOR (HL) = SECTOR NUMBER TO START WITH

4DA2  C5                LDE..	PUSH	B			; SAVE COUNT
4DA3  01 0002           	LXI	B,512
4DA6  EB                	XCHG
4DA7  2A 5121           	LHLD	S.SCR
4DAA  EB                	XCHG				; DE = SECTOR SCRATCH
4DAB  22 2D21           	SHLD	AIO.DES 		; ASSUME WILL FIND IN THIS BLOCK
4DAE  CD 8D4C           	CALL	DREAD			; READ FRM DEVICE
4DB1  C1                	POP	B			; RESTORE (BC)
4DB2  D8                	RC				; RETURN IF ERROR

                        *	SCAN SECTOR FOR INFO

4DB3  2A 5121           	LHLD	S.SCR
                        	ERRNZ	DIS.ENT

                        *	COMPARE

4DB6  11 3221           LDE3	LXI	D,AIO.DIR
4DB9  7E                	MOV	A,M
                        	ERRNZ	DF.EMP-377Q
4DBA  3C                	INR	A
4DBB  CA CA4D           	JZ	LDE5			; EMPTY SPOT
                        	ERRNZ	DF.CLR-376Q
4DBE  3C                	INR	A
4DBF  CA E44D           	JZ	LDE6			; NO MORE FILES IN DIRECTORY
4DC2  C5                	PUSH	B			; SAVE COPY OF (BC)
4DC3  E5                	PUSH	H			; SAVE ADDRESS
4DC4  CD 3018           	CALL	$COMP			; COMPARE
4DC7  E1                	POP	H
4DC8  C1                	POP	B			; (BC) = COMPARE COUNT
4DC9  C8                	RE				; GOT MATCH
4DCA  11 1700           LDE5	LXI	D,DIRELEN		; MISSED, SCAN TO NEXT ENTRY
4DCD  19                	DAD	D
4DCE  7E                	MOV	A,M
4DCF  A7                	ANA	A
4DD0  C2 B64D           	JNZ	LDE3			; MORE IN SECTOR

                        *	DIDNT FIND IT IN THIS SECTOR, TRY NEXT

4DD3  2A 5121           	LHLD	S.SCR
4DD6  CD 9C18           	CALL	$INDL
4DD9  FE01              	DW	DIS.LNK
4DDB  EB                	XCHG				; HL = NEXT DIRECTORY SECTOR
4DDC  22 2D21           	SHLD	AIO.DES 		; SET POSSIBLE SECTOR INDEX
4DDF  7C                	MOV	A,H
4DE0  B5                	ORA	L
4DE1  C2 A24D           	JNZ	LDE..			; HAVE MORE SECTORS
4DE4  3E 0C             LDE6	MVI	A,EC.FNF		; FILE NOT FOUND
4DE6  37                	STC
4DE7  C9                	RET
4DE8                    	XTEXT	LDI
4DE8                    	SPACE	4,10
                        **	LDI - LOCATE DEVICE INFORMATION.
                        *
                        *	LDI FINDS A DEVICE IN THE DEVICE TABLE, ENTERS THE PROPER
                        *	INFO IN THE AIO TABLE, AND LOADS THE DEVICE DRIVER, IF NECESSARY.
                        *
                        *	ENTRY	AIO.DEV = DEVICE CODE
                        *	EXIT	'C' CLEAR IF OK
                        *		AIO.DDA, AIO.FLG, AIO.SPG, AIO.GRT AND AIO.DTA SETUP
                        *		'C' SET IF ERROR
                        *		 (A) = CODE
                        *	USES	ALL
                        *

4DE8  CD F34D           LDI	CALL	LDI0
4DEB  D8                	RC
4DEC  CD 344E           	CALL	LDI4
4DEF  D8                	RC
4DF0  C3 484E           	JMP	LDI5
4DF3                    	SPACE	4,10
4DF3  2A EC20           LDI0	LHLD	S.DFWA
4DF6  EB                	XCHG				; (DE) = FWA DEVICE LIST

4DF7  EB                LDI1	XCHG
4DF8  22 2B21           	SHLD	AIO.DTA 		; SET DEVICE TABLE ADDRESS
4DFB  EB                	XCHG
4DFC  1A                	LDAX	D
4DFD  A7                	ANA	A
4DFE  3E 0D             	MVI	A,EC.UND
4E00  37                	STC
                        	ERRNZ	DV.EL			; END OF LIST
4E01  C8                	RZ				; UNKNOWN DEVICE

4E02  2A 2F21           	LHLD	AIO.DEV
4E05  1A                	LDAX	D
4E06  13                	INX	D
4E07  FE 01             	CPI	DV.NU
4E09  CA 154E           	JE	LDI2			; DEVICE ENTRY NOT USED
4E0C  BD                	CMP	L			; COMPARE 1ST CHAR
4E0D  C2 154E           	JNE	LDI2			; NOT THIS ONE
4E10  1A                	LDAX	D
4E11  BC                	CMP	H
4E12  CA 1D4E           	JE	LDI3			; GOT DEVICE

                        *	MISSED DEVICE. TRY NEXT ENTRY

4E15  21 0D00           LDI2	LXI	H,DEVELEN-1
4E18  19                	DAD	D
4E19  EB                	XCHG
4E1A  C3 F74D           	JMP	LDI1			; TRY AGAIN

                        *	GOT DEVICE.

4E1D  1B                LDI3	DCX	D			; DE = address of device table
4E1E  21 0300           	LXI	H,DEV.JMP
4E21  19                	DAD	D
4E22  22 2121           	SHLD	AIO.DDA 		; SET DEVICE DRIVER LINK ADDRESS

                        *	CHECK LEGALITY OF UNIT NUMBER

4E25  EB                	XCHG				; HL = address of device table
4E26  CD CF51           	CALL	$INDLB
4E29  0800              	DW	DEV.MNU
4E2B  57                	MOV	D,A			; D  = maximum number of units
4E2C  3A 3121           	LDA	AIO.UNI
4E2F  BA                	CMP	D			; 'C' SET IF AIO.UNI < DEV.MNU
4E30  3F                	CMC
4E31  3E 1B             	MVI	A,EC.UUN		; ASSUME UNKNOWN UNIT NUMBER
4E33  C9                	RET				; 'C' IF AIO.UNI >= DEV.MNU
4E34                    	SPACE	4,10
                        *	Check to see if unit is mounted

4E34  3A 3121           LDI4	LDA	AIO.UNI
4E37  47                	MOV	B,A
4E38  AF                	XRA	A
4E39  CD 8151           	CALL	BITS			; A  = MASK TO CHECK IF UNIT IS MOUNTED
4E3C  EB                	XCHG
4E3D  21 0700           	LXI	H,DEV.MUM
4E40  19                	DAD	D			; HL = address of mounted units
4E41  A6                	ANA	M
4E42  EB                	XCHG
4E43  C0                	RNZ				; UNIT IS MOUNTED

4E44  3E 1B             	MVI	A,EC.UUN		; ASSUME UNKNOWN UNIT NUMBER
4E46  37                	STC
4E47  C9                	RET				; UNIT WAS NOT MOUNTED
4E48                    	SPACE	4,10
                        *	Conditionally load Device Driver

4E48  11 0200           LDI5	LXI	D,DEV.RES
4E4B  19                	DAD	D			; HL = address of DEV.RES
4E4C  7E                	MOV	A,M
4E4D  E6 01             	ANI	DR.IM
4E4F  EB                	XCHG
4E50  CC 7150           	CZ	RDL			; REQUEST DEVICE DRIVER IF NOT IN
4E53  D8                	RC				; ERROR GETTING DRIVER

                        *	SET UP	AIO.FLG, AIO.GRT

4E54  21 0700           	LXI	H,DEV.UNT-DEV.RES
4E57  19                	DAD	D
4E58  3A 3121           	LDA	AIO.UNI
4E5B  CD 1721           	CALL	S.GUP			; HL = address of UNIT table

4E5E  CD CF51           	CALL	$INDLB
4E61  0100              	DW	UNT.SPG
4E63  32 2621           	STA	AIO.SPG 		; set the number of sectors/group

4E66  CD CF51           	CALL	$INDLB
4E69  0000              	DW	UNT.FLG
4E6B  32 2321           	STA	AIO.FLG

4E6E  CD 9C18           	CALL	$INDL
4E71  0200              	DW	UNT.GRT
4E73  EB                	XCHG
4E74  22 2421           	SHLD	AIO.GRT

4E77  A7                	ANA	A			; CLEAR CARRY
4E78  C9                	RET
4E79                    	XTEXT	LFD
4E79                    	SPACE	4,10
                        **	LFD - LOCATE FILE IN DIRECTORY.
                        *
                        *	LFD IS CALLED TO LOCATE A NAMED FILE IN IT'S
                        *	DEVICES DIRECTORY
                        *
                        *	ENTRY	(DE) = DEFAULT BLOCK
                        *		(HL) = FILE NAME ADDRESS
                        *	EXIT	'C' CLEAR, GOT ENTRY
                        *		 (HL) = ADDRESS OF FILE IN DIRECTORY BLOCK (IN SECSCR)
                        *		'C' SET, ERROR
                        *		 (A) = ERROR CODE
                        *	USES	A,F,D,E,H,L

4E79  C5                LFD	PUSH	B
4E7A  CD 7F4E           	CALL	LFD1			; FIND IT
4E7D  C1                	POP	B
4E7E  C9                	RET

4E7F  CD 7C4B           LFD1	CALL	DFA			; DECODE FILENAME INTO AIO.
4E82  D8                	RC				; ERROR
                        	ERRNZ	FT.DD-1
4E83  1F                	RAR
4E84  3F                	CMC				; 'C' SET IF NOT DIRECTORY
4E85  3E 05             	MVI	A,EC.DNS
4E87  D8                	RC				; DEVICE NOT SUITABLE
4E88  CD C84A           	CALL	CFP			; CHECK FOR POSESSION
4E8B  D8                	RC				; CAN'T DO IT NOW
4E8C  C3 944D           	JMP	LDE.			; LOCATE DIRECTORY ENTRY
4E8F                    	XTEXT	LUD
4E8F                    	SPACE	4,10
                        **	LUD	-  Look-Up Device Information
                        *
                        *	LUD looks up the device information in the  device table.
                        *
                        *
                        *	ENTRY:	DEVNAME	=  device name
                        *		UNIT	=  binary unit number
                        *
                        *	EXIT:	PSW	=  'C' clear if no errors
                        *			    HL =  Entry address
                        *			=  'C' set   if    errors
                        *			    A  =  error code
                        *
                        *
                        *	USES:	PSW,DE,HL
                        *

4E8F  2A EC20           LUD	LHLD	S.DFWA

4E92  7E                LUD1	MOV	A,M
4E93  A7                	ANA	A
                        	ERRNZ	DV.EL
4E94  3E 0D             	MVI	A,EC.UND
4E96  37                	STC
4E97  C8                	RZ				; UNKNOWN DEVICE

4E98  7E                	MOV	A,M
4E99  FE 01             	CPI	DV.NU
4E9B  CA B04E           	JZ	LUD3			; ENTRY NOT IN USE

4E9E  EB                	XCHG
4E9F  2A C052           	LHLD	DEVNAME
4EA2  BD                	CMP	L
4EA3  C2 AF4E           	JNZ	LUD2			; NOT FOUND
4EA6  13                	INX	D
4EA7  1A                	LDAX	D
4EA8  1B                	DCX	D
4EA9  BC                	CMP	H
4EAA  C2 AF4E           	JNZ	LUD2			; NOT FOUND

                        *	ENTRY FOUND

4EAD  EB                	XCHG				; HL = ENTRY ADDRESS
4EAE  C9                	RET

4EAF  EB                LUD2	XCHG
4EB0  11 0E00           LUD3	LXI	D,DEVELEN
4EB3  19                	DAD	D
4EB4  C3 924E           	JMP	LUD1
4EB7                    	XTEXT	MND
4EB7                    	SPACE	4,10
                        **	MND - MOUNT NEW DISK.
                        *
                        *	MND MOUNTS A NEW DISK INTO 'SY' UNIT 'UNIT'
                        *
                        *	1) ABORT DRIVER
                        *	2) READ LABEL RECORD
                        *	3) SET VOLUME NUMBER FOR DRIVER
                        *
                        *	EXIT	'C' CLEAR IF OK
                        *		 LABEL = LABEL SECTOR
                        *		'C' SET IF ERROR

4EB7  21 0000           MND	LXI	H,0
4EBA  3E 08             	MVI	A,DC.MOU
4EBC  CD 3047           	CALL	DRIVER			; Mount the disk as volume 0
4EBF  D8                	RC

4EC0  CD 124D           	CALL	GETLAB			; GET LABEL
4EC3  D8                	RC				; BAD ERROR

                        *	CALL DEVICE MOUNT ROUTINE

4EC4  2A 0300           	LHLD	S.LABEL
4EC7  CD CF51           	CALL	$INDLB			; (A) = VOLUME TYPE
4ECA  0800              	DW	LAB.VLT
4ECC  FE 02             	CPI	LAB.NOD
4ECE  D2 554F           	JNC	MND2			; DEVICE DOESNT HAVE A DIRECTORY

4ED1  CD 9C18           	CALL	$INDL			; (DE) = RGT ADDRESS
4ED4  0A00              	DW	LAB.RGT
4ED6  CD CF51           	CALL	$INDLB			; (A) = LABEL VERSION
4ED9  0900              	DW	LAB.VER
4EDB  EB                	XCHG
4EDC  FE 17             	CPI	017H
4EDE  D2 E44E           	JNC	MND0			; Volume has RGT pointer
4EE1  21 0A00           	LXI	H,10			; force 10 for the old diskettes
4EE4  22 CB52           MND0	SHLD	RGTADR			; Save address for later

4EE7  EB                	XCHG
4EE8  CD CF51           	CALL	$INDLB			; (A) = VOLUME SERIAL
4EEB  0000              	DW	LAB.SER
4EED  32 D052           	STA	VOLUME
4EF0  6F                	MOV	L,A
4EF1  26 00             	MVI	H,0
4EF3  3E 08             	MVI	A,DC.MOU
4EF5  CD 3047           	CALL	DRIVER			; MOUNT UNIT
4EF8  D8                	RC				; BAD ERROR

                        *	SETUP ENTRY IN DEVLST

4EF9  2A 0300           	LHLD	S.LABEL

4EFC  CD 9C18           	CALL	$INDL
4EFF  0500              	DW	LAB.GRT 		; GRT ADDRESS
4F01  D5                	PUSH	D

4F02  CD 9C18           	CALL	$INDL			; DIRECTORY SECTOR
4F05  0300              	DW	LAB.DIS
4F07  D5                	PUSH	D

4F08  CD CF51           	CALL	$INDLB			; SECTORS PER GROUP
4F0B  0700              	DW	LAB.SPG

4F0D  2A CE52           	LHLD	UNTTAB

4F10  CD FB51           	CALL	$INDSB			; Stuff sectors/group
4F13  0100              	DW	UNT.SPG
4F15  32 CD52           	STA	SPG

4F18  D1                	POP	D
4F19  CD E051           	CALL	$INDS			; SAVE	DIRECTORY SECTOR POINTER IN UNIT TABLE
4F1C  0600              	DW	UNT.DIS

4F1E  D1                	POP	D
4F1F  CD E051           	CALL	$INDS			; SAVE	GRT SECTOR POINTER IN TABLE
4F22  0400              	DW	UNT.GTS

                        *	Set UNT.FLG for disk version and writability

4F24  2A CE52           	LHLD	UNTTAB
                        	ERRNZ	UNT.FLG
4F27  7E                	MOV	A,M			; UNT.FLG for this device
                        	ERRNZ	DT.P3-01000000B
                        	ERRNZ	DT.CW-00000100B
4F28  E6 BB             	ANI	10111011B		; remove old bits
4F2A  47                	MOV	B,A			; save
4F2B  C5                	PUSH	B

                        *	check for write protect

4F2C  01 0000           	LXI	B,0			; set up dummy write
4F2F  60                	MOV	H,B
4F30  68                	MOV	L,B
4F31  3E 01             	MVI	A,DC.WRI
4F33  CD 3047           	CALL	DRIVER			; done.
4F36  C1                	POP	B
4F37  3E 04             	MVI	A,DT.CW 		; assume is able
4F39  D2 3D4F           	JNC	MND.5			; yep
4F3C  AF                	XRA	A			;  else stay off
4F3D  B0                MND.5	ORA	B			; combine
4F3E  47                	MOV	B,A			;  and save

                        *	check for version 3.0 disk

4F3F  2A 0300           	LHLD	S.LABEL
4F42  CD CF51           	CALL	$INDLB
4F45  0900              	DW	LAB.VER 		; (a) = version of disk
4F47  FE 30             	CPI	3*16+0			; is 3.0?
4F49  3E 40             	MVI	A,DT.P3 		; assume no.
4F4B  DA 4F4F           	JC	MND.6			; go
4F4E  AF                	XRA	A			;  else clear
4F4F  B0                MND.6	ORA	B			; combine

4F50  2A CE52           	LHLD	UNTTAB
                        	ERRNZ	UNT.FLG
4F53  77                	MOV	M,A			; set it.

4F54  C9                	RET

                        *	DEVICE DOES NOT HAVE A DIRECTORY.

4F55  3E 25             MND2	MVI	A,EC.DNI		; DISK NOT INITIALIZED
4F57  37                	STC				; FLAG ERROR
4F58  C9                	RET
4F59                    	XTEXT	NREDY
4F59                    	SPACE	4,10
                        **	NREDY	-  Not Ready
                        *
                        *	NREDY issues a call to the device driver to wait for the
                        *	device to go NOT ready.
                        *
                        *	ENTRY:	NONE
                        *
                        *	EXIT:	NONE
                        *
                        *	USES:	NONE
                        *

4F59  CD 2C19           NREDY	CALL	$SAVALL

4F5C  CD 9549           NREDY1	CALL	CAB.
4F5F  C2 2719           	JNZ	$RSTALL

4F62  3E 0A             	MVI	A,DC.RDY
4F64  CD 3047           	CALL	DRIVER
4F67  DA 2719           	JC	$RSTALL 		; device is not ready

4F6A  C3 5C4F           	JMP	NREDY1
4F6D                    	XTEXT	PGT
4F6D                    	SPACE	4,10
                        **	PGT - PREPARE GRT.
                        *
                        *	PGT PREPARES THE GROUP RESERVATION TABLE BY READING BOTH THE
                        *	GRT AND THE RGT INTO MEMORY.
                        *
                        *	THE GROUPS UNRESERVED VIA THE RGT ARE FLAGGED FREE (LINK TO GROUP 1)
                        *	
                        *	EACH DIRECTORY ENTRY IS THEN CHECKED, AND ITS GROUP IS
                        *	FOLLOWED THROUGH THE GRT. THE CHAIN IS DUPLICATED INTO THE GRT BEING
                        *	BUILT.
                        *
                        *	WHEN THIS PROCESS IS COMPLETE, ANY UNUSED GROUPS ARE CHAINED TO
                        *	THE FREE LIST.
                        *
                        *	ENTRY	NONE
                        *	EXIT	(HL) = SECTOR ADDRESS OF LAST DIRECTORY BLOCK CONTAINING FILES
                        *	USES	ALL
                        *	MODIFICATIONS:	B. WATZMAN 3/7/89 TO ALLOW USING EITHER SY1: OR SY0:
                        *

      = 4F6D            PGT	EQU	*

                        *	READ THE RGT INTO GRT MEMORY

4F6D  2A CE52           	LHLD	UNTTAB
4F70  CD 9C18           	CALL	$INDL			; DE = GRT ADDRESS
4F73  0200              	DW	UNT.GRT
4F75  EB                	XCHG
4F76  22 6150           	SHLD	PGTG			; SAVE GRT ADDRESS
4F79  EB                	XCHG
4F7A  E5                	PUSH	H
4F7B  2A CB52           	LHLD	RGTADR			; HL = RGT sector address
4F7E  CD 4150           	CALL	PGT10.			; READ RGT INTO GRT AREA
4F81  E1                	POP	H
4F82  D8                	RC				; ERROR

                        *	READ IN THE GRT

4F83  CD 9C18           	CALL	$INDL
4F86  0400              	DW	UNT.GTS 		; DE = GRT SECTOR
4F88  E5                	PUSH	H
4F89  2A 0300           	LHLD	PGTA			; HL = WORK SPACE
4F8C  EB                	XCHG				; HL = GRT SECTOR
4F8D  CD 4150           	CALL	PGT10.
4F90  E1                	POP	H
4F91  D8                	RC

                        *	INITIALIZE FOR BUILD TABLE LOOP

4F92  CD 9C18           	CALL	$INDL
4F95  0600              	DW	UNT.DIS
4F97  2A 5121           	LHLD	S.SCR
4F9A  CD E051           	CALL	$INDS			; STORE FIRST DIR. SECT.
4F9D  FE01              	DW	DIS.LNK

4F9F  2A 0300           	LHLD	PGTA
4FA2  36 00             	MVI	M,0

                        *	READ DIRECTORY BLOCK

4FA4  2A 5121           PGT3	LHLD	S.SCR
4FA7  CD 9C18           	CALL	$INDL
4FAA  FE01              	DW	DIS.LNK
4FAC  EB                	XCHG				; HL = DIRECTORY LINK SECTOR NUMBER
                        *					; DE = SECTOR SCRATCH ADDRESS

4FAD  7C                	MOV	A,H
4FAE  B5                	ORA	L
4FAF  CA 0C50           	JZ	PGT7			; ALL DONE

4FB2  01 0002           	LXI	B,512
4FB5  AF                	XRA	A
                        	ERRNZ	DC.REA
4FB6  CD 3047           	CALL	DRIVER
4FB9  D8                	RC

                        *	SAVE BLOCK INFO IN CONVENIENT PLACE

4FBA  2A 5121           	LHLD	S.SCR
4FBD  CD CF51           	CALL	$INDLB
4FC0  FB01              	DW	DIS.ENL
4FC2  32 5F50           	STA	PGTE			; SAVE DIRECTORY ENTRY LENGTH
4FC5  CD 9C18           	CALL	$INDL
4FC8  FC01              	DW	DIS.SEC
4FCA  EB                	XCHG
4FCB  22 5D50           	SHLD	PGTD			; SAVE THIS BLOCK NUMBER
4FCE  EB                	XCHG

                        *	SCAN DIRECTORY FOR ENTRYS. TRANSFER THE CHAIN TO THE NEW GRT.

4FCF  7E                PGT4	MOV	A,M			; (A) = 1ST CHARACTER OF NAME
                        	ERRNZ	DF.EMP-377Q
4FD0  3C                	INR	A
4FD1  CA FE4F           	JZ	PGT6			; SPACE IS EMPTY
                        	ERRNZ	DF.CLR-376Q
4FD4  3C                	INR	A
4FD5  CA 0C50           	JZ	PGT7			; ALL DONE
4FD8  FA FE4F           	JM	PGT6			; ** DEBUG ** SHOULD NOT OCCUR
4FDB  E5                	PUSH	H			; SAVE ADDRESS OF DIRECTORY ENTRY

4FDC  CD CF51           	CALL	$INDLB
4FDF  1000              	DW	DIR.FGN
4FE1  6F                	MOV	L,A			; L  = FIRST GROUP NUMBER

                        *	COPY CHAIN TO GRT

4FE2  3A 0400           PGT5	LDA	PGTA+1
4FE5  67                	MOV	H,A

4FE6  7E                	MOV	A,M

4FE7  F5                	PUSH	PSW
4FE8  3A 6250           	LDA	PGTG+1
4FEB  67                	MOV	H,A			; SET UP THE HIGH ORDER BYTE OF GRT ADDR
4FEC  F1                	POP	PSW

4FED  35                	DCR	M			; SEE IF FREE
4FEE  77                	MOV	M,A
4FEF  C2 3C50           	JNZ	PGTERR			; WAS NOT FREE ! DOUBLE LINKAGE & EXIT
4FF2  A7                	ANA	A
4FF3  6F                	MOV	L,A
4FF4  C2 E24F           	JNZ	PGT5			; MORE TO GO
4FF7  2A 5D50           	LHLD	PGTD
4FFA  22 3950           	SHLD	PGTB			; SAVE SECTOR ADDRESS OF BLOCK
4FFD  E1                	POP	H			; (HL) = DIRECTORY SECTOR POINTER

4FFE  3A 5F50           PGT6	LDA	PGTE			; DIRECTORY ENTRY LENGTH
5001  CD 4118           	CALL	$DADA.			; HL = HL + DIR. LENGTH

5004  7E                	MOV	A,M
5005  A7                	ANA	A			; SEE IF ENTRY
5006  C2 CF4F           	JNZ	PGT4			; MORE ENTRYS TO GO
5009  C3 A44F           	JMP	PGT3			; GET NEW SECTOR

                        *	ALL DONE, LINK UNUSED GUYS

500C  0E 00             PGT7	MVI	C,0			; (C) = NEXT FREE GROUP
500E  2A 6150           	LHLD	PGTG
5011  11 FF00           	LXI	D,255
5014  19                	DAD	D			; HL = GRT ADDRESS + 255

5015  3E 01             PGT8	MVI	A,1
5017  BE                	CMP	M
5018  C2 1D50           	JNE	PGT9			; NOT FREE
501B  71                	MOV	M,C			; LINK TO NEXT FREE
501C  4D                	MOV	C,L			; SAVE THIS ONES INDEX
501D  2D                PGT9	DCR	L
501E  C2 1550           	JNZ	PGT8			; NOT ALL PROCESSED
5021  71                	MOV	M,C			; SET FREE CHAIN

5022  2A CE52           	LHLD	UNTTAB
5025  CD 9C18           	CALL	$INDL
5028  0400              	DW	UNT.GTS
502A  D5                	PUSH	D
502B  CD 9C18           	CALL	$INDL			; DE = GRT ADDRESS
502E  0200              	DW	UNT.GRT
5030  E1                	POP	H			; HL = GRT SECTOR

5031  01 0001           	LXI	B,256
                        	ERRNZ	DC.WRI-1
5034  78                	MOV	A,B
5035  CD 3047           	CALL	DRIVER			; UPDATE GRT
5038  21 0000           	LXI	H,0			; (HL) = SECTOR NUMBER OF LAST BLOCK WITH FILES
      = 5039            PGTB	EQU	*-2
503B  C9                	RET
503C                    	SPACE	3,10
                        **	PGTERR - LINKAGE ERROR IN DISK FILE STRUCTURE.

503C  3E 27             PGTERR	MVI	A,EC.DSC		; DISK STRUCTURE IS CORRUPT
503E  37                	STC

503F  E1                PGTERR. POP	H
5040  C9                	RET
5041                    	SPACE	3,10
                        **	PGT10.	- GET ONE SECTOR

5041  01 0001           PGT10.	LXI	B,256
                        	ERRNZ	DC.REA
5044  AF                	XRA	A
5045  C3 3047           	JMP	DRIVER
5048                    	SPACE	3,10
                        **	PGT11.	- GET THE SECOND SECTOR OF THE DIRECTORY BLOCK

5048  E5                PGT11.	PUSH	H
5049  CD 5550           	CALL	PGT12.			; DE = SECTOR SCRATCH
504C  2A 5B50           	LHLD	PGTC
504F  23                	INX	H
5050  CD 4150           	CALL	PGT10.
5053  E1                	POP	H
5054  C9                	RET
5055                    	SPACE	3,10
                        **	PGT12.	- GET THE POINTER TO THE SECTOR SCRATCH AREA

5055  EB                PGT12.	XCHG
5056  2A 5121           	LHLD	S.SCR
5059  EB                	XCHG				; DE = SECTOR SCRATCH
505A  C9                	RET
505B                    	SPACE	3,10
      = 0003            PGTA	EQU	S.LABEL 		; GRT WORK AREA POINTER ADDRESS
505B  0000              PGTC	DW	0			; DIRECTORY LINK SECTOR
505D  0000              PGTD	DW	0			; CURRENT BLOCK NUMBER
505F  00                PGTE	DB	0			; DIRECTORY ENTRY LENGTH
5060  00                PGTF	DB	0			; SECOND SECT. OF BLOCK ALREADY READ FLAG
                        *					;  != 0  =>  TRUE
5061  0000              PGTG	DW	0			; SAVED GRT ADDRESS
5063                    	XTEXT	RBF
5063                    	SPACE	4,10
                        **	RBF - RETURN BLOCKS TO FREE POOL.
                        *
                        *	RBF RETURNS THE BLOCKS BELONGING TO A FILE TO THE
                        *	DISKS FREE POOL.
                        *
                        *	ENTRY	(HL) = ADDRESS OF ENTRY IN DIRECTORY SECTOR
                        *	EXIT	NONE
                        *	USES	A,F,D,E

5063  E5                RBF	PUSH	H			; SAVE ADDRESS OF ENTRY
5064  11 1000           	LXI	D,DIR.FGN
5067  19                	DAD	D
5068  7E                	MOV	A,M			; (A) = FIRST GROUP NUMBER
5069  2A 2421           	LHLD	AIO.GRT
506C  CD C34C           	CALL	FGC			; FREE GROUP CHAIN
506F  E1                	POP	H			; (HL) = POINTER TO DIRECTORY ENTRY
5070  C9                	RET
5071                    	XTEXT	RDL
5071                    	SPACE	4,10
                        **	RDL - REQUEST DEVICE DRIVER.
                        *
                        *	RDL SETS A REQUEST FOR THE LOADING OF A DEVICE DRIVER.
                        *
                        *	THE DRIVER IS LOADED INTO MEMORY JUST BELOW *S.SYSM*.
                        *
                        *	ENTRY	(DE) = #DEV.RES
                        *	EXIT	'C' SET IF ERROR
                        *		 (A) = ERROR CODE
                        *		'C' CLEAR IF OK
                        *		 DEVLST POINTERS SET
                        *	USES	A,F,B,C,H,L

      = 5071            RDL	EQU	*

5071  3A 1A21           	LDA	S.MOUNT
5074  A7                	ANA	A			; HAVE SYSTEM DISK?
5075  3E 35             	MVI	A,EC.SDR		; ASSUME SYSTEM DISK IS RESET
5077  37                	STC
5078  C8                	RZ				; CAN'T LOAD

5079  D5                	PUSH	D			; SAVE (DE)
507A  EB                	XCHG				; (HL) = #DEV.RES
507B  22 F620           	SHLD	S.DDDTA 		; SET DEVICE TABLE ADDRESS (OF DEV.RES)
507E  11 0900           	LXI	D,DEV.DVL-DEV.RES
5081  19                	DAD	D			; (HL) = ADDRESS OF LENGTH
5082  5E                	MOV	E,M
5083  23                	INX	H
5084  56                	MOV	D,M			; (DE) = LEN OF DRIVER
                        	ERRNZ	DEV.DVG-DEV.DVL-2
5085  23                	INX	H

5086  7E                	MOV	A,M			; (A) = (DEV.DVG)
5087  32 F420           	STA	S.DDGRP 		; SET GROUP FOR FILE

508A  CD 2749           	CALL	AGT			; HL = load address

508D  3E 08             	MVI	A,EC.NRD		; NO ROOM FOR DRIVER
508F  DA B150           	JC	RDL1			; ERROR

                        *	SEE IF THIS IS ABOVE THE USER HIMEM

5092  EB                	XCHG				; (DE) = NEW S.SYSM
5093  22 F220           	SHLD	S.DDLEN 		; SET LENGTH OF LOAD
5096  2A D220           	LHLD	S.USRM
5099  23                	INX	H

509A  7B                	MOV	A,E
509B  95                	SUB	L
509C  7A                	MOV	A,D
509D  9C                	SBB	H
509E  3E 08             	MVI	A,EC.NRD
50A0  DA B150           	JC	RDL1			; NO ROOM

50A3  2A D020           	LHLD	S.SYSM
50A6  EB                	XCHG
50A7  22 F020           	SHLD	S.DDLDA 		; SET LOAD ADDRESS
50AA  2B                	DCX	H
50AB  72                	MOV	M,D			; INSTALL POINTER
50AC  2B                	DCX	H			;  TO PREVIOUS
50AD  73                	MOV	M,E			;   S.SYSM
50AE  22 D020           	SHLD	S.SYSM			; SET NEW S.SYSM

50B1  D1                RDL1	POP	D			; RESTORE (DE)
50B2  C9                	RET
50B3                    	XTEXT	READY
50B3                    	SPACE	4,10
                        **	READY	-  Wait for Ready
                        *
                        *	READY issues the call to the device driver to wait
                        *	for the device to go ready.
                        *
                        *	ENTRY:	NONE
                        *
                        *	EXIT:	NONE
                        *
                        *	USES:	NONE
                        *

50B3  CD 2C19           READY	CALL	$SAVALL

50B6  CD 9549           READY1	CALL	CAB.
50B9  C2 2719           	JNZ	$RSTALL

50BC  3E 0A             	MVI	A,DC.RDY
50BE  CD 3047           	CALL	DRIVER
50C1  DA B650           	JC	READY1

50C4  C3 2719           	JMP	$RSTALL
50C7                    	XTEXT	RVD
50C7                    	SPACE	4,10
                        **	RVD	-  Require Valid Device
                        *
                        *	RVD requires a valid device
                        *
                        *		driver permanently in memory
                        *		directory type device
                        *		legal unit number
                        *
                        *
                        *	ENTRY:	HL	=  Device table address
                        *
                        *	EXIT:	PSW	=  'C' clear if no errors
                        *			=  'C' set   if not valid device
                        *			    A  = error code
                        *
                        *	USES:	PSW,HL
                        *

      = 50C7            RVD	EQU	*

                        *	Let the stand-in device driver flag non-resident fatal errors

50C7  CD CF51           	CALL	$INDLB
50CA  0600              	DW	DEV.FLG
50CC  E6 01             	ANI	DT.DD
50CE  3E 05             	MVI	A,EC.DNS
50D0  37                	STC
50D1  C8                	RZ				; NOT DIRECTORY TYPE

50D2  CD CF51           	CALL	$INDLB
50D5  0800              	DW	DEV.MNU
50D7  E5                	PUSH	H
50D8  21 C652           	LXI	H,UNIT
50DB  3D                	DCR	A
50DC  BE                	CMP	M			; 'C' SET IF  ( MAX NUM - 1 ) < CURRENT
50DD  E1                	POP	H
50DE  3E 1B             	MVI	A,EC.UUN		; assume unknown unit
50E0  C9                	RET
50E1                    	XTEXT	SGT
50E1                    	SPACE	4,10
                        **	SGT - SAVE GROUP TABLE.
                        *
                        *	SGT UPDATES THE GROUP TABLE ONTO THE DISK, IF IT HAS BEEN
                        *	ALTERED.
                        *
                        *	ENTRY	AIO.GRT = TABLE ADDRESS
                        *	EXIT	AIO.GRT FLAGGED UPDATED
                        *	USES	ALL

50E1  2A 2421           SGT	LHLD	AIO.GRT
50E4  23                	INX	H
50E5  7E                	MOV	A,M
50E6  A7                	ANA	A
50E7  C8                	RZ				; NOT CHANGED

50E8  36 00             	MVI	M,0			; FLAG NOT CHANGED
50EA  EB                	XCHG
50EB  1B                	DCX	D			; (DE) = GRT ADDRESS

50EC  2A 2B21           	LHLD	AIO.DTA 		; (HL) = DEVICE TABLE ADDRESS
50EF  01 0900           	LXI	B,DEV.UNT
50F2  09                	DAD	B			; HL = ADDRESS OF DEV.UNT TABLE
50F3  3A 3121           	LDA	AIO.UNI
50F6  CD 1721           	CALL	S.GUP
50F9  01 0400           	LXI	B,UNT.GTS
50FC  09                	DAD	B			; HL = ADDRESS OF  DEV.UNT  ENTRY
50FD  CD 8918           	CALL	$HLIHL			; HL = ADDRESS OF  GRT

5100  01 0001           	LXI	B,256			; SET I/O COUNT
5103  C3 914C           	JMP	DWRITE			; UPDATE GRT
5106                    	XTEXT	UAD
5106                    	SPACE	4,10
                        ***	Update Last Access date and Access Counter			/3.0a/
                        *
                        *	This routine will not perform the update to a disk
                        *	created prior to HDOS 3.0.
                        *
                        *	Entry:	AIO.XXX setup
                        *		 (hl) = address of entry in SECSCR
                        *	Exit:	DIR.ACD and DIR.NOA updated
                        *	Uses:	All

      = 5106            uad.	equ	*

5106  01 0B00           	lxi	b,DIRIDL		; entry length
5109  2A 2D21           	lhld	AIO.DES 		; sector number
510C  CD A24D           	call	lde..			; fetch it back
510F  DC 0B21           	cc	S.FASER 		; shouldn't happen

      = 5112            uad	equ	*

5112  E5                	push	h
5113  2A 2B21           	lhld	AIO.DTA 		; table address
5116  11 0900           	lxi	d,DEV.UNT
5119  19                	dad	d			; ((hl)) = unit table for device
511A  3A 3121           	lda	AIO.UNI 		; (a) = unit
511D  CD 1721           	call	S.GUP			; (hl) = unit table for unit
                        	ERRNZ	UNT.FLG
5120  3E 40             	mvi	a,DT.P3 		; prior 3.0
5122  A6                	ana	m			; well?
5123  E1                	pop	h
5124  C0                	rnz				; don't do this.

5125  11 0D00           	lxi	d,DIR.NOA
5128  19                	dad	d			; point to access counter
5129  3E 01             	mvi	a,1
512B  86                	add	m			; count
512C  DE 00             	sbi	0			; back out if overflow
512E  77                	mov	m,a			;  and set
512F  32 3F21           	sta	AIO.DIR+DIR.NOA 	; (also in AIO table)
5132  EB                	xchg
5133  2A C820           	lhld	S.DATC			; today's date
5136  22 4721           	shld	AIO.DIR+DIR.ACD 	; set access date
5139  EB                	xchg
513A  CD E051           	call	$inds
513D  0800              	dw	DIR.ACD-DIR.NOA
513F  C3 6351           	jmp	uds			; put the sector back to disk	
5142                    	XTEXT	UDE
5142                    	SPACE	4,10
                        **	UDE - UPDATE DIRECTORY ENTRY.
                        *
                        *	UDE UPDATES THE DIRECTORY ENTRY IN THE SECTOR BUFFER
                        *	FROM AIO.XXX
                        *
                        *	ENTRY	SECSCR = DIRECTORY SECTOR
                        *		(HL) = ADDRESS OF ENTRY IN SECSCR
                        *	EXIT	NONE
                        *	USES	ALL

5142  E5                UDE	PUSH	H			; SAVE (HL)
5143  2A 2921           	LHLD	AIO.LGN 		; (L) = AIO.LGN
                        	ERRNZ	AIO.LSI-AIO.LGN-1	; (H) = AIO.LSI
5146  22 4321           	SHLD	AIO.DIR+DIR.LGN 	; SET DIR.LGN
                        	ERRNZ	DIR.LSI-DIR.LGN-1	; SET DIR.LSI

5149  CD 104B           	call	dcf			; is file contiguous?		/3.0a/
514C  21 4021           	lxi	h,AIO.DIR+DIR.FLG	; point to flag byte		/3.0a/
514F  3E 10             	mvi	a,DIF.CNT		; 'C' flag			/3.0a/
5151  DA 5651           	jc	ude1			; not contiguous		/3.0a/
5154  B6                	ora	m			; set flag			/3.0a/
5155  11                	db	MI.LXID 		; skip next two instructions	/3.0a/
5156  2F                ude1	cma				; mask to clear 		/3.0a/
5157  A6                	ana	m			; strip off 'C' 		/3.0a/
5158  77                	mov	m,a			;  and replace. 		/3.0a/

5159  E1                	POP	H			; (hl)=entry in SECSCR
515A  01 1700           	LXI	B,DIRELEN
515D  11 3221           	LXI	D,AIO.DIR
5160  C3 AA18           	JMP	$MOVE			; UDPATE IN DIR
5163                    	XTEXT	UDS
5163                    	SPACE	4,10
                        **	UDS - UPDATE DIRECTORY SECTOR.
                        *
                        *	UDS UPDATES THE DIRECTORY SECTOR BACK ONTO THE DISK.
                        *
                        *	ENTRY	SECSCR = SECTOR
                        *	EXIT	'C' CLEAR IF OK
                        *		'C' SET IF ERROR
                        *		 (A) = CODE
                        *	USES	ALL

5163  01 0002           UDS	LXI	B,512
5166  2A 5121           	LHLD	S.SCR
5169  EB                	XCHG				; DE = SECTOR SCRATCH
516A  21 FC01           	LXI	H,DIS.SEC
516D  19                	DAD	D
516E  CD 8918           	CALL	$HLIHL			; HL = THIS SECTOR NUMBER
5171  C3 914C           	JMP	DWRITE			; WRITE AND EXIT
5174                    	XTEXT	UNUM
5174                    	SPACE	4,10
                        **	UNUM	-  Number
                        *
                        *	UNUM tests a character to see if it is a valid unit number.
                        *
                        *
                        *	ENTRY:	A	=  character to test
                        *
                        *	EXIT:	PSW	=  'C' clear if good unit number
                        *			   'C' set   if not  unit number
                        *
                        *	USES:	F
                        *

5174  FE 30             UNUM	CPI	'0'
5176  D8                	RC
5177  FE 38             	CPI	'7'+1
5179  3F                	CMC
517A  C9                	RET
517B                    	XTEXT	WDO
517B                    	SPACE	4,10
                        **	WDO	- WAIT FOR DRIVE TO OPEN
                        *
                        *	WAIT UNTIL USER OPENS SELECTED DRIVE.
                        *	DRIVE IS ASSUMED TO BE OPEN WHEN THERE ARE NO MORE TRANSITIONS
                        *	BETWEEN NOLE DETECT, AND NO HOLE DETECT IN 200 MIL. SEC.
                        *
                        *
                        *	ENTRY:	UNIT	= UNIT NUMBER
                        *
                        *	EXIT:	(PSW)	= 'Z' CLEAR IF AN ABORT IS PENDING
                        *			= 'Z' SET   IF NO ABORT
                        *
                        *	USES:	ALL
                        *

517B  CD 594F           WDO	CALL	NREDY
517E  C3 9549           	JMP	CAB.						;/3.0a/
5181                    	STL	'Common Decks'
5181                    	EJECT
5181                    	XTEXT	BITS							
5181                    	SPACE	4,10
                        ***	BITS - BIT SET.
                        *
                        *	BITS SETS THE SPECIFIED BIT IN THE ACCUMULATOR.
                        *
                        *	ENTRY:	(A)  =	ORIGINAL (A)
                        *		(B)  =	NUMBER OF BIT TO SET (7=HIGH, ... ,0=LOW)
                        *	EXIT:	(A)  =	ORIGINAL (A) WITH BIT (B) SET
                        *	USES:	A,F

5181  C5                BITS	PUSH	B

5182  F5                	PUSH	PSW
5183  3E 80             	MVI	A,10000000B
5185  04                	INR	B
5186  07                BITS1	RLC
5187  05                	DCR	B
5188  C2 8651           	JNZ	BITS1

518B  4F                	MOV	C,A
518C  F1                	POP	PSW
518D  B1                	ORA	C

518E  C1                	POP	B
518F  C9                	RET
5190                    	XTEXT	CPDEHL
5190                    	SPACE	4,10
                        ***	CPDEHL - Compare (HL) to (DE)
                        *
                        *	Entry:	NONE
                        *	Exit:	'C' Set if (HL) < (DE)
                        *		'Z' Set if (HL) = (DE)
                        *		 else (HL) > (DE)
                        *	Uses:	A,F

5190  7C                CPDEHL	MOV	A,H
5191  BA                	CMP	D
5192  C0                	RNZ
5193  7D                	MOV	A,L
5194  BB                	CMP	E
5195  C9                	RET
5196                    	XTEXT	CDEHL
5196                    CDEHL	SPACE	4,10
                        **	$CDEHL - COMPARE (DE) TO (HL)
                        *
                        *	$CDEHL COMPARES (DE) TO (HL) FOR EQUALITY.
                        *
                        *	ENTRY	NONE
                        *	EXIT	'Z' SET IF (DE) = (HL)
                        *	USES	A,F

      = 188E            $CDEHL	EQU	030216A 		; IN H17 ROM
5196                    	XTEXT	CHL
5196                    CHL	SPACE	4,10
                        **	$CHL - COMPLEMENT (HL).
                        *
                        *	(HL) = -(HL)		TWO'S COMPLEMENT
                        *
                        *	ENTRY	NONE
                        *	EXIT	NONE
                        *	USES	A,F,H,L

      = 1894            $CHL	EQU	030224A 		; IN H17 ROM
5196                    	XTEXT	COMP
5196                    COMP	SPACE	4,10
                        **	$COMP - COMPARE TWO CHARACTER STRINGS.
                        *
                        *	$COMP COMPARES TWO BYTE STRINGS.
                        *
                        *	ENTRY	(C) = COMPARE COUNT
                        *		(DE) = FWA OF STRING #1
                        *		(HL) = FWA OF STRING #2
                        *	EXIT	'Z' CLEAR, IS MIS-MATCH
                        *		 (C) = LENGTH REMAINING
                        *		 (DE) = ADDRESS OF MISMATCH IN STRING#1
                        *		 (HL) = ADDRESS OF MISMATCH IN STRING #2
                        *		'C' SET, HAVE MATCH
                        *		 (C) = 0
                        *		 (DE) = (DE) + (0C)
                        *		 (HL) = (HL) + (0C)
                        *	USES	A,F,C,D,E,H,L

      = 1830            $COMP	EQU	030060A 		; IN H17 ROM
5196                    	XTEXT	CRLF
5196                    CRLF	SPACE	4,10
                        **	$CRLF - TYPE CARRIAGE RETURN/ LINE FEED
                        *
                        *	$CRLF IS USED TO GENERATE PADDED CRLF'S.
                        *
                        *	ENTRY	NONE
                        *	EXIT	(A) = 0
                        *	USES	A,F

5196  3E 0A             $CRLF	MVI	A,NL
5198  FF 02             	SCALL	.SCOUT
519A  AF                	XRA	A
519B  C9                	RET
519C                    	XTEXT	DADA
519C                    DADA	SPACE	4,10
                        **	$DADA - PERFORM (H,L) = (H,L) + (0,A)
                        *
                        *	ENTRY	(H,L) = BEFORE VALUE
                        *		(A) = BEFORE VALUE
                        *	EXIT	(H,L) = (H,L) + (0,A)
                        *		'C' SET IF OVERFLOW
                        *	USES	F,H,L

      = 183A            $DADA	EQU	030072A 		; IN H17 ROM
519C                    	XTEXT	DADA2
519C                    DADA2	SPACE	4,10
                        **	$DADA. - ADD (0,A) TO (H,L)
                        *
                        *	ENTRY	NONE
                        *	EXIT	(HL) = (HL) + (0A)
                        *	USES	A,F,H,L

      = 1841            $DADA.	EQU	030101A 		; IN H17 ROM
519C                    	XTEXT	DTB
519C                    	SPACE	4,10
                        **	$DTB - DELETE TRAILING BLANKS.
                        *
                        *	$DTB DELETES THE TRAILING BLANKS FROM A CODED LINE.
                        *
                        *	ENTRY	(HL) = LINE FWA
                        *	EXIT	(A) = LENGTH OF RESULT (ENCLUDING 00 TERMINATOR BYTE)
                        *	USES	A,F

519C  D5                $DTB	PUSH	D			; SAVE (DE)
519D  54                	MOV	D,H
519E  5D                	MOV	E,L			; (DE) = FWA
519F  1B                	DCX	D			; (DE) = FWA-1
51A0  7E                $DTB1	MOV	A,M
51A1  23                	INX	H
51A2  A7                	ANA	A			; FIND END OF LINE
51A3  C2 A051           	JNZ	$DTB1
51A6  2B                	DCX	H			; (HL) = ADDRESS OF TERMINATING BYTE

                        *	GOT END OF LINE. DELETE TRAILING BLANKS

51A7  2B                $DTB2	DCX	H			; BACKUP ONE CHARACTER
51A8  CD 8E18           	CALL	$CDEHL
51AB  CA B451           	JE	$DTB3			; GONE PAST FRONT OF LINE, IS ALL BLANKS
51AE  7E                	MOV	A,M
51AF  FE 20             	CPI	' '
51B1  CA A751           	JE	$DTB2			; GOT BLANK

                        *	HAVE TRIMED LINE. COMPUTE LENGTH

51B4  23                $DTB3	INX	H
51B5  36 00             	MVI	M,0			; TERMINATE LINE
51B7  7D                	MOV	A,L
51B8  93                	SUB	E			; (A) = LENGTH +1 (FOR 00 BYTE)
51B9  EB                	XCHG
51BA  23                	INX	H			; (HL) = LINE FWA
51BB  D1                	POP	D			; RESTORE (DE)
51BC  C9                	RET
51BD                    	XTEXT	DU66
51BD                    DU66	SPACE	4,10
                        **	$DU66 - UNSIGNED 16 / 16 DIVIDE.
                        *
                        *	(HL) = (BC)/(DE)
                        *
                        *	ENTRY	(BC), (DE) PRESET
                        *	EXIT	(HL) = RESULT
                        *		(DE) = REMAINDER
                        *	USES	ALL

      = 1846            $DU66	EQU	030106A 		; IN H17 ROM
51BD                    	XTEXT	GUP
51BD                    GUP	SPACE	4,10
                        **	GUP	-  GET UNIT POINTER
                        *
                        *	GET THE UNIT SPECIFIC DATA POINTER FOR THE SPECIFIED UNIT
                        *
                        *
                        *	ENTRY:	A	= UNIT NUMBER
                        *		HL	= ADDRESS OF UNIT TABLE
                        *
                        *	EXIT:	HL	= ADDRESS OF TABLE ENTRY FOR SPECIFIED UNIT
                        *
                        *	USES:	PSW,HL
                        *

51BD  F5                GUP	PUSH	PSW
51BE  CD 8918           	CALL	$HLIHL			; HL = POINTER TO UNIT TABLE
51C1  F1                	POP	PSW			; SAVE	A

51C2  E6 07             	ANI	007Q			; Map out any extra bits
51C4  07                	RLC
51C5  07                	RLC
51C6  07                	RLC
                        	ERRNZ	UNT.SIZ-8

51C7  C3 4118           	JMP	$DADA.			; HL = HL + A			/3.0a/
51CA                    	XTEXT	HLIHL
51CA                    HLIHL	SPACE	4,10
                        **	$HLIHL - LOAD HL INDIRECT THROUGH HL.
                        *
                        *	(HL) = ((HL))
                        *
                        *	ENTRY	NONE
                        *	EXIT	NONE
                        *	USES	A,H,L

      = 1889            $HLIHL	EQU	030211A 		; IN H17 ROM
51CA                    	XTEXT	ILDEHL
51CA                    	SPACE	4,10
                        ***	ILDEHL - INDEXED LOAD OF (DE) FROM (HL).
                        *
                        *	LOAD (DE) WITH THE FULL WORD VALUE POINTED TO BY (HL).
                        *
                        *	ENTRY:	(HL) = ADDRESS OF VALUE
                        *	EXIT:	(DE) = ((HL))
                        *		(HL) = (HL) + 2
                        *	USES:	D,E

51CA  5E                ILDEHL	MOV	E,M
51CB  23                	INX	H
51CC  56                	MOV	D,M
51CD  23                	INX	H
51CE  C9                	RET
51CF                    	XTEXT	INDL
51CF                    INDL	SPACE	4,10
                        **	$INDL - INDEXED LOAD.
                        *
                        *	$INDL LOADS DE WITH THE TWO BYTES AT (HL)+DISPLACMENT
                        *
                        *	THIS ACTS AS AN INDEXED FULL WORD LOAD.
                        *
                        *	(DE) = ( (HL) + DSPLACEMENT )
                        *
                        *	ENTRY	((RET)) = DISPLACMENT (FULL WORD)
                        *		(HL) = TABLE ADDRESS
                        *	EXIT	TO (RET+2)
                        *	USES	A,F,D,E

      = 189C            $INDL	EQU	030234A 		; IN H17 ROM
51CF                    	XTEXT	INDXX
51CF                    	SPACE	4,10
                        **	$INDLB	-  INDEXED LOAD BYTE
                        *
                        *	BYTE INDEXED LOAD PRIMITIVE
                        *
                        *	ENTRY:	HL = BASE ADDRESS
                        *		(RET) = FULL WORD RELOCATION
                        *	EXIT:	A = ( HL + (RET) )
                        *	USES:	A

51CF  EB                $INDLB	XCHG				; DE = BASE
51D0  E3                	XTHL				; SAVE	.DE.
51D1  D5                	PUSH	D			; SAVE	BASE
51D2  C5                	PUSH	B			; SAVE	.BC.

51D3  4E                	MOV	C,M
51D4  23                	INX	H
51D5  46                	MOV	B,M			; BC = OFFSET
51D6  23                	INX	H			; HL =	.RET.

51D7  EB                	XCHG				; HL = BASE
51D8  09                	DAD	B			; HL = BASE + OFFSET
51D9  7E                	MOV	A,M			; A  = ( BASE + OFFSET )
51DA  EB                	XCHG				; HL =	.RET.

51DB  C1                	POP	B			; RESTORE  .BC.
51DC  D1                	POP	D			; RESTORE  BASE
51DD  E3                	XTHL				; HL = .DE. ; (SP) = .RET.
51DE  EB                	XCHG				; DE = .DE. ; HL = BASE
51DF  C9                	RET
51E0                    	SPACE	4,10
                        **	$INDS	-  INDEXED STORE
                        *
                        *	INDEXED STORE PRIMITIVE.
                        *
                        *	ENTRY:	HL = BASE ADDRESS
                        *		DE = VALUE TO STORE
                        *	EXIT:	( HL + (RET) ) = DE
                        *	USES:	NONE

51E0  CD 3452           $INDS	CALL	XCHGBC
51E3  E3                	XTHL				; SAVE	.BC.
51E4  D5                	PUSH	D
51E5  CD CA51           	CALL	ILDEHL			; DE = OFFSET
51E8  CD 3452           	CALL	XCHGBC			; BC = .RET.
51EB  EB                	XCHG				; DE = BASE ; HL = OFFSET
51EC  19                	DAD	D			; HL = BASE + OFFSET
51ED  EB                	XCHG
51EE  E3                	XTHL				; SAVE	BASE
51EF  EB                	XCHG				; DE = VALUE
51F0  CD 0C52           	CALL	ISDEHL
51F3  E1                	POP	H			; HL = BASE
51F4  CD 3452           	CALL	XCHGBC
51F7  E3                	XTHL				; RESTORE  .BC.
51F8  C3 3452           	JMP	XCHGBC
51FB                    	SPACE	4,10
                        **	$INDSB	-  INDEXED BYTE STORE
                        *
                        *	INDEXED BYTE STORE.
                        *
                        *	ENTRY:	A = VALUE TO STORE
                        *		HL = BASE ADDRESS
                        *		(RET) = OFFSET
                        *	EXIT:	NONE
                        *	USES:	PSW

51FB  EB                $INDSB	XCHG				; DE = BASE
51FC  E3                	XTHL				; SAVE	.DE.
51FD  D5                	PUSH	D			; SAVE	BASE
51FE  C5                	PUSH	B			; SAVE	.BC.

51FF  4E                	MOV	C,M
5200  23                	INX	H
5201  46                	MOV	B,M			; BC = OFFSET
5202  23                	INX	H			; HL =	.RET.

5203  EB                	XCHG				; HL = BASE
5204  09                	DAD	B			; HL = BASE + OFFSET
5205  77                	MOV	M,A			; ( BASE + OFFSET ) = A
5206  EB                	XCHG

5207  C1                	POP	B			; RESTORE  .BC.
5208  D1                	POP	D			; RESTORE  BASE
5209  E3                	XTHL				; HL = .DE. ; (SP) = .RET.
520A  EB                	XCHG				; DE = .DE. ; HL = BASE
520B  C9                	RET
520C                    	XTEXT	ISDEHL
520C                    	SPACE	4,10
                        **	ISDEHL	-  INDEXED STORE OF DE AT HL
                        *
                        *	STORE 'DE' AT THE ADDRESS POINTED TO BY 'HL', AND INCREMENT 'HL'
                        *	BY 2.
                        *
                        *	ENTRY:	DE = VALUE
                        *		HL = ADDRESS OF VALUE
                        *	EXIT:	(HL) = DE
                        *		HL = HL + 2
                        *	USES:	HL

520C  73                ISDEHL	MOV	M,E
520D  23                	INX	H
520E  72                	MOV	M,D
520F  23                	INX	H
5210  C9                	RET
5211                    	XTEXT	MCU
5211                    	SPACE	4,10
                        **	MCU - MAP LOWER CASE TO UPPER CASE.
                        *
                        *	MCU MAPS A LOWER CASE ALPHABETIC TO UPPER
                        *	CASE.
                        *
                        *	ENTRY	(A) = CHARACTER
                        *	EXIT	(A) = CHARACTER RESULT
                        *	USES	A,F

5211  FE 61             $MCU	CPI	'a'
5213  D8                	RC				; NOT LOWER CASE
5214  FE 7B             	CPI	'z'+1
5216  D0                	RNC				; NOT LOWER CASE
5217  D6 20             	SUI	'a'-'A'
5219  C9                	RET
521A                    	XTEXT	MOVE
521A                    MOVE	SPACE	4,10
                        **	$MOVE - MOVE DATA
                        *
                        *	$MOVE MOVES A BLOCK OF BYTES TO A NEW MEMORY ADDRESS.
                        *	IF THE MOVE IS TO A LOWER ADDRESS, THE BYTES ARE MOVED FROM
                        *	FIRST TO LAST.
                        *
                        *	IF THE MOVE IS TO A HIGHER ADDRESS, THE BYTES ARE MOVED FROM
                        *	LAST TO FIRST.
                        *
                        *	THIS IS DONE SO THAT AN OVERLAPED MOVE WILL NOT 'RIPPLE'.
                        *
                        *	ENTRY	(BC) = COUNT
                        *		(DE) = FROM
                        *		(HL) = TO
                        *	EXIT	MOVED
                        *		(DE) = ADDRESS OF NEXT FROM BYTE
                        *		(HL) = ADDRESS OF NEXT *TO* BYTE
                        *		'C' CLEAR
                        *	USES	ALL

      = 18AA            $MOVE	EQU	030252A 		; IN H17 ROM
521A                    	XTEXT	MU10
521A                    MU10	SPACE	4,10
                        **	$MU10 - MULTIPLY UNSIGNED 16 BIT QUANTITY BY 10.
                        *
                        *	(HL) = (DE)*10
                        *
                        *	ENTRY	(DE) = MULTIPLIER
                        *	EXIT	'C' CLEAR IF OK
                        *		 (HL) = PRODUCT
                        *		'C' SET IF ERROR
                        *	USES	D,E,H,L,F

      = 18D4            $MU10	EQU	030324A 		; IN H17 ROM
521A                    	XTEXT	MU86
521A                    MU86	SPACE	4,10
                        **	$MU86 - MULTIPLY 8X16 UNSIGNED.
                        *
                        *	$MU86 MULTIPLIES A 16 BIT VALUE BY A 8
                        *	BIT VALUE.
                        *
                        *	ENTRY	(A) = MULTIPLIER
                        *		(DE) = MULTIPLICAND
                        *	EXIT	(HL) = RESULT
                        *		'Z' SET IF NOT OVERFLOW
                        *	USES	A,F,H,L

      = 1907            $MU86	EQU	031007A 		; IN H17 ROM
521A                    	XTEXT	SAVALL
521A                    SAVALL	SPACE	3,10
                        **	$RSTALL - RESTORE ALL REGISTERS.
                        *
                        *	$RSTALL RESTORES ALL THE REGISTERS OFF THE STACK, AND
                        *	RETURNS TO THE PREVIOUS CALLER.
                        *
                        *	ENTRY	(SP) = PSW
                        *		(SP+2) = BC
                        *		(SP+4) = DE
                        *		(SP+6) = HL
                        *		(SP+8) = RET
                        *	EXIT	TO *RET*, REGISTERS RESTORED
                        *	USES	ALL

      = 1927            $RSTALL EQU	031047A 		; IN H17 ROM
521A                    	SPACE	3,10
                        **	$SAVALL - SAVE ALL REGISTERS ON STACK.
                        *
                        *	$SAVALL SAVES ALL THE REGISTERS ON THE STACK.
                        *
                        *	ENTRY	NONE
                        *	EXIT	(SP) = PSW
                        *		(SP+2) = BC
                        *		(SP+4) = DE
                        *		(SP+6) = HL
                        *	USES	H,L

      = 192C            $SAVALL EQU	031054A 		; IN H17 ROM
521A                    	XTEXT	SOB
521A                    	SPACE	4,10
                        **	$SOB - SKIP OVER BLANKS.
                        *
                        *	$SOB IS CALLED TO SKIP AN ARBITRARILY LONG STRING OF BLANKS AND TABS.
                        *
                        *	ENTRY	(HL) = FWA OF (POSSIBLE) BLANK STRING
                        *	EXIT	(HL) = LWA+1 OF BLANK STRING (UNCHANGED IF NO BLANKS)
                        *		(A) = FIRST NON-BLANK, NON-TAB CHARACTER EEN
                        *	USES	A,F,H,L

521A  2B                $SOB	DCX	H			; PRE-DECREMENT
521B  23                $SOB1	INX	H
521C  7E                	MOV	A,M
521D  FE 20             	CPI	' '
521F  CA 1B52           	JE	$SOB1			; GOT BLANK
5222  FE 09             	CPI	TAB
5224  CA 1B52           	JE	$SOB1			; GOT TAB
5227  C9                	RET
5228                    	XTEXT	TBRA
5228                    TBRA	SPACE	4,10
                        **	$TBRA - BRANCH RELATIVE THOUGH TABLE.
                        *
                        *	$TBRA USES THE SUPPLIED INDEX TO SELECT A BYTE FROM THE
                        *	JUMP TABLE. THE CONTENTS OF THIS BYTE ARE ADDED TO THE
                        *	ADDRESS OF THE BYTE, YEILDING THE PROCESSOR ADDRESS.
                        *
                        *	CALL	$TBRA
                        *	DB	LAB1-*		INDEX = 0 FOR LAB1
                        *	DB	LAB2-*		INDEX = 1 FOR LAB2
                        *	DB	LABN-*		INDEX = N-1 FOR LABN
                        *
                        *	ENTRY	(A) = INDEX
                        *		(RET) = TABLE FWA
                        *	EXIT	TO COMPUTED ADDRESS
                        *	USES	F,H,L

      = 193E            $TBRA	EQU	031076A 		; IN H17 ROM
5228                    	XTEXT	TYPCC
5228                    	SPACE	4,10
                        **	$TYPCC - TYPE A CHARACTER STRING BY COUNT.
                        *
                        *	$TYPCC TYPES A STRING OF CHARACTERS. THE CALLER SUPPLIES
                        *	THE CHARACTER ADDRESS AND COUNT.
                        *
                        *	ENTRY	(HL) = ADDRESS
                        *		(A) = COUNT
                        *	EXIT	(HL) = LAST CHARACTER ADDRESS+1
                        *	USES	A,F,H,L

      = 5228            $TYPCC	EQU	*

5228  A7                	ANA	A
5229  C8                	RZ				; NOTHING TO TYPE
522A  F5                	PUSH	PSW			; SAVE COUNT
522B  7E                	MOV	A,M			; (A) = CHARACTER
522C  23                	INX	H
522D  FF 02             	SCALL	.SCOUT
522F  F1                	POP	PSW
5230  3D                	DCR	A
5231  C3 2852           	JMP	$TYPCC
5234                    	XTEXT	TYPTX
5234                    TYPTX	SPACE	4,10
                        **	$TYPTX - TYPE TEXT.
                        *
                        *	$TYPTX IS CALLED TO TYPE A BLOCK OF TEXT ON THE SYSTEM CONSOLE.
                        *
                        *	IMBEDDED ZER0 BYTES INDICATE A CARRIAGE RETURN LINE FEED,
                        *	A BYTE WITH THE 200Q BIT SET IS THE LAST BYTE IN THE MESSAGE.
                        *
                        *	ENTRY	(RET) = TEXT
                        *	EXIT	TO (RET+LENGTH)
                        *	USES	A,F

      = 195E            $TYPTX	EQU	031136A 		; IN H17 ROM

      = 1964            $TYPTX. EQU	031144A 		; IN H17 ROM
5234                    	XTEXT	UDD
5234                    UDD	SPACE	4,10
                        **	$UDD - UNPACK DECIMAL DIGITS.
                        *
                        *	UDD CONVERTS A 16 BIT VALUE INTO A SPECIFIED NUMBER OF
                        *	DECIMAL DIGITS. THE RESULT IS ZERO FILLED.
                        *
                        *	ENTRY	(B,C) = ADDRESS VALUE
                        *		(A) = DIGIT COUNT
                        *		(H,L) = MEMORY ADDRESS
                        *	EXIT	(HL) = (HL) + (A)
                        *	USES	ALL

      = 196F            $UDD	EQU	031157A 		; IN H17 ROM
5234                    	XTEXT	XCHGBC
5234                    	SPACE	4,10
                        ***	XCHGBC - Exchange (HL) with (BC).
                        *
                        *	Entry:	NONE
                        *	Exit:	(HL) = (BC)
                        *		(BC) = (HL)
                        *	Uses:	B,C,H,L
                        *
                        *	Note:	Whoever wrote the original version of this routine
                        *		(that distributed by Heath), really ought to be shot.

5234  C5                XCHGBC	PUSH	B			; Put (BC) on stack
5235  E3                	XTHL				; Swap it with (HL)
5236  C1                	POP	B			; Pop new (BC)
5237  C9                	RET
5238                    	XTEXT	ZERO
5238                    ZERO	SPACE	4,10
                        **	$ZERO - ZERO MEMORY
                        *
                        *	$ZERO ZEROS A BLOCK OF MEMORY.
                        *
                        *	ENTRY	(HL) = ADDRESS
                        *		(B) = COUNT
                        *	EXIT	(A) = 0
                        *	USES	A,B,F,H,L

      = 198A            $ZERO	EQU	031212A 		; IN H17 ROM
5238                    	XTEXT	ZEROS
5238                    ZEROS	SPACE	4,10
                        **	8 CONSTANT ZERO BYTES.
                        *

      = 19D0            $ZEROS	EQU	031320A 		; IN H17 ROM
5238                    	STL	'Replacements for H17 ROM'
5238                    	EJECT
                        **	THE FOLLOWING ROUTINES ARE REPLACEMENTS FOR THE H17 ROM CODE.
                        *

                        **	ISY	- Internal SY Device Driver
                        *
                        *	ISY maps the logical system device units into the real
                        *	physical units known by the driver.  This is done so
                        *	that any device may be booted.
                        *
                        *	ENTRY:	NONE
                        *	EXIT:	NONE
                        *	USES:	NONE
                        *

5238  E5                ISY	PUSH	H
5239  21 3121           	LXI	H,AIO.UNI
523C  66                	MOV	H,M
523D  E3                	XTHL				; Save current device specification

523E  F5                	PUSH	PSW
523F  D5                	PUSH	D
5240  E5                	PUSH	H

5241  2A F847           	LHLD	GSPA
5244  CD CF51           	CALL	$INDLB
5247  0800              	DW	DEV.MNU
5249  57                	MOV	D,A			; D = max num of units

524A  3A 3121           	LDA	AIO.UNI
524D  2A BD52           	LHLD	SUNIT
5250  85                	ADD	L			; A = AIO.UNI+SUNIT

5251  92                	SUB	D
5252  D2 5652           	JNC	ISY1
5255  82                	ADD	D			; A = A mod D

      = 5256            ISY1	EQU	*

5256  32 3121           	STA	AIO.UNI

5259  E1                	POP	H
525A  D1                	POP	D
525B  F1                	POP	PSW

525C  E5                	PUSH	H
525D  21 6752           	LXI	H,ISY2
5260  E3                	XTHL				; Set up RETurn address
5261  E5                	PUSH	H
5262  2A BE52           	LHLD	MSYDD
5265  E3                	XTHL				; Set up Driver Address on Stack
5266  C9                	RET				; Call Driver

5267  E3                ISY2	XTHL
5268  F5                	PUSH	PSW
5269  7C                	MOV	A,H
526A  32 3121           	STA	AIO.UNI 		; Replace the original value
526D  F1                	POP	PSW
526E  E1                	POP	H			; Restore exit HL
526F  C9                	RET
5270                    	STL	'HOSNMI - NMI processor'
5270                    	EJECT
                        ***	HOSNMI - NMI processor
                        *

      = 5270            HOSNMI	EQU	*

5270  F5                	PUSH	PSW
5271  E5                	PUSH	H

5272  21 F73C           	LXI	H,NMIFL
5275  34                	INR	M			; bump flag

5276  E1                	POP	H
5277  F1                	POP	PSW

5278  ED45              	DB	0EDH,45H		; <RETN>
527A                    	STL	'HOSTIC - 2ms Clock'
527A                    	EJECT
                        ***	HOSTIC - 2ms Tick
                        *
                        *	This routine remains as the only hardware dependent
                        *	code within HDOS. (well, nearly...)

      = 527A            HOSTIC	equ	*

527A  F5                	PUSH	PSW			; save
527B  E5                	PUSH	H			;  everything
527C  D5                	PUSH	D
527D  C5                	PUSH	B

527E  2A 1B20           	LHLD	.TICCNT
5281  23                	INX	H			; bump 2ms clock
5282  22 1B20           	SHLD	.TICCNT

5285  3A 3620           	LDA	.CTL2FL
5288  D3 F2             	OUT	OP2.CTL 		; write ROM disable/H89 control

528A  3A 0920           	LDA	.CTLFLG
528D  A7                	ANA	A			; is an H8?
528E  CA A152           	JZ	HOSTIC1 		; no.

5291  67                	MOV	H,A			; save flag

5292  7D                	MOV	A,L
5293  A7                	ANA	A			; is 256 tics?
5294  C2 9E52           	JNZ	HOSTIC0 		; no.

5297  3E 20             	MVI	A,CB.MTL
5299  AC                	XRA	H			; blink light
529A  32 0920           	STA	.CTLFLG 		; fix value
529D  67                	MOV	H,A

529E  7C                HOSTIC0 MOV	A,H
529F  D3 F0             	OUT	OP.CTL			;  else write H8 control port.

                        *	check for user interrupt processing

52A1  3A 0820           HOSTIC1 LDA	.MFLAG
52A4  0F                	RRC
                        	ERRNZ	UO.CLK-1
52A5  DC 1F20           	CC	.UIVEC

                        *	return from interrupt

52A8  C1                	POP	B
52A9  D1                	POP	D
52AA  E1                	POP	H
52AB  F1                	POP	PSW

52AC  FB                	EI
52AD  C9                	RET
52AE                    	STL	'HOSDLY - Timed Delay'
52AE                    	EJECT
                        ***	HOSDLY - Timed Delay
                        *
                        *	Entry:	(a) = 2ms ticks to wait
                        *	Exit:	None
                        *	Uses:	PSW

      = 52AE            HOSDLY	equ	*

52AE  E5                	PUSH	H

52AF  21 1B20           	LXI	H,.TICCNT
52B2  86                	ADD	M			; time to wait 'til
52B3  BE                DLY1	CMP	M			; done?
52B4  C2 B352           	JNZ	DLY1

52B7  E1                	POP	H

52B8  C9                	RET
52B9                    	STL	'Private RAM Area'
52B9                    	EJECT

      = 52B9            HIGHDAT EQU	*

                        **	SYSTEM MODE. NON-ZERO WHEN PROCESSING SYSCALL.

                        	ERRNZ	*-HIGHDAT-M.SYSM
52B9  00                SYSMODE	DB	0

52BA  00                	DB	0			; stand-alone flag (obsolete)	

                        	ERRNZ	*-HIGHDAT-M.CSL
52BB  0000              SCSLDAT DW	0			; Pointer to console data

                        	ERRNZ	*-HIGHDAT-M.SUNI
52BD  00                SUNIT	DB	0			; System Unit Number
                        	ERRNZ	*-HIGHDAT-M.SYDD
52BE  0000              MSYDD	DW	0			; System Device Driver


                        ***	DATA FOR MOUNT & DISMOUNT

52C0  6464753A 008A     DEVNAME DB	'ddu:',0,ENL
      = 0004            DEVNAML	EQU	*-DEVNAME-2

52C6  00                UNIT	DB	0			; DEVICE UNIT NUMBER
52C7  0000              DEVTAB	DW	0			; DEVICE TABLE ADDRESS
52C9  0000              DEVENT	DW	0			; DEVICE DRIVER ENTRY POINT
52CB  0000              RGTADR	DW	0			; RGT Address
52CD  00                SPG	DB	0			; Sectors Per Group
52CE  0000              UNTTAB	DW	0			; DEVICE UNIT TABLE ADDRESS
52D0  00                VOLUME	DB	0			; Volume Number
52D1                    	STL	'Patch Area and PIC Table'
52D1                    	EJECT
                        *	PATCH AREA

52D1  1B704279 20574750 TRIBUTE DB	ESC,'pBy WGP in remembrance of JGL and GAC.',ESC,'q'
52D9  20696E20 72656D65
52E1  6D627261 6E636520
52E9  6F66204A 474C2061
52F1  6E642047 41432E1B
52F9  71
52FA  8C                	DB	FF+EOL

52FB  7062              	DW	'bp'			; dummy for patching PIC table

      = 52FD            LWASYS	EQU	*	;END OF MONITOR
      = 166F            LENSYS	EQU	LWASYS-FWASYS

52FD                    	NOTE	LENSYS

                        ***	PIC Table

52FD                    	LON	G

52FD                    	END
PIC Table

  3090
  30B1
  3189
  31B2
  31B9
  31BC
  31BF
  31C2
  31C5
  31C8
  31CB
  31CE
  31D1
  31D4
  31D7
  31DA
  31DD
  322B
  3232
  323B
  32EF
  35A8
  36B5
  3719
  376A
  378B
  3792
  37D8
  37E8
  37F0
  37F9
  3805
  3811
  3818
  38E3
  390A
  39F7
  3A87
  3C94
  3C97
  3CBA
  3CCA
  3CF5
  3D1B
  3D20
  3D25
  3D2A
  3D39
  3D47
  3D50
  3D54
  3D58
  3D60
  3D66
  3D6B
  3D70
  3D73
  3D78
  3D7D
  3D82
  3D85
  3D8A
  3D92
  3DA0
  3DA2
  3DA4
  3DA6
  3DA8
  3DAA
  3DAC
  3DAE
  3DB0
  3DB2
  3DB4
  3DB6
  3DB8
  3DBA
  3DBC
  3DBE
  3DC0
  3DC2
  3DC4
  3DC6
  3DC8
  3DCA
  3DCC
  3DCE
  3DD0
  3DD2
  3DD4
  3DD6
  3DD8
  3DDA
  3DDC
  3DDE
  3DE0
  3DE2
  3DE4
  3DE6
  3DE8
  3DEA
  3E0D
  3E13
  3E17
  3E2B
  3E2E
  3E3B
  3E41
  3E48
  3E52
  3E5B
  3E60
  3E68
  3E6B
  3E70
  3E74
  3F18
  3F2B
  3F2E
  3F31
  3F46
  3F49
  3F55
  3F60
  3F6D
  3F7A
  3F81
  3F90
  3F9D
  3FA2
  3FAF
  3FB3
  3FD3
  3FDB
  3FE4
  3FF6
  4032
  4035
  4061
  4066
  4077
  407A
  4087
  408F
  4094
  4097
  40AC
  40BB
  40BE
  40C7
  40CB
  40D2
  40D5
  40D8
  40E7
  40EA
  40EE
  40F1
  40FB
  4133
  4136
  4139
  414A
  414E
  4152
  416C
  416F
  4173
  4183
  4189
  4194
  4197
  419C
  419F
  41A3
  41B9
  41C1
  41C5
  41DD
  41EE
  41F2
  41FD
  4210
  4213
  4216
  4223
  422C
  422F
  4232
  4237
  423A
  4243
  4246
  424B
  424E
  4257
  425B
  425E
  4269
  427A
  4283
  4293
  429A
  42A5
  42AB
  42B7
  42D0
  42D5
  42D8
  42DB
  42F1
  430B
  4322
  4338
  435A
  435D
  43A2
  43B1
  43B8
  43BF
  43C7
  43CA
  43CD
  43D6
  43D9
  43DD
  43E1
  43EA
  43ED
  43F3
  43F8
  4402
  440C
  440F
  4416
  4419
  4453
  4479
  4487
  448A
  448E
  4492
  4496
  449D
  44AE
  44B3
  44B7
  44BA
  44C8
  44CC
  44CF
  44E2
  44EC
  44EF
  44F2
  44F5
  44F8
  44FB
  44FE
  4501
  4509
  450D
  4510
  4519
  451C
  451F
  4522
  4528
  453B
  453F
  4546
  454D
  4550
  4554
  4557
  4560
  4563
  4567
  456A
  4571
  4584
  458D
  4591
  459B
  459F
  45A2
  45AD
  45B0
  45B4
  45BC
  45BF
  45C3
  45C7
  45CA
  45CF
  45F6
  45F9
  45FC
  45FF
  4607
  460A
  460D
  4610
  4617
  461A
  4623
  4627
  462E
  463A
  463D
  4641
  4647
  464D
  4655
  4658
  465B
  4660
  4669
  4673
  4676
  467C
  4682
  4687
  468C
  4690
  4699
  469D
  46A4
  46AB
  46AF
  46B3
  46B6
  46BA
  46DC
  46E0
  46F4
  4707
  471A
  4729
  472D
  4732
  4738
  4740
  4754
  4758
  4765
  476F
  4772
  477A
  477D
  4782
  479E
  47BB
  47C5
  47CF
  47EB
  4802
  4816
  4819
  481F
  4822
  482A
  482D
  4830
  4834
  4838
  483B
  484E
  4857
  485B
  4863
  4867
  486D
  487A
  4895
  48B2
  48BB
  48BE
  48CA
  48CE
  48D1
  48D7
  48DA
  48DD
  48E0
  48E3
  48EA
  48ED
  4908
  490D
  4912
  4929
  4930
  4933
  4936
  493B
  494B
  495A
  496D
  4975
  497D
  4993
  49AB
  49AF
  49B3
  49BD
  49C1
  49C8
  49CE
  49D1
  49D8
  49DD
  49E6
  49EB
  49F4
  49F7
  49FC
  4A02
  4A08
  4A0C
  4A11
  4A17
  4A2B
  4A44
  4A4B
  4A52
  4A61
  4A7D
  4A8E
  4A97
  4AC9
  4AD2
  4AD5
  4AD8
  4ADB
  4AE8
  4AF2
  4AF8
  4B01
  4B20
  4B23
  4B31
  4B3C
  4B41
  4B44
  4B47
  4B50
  4B53
  4B56
  4B5D
  4B63
  4B66
  4B69
  4B71
  4B7D
  4B80
  4B84
  4B87
  4B8B
  4BAD
  4BC4
  4BC7
  4BCE
  4BD3
  4BD8
  4BDB
  4BDE
  4BE3
  4BEA
  4BF8
  4BFB
  4C0C
  4C10
  4C13
  4C19
  4C2A
  4C31
  4C3F
  4C44
  4C4E
  4C58
  4C5B
  4C5F
  4C64
  4C69
  4C6E
  4C73
  4C7B
  4C81
  4CD1
  4CD8
  4CDF
  4CE2
  4CED
  4CF7
  4CFE
  4D0C
  4D15
  4D24
  4D2E
  4D35
  4D3F
  4D42
  4D4A
  4D55
  4D58
  4D5E
  4D66
  4D72
  4D75
  4D78
  4DA0
  4DAF
  4DBC
  4DC0
  4DD1
  4DE2
  4DE9
  4DED
  4DF1
  4E0A
  4E0E
  4E13
  4E1B
  4E27
  4E3A
  4E51
  4E5F
  4E67
  4E7B
  4E80
  4E89
  4E8D
  4E9C
  4EA0
  4EA4
  4EAB
  4EB5
  4EBD
  4EC1
  4EC8
  4ECF
  4ED7
  4EDF
  4EE5
  4EE9
  4EEE
  4EF6
  4F09
  4F0E
  4F11
  4F16
  4F1A
  4F20
  4F25
  4F34
  4F3A
  4F43
  4F4C
  4F51
  4F5D
  4F65
  4F6B
  4F6E
  4F77
  4F7C
  4F7F
  4F8E
  4F9B
  4FB0
  4FB7
  4FBE
  4FC3
  4FCC
  4FD2
  4FD6
  4FD9
  4FDD
  4FE9
  4FF0
  4FF5
  4FF8
  4FFB
  4FFF
  5007
  500A
  500F
  5019
  501F
  5023
  5036
  5046
  504A
  504D
  5051
  506D
  508B
  5090
  50A1
  50B7
  50BF
  50C2
  50C8
  50D3
  50D9
  5104
  510D
  513B
  5140
  514A
  5152
  5172
  517C
  517F
  5189
  51A4
  51AC
  51B2
  51E1
  51E6
  51E9
  51F1
  51F5
  51F9
  5220
  5225
  5232
  5242
  5245
  524E
  5253
  525E
  5263
  5273
  528F
  5295
  52B5

00001 Total Error 


00000 Total Warnings

$CAD               3A3B    $CAD0              3A4D    $CAD1              3A99
$CAD2              3AB5    $CAD3              3AB8    $CADA              3B06
$CADB              3B2B    $CADBL             0007 E  $CADD              3AF8
$CDEHL             188E E  $CFD               4A9B R  $CHL               1894 E
$COMP              1830 E  $CRLF              5196 R  $DAD               3B39
$DADA              183A E  $DADA.             1841 E  $DDD               3BD9
$DDD1              3BDC    $DTB               519C R  $DTB1              51A0 R
$DTB2              51A7 R  $DTB3              51B4 R  $DU66              1846 E
$HLIHL             1889 E  $INDL              189C E  $INDLB             51CF R
$INDS              51E0 R  $INDSB             51FB R  $MCU               5211 R
$MLU               39F1    $MLU1              39F4    $MOVE              18AA E
$MOVEL             3A01    $MU10              18D4 E  $MU86              1907 E
$RSTALL            1927 E  $RTL               3A1B E  $RTL.              3A14
$RTL1              3A1C    $RTL2              3A38    $SAVALL            192C E
$SOB               521A R  $SOB1              521B R  $TBRA              193E E
$TYPCC             5228 ER $TYPTX             195E E  $TYPTX.            1964 E
$UDD               196F E  $UDDN              3BF6 E  $UDDS              3BFB E
$UDDX              3BFE    $ZERO              198A E  $ZEROS             19D0 E
.                  0021 S  ..CLRCO            007C    ..CONSL            0079
..PRINT            0076    ..SCIN             0070    ..SCOUT            0073
.ABUSS             2014 E  .ALEDS             200B E  .CHFLG             0030
.CLEAR             002D    .CLEARA            002E    .CLOSE             0026
.CLRCO             0007    .CLRCO.            3D0A R  .CONSL             0006
.CONSL.            3D07 R  .CRC16             000B    .CRCSUM            2017 E
.CTL2FL            2036 E  .CTLC              0021    .CTLFLG            2009 E
.DAD               0086    .DATE.             0001 E  .DECODE            002B
.DELET             0028    .DELETE            0028 E  .DISMT             0031
.DLEDS             2011 E  .DLY               002B E  .DMNMS             0083
.DMOUN             0081    .DMOUNT            0081 E  .DSPMOD            2007 E
.DSPROT            2006 E  .ERROR             002F    .EXIT              0000
.GDA               000A    .IOWRK             2002 E  .LINK              0020
.LOADD             0032    .LOADO             0008    .MFLAG             2008 E
.MONMS             0082    .MOUNT             0080    .NAME              002C
.NMIRET            2034 E  .OPENC             0025    .OPENR             0022
.OPENU             0024    .OPENW             0023    .POSIT             0027
.PRINT             0003    .PRINT.            3D04 R  .READ              0004
.REGI              2005 E  .REGPTR            201D E  .RENAM             0029
.RENAME            0029 E  .RESET             0084    .RESNMS            0085
.SCIN              0001    .SCIN.             3CFE R  .SCOUT             0002
.SCOUT.            3D01 R  .SETTOP            002A E  .SETTP             002A
.START             2000 E  .SYSRES            000C    .TICCNT            201B E
.TIME.             0002 E  .TPERRX            2019 E  .UIVEC             201F E
.VERS              0009    .WRITE             0005    .Z80.              0000 U
ABS.COD            0008    ABS.ENT            0006    ABS.ID             0000
ABS.LDA            0002    ABS.LEN            0004    ACA                4744 R
ACA0               4746 R  ACA1               474C R  ACA2               475B R
ACA3               4767 R  ACA8               477F R  ACA9               4789 R
ACT                379F E  ACT1               37C0    ADB                31DF E
AFP                428A R  AFP1               4287 R  AFP2               42A0 R
AGT                4927 R  AGT1               493F R  AGT2               496B R
AGT3               497F R  AGTA               4982 R  AGTB               4983 R
AIO.CGN            2127    AIO.CHA            214E    AIO.CNT            2149
AIO.CSI            2128    AIO.DDA            2121 E  AIO.DES            212D
AIO.DEV            212F    AIO.DIR            2132    AIO.DTA            212B
AIO.EOF            214B    AIO.EOM            214A    AIO.FLG            2123
AIO.GRT            2124    AIO.LGN            2129    AIO.LSI            212A
AIO.SPG            2126    AIO.TFP            214C    AIO.UNI            2131
AIO.VEC            2120    ALP                4984 R  ASG                3774 E
ASG1               3791    ASGA               379D    B.END              0080 E
B.INT0             0000    B.INT1             0008    B.INT2             0010
B.INT3             0018    B.INT4             0020    B.INT5             0028
B.INT6             0030    B.INT7             0038    B.NMI              0066
B.NMIFL            0069    B.SCALL            003B    BATBUF             0054
BATGNS             0052    BATNAME            0040    BATPTR             0056
BATSEC             0051    BELL               0007 E  BFLG.A             0001 E
BITS               5181 R  BITS1              5186 R  BKSP               0008 E
BOOT.P             0001 E  BOOTA              1F5A E  BOOTABT            3882
BOOTAL             0058 E  BOOTERR            385D    BS                 0008 E
BTS                4794 R  BUFF               2F00 E  BUFFE              3000 E
BUFFWA             1F94 S  BUFFWA.            1F94 E  C.STX              0002 E
C.SYN              0016 E  CAB                4992 R  CAB.               4995 R
CAC                499A R  CAD.M              3A95    CAD.Y              3AD8
CADHL              3AF5 E  CADL               3A85    CADR               3AF3
CB.CLI             0040 E  CB.MTL             0020 E  CB.SPK             0080 E
CB.SSI             0010 E  CB2.CLI            0002 E  CB2.ORG            0020 E
CB2.SID            0040 E  CB2.SSI            0001 E  CDB.H84            0001 E
CDB.H85            0000 E  CDM                49A7 R  CDM.               49AA R
CDS                49E2 R  CDS1               49F1 R  CDS2               49FB R
CDS3               4A04 R  CDS4               4A05 R  CDS4.5             4A10 R
CDS5               4A19 R  CDS6.              4A4D R  CDU                4A58 R
CDU1               4A67 R  CFC                4A6A R  CFC1               4A6F R
CFC2               4A93 R  CFF                19EC E  CFI                4AAD R
CFM                4601 R  CFM0               4632 R  CFM1               4633 R
CFMA               462B ER CFP                4AC8 R  CHFLG              4452 ER
CLEAR              4382 ER CLEAR1             4389 R  CLOCK              1C19 E
CLOSE              41F1 ER CLOSE0             420C R  CLOSE1             4218 R
CLOSE2             4226 R  CLOSE3             422E R  CLOSE4             4239 R
CLOSE6             423E R  CLOSE7             423F R  CLOSE8             4250 R
CLRALL             43A4 ER CLRALL1            43AA R  CN.170M            000C E
CN.174M            0003 E  CN.ABO             0080 E  CN.BAU             0040 E
CN.MEM             0020 E  CN.PRI             0010 E  CND.H17            0000 E
CND.H47            0001 E  CND.NDI            0000 E  CO.FLG             0001 E
COF                4ACF R  COF1               4AE0 R  COF2               4AFA R
COF3               4B06 R  COFA               4B0D R  COFB               4B0F R
CPA                479D ER CPDEHL             5190 R  CR                 000D E
CRC16              3F77 R  CRC16.             3F85 R  CRC16.1            3F88 R
CRC16.2            3F9A R  CRC161             3F78 R  CS.FLG             0080 E
CSL.CHR            0001 E  CSL.ECH            0080 E  CSL.RAW            0004 E
CSL.WRP            0002 E  CSLIBUF            003E    CTLA               0001 E
CTLB               0002 E  CTLC               0003 E  CTLD               0004 E
CTLE               0005 E  CTLO               000F E  CTLP               0010 E
CTLQ               0011 E  CTLR               0012 E  CTLS               0013 E
CTLX               0018 E  CTLZ               001A E  CTP.2SB            0008 E
CTP.BKM            0002 E  CTP.BKS            0080 E  CTP.FF             0040 E
CTP.HHS            0004 E  CTP.MLI            0020 E  CTP.MLO            0010 E
CTP.TAB            0001 E  D.CON              2048    D.RAM              20A0
D.VEC              2058    DAD1               3B91    DAD1.              3B92 E
DAD1X              3B90    DAD2               3B9A    DAD3               3B9D
DADB               3BA3    DADC               3BC7    DADCL              0009 E
DADCX              3BD0    DADD               4662 ER DADD1              4665 R
DADD2              468E R  DADD3              4692 R  DADD4              46A6 R
DADD5              46B8 R  DADDA              46C5 R  DADDB              46C7 R
DBUF               3B32    DC.ABT             0007    DC.CLO             0006
DC.DSF             000E    DC.INT             000D    DC.LOD             0009
DC.MAX             000F    DC.MOU             0008    DC.OPR             0003
DC.OPU             0005    DC.OPW             0004    DC.RDY             000A
DC.REA             0000    DC.RER             0002    DC.SET             000B
DC.UNL             000C    DC.WRI             0001    DCA                1A02 E
DCF                4B10 R  DCF1               4B17 R  DDF.BOL            0009 E
DDF.BOO            0000    DDF.LAB            0009    DDF.USR            000A
DDS                4B2F ER DDS.               4B22 R  DDS1               4B4E R
DDS2               4B5F R  DDS3               4B73 R  DDS5               4B78 R
DEBUG              0000 E  DECODE             4336 ER DEL                007F E
DELETE             42AA ER DELETE0            42C2 R  DEV.DDA            0004
DEV.DVG            000D    DEV.DVL            000B    DEV.FLG            0006
DEV.JMP            0003    DEV.MNU            0008    DEV.MUM            0007
DEV.NAM            0000    DEV.RES            0002    DEV.UNT            0009
DEVELEN            000E E  DEVENT             52C9 R  DEVNAME            52C0 R
DEVNAML            0004 ER DEVTAB             52C7 R  DF.CLR             00FE E
DF.EMP             00FF E  DFA                4B7C R  DFC                4BA1 R
DFD                4BAF R  DFD1               4BDA R  DFD2               4BFD R
DFD3               4C26 R  DFD4               4C28 R  DFD5               4C49 R
DIF.ARC            0008 E  DIF.BAD            0004 E  DIF.CNT            0010 E
DIF.DL             0002 E  DIF.LOC            0040 E  DIF.SYS            0080 E
DIF.USR            0001 E  DIF.WP             0020 E  DIR.ACD            0015
DIR.CRD            0013    DIR.CTH            000B    DIR.CTM            000C
DIR.EXT            0008    DIR.FGN            0010    DIR.FLG            000E
DIR.LGN            0011    DIR.LSI            0012    DIR.NAM            0000
DIR.NOA            000D    DIR.USR            000F    DIREAD             46CA ER
DIREAD1            46E3 R  DIRELEN            0017 E  DIRIDL             000B E
DIS.ENL            01FB    DIS.ENT            0000 E  DIS.LNK            01FE
DIS.SEC            01FC    DISMT              447B ER DIWRITE            46FA ER
DLY1               52B3 R  DM.MR              0000 E  DM.MW              0001 E
DM.RR              0002 E  DM.RW              0003 E  DMO1               4545 R
DMO2               4566 R  DMO3               4586 R  DMO4               45A4 R
DMOA               45B6 R  DMOB               45B8 R  DMOC               45B9 R
DMONMS             453A ER DMOUA              44D1 R  DMOUNT             44C7 ER
DNT                4C4D R  DNT1               4C54 R  DNT2               4C5D R
DNT3               4C75 R  DNT4               4C7F R  DNTA               4C84 R
DR.FX              0004 E  DR.IM              0001 E  DR.PR              0002 E
DR.SPL             00E0 E  DR.UNL             0008 E  DREAD              4C8D R
DRIVER             4730 R  DT.CH              0010 E  DT.CR              0002 E
DT.CW              0004 E  DT.DD              0001 E  DT.FX              0020 E
DT.P3              0040 E  DT.RN              0008 E  DT.UL              0080 E
DV.EL              0000 E  DV.NU              0001 E  DVD.CAP            0007
DVD.DVD            0006    DVD.ENT            0200 E  DVD.INP            0013
DVD.MNU            0009    DVD.MUM            0008    DVD.SET            0012
DVD.SPL            0016    DVD.STE            002B E  DVD.UFL            000A
DVD.V30            0015    DVDFLV             00C7 E  DWRIT1             46ED R
DWRIT2             4709 R  DWRITE             4C91 R  EC.CNA             0004
EC.CNR             0034    EC.CUI             0037    EC.DDA             0017
EC.DFM             0031    EC.DIF             000F    EC.DIW             001D
EC.DNI             0025    EC.DNL             002F    EC.DNP             0030
EC.DNR             0026    EC.DNS             0005    EC.DSC             0027
EC.EOF             0001    EC.EOM             0002    EC.FAO             0019
EC.FAP             0016    EC.FIX             002D    EC.FL              0018
EC.FNF             000C    EC.FNO             0009    EC.FNR             001C
EC.FOD             0023    EC.FUC             000B    EC.ICN             000E
EC.IDF             0032    EC.IDN             0006    EC.IFC             0010
EC.IFN             0007    EC.ILA             002E    EC.ILC             0003
EC.ILO             0020    EC.ILR             000A    EC.ILV             001F
EC.IOI             002A    EC.IS              001A    EC.ITS             0033
EC.LAD             002C    EC.LBO             0036    EC.NCV             0028
EC.NEM             0011    EC.NOS             0029    EC.NPM             0024
EC.NRD             0008    EC.NVM             0022    EC.OTL             002B
EC.RF              0012    EC.SDR             0035    EC.UNA             001E
EC.UND             000D    EC.UUN             001B    EC.VPM             0021
EC.WF              0013    EC.WP              0015    EC.WPV             0014
EDL                361D E  EDL.0              3675    EDL0               36AD
EDL0.5             36C4 E  EDL1               36E7    EDL2               3713
EDL3               372B    EDL5               3737    EDLCAP             376C
EDLD               375F    EDLDEV             3766 E  EDLDVG             3773
EDLDVL             3771    EDLMNU             376E    EDLMUM             376D
EDLNAM             3766    EDLPTR             376F    EDLRES             3768
EIRET              3D5C R  ENL                008A E  EOL                0080 E
ERR.FNO            19E4 E  ERR.ILR            19E8 E  ERR0               43E7 R
ERR0.5             43D5 ER ERR1               43EC R  ERR2               4401 R
ERR2.5             440E R  ERR4               43D1 R  ERRILC             3D8D R
ERROR              43BA ER ERRORA             441B R  ERRORB             4428 R
ERRORC             442C R  ESC                001B E  EXIT               3E0F ER
EXIT1              3E22 R  EXIT2              3E2A R  EXIT3              3E58 R
EXIT30             3E4C R  EXIT31             3E62 R  EXIT4              3E73 R
EXITA              3E90 R  EXITB              3E80 R  EXITD              3EA0 R
EXITE              3EA1 R  EXITF              3EA6 R  F.2MHZ             0000 E
F.4MHZ             0001 E  F.6MHZ             0002 E  F.8080             0000 E
F.8085             0040 E  F.CLK              0003 E  F.CPU              00C0 E
F.H19              0010 E  F.H8               0000 E  F.H89              0004 E
F.MACH             000C E  F.OCPU             00C0 E  F.OMACH            000C E
F.TERM             0030 E  F.TTY              0000 E  F.Z100             0008 E
F.Z80              0080 E  FALSE              0000 E  FATSERR            3DEC R
FCC                4C96 R  FCI                47B3 R  FCI1               47B8 R
FCI2               47CC R  FCI3               47EF R  FDB                4CAF R
FF                 000C E  FFB                1A5B E  FFL                1A85 E
FGC                4CC3 R  FGC0               4CC6 R  FGC1               4CCD R
FGC2               4CDA R  FLT.MNC            0000    FLT.OPT            0001
FLT.PBO            0002    FMASK              3C93 R  FOE                4CE1 R
FOE1               4CE4 R  FOE2               4CF3 R  FOE3               4D00 R
FSM                352E E  FT.ABS             0000 E  FT.BAC             0003 E
FT.DD              0001 E  FT.OC              0010 E  FT.OR              0002 E
FT.OU              0008 E  FT.OW              0004 E  FT.PIC             0001 E
FT.REL             0002 E  FWAREL             3C8E E  FWASYS             3C8E ER
GDA                3F4F R  GDA1               3F52 R  GDA2               3F68 R
GDA3               3F6F R  GETLAB             4D12 R  GETLAB.            4D17 R
GO0                30B7 E  GO0.1              30EA    GO0.2              30F6
GO0NMI             3101    GSP                47F7 R  GSPA               47F8 ER
GUP                51BD R  GVM                32EE E  GVM1               34EB
GVM2               3512    GVMA               3521    H17ROM             1800 E
H17ROML            0800 E  HIGHDAT            52B9 ER HOSB2              3060
HOSBA              3063    HOSBASE            0000 E  HOSBOO1            300C E
HOSBOOT            3006    HOSDLY             52AE ER HOSNMI             5270 ER
HOSRES             0001 E  HOSTAB             3009 E  HOSTIC             527A ER
HOSTIC0            529E R  HOSTIC1            52A1 R  I.CONFL            0004 E
I.CONTY            0001 E  I.CONWI            0003 E  I.CSLMD            0000 E
I.CUSOR            0002 E  ILDEHL             51CA R  IMM                4D29 R
IMM1               4D41 R  IMM2               4D49 R  IMMA               4D7A R
IMMB               4D81 R  IMMC               4D88 R  IOC.CGN            0008
IOC.CSI            0009    IOC.DDA            0002    IOC.DES            000E
IOC.DEV            0010    IOC.DIL            0011 E  IOC.DIR            0013
IOC.DRL            0008 E  IOC.DTA            000C    IOC.FLG            0004
IOC.GRT            0005    IOC.LGN            000A    IOC.LNK            0000
IOC.LSI            000B    IOC.SPG            0007    IOC.SQL            0003 E
IOC.UNI            0012    IOCCTD             0001 E  IOCELEN            002A E
IP.CON             00F2 E  IP.PAD             00F0 E  ISDEHL             520C R
ISY                5238 R  ISY1               5256 ER ISY2               5267 R
LAB.AUX            004F E  LAB.AXL            0001 E  LAB.DAT            0000 E
LAB.DIS            0003    LAB.GRT            0005    LAB.IND            0001
LAB.LAB            0011    LAB.LBL            003C E  LAB.LVN            0050
LAB.NOD            0002 E  LAB.PSS            000E    LAB.RGT            000A
LAB.SER            0000    LAB.SIZ            000C    LAB.SPG            0007
LAB.SPT            004F    LAB.SYS            0001 E  LAB.VER            0009
LAB.VFL            0010    LAB.VLT            0008    LAB.VPL            0005 E
LAB.VPR            000C E  LDD                4804 R  LDD1               4833 R
LDD10              48D6 R  LDD2               484D R  LDD3               4862 R
LDD4               487C R  LDD8               489C R  LDD8A              48C4 R
LDD8B              48C6 R  LDD8C              48C7 R  LDD9               48C9 R
LDD9A              48EF R  LDD9B              48F0 R  LDDA               489B R
LDE                4D97 R  LDE.               4D94 R  LDE..              4DA2 R
LDE3               4DB6 R  LDE5               4DCA R  LDE6               4DE4 R
LDI                4DE8 R  LDI0               4DF3 R  LDI1               4DF7 R
LDI2               4E15 R  LDI3               4E1D R  LDI4               4E34 R
LDI5               4E48 R  LENSYS             166F E  LF                 000A E
LFD                4E79 R  LFD1               4E7F R  LINK               3FA1 ER
LINKA              405D ER LOADD              4483 ER LOADO              3F4B ER
LUD                4E8F R  LUD1               4E92 R  LUD2               4EAF R
LUD3               4EB0 R  LWASYS             52FD ER M.CSL              0002
M.FOX              00C3 E  M.PAM8             0011 E  M.SUNI             0004
M.SYDD             0005    M.SYSM             0000    MI.JMP             00C3 E
MI.LXID            0011 E  MND                4EB7 R  MND.5              4F3D R
MND.6              4F4F R  MND0               4EE4 R  MND2               4F55 R
MOU2               4531 R  MOU2.              452F R  MOU2.5             4537 R
MOUA               44BC R  MOUNMS             44E1 ER MOUNT              44AD ER
MSD                37D7 E  MSD0               381C    MSD1               3844
MSDA               3858    MSDAL              0005 E  MSYDD              52BE R
NAME               4357 R  NAME1              4362 R  NL                 000A E
NMIFL              3CF7 R  NREDY              4F59 R  NREDY1             4F5C R
NUL                0000 E  NUL2               0000 E  NULL               0080 E
OP.CTL             00F0 E  OP.DIG             00F0 E  OP.SEG             00F1 E
OP2.CTL            00F2 E  OPENC              416A ER OPENC1             4171 R
OPENC2             419A R  OPENC3             41AE R  OPENC4             41B7 R
OPENC5             41C7 R  OPENC9             41ED R  OPENCA             41B6 ER
OPENCB             41F0 R  OPENEX             40A6 R  OPENHL             40A8 ER
OPENR              4075 ER OPENR1             40AB R  OPENR2             40CD R
OPENU              4131 ER OPENU1             4138 R  OPENW              40D0 ER
OPENW1             40D7 R  OPENW2             4106 R  OPENW2A            4122 R
OPENW3             412E R  OPENX              4079 R  OPENX1             4096 R
OPENX2             4099 R  OPT.H19            0010 E  OPT.TTY            0000 E
PATCH              3C4E E  PBO.DAT            0001 E  PBO.MNT            0002 E
PDI                1B65 E  PGT                4F6D ER PGT10.             5041 R
PGT11.             5048 R  PGT12.             5055 R  PGT3               4FA4 R
PGT4               4FCF R  PGT5               4FE2 R  PGT6               4FFE R
PGT7               500C R  PGT8               5015 R  PGT9               501D R
PGTA               0003 E  PGTB               5039 ER PGTC               505B R
PGTD               505D R  PGTE               505F R  PGTERR             503C R
PGTERR.            503F R  PGTF               5060 R  PGTG               5061 R
PIC.COD            0006    PIC.ID             0000    PIC.LEN            0002
PIC.PTR            0004    POSIT              4259 ER POSIT2             4274 R
POSIT3             4285 R  QUOTE              0027 E  RBD                3098 E
RBF                5063 R  RDD                3240 E  RDD0               3254
RDDA               32AD    RDDB               32AF    RDDC               32B1
RDDD               32B3    RDDE               32B5    RDL                5071 ER
RDL1               50B1 R  READ               3F17 R  READY              50B3 R
READY1             50B6 R  REL                1B7F E  REL.               1B7D E
RENAME             42DA ER RENAME1            42FD R  RESET              45BB ER
RESET1             45D1 ER RESN2A             4657 R  RESN2B             465A R
RESNMS             4639 ER REV                0000 E  RGTADR             52CB R
ROMBUF             2380 E  RRH                3105 E  RRH1               310A
RRH1.5             3115    RRH2               3116 E  RRH3               312B
RRH4               3146    RRH5               3162    RRH6               315A
RST0               3C8E R  RST1               3C96 R  RST2               3C9E R
RST3               3CA6 R  RST4               3CAE R  RST5               3CB6 R
RST6               3CBE R  RST7               3CC6 R  RSY                321F E
RTB                443D R  RTT                3211 E  RUBOUT             007F E
RVD                50C7 ER S.BATCH            0008 E  S.BAUD             20E4
S.BDA              2150    S.BITS             0062    S.BOOTF            211C
S.BREAK            0020 E  S.CAADR            20DB    S.CACC             2106
S.CCTAB            20DD    S.CDB              20E3    S.CFWA             20EA
S.CLKTR            20CD    S.CODE             2107    S.CONFL            20DA
S.CONTY            20D7    S.CONWI            20D9    S.COUNT            0060
S.CSLMD            20D6    S.CUSOR            20D8    S.CVEC             0070
S.CVECL            000F E  S.DATC             20C8    S.DATE             20BF
S.DDDTA            20F6    S.DDGRP            20F4    S.DDLDA            20F0
S.DDLEN            20F2    S.DDOPC            20F8    S.DFBLK            006A
S.DFWA             20EC    S.DIREA            210E    S.DLINK            20E6
S.DLY              002B    S.ECHO             0004 E  S.EDLIN            005E
S.EXITA            2040    S.EXITC            0010 E  S.FASER            210B
S.FCI              2111    S.FLAG             007F    S.FMASK            0005
S.GUP              2117    S.HIMEM            20CE    S.INIT             0080 E
S.INT              20E3    S.JUMPS            2108    S.LABEL            0003
S.LWA              0006    S.MOUNT            211A    S.OSI              2156
S.OSO              2157    S.OSZ              2158    S.PATH             005A
S.PRMT             005C    S.READ             19BD E  S.REV              000B
S.RFWA             20EE    S.SCI              2114    S.SCR              2151
S.SDD              2108    S.SHIFT            0061    S.SOVR             2176
S.SYSCM            0001 E  S.SYSM             20D0    S.TABUF            0040 E
S.TFWA             20E8    S.TIME             20CA    S.USRM             20D2
S.VAL              20BF    S.VFLG             0002 E  S.WRITE            19D8 E
SB.BAU             2285    SB.BOO             2280    SB.BPE             22A0 E
SB.DAT             2287    SB.DRV             22A0    SB.FLG             2284
SB.ORG             3000 E  SB.SDB             2480 E  SB.VER             2283
SBD                3074 E  SBDA               3093    SBDB               3094
SBDC               3096    SBDD               3097    SCI                48F1 R
SCSLDAT            52BB R  SCTLC              405F ER SDD                4905 R
SDD1               4914 R  SDT                3566 E  SDT0               35AC E
SDT0.5             359E    SDT1               35B5    SDT2               35C7
SDT2.5             35F5    SDT3               3608    SDT4               3609
SDTA               2C00 E  SDTB               3612    SDTBL              0009 E
SDTC               361B    SDTD               361C    SDTE               3605
SETTOP             4324 ER SFM                32B7 E  SFM1               32C1
SFM2               32D2    SFM9               32E4    SFM9.5             32E8
SGT                50E1 R  SLABEL             3C91 R  SLR                316F E
SLRA               31B0 E  SLRAL              0008 E  SLRB               31B8 E
SLRBL              0012 E  SLRC               31CA E  SLRCL              0015 E
SPG                52CD R  SSD                3897 E  SSD0               38A5
SSD1               38C8    SSD1.5             38DD    SSD1.7             38E2
SSD2               38E5    SSD3               3904    SSD4               390C
SSD5               3929    SSD6               392F    SSD7               3960
SSD8               3961    SSDA               396B    SSDB               2B80 E
STACK              2280 E  STACKL             010A E  STB                4918 R
SUBBUF             0058    SUNIT              52BD R  SYDD               2058 E
SYFWA              323E    SYS0               3D2C R  SYS1               3D3E R
SYS3               3D46 R  SYS6               3D5E R  SYS6A              3D7A R
SYS7               3D8C R  SYS8               3D91 R  SYS9               3D94 R
SYSCAL             3D0E ER SYSCALA            3DA0 ER SYSCALB            3DB8 ER
SYSCALC            3DDE ER SYSCALL            00FF E  SYSLAB             2E00 E
SYSLWA             3C94 R  SYSMODE            52B9 R  TAB                0009 E
TFE                1B9B E  THRUHL             489A R  TRIBUTE            52D1 R
TRUE               0001 E  TTFWA              321D    UAD                5112 ER
UAD.               5106 ER UBP                396C E  UBP1               39C5
UBPA               39D4    UBPAL              001D E  UDDPAD             3C29 E
UDDX1              3C06    UDDX1.5            3C20    UDDX2              3C22
UDDX3              3C23    UDE                5142 R  UDE1               5156 R
UDS                5163 R  UNIT               52C6 R  UNT.DIS            0006
UNT.FLG            0000    UNT.GRT            0002    UNT.GTS            0004
UNT.SIZ            0008 E  UNT.SPG            0001    UNTTAB             52CE R
UNUM               5174 R  UO.CLK             0001 E  UO.DDU             0002 E
UO.HLT             0080 E  UO.NFR             0040 E  USERFWA            2280 E
VERS               0030 E  VERSN              3F4B R  VFL.80T            0002 E
VFL.DTD            0002 E  VFL.FIX            0004 E  VFL.NSD            0001 E
VOLUME             52D0 R  WDO                517B R  WRITE              3F30 R
XCHGBC             5234 R
