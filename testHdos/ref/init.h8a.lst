0000                    	TITLE	'INIT - INITIALIZE DISK'
                        ***	INITIALIZE - INITIALIZE DISK.
                        *
                        *	J.G. LETWIN, 10/77
                        *
                        *	COPYRIGHT 10/77, HEATH CO.
                        *	COPYRIGHT 79/04, HEATH CO.
                        *
                        *	G. Chandler,	78/10		Maintenence release
                        *			79/04		Renamed INIT from INIT17 for H89
                        *					compatibility reasons.
                        *			80/05	/2.0b/	Arbitrary Mass Storage
                        *	B. Parrott,	85/02	/3.0a/	Adapted for HDOS 3.0
                        *
                        *
                        *	Modified to fix minor bug with parameter files.  If the length	/2.1b/
                        *	was within PIC.COD bytes of the end of the sectors  allocated,
                        *	FDP would attempt to read too many bytes.  This problem  never
                        *	occured for our users, however, because  all  of  our  drivers
                        *	worked.
                        *

      = 0000            FALSE	EQU	0
      = 0001            TRUE	EQU	!FALSE

      = 0001            DEBUG	EQU	TRUE
      = 0001            VOLZERO EQU	TRUE			; allow initializing volume 0	
0000                    	SPACE	4,10
                        ***	INITIALIZE INITIALIZES A NEW DISK VOLUME.
                        *
                        *	ACTIONS TAKEN:
                        *
                        *	1) REQUEST MEDIA INSERTION
                        *	2) CHECK FOR PROPER HOLE PATTERN
                        *	3) READ LABEL AND TYPE INFORMATION
                        *	4) ASK FOR # OF TRACKS
                        *	5) ASK FOR DISK SERIAL NUMBER AND LABEL
                        *	6) ZERO AND INITIALIZE TRACKS
                        *	7) ASK FOR LIST OF BAD SECTORS
                        *	8) FORMAT DEVICE
                        *	9) PROMPT RESTORATION OF SYSTEM DEVICE

      = 00C3            MI.JMP	EQU	303Q

      = 0001            CN.FDP	EQU	1			; Parameter File Channel

      = 0004            DVT.MAX EQU	4			; Maximum of 4 Device Entries
0000                    	STL	'Definitions'
0000                    	EJECT
0000                    	XTEXT	MTR
0000                    MTR	SPACE	4,10
                        **	MTR - PAM/8 EQUIVALENCES.
                        *
                        *	THIS DECK CONTAINS SYMBOLIC DEFINITIONS USED TO
                        *	MAKE USE OF THE PAM/8 CODE.
0000                    	SPACE	3,10
                        **	IO PORTS

      = 00F0            IP.PAD	EQU	360Q			; PAD INPUT PORT
      = 00F0            OP.CTL	EQU	360Q			; CONTROL OUTPUT PORT
      = 00F0            OP.DIG	EQU	360Q			; DIGIT SELECT OUTPUT PORT
      = 00F1            OP.SEG	EQU	361Q			; SEGMENT SELECT OUTPUT PORT
      = 00F2            IP.CON	EQU	362Q			; H-88/H-89/HA-8-8 Configuration
      = 00F2            OP2.CTL EQU	362Q			; H-88/H-89/HA-8-8 Control Port
0000                    	SPACE	3,10
                        **	MONITOR IDENTIFICATION FLAGS
                        *
                        *	THESE BYTES IDENTIFY THE ROM MONITOR.
                        *	THEY ARE THE VARIOUS VALUES OF LOCATION .IDENT

      = 0011            M.PAM8	EQU	021Q			; 'LXI' INSTRUCTION AT 0 IN PAM-8
      = 00C3            M.FOX	EQU	303Q			; 'JMP' INSTRUCTION AT 0 IN FOX ROM
0000                    	SPACE	4,10
                        **	Configuration Flags
                        *
                        *	These bits are read in IP.CON.
                        *

      = 0003            CN.174M EQU	00000011B		; Port 174Q Device-Type Mask
      = 000C            CN.170M EQU	00001100B		; Port 170Q Device-Type Mask
      = 0010            CN.PRI	EQU	00010000B		; Primary/Secondary:  1=>primary == 170Q
      = 0020            CN.MEM	EQU	00100000B		; Memory Test/Normal Switch:  0=>Test; 1=>Normal
      = 0040            CN.BAU	EQU	01000000B		; Baud Rate:  0=>9600; 1=>19,200
      = 0080            CN.ABO	EQU	10000000B		; Auto-Boot:  1=>Auto-Boot

      = 0000            CND.H17 EQU	00B			; H-17 Disk, Valid only in CN.174M
      = 0000            CND.NDI EQU	00B			; No Device Installed
      = 0001            CND.H47 EQU	01B			; H-47 Disk
0000                    	SPACE	4,10
                        **	ROUTINE ENTRY POINTS.
                        *

      = 002B            .DLY	EQU	000053A 		; DELAY

                        *	All following entry points are unavailable under HDOS 3.0

                        *.IDENT EQU	000000A 		; IDENTIFICATION LOCATION
                        *.LOAD	EQU	001267A 		; TAPE LOAD
                        *.DUMP	EQU	001374A 		; TAPE DUMP
                        *.ALARM	EQU	002136A 		; ALARM ROUTINE
                        *.HORN	EQU	002140A 		; HORN
                        *.CTC	EQU	002172A 		; CHECK TAPE CHECKSUM
                        *.TPERR	EQU	002205A 		; TAPE ERROR ROUTINE
                        *.PCHL	EQU	002264A 		; PCHL INSTRUCTION
                        *.SRS	EQU	002265A 		; SCAN RECORD START
                        *.RNP	EQU	002325A 		; READ NEXT PAIR
                        *.RNB	EQU	002331A 		; READ NEXT BYTE
                        *.CRC	EQU	002347A 		; CRC-16 CALCULATOR
                        *.WNP	EQU	003017A 		; WRITE NEXT PAIR
                        *.WNB	EQU	003024A 		; WRITE NEXT BYTE
                        *.DOD	EQU	003122A 		; DECODE FOR OCTAL DISPLAY
                        *.RCK	EQU	003260A 		; READ CONSOLE KEYSET
                        *.DODA	EQU	003356A 		; SEGMENT CODE TABLE
0000                    	XTEXT	MTRRAM
0000                    MTRRAM	SPACE	4,10
                        **	MTR - PAM/8 EQUIVALENCES.
                        *
                        *	THIS DECK CONTAINS SYMBOLIC DEFINITIONS USED TO
                        *	MAKE USE OF THE PAM-8 CONTROL BYTES.
0000                    	SPACE	3,10
                        **	FRONT PANEL CONTROL BITS.
                        *
                        *	CB.*  set in OP.CTL
                        *	CB2.* set in OP2.CTL
                        *

      = 0010            CB.SSI	EQU	00010000B		; SINGLE STEP INTERRUPT
      = 0020            CB.MTL	EQU	00100000B		; MONITOR LIGHT
      = 0040            CB.CLI	EQU	01000000B		; CLOCK INTERRUPT ENABLE
      = 0080            CB.SPK	EQU	10000000B		; SPEAKER ENABLE

      = 0001            CB2.SSI EQU	00000001B		; Single Step Interrupt
      = 0002            CB2.CLI EQU	00000010B		; Clock Interrupt Enable
      = 0020            CB2.ORG EQU	00100000B		; ORG 0 Select
      = 0040            CB2.SID EQU	01000000B		; Side 1 Select
0000                    	SPACE	3,10
                        **	Secondary Control Bits
                        *

                        **	MONITOR MODE FLAGS.

      = 0000            DM.MR	EQU	0			; MEMORY READ
      = 0001            DM.MW	EQU	1			; MEMORY WRITE
      = 0002            DM.RR	EQU	2			; REGISTER READ
      = 0003            DM.RW	EQU	3			; REGISTER WRITE
0000                    	SPACE	3,10
                        **	USER OPTION BITS.
                        *
                        *	THESE BITS ARE SET IN CELL .MFLAG.

      = 0080            UO.HLT	EQU	10000000B		; DISABLE HALT PROCESSING
      = 0040            UO.NFR	EQU	CB.CLI			; NO REFRESH OF FRONT PANEL
      = 0002            UO.DDU	EQU	00000010B		; DISABLE DISPLAY UPDATE
      = 0001            UO.CLK	EQU	00000001B		; ALLOW PRIVATE INTERRUPT PROCESSING
0000                    	SPACE	3,10
                        **	RAM CELLS USED BY H8MTR.
                        *

      = 2000            .START	EQU	040000A 		; START DUMP ADDRESS
      = 2002            .IOWRK	EQU	040002A 		; IN OR OUT INSTRUCTION
      = 2005            .REGI	EQU	040005A 		; DISPLAYED REGISTER INDEX
      = 2006            .DSPROT EQU	040006A 		; PERIOD FLAG BYTE
      = 2007            .DSPMOD EQU	040007A 		; DISPLAY MODE
      = 2008            .MFLAG	EQU	040010A 		; USER OPTION BYTE
      = 2009            .CTLFLG EQU	040011A 		; PANEL CONTROL BYTE
      = 200B            .ALEDS	EQU	040013A 		; ABUSS LEDS
      = 2011            .DLEDS	EQU	040021A 		; DBUSS LEDS
      = 2014            .ABUSS	EQU	040024A 		; ABUSS REGISTER
      = 2017            .CRCSUM EQU	040027A 		; CRCSUM WORD
      = 2019            .TPERRX EQU	040031A 		; TAPE ERROR EXIT VECTOR
      = 201B            .TICCNT EQU	040033A 		; CLOCK TICK COUNTER
      = 201D            .REGPTR EQU	040035A 		; REGISTER POINTER
      = 201F            .UIVEC	EQU	040037A 		; USER INTERRUPT VECTORS
      = 2034            .NMIRET EQU	040064A 		; H88/H89 NMI Return Address
      = 2036            .CTL2FL EQU	040066A 		; OP2.CTL Control Byte
0000                    	XTEXT	HOSBASE
0000                    	SPACE	4,10
                        **	HDOS BASE PAGE DEFINITION
                        *

0000                    	ORG	0

      = 0000            HOSBASE EQU	*

                        	ERRNZ	*-000000A
0000   (0003)           B.INT0	DS	3

0003   (0002)           S.LABEL DS	2			; address of label buffer

0005   (0001)           S.FMASK DS	1			; feature mask

      = 0003            F.CLK	EQU	00000011B		; system clock speed
      = 0000            F.2MHZ	EQU	00000000B		;  2 MHz
      = 0001            F.4MHZ	EQU	00000001B		;  4 MHz
      = 0002            F.6MHZ	EQU	00000010B		;  6 MHz

      = 000C            F.MACH	EQU	00001100B		; System type
      = 0000            F.H8	EQU	00000000B		;  H8
      = 0004            F.H89	EQU	00000100B		;  H89
      = 0008            F.Z100	EQU	00001000B		;  Z-100
      = 000C            F.OMACH EQU	00001100B		;  PC, ETC.

      = 0030            F.TERM	EQU	00110000B		; Terminal type
      = 0000            F.TTY	EQU	00000000B		;  Dumb TTY
      = 0010            F.H19	EQU	00010000B		;  H19

      = 00C0            F.CPU	EQU	11000000B		; CPU type
      = 0000            F.8080	EQU	00000000B		;  8080
      = 0040            F.8085	EQU	01000000B		;  8085
      = 0080            F.Z80	EQU	10000000B		;  Z-80
      = 00C0            F.OCPU	EQU	11000000B		;  HD64180, V20, ETC.

0006   (0002)           S.LWA	DS	2			; lwa of HDOS

                        	ERRNZ	*-000010A
0008   (0003)           B.INT1	DS	3			; clock interrupt

000B   (0005)           S.REV	DS	5			; rev, date, time of HDOS

                        	ERRNZ	*-000020A
0010   (0003)           B.INT2	DS	3			; available

0013   (0005)           	DS	5

                        	ERRNZ	*-000030A
0018   (0003)           B.INT3	DS	3			; available

001B   (0005)           	DS	5

                        	ERRNZ	*-000040A
0020   (0003)           B.INT4	DS	3			; available

0023   (0005)           	DS	5

                        	ERRNZ	*-000050A
0028   (0003)           B.INT5	DS	3			; available

                        	ERRNZ	*-000053A		; same as .DLY
002B   (0003)           S.DLY	DS	3

002E   (0002)           	DS	2

                        	ERRNZ	*-000060A
0030   (0003)           B.INT6	DS	3			; available

0033   (0005)           	DS	5

                        	ERRNZ	*-000070A
0038   (0003)           B.INT7	DS	3			; SCALL interrupt

003B   (0003)           B.SCALL DS	3			; JMP directly to SCALL processor

003E   (0002)           CSLIBUF DS	2			; FWA of console type-ahead buffer

0040   (0011)           BATNAME DS	17			; complete batch file name
0051   (0001)           BATSEC	DS	1			; current sector index in batch file
0052   (0002)           BATGNS	DS	2			; batch file group numbers

0054   (0002)           BATBUF	DS	2			; address of batch buffer
0056   (0002)           BATPTR	DS	2			; address of next char. in BATBUF

0058   (0002)           SUBBUF	DS	2			; address of substitution buffer

005A   (0002)           S.PATH	DS	2			; address of path buffer
005C   (0002)           S.PRMT	DS	2			; address of prompt buffer
005E   (0002)           S.EDLIN DS	2			; adderss of line buffer

0060   (0001)           S.COUNT DS	1			; counter
0061   (0001)           S.SHIFT DS	1			; shift count
0062   (0001)           S.BITS	DS	1			; bit flags

0063   (0003)           	DS	3

                        	ERRNZ	*-66H
0066   (0003)           B.NMI	DS	3			; NMI handler vector
0069   (0001)           B.NMIFL DS	1			; NMI flag (0=no NMI's occured)

006A   (0006)           S.DFBLK DS	6			; system wide default block

0070   (000F)           S.CVEC	DS	5*3			; console SCALL vectors

007F   (0001)           S.FLAG	DS	1			; system flags

      = 0001            S.SYSCM equ	00000001b		; SYSCMD.SYS in memory
      = 0002            S.VFLG	equ	00000010b		; Verify is on
      = 0004            S.ECHO	equ	00000100b		; Echo is off
      = 0008            S.BATCH equ	00001000b		; Batch is active
      = 0010            S.EXITC equ	00010000b		; SYSCMD prints exit code
      = 0020            S.BREAK equ	00100000b		; used by PIP
      = 0040            S.TABUF equ	01000000b		; type-ahead is stuffed
      = 0080            S.INIT	equ	10000000b		; set 1st time SYSCMD.SYS runs

                        	ERRNZ	*-80H			; MAKE SURE GOT EM' ALL
      = 0080            B.END	EQU	*
0080                    	XTEXT	BOODEF
0080                    	SPACE	4,10
                        **	BOODEF - SPECIAL BOOT-HDOS INTERFACE DEFINTIONS.

      = 3000            SB.ORG	EQU	060000A 		; ORG FOR LOAD OF INITIAL HDOS	/3.0a/

2280                    	ORG	042200A

2280   (0003)           SB.BOO	DS	3			; Jump to Boot routine
2283   (0001)           SB.VER	DS	1			; Version of INIT that built disk
2284   (0001)           SB.FLG	DS	1			; Boot Flags
      = 0001            BFLG.A	EQU	00000001B		; Auto-Boot:  1 => Boot
2285   (0002)           SB.BAU	DS	2			; Baud Rate Divisor (0=>ignore)
2287   (0002)           SB.DAT	DS	2			; Default Date
                        	ERRMI	SB.BOO+32-*
2289   (0017)           	DS	SB.BOO+32-*		; Reserved
      = 22A0            SB.BPE	EQU	*			; End of BOOT-parameters

22A0   (01E0)           SB.DRV	DS	SB.BOO+512-*		; Primary Boot

      = 2480            SB.SDB	EQU	*			; Secondary Boot
2480                    	XTEXT	ECDEF
2480                    	SPACE	4,10
                        **	ERROR CODE DEFINITIONS.

0000                    	ORG	0

0000   (0001)           	DS	1		; NO ERROR #0
0001   (0001)           EC.EOF	DS	1		; END OF FILE
0002   (0001)           EC.EOM	DS	1		; END OF MEDIA
0003   (0001)           EC.ILC	DS	1		; ILLEGAL SCALL CODE
0004   (0001)           EC.CNA	DS	1		; CHANNEL NOT AVAILABLE
0005   (0001)           EC.DNS	DS	1		; DEVICE NOT SUITABLE
0006   (0001)           EC.IDN	DS	1		; ILLEGAL DEVICE NAME
0007   (0001)           EC.IFN	DS	1		; ILLEGAL FILE NAME
0008   (0001)           EC.NRD	DS	1		; NO ROOM FOR DEVICE DRIVER
0009   (0001)           EC.FNO	DS	1		; CHANNEL NOT OPEN
000A   (0001)           EC.ILR	DS	1		; ILLEGAL REQUEST
000B   (0001)           EC.FUC	DS	1		; FILE USAGE CONFLICT
000C   (0001)           EC.FNF	DS	1		; FILE NAME NOT FOUND
000D   (0001)           EC.UND	DS	1		; UNKNOWN DEVICE
000E   (0001)           EC.ICN	DS	1		; ILLEGAL CHANNEL NUMBER
000F   (0001)           EC.DIF	DS	1		; DIRECTORY FULL
0010   (0001)           EC.IFC	DS	1		; ILLEGAL FILE CONTENTS
0011   (0001)           EC.NEM	DS	1		; NOT ENOUGH MEMORY
0012   (0001)           EC.RF	DS	1		; READ FAILURE
0013   (0001)           EC.WF	DS	1		; WRITE FAILURE
0014   (0001)           EC.WPV	DS	1		; WRITE PROTECTION VIOLATION
0015   (0001)           EC.WP	DS	1		; DISK WRITE PROTECTED
0016   (0001)           EC.FAP	DS	1		; FILE ALREADY PRESENT
0017   (0001)           EC.DDA	DS	1		; DEVICE DRIVER ABORT
0018   (0001)           EC.FL	DS	1		; FILE LOCKED
0019   (0001)           EC.FAO	DS	1		; FILE ALREADY OPEN
001A   (0001)           EC.IS	DS	1		; ILLEGAL SWITCH
001B   (0001)           EC.UUN	DS	1		; UNKNOWN UNIT NUMBER
001C   (0001)           EC.FNR	DS	1		; FILE NAME REQUIRED
001D   (0001)           EC.DIW	DS	1		; DEVICE IS NOT WRITABLE (OR WRITE LOCKED)
001E   (0001)           EC.UNA	DS	1		; UNIT NOT AVAILABLE
001F   (0001)           EC.ILV	DS	1		; ILLEGAL VALUE
0020   (0001)           EC.ILO	DS	1		; ILLEGAL OPTION
0021   (0001)           EC.VPM	DS	1		; VOLUME PRESENTLY MOUNTED ON DEVICE
0022   (0001)           EC.NVM	DS	1		; NO VOLUME PRESENTLY MOUNTED
0023   (0001)           EC.FOD	DS	1		; FILE OPEN ON DEVICE
0024   (0001)           EC.NPM	DS	1		; NO PROVISIONS MADE FOR REMOUNTING MORE DISKS
0025   (0001)           EC.DNI	DS	1		; DISK NOT INITIALIZED
0026   (0001)           EC.DNR	DS	1		; DISK IS NOT READABLE
0027   (0001)           EC.DSC	DS	1		; DISK STRUCTURE IS CORRUPT
0028   (0001)           EC.NCV	DS	1		; NOT CORRECT VERSION OF HDOS
0029   (0001)           EC.NOS	DS	1		; NO OPERATING SYSTEM MOUNTED
002A   (0001)           EC.IOI	DS	1		; ILLEGAL OVERLAY INDEX
002B   (0001)           EC.OTL	DS	1		; OVERLAY TOO LARGE
002C   (0001)           EC.LAD	DS	1		; File is locked against delete 	/3.0a/
002D   (0001)           EC.FIX	DS	1		; Device media is fixed 		/3.0a/
002E   (0001)           EC.ILA	DS	1		; Illegal Load Address			/3.0a/
002F   (0001)           EC.DNL	DS	1		; Device Not Loaded			/3.0a/
0030   (0001)           EC.DNP	DS	1		; Device Not Locked in Memory		/3.0a/
0031   (0001)           EC.DFM	DS	1		; Device is Fixed in Memory		/3.0a/
0032   (0001)           EC.IDF	DS	1		; Illegal Date Format			/3.0a/
0033   (0001)           EC.ITS	DS	1		; Illegal Time Format			/3.0a/
0034   (0001)           EC.CNR	DS	1		; System Clock Not Resident		/3.0a/
0035   (0001)           EC.SDR	DS	1		; System Disk is Reset			/3.0a/
0036   (0001)           EC.LBO	DS	1		; Line Buffer Overflow			/3.0a/
0037   (0001)           EC.CUI	DS	1		; Can't Unlink from Interrupt Vector	/3.0a/
0038                    	XTEXT	U8251
0038                    U8251	SPACE	4,10
                        ***	8251 USART BIT DEFINITIONS.
                        *

                        **	PORT ADDRESSES

      = 0000            UDR	EQU	0			; DATA REGISTER IS EVEN
      = 0001            USR	EQU	1			; STATUS REGISTER IS NEXT

      = 00FA            SC.UART EQU	372Q			; CONSOLE USART ADDRESS (IFF 8251)


                        **	MODE INSTRUCTION CONTROL BITS.

      = 0040            UMI.1B	EQU	01000000B		; 1 STOP BIT
      = 0080            UMI.HB	EQU	10000000B		; 1 1/2 STOP BITS
      = 00C0            UMI.2B	EQU	11000000B		; 2 STOP BITS
      = 0020            UMI.PE	EQU	00100000B		; EVEN PARITY
      = 0010            UMI.PA	EQU	00010000B		; USE PARITY
      = 0000            UMI.L5	EQU	00000000B		; 5 BIT CHARACTERS
      = 0004            UMI.L6	EQU	00000100B		; 6 BIT CHARACTERS
      = 0008            UMI.L7	EQU	00001000B		; 7 BIT CHARACTERS
      = 000C            UMI.L8	EQU	00001100B		; 8 BIT CHARACTERS
      = 0001            UMI.1X	EQU	00000001B		; CLOCK X 1
      = 0002            UMI.16X EQU	00000010B		; CLOCK X 16
      = 0003            UMI.64X EQU	00000011B		; CLOCK X 64

                        **	COMMAND INSTRUCTION BITS.

      = 0040            UCI.IR	EQU	01000000B		; INTERNAL RESET
      = 0020            UCI.RO	EQU	00100000B		; READER-ON CONTROL FLAG
      = 0010            UCI.ER	EQU	00010000B		; ERROR RESET
      = 0004            UCI.RE	EQU	00000100B		; RECEIVE ENABLE
      = 0002            UCI.IE	EQU	00000010B		; ENABLE INTERRUPTS FLAG
      = 0001            UCI.TE	EQU	00000001B		; TRANSMIT ENABLE

                        **	STATUS READ COMMAND BITS.

      = 0040            USR.BD	EQU	01000000B		; Break Detect
      = 0020            USR.FE	EQU	00100000B		; FRAMING ERROR
      = 0010            USR.OE	EQU	00010000B		; OVERRUN ERROR
      = 0008            USR.PE	EQU	00001000B		; PARITY ERROR
      = 0004            USR.TXE EQU	00000100B		; TRANSMITTER EMPTY
      = 0002            USR.RXR EQU	00000010B		; RECEIVER READY
      = 0001            USR.TXR EQU	00000001B		; TRANSMITTER READY
0038                    	XTEXT	U8250
0038                    U8250	SPACE	4,10
                        ***	8250 ACE CONTROL AND BIT DEFINITIONS.
                        *

      = 00E8            SC.ACE	EQU	350Q			; SYSTEM CONSOLE PORT IF 8250 ACE
      = 006E            AC.DLY	EQU	110			; 220 MIL. SEC. DELAY FOR 8250

      = 0000            UR.RBR	EQU	0			; RECEIVER BUFFER REGISTER

      = 0000            UR.THR	EQU	0			; TRANSMITTER HOLDING REGISTER

      = 0000            UR.DLL	EQU	0			; DIVISOR LATCH (LEAST SIGNIFICANT)

      = 0001            UR.DLM	EQU	1			; DIVISOR LATCH (MOST SIGNIFICANT)

      = 0001            UR.IER	EQU	1			; INTERRUPT ENABLE REGISTER
      = 0001            UC.EDA	EQU	00000001B		;  ENABLE RECEIVED DATA AVAILABLE INTERRUPT
      = 0002            UC.TRE	EQU	00000010B		;  ENABLE TRANSMIT HOLD REGISTER EMPTY INTERRUPT
      = 0004            UC.RSI	EQU	00000100B		;  ENABLE RECEIVE STATUS INTERRUPT
      = 0008            UC.MSI	EQU	00001000B		;  ENABLE MODEM STATUS INTERRUPT

      = 0002            UR.IIR	EQU	2			; INTERRUPT IDENTIFICATION REGISTER
      = 0001            UC.IIP	EQU	00000001B		;  INVERTED INTERRUPT PENDING (0 MEANS PENDING)
      = 0006            UC.IID	EQU	00000110B		;  INTERRUPT ID

      = 0003            UR.LCR	EQU	3			; LINE CONTROL REGISTER
      = 0000            UC.5BW	EQU	00000000B		;  5 BIT WORDS
      = 0001            UC.6BW	EQU	00000001B		;  6 BIT WORDS
      = 0002            UC.7BW	EQU	00000010B		;  7 BIT WORDS
      = 0003            UC.8BW	EQU	00000011B		;  8 BIT WORDS
      = 0004            UC.2SB	EQU	00000100B		;  TWO STOP BITS SELECTED
      = 0008            UC.PEN	EQU	00001000B		;  PARITY COMPUTATION ENABLED
      = 0010            UC.EPS	EQU	00010000B		;  EVEN PARITY SELECT
      = 0020            UC.SKP	EQU	00100000B		;  STICK PARITY
      = 0040            UC.SB	EQU	01000000B		;  SET BREAK
      = 0080            UC.DLA	EQU	10000000B		;  DIVISOR LATCH ACCESS

      = 0004            UR.MCR	EQU	4			; MODEM CONTROL REGISTER
      = 0001            UC.DTR	EQU	00000001B		;  DATA TERMINAL READY
      = 0002            UC.RTS	EQU	00000010B		;  REQUEST TO SEND
      = 0004            UC.OU1	EQU	00000100B		;  OUT 1
      = 0008            UC.OU2	EQU	00001000B		;  OUT 2
      = 0010            UC.LOO	EQU	00010000B		;  LOOP

      = 0005            UR.LSR	EQU	5			; LINE STATUS REGISTER
      = 0001            UC.DR	EQU	00000001B		;  DATA READY
      = 0002            UC.OR	EQU	00000010B		;  OVERRUN
      = 0004            UC.PE	EQU	00000100B		;  PARITY ERROR
      = 0008            UC.FE	EQU	00001000B		;  FRAMING ERROR
      = 0010            UC.BI	EQU	00010000B		;  BREAK INTERRUPT
      = 0020            UC.THE	EQU	00100000B		;  TRANSMITTER HOLDING REGISTER EMPTY
      = 0040            UC.TSE	EQU	01000000B		;  TRANSMITTER SHIFT REGISTER EMPTY

      = 0006            UR.MSR	EQU	6			; MODEM STATUS REGISTER
      = 0001            UC.DCS	EQU	00000001B		;  DELTA CLEAR TO SEND
      = 0002            UC.DDR	EQU	00000010B		;  DELTA DATA SET READY
      = 0004            UC.TER	EQU	00000100B		;  TRAILING EDGE OF RING
      = 0008            UC.DRL	EQU	00001000B		;  DELTA RECEIVE LINE SIGNAL DETECT
      = 0010            UC.CTS	EQU	00010000B		;  CLEAR TO SEND
      = 0020            UC.DSR	EQU	00100000B		;  DATA SET READY
      = 0040            UC.RI	EQU	01000000B		;  RING INDICATOR
      = 0080            UC.RLS	EQU	10000000B		;  RECEIVED LINE SIGNAL DETECT
0038                    	XTEXT	DDDEF
0038                    	SPACE	3,10
                        **	DEVICE DRIVER COMMUNICATION FLAGS.
                        *

0000                    	ORG	0

0000   (0001)           DC.REA	DS	1			; READ
0001   (0001)           DC.WRI	DS	1			; WRITE
0002   (0001)           DC.RER	DS	1			; READ REGARDLESS
0003   (0001)           DC.OPR	DS	1			; OPEN FOR READ
0004   (0001)           DC.OPW	DS	1			; OPEN FOR WRITE
0005   (0001)           DC.OPU	DS	1			; OPEN FOR UPDATE
0006   (0001)           DC.CLO	DS	1			; CLOSE
0007   (0001)           DC.ABT	DS	1			; ABORT
0008   (0001)           DC.MOU	DS	1			; MOUNT DEVICE
0009   (0001)           DC.LOD	DS	1			; LOAD DEVICE DRIVER
000A   (0001)           DC.RDY	DS	1			; Device Ready
000B   (0001)           DC.SET	DS	1			; Update SET parameters 	/3.0a/
000C   (0001)           DC.UNL	DS	1			; Unload device driver		/3.0a/
000D   (0001)           DC.INT	DS	1			; Interrupt			/3.0a/
000E   (0001)           DC.DSF	DS	1			; Device-specific function	/3.0a/
000F   (0001)           DC.MAX	DS	1			; MAXIMUM ENTRY INDEX
0010                    	XTEXT	FILDEF
0010                    	SPACE	4,10
                        **	FILDEF - FILE TYPE DEFINITIONS.
                        *
                        *	DB	377Q,FT.XXX

      = 0000            FT.ABS	EQU	0			; ABSOLUTE BINARY
      = 0001            FT.PIC	EQU	1			; POSITION INDEPENDANT CODE
      = 0002            FT.REL	EQU	2			; RELOCATABLE CODE
      = 0003            FT.BAC	EQU	3			; COMPILED BASIC CODE
0010                    	XTEXT	ABSDEF
0010                    ABSDEF	SPACE	3,10
                        **	ABS FORMAT EQUIVALENCES.

0000                    	ORG	0

0000   (0001)           ABS.ID	DS	1	;377Q = BINARY FILE FLAG
0001   (0001)           	DS	1	;FILE TYPE (FT.ABS)
0002   (0002)           ABS.LDA	DS	2	;LOAD ADDRESS
0004   (0002)           ABS.LEN	DS	2	;LENGTH OF ENTIRE RECORD
0006   (0002)           ABS.ENT	DS	2	;ENTRY POINT

0008   (0000)           ABS.COD	DS	0	;CODE STARTS HERE
0008                    	XTEXT	PICDEF
0008                    PICDEF	SPACE	3,10
                        **	PIC FORMAT EQUIVALENCES.

0000                    	ORG	0

0000   (0001)           PIC.ID	DS	1			; 377Q = BINARY FILE FLAG
0001   (0001)           	DS	1			; FILE TYPE (FT.PIC)
0002   (0002)           PIC.LEN DS	2			; LENGTH OF ENTIRE RECORD
0004   (0002)           PIC.PTR DS	2			; INDEX OF START OF PIC TABLE

0006   (0000)           PIC.COD DS	0			; CODE STARTS HERE
0006                    	XTEXT	DIRDEF
0006                    	SPACE	3,10
                        **	DIRECTORY ENTRY FORMAT.

0000                    	ORG	0

      = 00FF            DF.EMP	EQU	377Q			; ENTRY EMPTY
      = 00FE            DF.CLR	EQU	376Q			; ENTRY EMPTY, REMAINDER ALSO CLEAR

0000   (0008)           DIR.NAM DS	8			; NAME
0008   (0003)           DIR.EXT DS	3			; EXTENSION
      = 000B            DIRIDL	equ	*			; file identification length	/3.0a/

000B   (0001)           DIR.CTH DS	1			; creation time (BCD hours)	/3.0a/
000C   (0001)           DIR.CTM DS	1			; creation date (BCD minutes)	/3.0a/

000D   (0001)           DIR.NOA DS	1			; number of accesses		/3.0a/
000E   (0001)           DIR.FLG DS	1			; FLAGS
000F   (0001)           DIR.USR DS	1			; user area mask		/3.0a/
0010   (0001)           DIR.FGN DS	1			; FIRST GROUP NUMBER
0011   (0001)           DIR.LGN DS	1			; LAST GROUP NUMBER
0012   (0001)           DIR.LSI DS	1			; LAST SECTOR INDEX (IN LAST GROUP)
0013   (0002)           DIR.CRD DS	2			; CREATION DATE
0015   (0002)           DIR.ACD DS	2			; last access date		/3.0a/

      = 0017            DIRELEN EQU	*			; DIRECTORY ENTRY LENGTH
0017                    	XTEXT	DISDEF
0017                    DISDEF	SPACE	3,10
                        **	DIRECTORY BLOCK FORMAT.

0000                    	ORG	0

      = 0000            DIS.ENT EQU	*			; FIRST ENTRY ADDRESS

0000   (01FA)           	DS	22*DIRELEN		; 22 DIRECTORY ENTRYS PER BLOCK
01FA   (0001)           	DS	1			; 0 BYTE = END OF ENTRYS IN THIS BLOCK

01FB                    	ORG	512-5			; AT END OF BLOCK

01FB   (0001)           DIS.ENL DS	1			; LENGTH OF EACH ENTRY (=DIRELEN)
01FC   (0002)           DIS.SEC DS	2			; BLOCK # OF THIS BLOCK,
01FE   (0002)           DIS.LNK DS	2			; BLOCK # OF NEXT BLOCK, =0 IF LAST
0200                    	XTEXT	DEVDEF
0200                    	SPACE	4,10
                        ***	DEVICE TABLE ENTRYS.

0000                    	ORG	0

0000   (0002)           DEV.NAM DS	2			; DEVICE NAME
      = 0000            DV.EL	EQU	00000000B		; END OF DEVICE LIST FLAG
      = 0001            DV.NU	EQU	00000001B		; DEVICE ENTRY NOT IN USE

0002   (0001)           DEV.RES DS	1			; DRIVER RESIDENSE CODE
      = 0001            DR.IM	EQU	00000001B		; DRIVER IN MEMORY
      = 0002            DR.PR	EQU	00000010B		; DRIVER PERMANENTLY RESIDENT
      = 0004            DR.FX	equ	00000100b		; Driver FIXED in memory	/3.0a/
      = 0008            DR.UNL	equ	00001000b		; Driver unload pending 	/3.0a/
                        *	equ	00010000b		; Reserved			/3.0a/
      = 00E0            DR.SPL	equ	11100000b		; SET preamble size mask	/3.0a/

0003   (0001)           DEV.JMP DS	1			; JMP TO PROCESSOR
0004   (0002)           DEV.DDA DS	2			; DRIVER ADDRESS
0006   (0001)           DEV.FLG DS	1			; FLAG BYTE
      = 0001            DT.DD	EQU	00000001B		; DIRECTORY DEVICE
      = 0002            DT.CR	EQU	00000010B		; CAPABLE OF READ OPERATION
      = 0004            DT.CW	EQU	00000100B		; CAPABLE OF WRITE OPERATION
      = 0008            DT.RN	EQU	00001000B		; Capable of random access
      = 0010            DT.CH	EQU	00010000B		; Capable of Character mode
      = 0020            DT.FX	EQU	00100000B		; Fixed Media			/3.0a/
      = 0040            DT.P3	EQU	01000000B		; pre-3.0 media 		/3.0a/
      = 0080            DT.UL	EQU	10000000B		; requires unload notification	/3.0a/

0007   (0001)           DEV.MUM DS	1			; MOUNTED UNIT MASK
0008   (0001)           DEV.MNU DS	1			; MAXIMUM NUMBER OF UNITS
0009   (0002)           DEV.UNT DS	2			; ADDRESS OF UNIT SPECIFIC DATA TABLE

000B   (0002)           DEV.DVL DS	2			; DRIVER BYTE LENGTH
000D   (0001)           DEV.DVG DS	1			; DRIVER ROUTINE GROUP ADDRESS

      = 000E            DEVELEN EQU	*			; DEVICE TABLE ENTRY LENGTH
000E                    UNT.TAB	SPACE	4,10
                        **	UNIT SPECIFIC DEVICE DATA TABLE ENTRIES

0000                    	ORG	0

0000   (0001)           UNT.FLG DS	1			; UNIT SPECIFIC  *DEV.FLG*
0001   (0001)           UNT.SPG DS	1			; Sectors Per Group
0002   (0002)           UNT.GRT DS	2			; ADDRESS OF GRT (IF DT.DD)
0004   (0002)           UNT.GTS DS	2			; GRT SECTOR NUMBER
0006   (0002)           UNT.DIS DS	2			; DIRECTORY FIRST SECTOR NUMBER

      = 0008            UNT.SIZ EQU	*			; SIZE OF UNIT SPECIFIC DATA ENTRY
0008                    	XTEXT	DDFDEF
0008                    	SPACE	3,10
                        **	DIRECTORY DEVICE FORMAT DEFINITION.
                        *

0000                    	ORG	0

0000   (0009)           DDF.BOO DS	9			; 2K BOOT PROGRAM
      = 0009            DDF.BOL EQU	*			; LENGTH OF BOOT
0009   (0001)           DDF.LAB DS	1			; LABEL SECTOR
000A   (0000)           DDF.USR DS	0			; BEGINNING OF OPEN SPACE
000A                    	XTEXT	DVDDEF
000A                    	SPACE	4,10
                        **	DEVICE DRIVER EQUIVALENCES.

      = 00C7            DVDFLV	EQU	307Q			; DEVICE DRIVER FLAG VALUE

0006                    	ORG	PIC.COD 		; STARTS AT PIC CODE AREA

0006   (0001)           DVD.DVD DS	1			; MUST BE DVDFLV, IDENTIFIES AS DRIVER
0007   (0001)           DVD.CAP DS	1			; DEVICE CAPABILITY FLAG
0008   (0001)           DVD.MUM DS	1			; MOUNTED UNIT MASK
0009   (0001)           DVD.MNU DS	1			; MAXIMUM NUMBER OF UNITS
000A   (0008)           DVD.UFL DS	8			; UNIT CAPABILITY FLAGS FOR UNITS 0-7
0012   (0001)           DVD.SET DS	1			; = DVDFLV IFF DRIVER WILL TAKE SET OPTIONS
0013   (0002)           DVD.INP DS	2			; Pointer to Init Code
0015   (0001)           DVD.V30 DS	1			; = DVDFLV IFF HDOS 3.0 Driver	/3.0a/
0016   (0001)           DVD.SPL DS	1			; SET preamble size (pages/2)	/3.0a/
0017   (0014)           	DS	20			; RESERVED, MUST BE 0		/3.0a/
      = 002B            DVD.STE EQU	*			; ENTRY FOR 'SET' INVOCATION

      = 0200            DVD.ENT EQU	002000A 		; DRIVER ENTRY POINT (MULT OF 512)
002B                    	XTEXT	FBDEF
002B                    	SPACE	4,10
                        **	FILE BLOCK DEFINITIONS.

0000                    	ORG	0

0000   (0001)           FB.CHA	DS	1			; CHANNEL NUMBER
0001   (0001)           FB.FLG	DS	1			; FLAGS
0002   (0002)           FB.FWA	DS	2			; BUFFER FWA
0004   (0002)           FB.PTR	DS	2			; BUFFER POINTER
0006   (0002)           FB.LIM	DS	2			; LIMIT OF DATA IN BUFFER (READ)
0008   (0002)           FB.LWA	DS	2			; LWA OF BUFFER
000A   (0011)           FB.NAM	DS	4+8+4+1 		; NAME OF FILE
      = 0011            FB.NAML EQU	*-FB.NAM
      = 001B            FBENL	EQU	*			; ENTRY LENGTH
001B                    	XTEXT	IOCDEF
001B                    IOCDEF	SPACE	3,10
                        **	I/O CHANNEL DEFINITIONS.

0000                    	ORG	0

0000   (0002)           IOC.LNK DS	2			; ADDRESS OF NEXT CHANNEL, =0 IF LAST
0002   (0002)           IOC.DDA DS	2			; THREAD JUMP TO DEVICE DRIVER (VIA DEV TABLE)

0004   (0001)           IOC.FLG DS	1			; FILE TYPE FLAGS
      = 0001            FT.DD	EQU	00000001B		;  =1 IF DIRECTORY DEVICE
      = 0002            FT.OR	EQU	00000010B		;  =1 IF OPEN FOR READ
      = 0004            FT.OW	EQU	00000100B		;  =1 IF OPEN FOR WRITE
      = 0008            FT.OU	EQU	00001000B		;  =1 IF OPEN FOR UPDATE
      = 0010            FT.OC	EQU	00010000B		;  =1 IF OPEN FOR CHARACTER MODE
      = 0003            IOC.SQL EQU	*-IOC.DDA		; LENGTH OF INFO FOR SEQUENTIAL FILE

0005   (0002)           IOC.GRT DS	2			; ADDRESS OF GROUP RESERVATION TABLE
0007   (0001)           IOC.SPG DS	1			; SECTORS PER GROUP, THIS DEVICE
0008   (0001)           IOC.CGN DS	1			; CURRENT GROUP NUMBER
0009   (0001)           IOC.CSI DS	1			; CURRENT SECTOR INDEX (IN CURRENT GROUP)
000A   (0001)           IOC.LGN DS	1			; LAST GROUP NUMBER
000B   (0001)           IOC.LSI DS	1			; LAST SECTOR INDEX (IN LAST GROUP)
      = 0008            IOC.DRL EQU	*-IOC.FLG		; LENGTH OF INFO NORMALLY COPIED BACK TO
                        *					; THE CHANNEL TABLE
000C   (0002)           IOC.DTA DS	2			; DEVICE TABLE ADDRESS FOR THIS DEVICE
000E   (0002)           IOC.DES DS	2			; SECTOR NUMBER OF DIRECTORY ENTRY
0010   (0002)           IOC.DEV DS	2			; DEVICE CODE
0012   (0001)           IOC.UNI DS	1			; UNIT NUMBER (0-9)
      = 0011            IOC.DIL EQU	*-IOC.DDA		; LENGTH OF INFO FOR DIRECTORY FILE

0013   (0017)           IOC.DIR DS	DIRELEN 		; DIRECTORY ENTRY

      = 002A            IOCELEN EQU	*			; IOC ENTRY LENGTH

      = 0001            IOCCTD	EQU	1			; INDEX OF USER CHANNEL #0 IN CHANTAB (FIRST = 0)
002A                    	XTEXT	LABDEF
002A                    	SPACE	3,10
                        **	DISK LABEL SECTOR FORMATS.

0000                    	ORG	0

0000   (0001)           LAB.SER DS	1			; SERIAL NUMBER OF VOLUME
0001   (0002)           LAB.IND DS	2			; INITIALIZATION DATE
0003   (0002)           LAB.DIS DS	2			; SECTOR NUMBER OF 1ST DIRECTORY SECTOR
0005   (0002)           LAB.GRT DS	2			; INDEX OF GRT SECTOR
0007   (0001)           LAB.SPG DS	1			; SECTORS PER GROUP

      = 0000            LAB.DAT EQU	0			; DATA VOLUME ONLY
      = 0001            LAB.SYS EQU	1			; SYSTEM VOLUME
      = 0002            LAB.NOD EQU	2			; VOLUME HAS NO DIRECTORY

0008   (0001)           LAB.VLT DS	1			; VOLUME TYPE
0009   (0001)           LAB.VER DS	1			; VERSION OF INIT17 THAT INITED DISK

000A   (0002)           LAB.RGT DS	2			; RGT sector number

      = 000C            LAB.VPR EQU	*			; Volume dependant data
000C   (0002)           LAB.SIZ DS	2			;  Volume Size (Bytes/256)
000E   (0002)           LAB.PSS DS	2			;  Physical Sector Size
0010   (0001)           LAB.VFL DS	1			;  Volume dependant Flags
      = 0001            VFL.NSD EQU	00000001B		;   Number of Sides:  1 => 2
      = 0002            VFL.DTD EQU	00000010b		;   96 tracks per inch		/3.0a/
      = 0002            VFL.80T EQU	VFL.DTD 		;   (ditto)
      = 0004            VFL.FIX EQU	00000100b		;   Media is fixed		/3.0a/
      = 0005            LAB.VPL EQU	*-LAB.VPR		; Length of volume dependant data

                        	ERRMI	5-LAB.VPL
0011   (0000)           	DS	5-LAB.VPL		; Reserved

0011   (003C)           LAB.LAB DS	60			; LABEL
      = 003C            LAB.LBL EQU	*-LAB.LAB		; LABEL LENGTH
004D   (0002)           	DS	2			; Reserved for 0 bytes

      = 004F            LAB.AUX EQU	*			; Auxiliary Data
004F   (0001)           LAB.SPT DS	1			;  Sectors per Track
      = 0001            LAB.AXL EQU	*-LAB.AUX		; Length of Aux. Data

0050   (0002)           LAB.LVN DS	2			; Long volume number		/3.0a/
0052                    	XTEXT	MTRDEF
0052                    	SPACE	4,10
                        **	HDOS MONITOR PRIVATE RAM AREA DEFINITIONS.

0000                    	ORG	0

0000   (0001)           M.SYSM	DS	1			; SYSCALL ITTERATION COUNT
0001   (0001)           	DS	1			; STAND-ALONE FLAG (obsolete)	/3.0a/

0002   (0002)           M.CSL	DS	2			; Address of console data area	/3.0a/

0004   (0001)           M.SUNI	DS	1			; System Unit Number
0005   (0002)           M.SYDD	DS	2			; Address of Raw System Driver
0007                    	XTEXT	DIFDEF
0007                    DIFDEF	SPACE	4,10
                        **	DIRECTORY FILE FLAGS.

      = 0080            DIF.SYS EQU	10000000B		; System file
      = 0040            DIF.LOC EQU	01000000B		; Locked from flag changes
      = 0020            DIF.WP	EQU	00100000B		; Write protected
      = 0010            DIF.CNT EQU	00010000B		; Contiguous file
      = 0008            DIF.ARC EQU	00001000B		; File archive attribute	/3.0a/
      = 0004            DIF.BAD EQU	00000100B		; File is damaged		/3.0a/
      = 0002            DIF.DL	EQU	00000010B		; Locked against delete 	/3.0a/
      = 0001            DIF.USR EQU	00000001B		; User-defined			/3.0a/
0007                    	XTEXT	NAMDEF
0007                    NAMDEF	SPACE	4,10
                        **	SYSTEM FILE NAME CONVENTIONS
                        *
                        *	HDOS30	.SYS		SYSTEM IMAGE PROGRAM FOR SYSTEM 	/3.0a/
                        *	TT	.DVD		Console Device Driver			/3.0a/
                        *	SY	.DVD		System Disk Device Drivecr		/3.0a/
                        *
                        *	RGT	.SYS		RESERVED GROUP TABLE (1 SECTOR)
                        *	GRT	.SYS		GROUP RESERVATION TABLE (1 SECTOR)
                        *	DIRECT	.SYS		DIRECTORY
0007                    	XTEXT	HDSROM
0007                    HSDROM	SPACE	3,10
                        **	HDOS H17 ROM ENTRY POINTS.

      = 19BD            S.READ	EQU	031275A 		; Read from system disk
      = 19D8            S.WRITE EQU	031330A 		; Write to system disk
      = 19E4            ERR.FNO EQU	031344A 		; Error: File not open
      = 19E8            ERR.ILR EQU	031350A 		; Error: Illegal request
      = 19EC            CFF	EQU	031354A 		; Chain free block to file
      = 1A02            DCA	EQU	032002A 		; Determine contiguous area
      = 1A5B            FFB	EQU	032133A 		; Find free block
      = 1A85            FFL	EQU	032205A 		; Follow forward link
                        *LDO	EQU	033012A 		; Load overlay code
      = 1B65            PDI	EQU	033145A 		; Prepare for device I/O
      = 1B7D            REL.	EQU	033175A 		; Relocate code
      = 1B7F            REL	EQU	033177A 		; ditto
      = 1B9B            TFE	EQU	033233A 		; Test for end-of-file
                        *RUC	EQU	033257A 		; Restore user code

      = 1F5A            BOOTA	EQU	037132A 		; Boot Vectors
      = 0058            BOOTAL	EQU	000130A 		; Length of boot vectors

      = 1C19            CLOCK	EQU	034031A 		; Clock vector
0007                    	XTEXT	HOSEQU
0007                    	SPACE	4,10
                        **	HDOS SYSTEM EQUIVALENCES.					/3.0a/
                        *

2040                    	ORG	040100A

2040   (0008)           S.EXITA DS	8			; Jump to System Exit

2048   (0010)           D.CON	DS	16			; Disk Constants

      = 2058            SYDD	EQU	*			; System Disk Entry Point

2058   (0048)           D.VEC	DS	24*3			; H17 Disk Vectors
20A0   (001F)           D.RAM	DS	31			; H17 Disk Work Area

20BF   (0024)           S.VAL	DS	36			; SYSTEM VALUES
20E3   (0093)           S.INT	DS	147			; SYSTEM INTERNAL WORK AREAS

2176   (0002)           S.SOVR	DS	2			; STACK OVERFLOW WARNING
2178   (0108)           	DS	042200A-*		; SYSTEM STACK
      = 010A            STACKL	EQU	*-S.SOVR		; STACK SIZE

      = 2280            STACK	EQU	*			; LWA+1 SYSTEM STACK
      = 2280            USERFWA EQU	*			; USER FWA

                        *	Ensure Compatibility

                        	ERRNZ	040130A-SYDD
                        	ERRNZ	040277A-S.VAL
                        	ERRNZ	040343A-S.INT
                        	ERRNZ	042200A-USERFWA
2280                    	XTEXT	ECVEC
2280                    EDVEC	SPACE	4,10
                        **	JMP Vectors to TT.DVD
                        *
                        *	It is the responsibility of TT.DVD to initialize this
                        *	vector table when it is loaded.

0070                    	ORG	S.CVEC

0070   (0003)           ..SCIN	DS	3			; JMP to .SCIN
0073   (0003)           ..SCOUT DS	3			; JMP to .SCOUT
0076   (0003)           ..PRINT DS	3			; JMP to .PRINT
0079   (0003)           ..CONSL DS	3			; JMP to .CONSL
007C   (0003)           ..CLRCO DS	3			; JMP to .CLRCO

      = 000F            S.CVECL EQU	*-S.CVEC
007F                    	XTEXT	HOSDEF
007F                    	SPACE	3,10
                        **	HOSDEF - Define HOS Parameters.
                        *

      = 0030            VERS	equ	3*16+0			; VERSION 3.0			/3.0a/

      = 00FF            SYSCALL equ	377Q			; SYSCALL INSTRUCTION

0000                    	org	0

                        *	Resident Functions

0000   (0001)           .EXIT	ds	1			; EXIT (MUST BE FIRST)
0001   (0001)           .SCIN	ds	1			; SCIN
0002   (0001)           .SCOUT	ds	1			; SCOUT
0003   (0001)           .PRINT	ds	1			; PRINT
0004   (0001)           .READ	ds	1			; READ
0005   (0001)           .WRITE	ds	1			; WRITE
0006   (0001)           .CONSL	ds	1			; SET/CLEAR CONSOLE OPTIONS
0007   (0001)           .CLRCO	ds	1			; CLEAR CONSOLE BUFFER
0008   (0001)           .LOADO	ds	1			; LOAD AN OVERLAY (obsolete)	/3.0a/
0009   (0001)           .VERS	ds	1			; RETURN HDOS VERSION NUMBER
000A   (0001)           .GDA	ds	1			; Get Device Driver Address	/3.0a/
000B   (0001)           .CRC16	ds	1			; CRC a block of memory 	/3.0a/
000C   (0001)           .SYSRES ds	1			; PRECEDING FUNCTIONS ARE RESIDENT


                        *	*HDOSOVL0.SYS*  FUNCTIONS

0020                    	org	40Q

0020   (0001)           .LINK	ds	1			; LINK	(MUST BE FIRST)
0021   (0001)           .CTLC	ds	1			; CTL-C
0022   (0001)           .OPENR	ds	1			; OPENR
0023   (0001)           .OPENW	ds	1			; OPENW
0024   (0001)           .OPENU	ds	1			; OPENU
0025   (0001)           .OPENC	ds	1			; OPENC
0026   (0001)           .CLOSE	ds	1			; CLOSE
0027   (0001)           .POSIT	ds	1			; POSITION
0028   (0001)           .DELET	ds	1			; DELETE
      = 0028            .DELETE equ	.DELET
0029   (0001)           .RENAM	ds	1			; RENAME
      = 0029            .RENAME equ	.RENAM
002A   (0001)           .SETTP	ds	1			; SETTOP
      = 002A            .SETTOP equ	.SETTP
002B   (0001)           .DECODE ds	1			; NAME DECODE
002C   (0001)           .NAME	ds	1			; GET FILE NAME FROM CHANNEL
002D   (0001)           .CLEAR	ds	1			; CLEAR CHAN
002E   (0001)           .CLEARA ds	1			; CLEAR ALL CHANS
002F   (0001)           .ERROR	ds	1			; LOOKUP ERROR
0030   (0001)           .CHFLG	ds	1			; CHANGE FLAGS
0031   (0001)           .DISMT	ds	1			; FLAG SYSTEM DISK DISMOUNTED
0032   (0001)           .LOADD	ds	1			; LOAD DEVICE DRIVER

                        *	*HDOSOVL1.SYS*  FUNCTIONS

0080                    	org	200Q

0080   (0001)           .MOUNT	ds	1			; MOUNT  (MUST BE FIRST)
0081   (0001)           .DMOUN	ds	1			; DISMOUNT
      = 0081            .DMOUNT equ	.DMOUN
0082   (0001)           .MONMS	ds	1			; MOUNT/NO MESSAGE
0083   (0001)           .DMNMS	ds	1			; DISMOUNT/NO MESSAGE
0084   (0001)           .RESET	ds	1			; RESET = DISMOUNT/MOUNT OF UNIT
0085   (0001)           .RESNMS ds	1			; RESET/NO (OR USER) MESSAGE
0086   (0001)           .DAD	ds	1			; Dismount All Disks
0087                    	XTEXT	ESVAL
0087                    	SPACE	4,10
                        **	S.VAL - SYSTEM VALUE DEFINTIONS.
                        *
                        *	THESE VALUES ARE SET AND MAINTAINED BY THE SYSTEM.
                        *
                        *	THE DECK HOSEQU MUST BE MODIFIED WHEN THIS IS MODIFIED.

20BF                    	ORG	S.VAL

20BF   (0009)           S.DATE	DS	9			; SYSTEM DATE (IN ASCII)
20C8   (0002)           S.DATC	DS	2			; CODED DATE
20CA   (0003)           S.TIME	DS	3			; TIME (BCD HH MM SS)		/3.0a/
20CD   (0001)           S.CLKTR DS	1			; 0 if no clock task resident	/3.0a/
20CE   (0002)           S.HIMEM DS	2			; HARDWARE HIGH MEMORY ADRESS+1

20D0   (0002)           S.SYSM	DS	2			; FWA RESIDENT SYSTEM

20D2   (0002)           S.USRM	DS	2			; LWA USER MEMORY

20D4   (0002)           	DS	2			; obsolete (must be zero!!)	/3.0a/
20D6                    	SPACE	3,10
                        **	THE FOLLOWING CELLS SHOULD BE MODIFIED/READ ONLY VIA THE .CONSL SCALL

      = 0080            CSL.ECH EQU	10000000B		; SUPPRESS ECHO
      = 0004            CSL.RAW EQU	00000100B		; Raw Mode I/O
      = 0002            CSL.WRP EQU	00000010B		; WRAP LINES AT WIDTH
      = 0001            CSL.CHR EQU	00000001B		; OPERATE IN CHARACTER MODE

      = 0000            I.CSLMD EQU	0			; S.CSLMD IS FIRST BYTE
20D6   (0001)           S.CSLMD DS	1			; CONSOLE MODE


      = 0080            CTP.BKS EQU	10000000B		; TERMINAL PROCESSES BACKSPACES
      = 0040            CTP.FF	EQU	01000000B		; Terminal Processes Form-Feed
      = 0020            CTP.MLI EQU	00100000B		; MAP LOWER CASE TO UPPER ON INPUT
      = 0010            CTP.MLO EQU	00010000B		; MAP LOWER CASE TO UPPER ON OUTPUT
      = 0008            CTP.2SB EQU	00001000B		; TERMINAL NEEDS TWO STOP BITS
      = 0004            CTP.HHS EQU	00000100B		; Terminal uses hdwr handshake	/3.0a/
      = 0002            CTP.BKM EQU	00000010B		; MAP BKSP (UPON INPUT) TO RUBOUT
      = 0001            CTP.TAB EQU	00000001B		; TERMINAL SUPPORTS TAB CHARACTERS

      = 0001            I.CONTY EQU	1			; S.CONTY IS 2ND BYTE
                        	ERRNZ	*-S.CSLMD-I.CONTY
20D7   (0001)           S.CONTY DS	1			; CONSOLE TYPE FLAGS


      = 0002            I.CUSOR EQU	2			; S.CUSOR IS 3RD BYTE
                        	ERRNZ	*-S.CSLMD-I.CUSOR
20D8   (0001)           S.CUSOR DS	1			; CURRENT CURSOR POSITION


      = 0003            I.CONWI EQU	3			; S.CONWI IS 4TH BYTE
                        	ERRNZ	*-S.CSLMD-I.CONWI
20D9   (0001)           S.CONWI DS	1			; CONSOLE WIDTH


      = 0001            CO.FLG	EQU	00000001B		; CTL-O FLAG
      = 0080            CS.FLG	EQU	10000000B		; CTL-S FLAG

      = 0004            I.CONFL EQU	4			; S.CONFL IS 5TH BYTE
                        	ERRNZ	*-S.CSLMD-I.CONFL
20DA   (0001)           S.CONFL DS	1			; CONSOLE FLAGS


20DB   (0002)           S.CAADR DS	2			; ADDRESS FOR ABORT PROCESSING (>256 IF VALID)
20DD   (0006)           S.CCTAB DS	6			; ADDR FOR CTL-A, CTL-B, CTL-C PROCESSING
20E3                    	XTEXT	ESINT
20E3                    	SPACE	4,10
                        **	S.INT - SYSTEM INTERNAL WORKAREA DEFINITIONS.
                        *
                        *	THESE CELLS ARE REFERENCED BY OVERLAYS AND MAIN CODE, AND
                        *	MUST THEREFORE RESIDE IN FIXED LOW MEMORY.

20E3                    	ORG	S.INT

                        **	CONSOLE STATUS FLAGS

20E3   (0001)           S.CDB	DS	1			; CONSOLE DESCRIPTOR BYTE
      = 0000            CDB.H85	EQU	00000000B
      = 0001            CDB.H84 EQU	00000001B		; =0 IF H8-5, =1 IF H8-4
20E4   (0002)           S.BAUD	DS	2			; [0-14]  H8-4 BAUD RATE, =0 IF H8-5
                        *					; [15]	  =1 IF BAUD RATE => 2 STOP BITS

                        **	TABLE ADDRESS WORDS

20E6   (0002)           S.DLINK DS	2			; ADDRESS OF DATA IN HDOS CODE
20E8   (0002)           S.TFWA	DS	2			; FWA Task Table		/3.1a/
20EA   (0002)           S.CFWA	DS	2			; FWA CHANNEL TABLE
20EC   (0002)           S.DFWA	DS	2			; FWA DEVICE TABLE
20EE   (0002)           S.RFWA	DS	2			; FWA RESIDENT HDOS CODE

                        **	DEVICE DRIVER DELAYED LOAD FLAGS

20F0   (0002)           S.DDLDA DS	2			; DRIVER LOAD ADDRESS (HIGH BYTE=0 IF NO LOAD PENDING)
20F2   (0002)           S.DDLEN DS	2			; CODE LENGTH IN BYTES
20F4   (0001)           S.DDGRP DS	1			; GROUP NUMBER FOR DRIVER
20F5   (0001)           	DS	1			; HOLD PLACE
20F6   (0002)           S.DDDTA DS	2			; DEVICE'S ADDRESS IN DEVLST +DEV.RES
20F8   (0001)           S.DDOPC DS	1			; OPEN OPCODE PENDEDING

20F9   (000D)           	DS	13			; reserved

                        *	SYSCALL PROCESSING WORK AREAS

                        	ERRNZ	*-041006A
2106   (0001)           S.CACC	DS	1			; (ACC) UPON SYSCALL
2107   (0001)           S.CODE	DS	1			; SYSCALL INDEX IN PROGRESS

                        *	JUMPS TO ROUTINES IN RESIDENT HDOS CODE

2108   (0000)           S.JUMPS DS	0			; START OF DUMP VECTORS
2108   (0003)           S.SDD	DS	3			; JUMP TO STAND-IN DEVICE DRIVER
210B   (0003)           S.FASER DS	3			; JUMP TO FATSERR (FATAL SYSTEM ERROR)
210E   (0003)           S.DIREA DS	3			; JUMP TO DIREAD (DISK FILE READ)
2111   (0003)           S.FCI	DS	3			; JUMP TO FCI (FETCH CHANNEL INFO)
2114   (0003)           S.SCI	DS	3			; JUMP TO SCI (STORE CHANNEL INFO)
2117   (0003)           S.GUP	DS	3			; JUMP TO GUP (GET UNIT POINTER)

211A   (0001)           S.MOUNT DS	1			; <>0 IF THE SYSTEM DISK IS MOUNTED
211B   (0001)           	DS	1			; reserved			/3.0a/

211C   (0001)           S.BOOTF DS	1			; BOOT FLAGS
      = 0001            BOOT.P	EQU	00000001B		; EXECUTE PROLOGUE UPON BOOTUP

211D   (0003)           	DS	3			; reserved
2120                    	SPACE	4,10
                        **	ACTIVE I/O AREA.
                        *
                        *	THE AIO.XXX AREA CONTAINS INFORMATION ABOUT THE I/O OPERATION
                        *	CURRENTLY BEING PERFORMED. THE INFORMATION IS OBTAINED FROM
                        *	THE CHANNEL TABLE, AND WILL BE RESTORED THERE WHEN DONE.
                        *
                        *	NORMALLY, THE AIO.XXX INFORMATION WOULD BE OBTAINED DIRECTLY
                        *	FROM VARIOUS SYSTEM TABLES VIA POINTER REGISTERS. SINCE THE
                        *	8080 HAS NO GOOD INDEXED ADDRESSING, THE DATA IS MANUALLY
                        *	COPIED INTO THE AIO.XXX CELLS BEFORE PROCESSING, AND
                        *	BACKDATED AFTER PROCESSING.

                        	ERRNZ	*-041040A
2120   (0003)           AIO.VEC DS	3			; JUMP INSTRUCTION
      = 2121            AIO.DDA EQU	*-2			; DEVICE DRIVER ADDRESS
2123   (0001)           AIO.FLG DS	1			; FLAG BYTE
2124   (0002)           AIO.GRT DS	2			; ADDRESS OF GROUP RESERV TABLE
2126   (0001)           AIO.SPG DS	1			; SECTORS PER GROUP
2127   (0001)           AIO.CGN DS	1			; CURRENT GROUP NUMBER
2128   (0001)           AIO.CSI DS	1			; CURRENT SECTOR INDEX
2129   (0001)           AIO.LGN DS	1			; LAST GROUP NUMBER
212A   (0001)           AIO.LSI DS	1			; LAST SECTOR INDEX
212B   (0002)           AIO.DTA DS	2			; DEVICE TABLE ADDRESS
212D   (0002)           AIO.DES DS	2			; DIRECTORY SECTOR
212F   (0002)           AIO.DEV DS	2			; DEVICE CODE
2131   (0001)           AIO.UNI DS	1			; UNIT NUMBER (0-9)

2132   (0017)           AIO.DIR DS	DIRELEN 		; DIRECTORY ENTRY

2149   (0001)           AIO.CNT DS	1			; SECTOR COUNT
214A   (0001)           AIO.EOM DS	1			; END OF MEDIA FLAG
214B   (0001)           AIO.EOF DS	1			; END OF FILE FLAG
214C   (0002)           AIO.TFP DS	2			; TEMP FILE POINTERS
214E   (0002)           AIO.CHA DS	2			; ADDRESS OF CHANNEL BLOCK (IOC.DDA)
2150                    	SPACE	4,10
                        *	these cells set by monitor boot code

2150   (0001)           S.BDA	DS	1			; Boot Device Address (Setup by ROM)
2151   (0002)           S.SCR	DS	2			; SYSTEM SCRATCH AREA ADDRESS
2153   (0003)           	DS	3
2156   (0001)           S.OSI	DS	1			; Operating system index	/3.0a/
2157   (0001)           S.OSO	DS	1			; Operating system occurance	/3.0a/
2158   (0003)           S.OSZ	DS	3			; Operating system sector zero	/3.0a/
215B                    	XTEXT	ASCII
215B                    	SPACE	3,10
                        **	ASCII CHARACTER EQUIVALENCES.

      = 0000            NUL	EQU	000Q			; null
      = 0007            BELL	EQU	007Q			; bell
      = 0008            BKSP	EQU	010Q			; backspace
      = 0008            BS	EQU	BKSP
      = 0009            TAB	EQU	011Q			; horizontal tab
      = 000A            LF	EQU	012Q			; line feed
      = 000A            NL	EQU	012Q			; new line (HDOS)
      = 000C            FF	EQU	014Q			; form feed
      = 000D            CR	EQU	015Q			; carriage return
      = 001B            ESC	EQU	033Q			; escape
      = 007F            DEL	EQU	177Q			; delete

                        *	Specials

      = 0080            EOL	EQU	200Q			; end of line flag
      = 0080            NULL	EQU	200Q			; pad character
      = 0000            NUL2	EQU	0			; ditto
      = 007F            RUBOUT	EQU	DEL			; rubout/delete
      = 0016            C.SYN	EQU	026Q			; SYNC
      = 0002            C.STX	EQU	002Q			; STX
      = 0027            QUOTE	EQU	047Q			; quote character (")
      = 008A            ENL	EQU	NL+EOL			; NL + end-of-line flag

                        *	Control keys

      = 0001            CTLA	EQU	'A'-'@' 		; CTRL/A
      = 0002            CTLB	EQU	'B'-'@' 		; CTRL/B
      = 0003            CTLC	EQU	'C'-'@' 		; CTRL/C
      = 0004            CTLD	EQU	'D'-'@' 		; CTRL/D
      = 0005            CTLE	EQU	'E'-'@' 		; CTRL/E
      = 000F            CTLO	EQU	'O'-'@' 		; CTRL/O
      = 0010            CTLP	EQU	'P'-'@' 		; CTRL/P
      = 0011            CTLQ	EQU	'Q'-'@' 		; CTRL/Q
      = 0012            CTLR	EQU	'R'-'@' 		; CTRL/R
      = 0013            CTLS	EQU	'S'-'@' 		; CTRL/S
      = 0018            CTLX	EQU	'X'-'@' 		; CTRL/X
      = 001A            CTLZ	EQU	'Z'-'@' 		; CTRL/Z
215B                    	XTEXT	INIDEF
215B                    	SPACE	4,10
                        **	INIDEF	-  Init Sub-Function Definitions
                        *

0000                    	ORG	0

0000   (0001)           INI.CMV DS	1			; Check Media Validity
0001   (0001)           INI.IDS DS	1			; Initialize Disk Surface
0002   (0001)           INI.DBI DS	1			; Directory Block Interleave
0003   (0001)           INI.PAR DS	1			; Parameters

      = 0004            INI.MAX	EQU	*
0004                    	SPACE	4,10
                        **	Definition of Shared Routines
                        *

      = 2C00            INITVEC EQU	054000A 		; Vector Address

2C00                    	ORG	INITVEC

2C00   (0001)           $$VER	DS	1			; Version of Init

2C01   (0003)           $$BITC	DS	3			; Bit CLEAR

2C04   (0003)           $$BITS	DS	3			; Bit SET

2C07   (0002)           $$BUFF	DS	2			; 256 byte buffer

2C09   (0003)           $$CHL	DS	3			; Complement HL

2C0C   (0003)           $$CNO	DS	3			; Check  NO

2C0F   (0003)           $$CYS	DS	3			; Check  YES

2C12   (0003)           $$DRVR	DS	3			; Device Driver

2C15   (0003)           $$DRVR. DS	3			; Device Driver with ERROR detection

2C18   (0003)           $$ITL.	DS	3			; Input Text Line

2C1B   (0003)           $$MOVE	DS	3			; Move bytes

2C1E   (0003)           $$TBRA	DS	3			; Table Branch

2C21   (0003)           $$TYPTX DS	3			; Type Text

2C24   (0003)           $$VSN	DS	3			; Volume Serial Number

2C27   (0003)           $$RBS	DS	3			; Request Buffer Space		/2.1a/

      = 2C2A            $$MAX	EQU	*
2C2A                    	STL	'INITIAL BOOT ROUTINE'
2C2A                    	EJECT

2480                    	ORG	SB.SDB

2480                    	LON	C

                        **	T0BOOT - Track 0 Boot Routine.
                        *
                        *	THIS BOOT STARTS AT SECTOR 0 ON EVERY INITIALIZED
                        *	DISK, AND OCCUPIES THE FIRST 9 SECTORS OF THE DISK.
                        *
                        *	IT IS BROUGHT IN BY THE SYSTEM MONITOR PROGRAM.

2480  31 8022           T0BOOT	LXI	SP,STACK		; Insure valid STACK

2483  21 191C           	LXI	H,CLOCK
2486  22 2020           	SHLD	.UIVEC+1		; Insure valid CLOCK

2489  CD 2E29           	CALL	FCU			; FIND CONSOLE USART

                        *	Mount the system disk

248C  CD A328           	CALL	MSD			; mount system disk		

                        *	See if we're wasting our time

248F  3A C72A           	LDA	BLABEL+LAB.VLT 		; (A) = VOLUME TYPE
2492  A7                	ANA	A
                        	ERRNZ	LAB.DAT
2493  CA 7526           	JZ	T0BOOT9 		; IS DATA DISK
2496  3D                	DCR	A
                        	ERRNZ	LAB.SYS-1
2497  C2 2126           	JNZ	T0BOOT8 		; IS GARBAGE DISK

                        *	Find the system files

249A  11 CA24           	LXI	D,HDOS30		; HDOS30.SYS
249D  CD B426           	CALL	LSF

24A0  11 D924           	LXI	D,TTDVD 		; TT.DVD
24A3  CD B426           	CALL	LSF

24A6  11 EA24           	LXI	D,SYDVD 		; SY.DVD
24A9  CD B426           	CALL	LSF

                        *	Load 'em

24AC  11 CA24           	LXI	D,HDOS30
24AF  21 0030           	LXI	H,SB.ORG		; load place
24B2  CD 4F27           	CALL	LCF

24B5  22 E824           	SHLD	TTDRV
24B8  11 D924           	LXI	D,TTDVD
24BB  CD 4F27           	CALL	LCF

24BE  22 F924           	SHLD	SYDRV
24C1  11 EA24           	LXI	D,SYDVD
24C4  CD 4F27           	CALL	LCF

24C7  C3 FB24           	JMP	T0BOOTX 		; do remaining boot code
24CA                    	SPACE	4,10
                        ***	System File Information

24CA  48444F53 33300000 HDOS30	DB	'HDOS30',0,0,'SYS'
24D2  535953
24D5   (0002)           	DS	2			; sector number of file
24D7   (0002)           	DS	2			; length of file (in bytes)

24D9  54540000 00000000 TTDVD	DB	'TT',0,0,0,0,0,0,'DVD'
24E1  445644
24E4   (0002)           	DS	2
24E6   (0002)           	DS	2

24E8   (0002)           TTDRV	DS	2			; where we loaded TT.DVD

24EA  53590000 00000000 SYDVD	DB	'SY',0,0,0,0,0,0,'DVD'
24F2  445644
24F5   (0002)           	DS	2
24F7   (0002)           	DS	2

24F9   (0002)           SYDRV	DS	2			; where we loaded SY.DVD
24FB                    	EJECT
                        *	Do user's bidding

24FB  31 8022           T0BOOTX LXI	SP,STACK		; ensure clean stack

                        *	Check auto-boot set

24FE  3A 8422           	LDA	SB.FLG
2501  E6 01             	ANI	BFLG.A			; is auto-boot?
2503  C2 FD25           	JNZ	T0BOOT4 		; yes. no choices here.

2506  CD C427           	CALL	$TYPET
2509  000A4163 74696F6E 	DB	0,LF,'Action? <Boot>',' '+EOL
2511  3F203C42 6F6F743E
2519  A0

                        *	GET REPLY. MAY BE:
                        *
                        *	B<oot>
                        *	I<gnore>
                        *	H<elp>

251A  0E 64             T0BOOTY MVI	C,100			; C = Time-Out Counter
251C  CD 6929           	CALL	RCC			; INPUT TASK TIME
251F  DA 4925           	JC	T0BOOT1 		; Output Message at new Baud-Rate
2522  47                	MOV	B,A			; Save character if any
2523  79                	MOV	A,C
2524  A7                	ANA	A
2525  CA F525           	JZ	T0BOOT2 		; Time-out, auto boot.

2528  78                T0BOOT0 MOV	A,B			; A  = saved character
2529  CD 7A29           	CALL	$MCU			; MAP TO UPPER CASE
252C  FE 0D             	CPI	CR
252E  CA F525           	JE	T0BOOT2 		; IS BOOT
2531  FE 20             	CPI	' '			; accept space, too.
2533  CA F525           	JE	T0BOOT2
2536  FE 42             	CPI	'B'
2538  CA F525           	JE	T0BOOT2 		; IS BOOT
253B  FE 49             	CPI	'I'
253D  CA 0F26           	JE	T0BOOT5 		; IS IGNORE
2540  FE 48             	CPI	'H'
2542  CA 4925           	JE	T0BOOT1

2545  CD C427           	CALL	$TYPET
2548  87                	DB	BELL+EOL		; <ding> for an error.

                        *	ASSUME HELP

2549  CD C427           T0BOOT1 CALL	$TYPET
254C  48656C70 0000     	DB	'Help',0,0
2552  4C656761 6C20436F 	DB	'Legal Commands:',0,0
255A  6D6D616E 64733A00
2562  00
2563  426F6F74 092D2042 	DB	'Boot',TAB,'- Boot HDOS',0
256B  6F6F7420 48444F53
2573  00
2574  49676E6F 7265092D 	DB	'Ignore',TAB,'- Ignore PROLOGUE File(s)',0
257C  2049676E 6F726520
2584  50524F4C 4F475545
258C  2046696C 65287329
2594  00
2595  48656C70 092D2050 	DB	'Help',TAB,'- Print this list',0,0
259D  72696E74 20746869
25A5  73206C69 73740000
25AD  596F7520 77616E74 	DB	'You want I should hold your hand',0
25B5  20492073 686F756C
25BD  6420686F 6C642079
25C5  6F757220 68616E64
25CD  00
25CE  7768696C 6520796F 	DB	'while you go to the bathroom, too?',0
25D6  7520676F 20746F20
25DE  74686520 62617468
25E6  726F6F6D 2C20746F
25EE  6F3F00
25F1  80                	DB	EOL

25F2  C3 FB24           	JMP	T0BOOTX 		; TRY AGAIN

                        *	IS BOOT

25F5  CD C427           T0BOOT2 CALL	$TYPET
25F8  426F6F74 80       	DB	'Boot',EOL

25FD  3A 1C21           T0BOOT4 LDA	S.BOOTF
2600  F6 01             	ORI	BOOT.P			; FLAG PROLOGUE EXECUTION UPON BOOTUP

2602  32 1C21           T0BOOT3 STA	S.BOOTF

2605  2A E824           	LHLD	TTDRV
2608  EB                	XCHG
2609  2A F924           	LHLD	SYDRV

                        *	Enter HDOS with:
                        *
                        *	   (hl) = TT.DVD address
                        *	   (de) = SY.DVD address

260C  C3 0630           	JMP	SB.ORG+PIC.COD		; enter HDOS


                        *	IS IGNORE

260F  CD C427           T0BOOT5 CALL	$TYPET
2612  49676E6F 726580   	DB	'Ignore',EOL

2619  3A 1C21           	LDA	S.BOOTF
261C  E6 FE             	ANI	377Q-BOOT.P		; Turn off Prologue at BOOT

261E  C3 0226           	JMP	T0BOOT3
2621                    	EJECT
                        ***	Errors

                        *	GARBAGE DISK.

2621  CD C427           T0BOOT8 CALL	$TYPET
2624  00073F30 30205468 	DB	0,BELL,'?00 This disk must be initialized and then SYSGENed'
262C  69732064 69736B20
2634  6D757374 20626520
263C  696E6974 69616C69
2644  7A656420 616E6420
264C  7468656E 20535953
2654  47454E65 64
2659  00626566 6F726520 	DB	0,'before it can be used.',BELL,EOL
2661  69742063 616E2062
2669  65207573 65642E07
2671  80

2672  C3 F026           	JMP	SYSHLT

                        *	IS DATA DISK. NOT YET SYSGENED

2675  CD C427           T0BOOT9 CALL	$TYPET
2678  00073F30 30205468 	DB	0,BELL,'?00 This disk must be SYSGENed before it can be used.',BELL,EOL
2680  69732064 69736B20
2688  6D757374 20626520
2690  53595347 454E6564
2698  20626566 6F726520
26A0  69742063 616E2062
26A8  65207573 65642E07
26B0  80

26B1  C3 F026           	JMP	SYSHLT
26B4                    	STL	'LSF - Locate System File'
26B4                    	EJECT
                        **	LSF is called to locate a system file.
                        *
                        *	The disk directory is searched for the given file and if found
                        *	information concerning its location on disk and size is returned,
                        *	otherwise, the message:
                        *
                        *	?00 Required file FILENAME.EXT missing!
                        *
                        *	is displayed and the system is halted.
                        *
                        *	ENTRY	(DE) = File name
                        *	EXIT	'C' Clear if successful
                        *		 The two words following the file filled in
                        *		 with sector number and size of file.
                        *	USES	ALL

26B4  01 0B00           LSF	LXI	B,DIRIDL
26B7  21 3221           	LXI	H,AIO.DIR
26BA  CD AA18           	CALL	$MOVE			; MOVE IN NAME

26BD  D5                	PUSH	D			; save place

26BE  01 0B00           	LXI	B,DIRIDL
26C1  2A C22A           	LHLD	BLABEL+LAB.DIS
26C4  CD 3128           	CALL	LDE..			; LOAD ENTRY

26C7  D2 F426           	JNC	LSF1			; FOUND

                        *	COULDNT FIND IT

26CA  CD C427           	CALL	$TYPET
26CD  073F3030 20526571 	DB	BELL,'?00 Required file',' '+EOL
26D5  75697265 64206669
26DD  6C65A0
26E0  CD AA27           	CALL	TFN			; TYPE FILE NAME
26E3  CD C427           	CALL	$TYPET
26E6  206D6973 73696E67 	DB	' missing!',BELL+EOL
26EE  2187

26F0  F3                SYSHLT	DI
26F1  C3 F126           	JMP	*			; stop system here.

                        *	Got directory entry. Check it.

26F4  11 0E00           LSF1	LXI	D,DIR.FLG
26F7  19                	DAD	D			; (HL) = ADDRESS OF FLG
26F8  7E                	MOV	A,M
26F9  E6 10             	ANI	DIF.CNT
26FB  CA 2427           	JZ	LSF4			; NOT CONTIGUOUS
                        	ERRNZ	DIR.FGN-DIR.FLG-2
26FE  23                	INX	H
26FF  23                	INX	H			; (HL) = #DIR.FGN
2700  5E                	MOV	E,M
2701  16 00             	MVI	D,0			; (DE) = GROUP NUMBER
2703  3A C62A           	LDA	BLABEL+LAB.SPG 		; (A) = SECTORS PER GROUP
2706  CD 0719           	CALL	$MU86			; (HL) = SECTOR NUMBER FOR FILE

                        *	Save file's location

2709  D1                	POP	D			; place for sector number
270A  7D                	MOV	A,L
270B  12                	STAX	D			; low byte
270C  13                	INX	D
270D  7C                	MOV	A,H
270E  12                	STAX	D			; high byte
270F  13                	INX	D
2710  D5                	PUSH	D			; pointing to size now.

                        *	(hl) = Sector number for file, get size information.

2711  01 0001           LSF3	LXI	B,256
2714  11 0030           	LXI	D,SB.ORG
2717  CD 6528           	CALL	READD			; Read first sector of file

271A  2A 0230           	LHLD	SB.ORG+PIC.LEN		; (hl) = length in bytes

271D  D1                	POP	D			; place for length
271E  7D                	MOV	A,L
271F  12                	STAX	D			; low byte
2720  13                	INX	D
2721  7C                	MOV	A,H
2722  12                	STAX	D			; high byte

2723  C9                	RET

                        *	FILE NOT CONTIGUOUS

2724  CD C427           LSF4	CALL	$TYPET
2727  00073F30 30204669 	DB	0,BELL,'?00 File',' '+EOL
272F  6C65A0
2732  CD AA27           	CALL	TFN			; TYPE FILE NAME
2735  CD C427           	CALL	$TYPET
2738  20697320 6E6F7420 	DB	' is not contiguous!',BELL+EOL
2740  636F6E74 6967756F
2748  75732187

274C  C3 F026           	JMP	SYSHLT
274F                    	STL	'LCF - Load Contiguous File'
274F                    	EJECT
                        **	LCF is called to load a contiguous file.
                        *
                        *	Entry:	(hl) = Load address
                        *		(de) = Address of file name & address
                        *	Exit:	(hl) = Next load address
                        *

      = 274F            LCF	EQU	*

274F  E5                	PUSH	H			; save load address

2750  01 0B00           	LXI	B,DIRIDL
2753  21 3221           	LXI	H,AIO.DIR
2756  CD AA18           	CALL	$MOVE			; MOVE IN NAME

2759  EB                	XCHG				; (hl) = address of pointers
275A  CD 9C18           	CALL	$INDL
275D  0000              	DW	0			; load sector number

275F  D5                	PUSH	D

2760  CD 9C18           	CALL	$INDL
2763  0200              	DW	2			; load file size

2765  21 FF00           	LXI	H,255
2768  19                	DAD	D			; round it up
2769  2E 00             	MVI	L,0			; (and truncate to even sector)
276B  44                	MOV	B,H
276C  4D                	MOV	C,L			; (bc) = count
276D  E1                	POP	H			; (hl) = sector number
276E  D1                	POP	D			; (de) = load address

276F  D5                	PUSH	D			; save address
2770  C5                	PUSH	B			;  and count

2771  CD 6528           	CALL	READD			; read it in

2774  C1                	POP	B			; count
2775  E1                	POP	H			; where loaded
2776  09                	DAD	B			; (hl) = next load address

2777  C9                	RET
2778                    	STL	'SUBROUTINES'
2778                    	EJECT
2778                    	XTEXT	ICTT
2778                    	SPACE	4,10
                        **	$ICTT - INPUT FROM CONSOLE TASK TIME.
                        *
                        *	$ICTT IS A TASK-TIME CONSOLE INPUT ROUTINE, WHICH
                        *	PERFORMS SIMPLE SINGLE CHARACTER INPUTS.
                        *
                        *	IT IS CALLED DURING BOOT OPERATIONS, AND BY SPECIAL ROUTINES
                        *	WHICH MAY BE RUNNING IN ENVIRONMENTS WHERE KEYBOARD INTERRUPTS
                        *	ARE UNDESIRABLE.
                        *
                        *	Modified to handle H8-4 ports by G. Chandler, 1-SEP-78
                        *	This routine assumes that the ports have been previously initialized,
                        *	and that S.CDB has been previously initialized.
                        *
                        *	ENTRY	NONE
                        *	EXIT	(A) = CHARACTER
                        *	USES	A,F

2778  CD 8227           $ICTT	CALL	$ICTT.
277B  DA 7827           	JC	$ICTT
277E  CD 9827           	CALL	$ICTT..
2781  C9                	RET

2782  3A E320           $ICTT.	LDA	S.CDB
2785  FE 01             	CPI	CDB.H84
2787  CA 9127           	JZ	ICTT2			; IF  H8-4 PORT

                        *	HAVE 8251 FOR CONSOLE

278A  DB FB             ICTT1	IN	SC.UART+USR
278C  E6 02             	ANI	USR.RXR
278E  C0                	RNZ				; READY

278F  37                	STC				; FLAG NOT READY
2790  C9                	RET

                        *	HAVE 8250 PORT FOR CONSOLE

2791  DB ED             ICTT2	IN	SC.ACE+UR.LSR
2793  E6 01             	ANI	UC.DR
2795  C0                	RNZ				; READY

2796  37                	STC				; FLAG NOT READY
2797  C9                	RET

2798  3A E320           $ICTT.. LDA	S.CDB
279B  FE 01             	CPI	CDB.H84
279D  CA A527           	JZ	ICTT3

                        *	HAVE 8251 FOR CONSOLE

27A0  DB FA             	IN	SC.UART+UDR
27A2  E6 7F             	ANI	177Q
27A4  C9                	RET

                        *	HAVE 8250 FOR CONSOLE

27A5  DB E8             ICTT3	IN	SC.ACE+UR.RBR
27A7  E6 7F             	ANI	177Q
27A9  C9                	RET
27AA                    	SPACE	4,10
                        **	TFN - TYPE FILE NAME.
                        *
                        *	TFN TYPES THE FILE WHOSE NAME APPEARS IN AIO.XXX
                        *
                        *	ENTRY	NONE
                        *	EXIT	NONE
                        *	USES	A,F,B,H,L

27AA  21 3221           TFN	LXI	H,AIO.DIR+DIR.NAM
27AD  06 08             	MVI	B,8
27AF  CD B927           	CALL	TFN1			; TYPE NAME
27B2  3E 2E             	MVI	A,'.'
27B4  CD E127           	CALL	$TYPEC.
27B7  06 03             	MVI	B,3

27B9  7E                TFN1	MOV	A,M
27BA  A7                	ANA	A
27BB  C4 E127           	CNZ	$TYPEC.
27BE  23                	INX	H
27BF  05                	DCR	B
27C0  C2 B927           	JNZ	TFN1
27C3  C9                	RET
27C4                    	XTEXT	MU86
27C4                    MU86	SPACE	4,10
                        **	$MU86 - MULTIPLY 8X16 UNSIGNED.
                        *
                        *	$MU86 MULTIPLIES A 16 BIT VALUE BY A 8
                        *	BIT VALUE.
                        *
                        *	ENTRY	(A) = MULTIPLIER
                        *		(DE) = MULTIPLICAND
                        *	EXIT	(HL) = RESULT
                        *		'Z' SET IF NOT OVERFLOW
                        *	USES	A,F,H,L

      = 1907            $MU86	EQU	031007A 		; IN H17 ROM
27C4                    	XTEXT	TYPET
27C4                    	SPACE	4,10
                        **	$TYPET - TYPE TEXT.
                        *
                        *	$TYPET IS CALLED TO TYPE A BLOCK OF TEXT ON THE SYSTEM CONSOLE
                        *	AT TASK TIME RATHER THAN AT INTERRUPT TIME.
                        *
                        *	IMBEDDED ZER0 BYTES INDICATE A CARRIAGE RETURN LINE FEED,
                        *	A BYTE WITH THE 200Q BIT SET IS THE LAST BYTE OF THE MESSAGE.
                        *
                        *	This routine modified to accomodate H8-4 ports by G.Chandler, 1-SEP-78.
                        *	This routine assumes that the ports have been previously initialized,
                        *	and that S.CDB has been previously initialized.
                        *
                        *	ENTRY	(RET) = TEXT
                        *	EXIT	TO (RET+LENGTH)
                        *	USES	A,F

27C4  E3                $TYPET	XTHL				; (HL) = TEXT ADDRESS
27C5  CD CA27           	CALL	$TYPET. 		; TYPE IT
27C8  E3                	XTHL
27C9  C9                	RET

27CA  7E                $TYPET.	MOV	A,M
27CB  E6 7F             	ANI	177Q
27CD  C4 E127           	CNZ	$TYPEC. 		; IF NOT CRLF
27D0  A7                	ANA	A
27D1  CC DA27           	CZ	$TYPET1 		; IS CRLF
27D4  BE                	CMP	M
27D5  23                	INX	H
27D6  C0                	RNE				; WAS 200 BIT SET
27D7  C3 CA27           	JMP	$TYPET.

                        *	TYPE CRLF

27DA  CD C427           $TYPET1	CALL	$TYPET
27DD  0D8A              	DB	CR,ENL
27DF  AF                	XRA	A	;RESTORE (A)
27E0  C9                	RET
27E1                    	SPACE	4,10
                        **	$TYPEC. - TYPE SINGLE CHARACTER.
                        *
                        *	IF CR, PAD WITH 4 ZERO BYTES
                        *
                        *	ENTRY	(A) = CHARACTER
                        *	EXIT	(A) = CHARACTER
                        *	USES	A,F

27E1  F5                $TYPEC. PUSH	PSW			; save character for exit	/3.0a/
27E2  F5                	PUSH	PSW			; SAVE CHAR
27E3  3A D720           	LDA	S.CONTY 		; console type			/3.0a/
27E6  E6 10             	ANI	CTP.MLO 		; isolate l/c map		/3.0a/
27E8  CA F027           	JZ	TYPEC0			; not mapping today		/3.0a/
27EB  F1                	POP	PSW			; get character 		/3.0a/
27EC  CD 7A29           	CALL	$MCU			; map it			/3.0a/
27EF  F5                	PUSH	PSW			;  and put it back		/3.0a/
27F0  3A E320           TYPEC0	LDA	S.CDB						;/3.0a/
27F3  FE 01             	CPI	CDB.H84
27F5  CA 0528           	JZ	TYPEC2			; IF H8-4 PORT

                        *	HAVE 8251 PORT FOR CONSOLE

27F8  DB FB             TYPEC1	IN	SC.UART+USR
27FA  E6 01             	ANI	USR.TXR
27FC  CA F827           	JZ	TYPEC1			; NOT READY
27FF  F1                	POP	PSW
2800  D3 FA             	OUT	SC.UART+UDR
2802  C3 1E28           	JMP	TYPEC3

                        *	HAVE 8250 PORT FOR CONSOLE

2805  DB ED             TYPEC2	IN	SC.ACE+UR.LSR
2807  E6 20             	ANI	UC.THE
2809  CA 0528           	JZ	TYPEC2			; NOT READY
280C  3A D720           	LDA	S.CONTY 		; check type			/3.0a/
280F  E6 04             	ANI	CTP.HHS 		; need to do handshake? 	/3.0a/
2811  CA 1B28           	JZ	TYPEC2B 		; no.				/3.0a/
2814  DB EE             TYPEC2A IN	SC.ACE+UR.MSR		; check modem status		/3.0a/
2816  E6 10             	ANI	UC.CTS			; have Clear-to-send?		/3.0a/
2818  CA 1428           	JZ	TYPEC2A 		; not yet.			/3.0a/
281B  F1                TYPEC2B POP	PSW						;/3.0a/
281C  D3 E8             	OUT	SC.ACE+UR.THR

281E  F1                TYPEC3	POP	PSW			; character we started with	/3.0a/
281F  FE 0D             	CPI	CR
2821  C0                	RNE				; NOT CR

                        *	IS CR. PAD 4 TIMES

2822  3E 04             	MVI	A,4
2824  F5                TYPEC4	PUSH	PSW
2825  AF                	XRA	A
2826  CD E127           	CALL	$TYPEC.
2829  F1                	POP	PSW
282A  3D                	DCR	A
282B  C2 2428           	JNZ	TYPEC4
282E  3E 0D             	MVI	A,CR
2830  C9                	RET
2831                    	XTEXT	MOVE
2831                    MOVE	SPACE	4,10
                        **	$MOVE - MOVE DATA
                        *
                        *	$MOVE MOVES A BLOCK OF BYTES TO A NEW MEMORY ADDRESS.
                        *	IF THE MOVE IS TO A LOWER ADDRESS, THE BYTES ARE MOVED FROM
                        *	FIRST TO LAST.
                        *
                        *	IF THE MOVE IS TO A HIGHER ADDRESS, THE BYTES ARE MOVED FROM
                        *	LAST TO FIRST.
                        *
                        *	THIS IS DONE SO THAT AN OVERLAPED MOVE WILL NOT 'RIPPLE'.
                        *
                        *	ENTRY	(BC) = COUNT
                        *		(DE) = FROM
                        *		(HL) = TO
                        *	EXIT	MOVED
                        *		(DE) = ADDRESS OF NEXT FROM BYTE
                        *		(HL) = ADDRESS OF NEXT *TO* BYTE
                        *		'C' CLEAR
                        *	USES	ALL

      = 18AA            $MOVE	EQU	030252A 		; IN H17 ROM
2831                    	XTEXT	COMP
2831                    COMP	SPACE	4,10
                        **	$COMP - COMPARE TWO CHARACTER STRINGS.
                        *
                        *	$COMP COMPARES TWO BYTE STRINGS.
                        *
                        *	ENTRY	(C) = COMPARE COUNT
                        *		(DE) = FWA OF STRING #1
                        *		(HL) = FWA OF STRING #2
                        *	EXIT	'Z' CLEAR, IS MIS-MATCH
                        *		 (C) = LENGTH REMAINING
                        *		 (DE) = ADDRESS OF MISMATCH IN STRING#1
                        *		 (HL) = ADDRESS OF MISMATCH IN STRING #2
                        *		'C' SET, HAVE MATCH
                        *		 (C) = 0
                        *		 (DE) = (DE) + (0C)
                        *		 (HL) = (HL) + (0C)
                        *	USES	A,F,C,D,E,H,L

      = 1830            $COMP	EQU	030060A 		; IN H17 ROM
2831                    	XTEXT	DADA2
2831                    DADA2	SPACE	4,10
                        **	$DADA. - ADD (0,A) TO (H,L)
                        *
                        *	ENTRY	NONE
                        *	EXIT	(HL) = (HL) + (0A)
                        *	USES	A,F,H,L

      = 1841            $DADA.	EQU	030101A 		; IN H17 ROM
2831                    	SPACE	4,10
                        **	LDE - LOCATE DIRECTORY ENTRY.
                        *
                        *	LDE LOCATES A DIRECTORY ENTRY CORRESPONDING TO THE AIO.DIR ENTRY.
                        *
                        *	ENTRY	(BC) = NUMBER OF CHARACTERS TO MATCH ON
                        *	EXIT	'C' CLEAR IF FOUND
                        *		 AIO.DES SETUP
                        *		 (HL) = ADDRESS OF DIRECTORY ENTRY IN BUFF
                        *		'C' SET IF NOT FOUND
                        *		 (A) = CODE
                        *	USES	ALL

                        **	ENTRY FOR (HL) = SECTOR NUMBER TO START WITH

2831  C5                LDE..	PUSH	B			; SAVE COUNT
2832  01 0002           	LXI	B,512
2835  11 BF2B           	LXI	D,BUFF
2838  22 2D21           	SHLD	AIO.DES 		; ASSUME WILL FIND IN THIS BLOCK
283B  CD 6528           	CALL	READD			; READ FRM DEVICE
283E  C1                	POP	B			; RESTORE (BC)

                        *	SCAN SECTOR FOR INFO

283F  21 BF2B           	LXI	H,DIS.ENT+BUFF

                        *	COMPARE

2842  11 3221           LDE3	LXI	D,AIO.DIR
2845  C5                	PUSH	B			; SAVE COPY OF (BC)
2846  E5                	PUSH	H			; SAVE ADDRESS
2847  CD 3018           	CALL	$COMP			; COMPARE
284A  E1                	POP	H
284B  C1                	POP	B			; (BC) = COMPARE COUNT
284C  C8                	RE				; GOT MATCH
284D  11 1700           	LXI	D,DIRELEN		; MISSED, SCAN TO NEXT ENTRY
2850  19                	DAD	D
2851  7E                	MOV	A,M
2852  A7                	ANA	A
2853  C2 4228           	JNZ	LDE3			; MORE IN SECTOR

                        *	DIDNT FIND IT IN THIS SECTOR, TRY NEXT

2856  2A BD2D           	LHLD	DIS.LNK+BUFF
2859  22 2D21           	SHLD	AIO.DES 		; SET POSSIBLE SECTOR INDEX
285C  7C                	MOV	A,H
285D  B5                	ORA	L
285E  C2 3128           	JNZ	LDE..			; HAVE MORE SECTORS
2861  3E 0C             	MVI	A,EC.FNF		; FILE NOT FOUND
2863  37                	STC
2864  C9                	RET
2865                    	SPACE	4,10
                        **	READD - READ DISK.
                        *
                        *	READD CALLS THE SYSTEM DEVICE DRIVER FOR A
                        *	READ OPERATION.
                        *
                        *	IF AN ERROR OCCURS, A MESSAGE IS PRINTED, AND THE
                        *	BOOT OPERATION RESTARTS.
                        *
                        *	ENTRY	REGISTERS SET FOR READ
                        *	EXIT	FROM SYDD
                        *	USES	ALL

2865  AF                READD	XRA	A			; A = 0
                        	ERRNZ	DC.REA
2866  CD 5820           READD1	CALL	SYDD			; ISSUE READ
2869  D0                	RNC				; ALL OK

                        *	READ ERROR

286A  CD C427           READERR	CALL	$TYPET
286D  0000073F 30302052 	DB	0,0,BELL,'?00 Read error during boot.',0		
2875  65616420 6572726F
287D  72206475 72696E67
2885  20626F6F 742E00
288C  07426F6F 74206162 	DB	BELL,'Boot aborted.',EOL
2894  6F727465 642E80

289B  C3 F026           	JMP	SYSHLT

289E  3E 02             READR	MVI	A,DC.RER
28A0  C3 6628           	JMP	READD1			; Read Regardless
28A3                    	SPACE	4,10
                        **	MSD - MOUNT SYSTEM DISK.
                        *
                        *	MSD MOUNTS THE SYSTEM DISK.
                        *
                        *	1) ABORT DRIVER
                        *	2) READ BLABEL RECORD
                        *	3) SET VOLUME NUMBER FOR DRIVER
                        *	4) INITIALIZE DEVICE TABLE
                        *	5) BUILD GRT

28A3  3E 07             MSD	MVI	A,DC.ABT
28A5  CD 5820           	CALL	SYDD			; ABORT DRIVER
28A8  2E 00             	MVI	L,0			; Mount volume 0
28AA  CD D128           	CALL	MSD.

28AD  01 0001           	LXI	B,256
28B0  11 BF2A           	LXI	D,BLABEL
28B3  21 0900           	LXI	H,DDF.LAB
28B6  CD 9E28           	CALL	READR			; Read Regardless

                        *	CALL DEVICE MOUNT ROUTINE

28B9  2A BF2A           	LHLD	BLABEL+LAB.SER		; L = Volume Number
28BC  CD D128           	CALL	MSD.			; Mount the volume

                        *	Patch Label for old diskettes

28BF  3A C82A           	LDA	BLABEL+LAB.VER
28C2  FE 17             	CPI	017H
28C4  D0                	RNC				; Version >= 1.7

28C5  21 9001           	LXI	H,400
28C8  22 CB2A           	SHLD	BLABEL+LAB.SIZ		; Force size of 400
28CB  3E 0A             	MVI	A,10
28CD  32 0E2B           	STA	BLABEL+LAB.SPT		; 10 Sectors per Track
28D0  C9                	RET

                        *	Mount the volume

28D1  26 00             MSD.	MVI	H,0
28D3  3E 08             	MVI	A,DC.MOU
28D5  CD 5820           	CALL	SYDD
28D8  DC 6A28           	CC	READERR
28DB  C9                	RET
28DC                    	EJECT
                        **	CBS	- Check Break Status
                        *
                        *	CBS checks the break status to see if the user
                        *	has hit the break key.  If so, it is assumed
                        *	that the user wishes to re-determine the baud-rate.
                        *
                        *	This routine also waits for a character from the
                        *	selected device.
                        *
                        *	ENTRY:	C	= Time-Out Counter
                        *		S.CDB	= Console definition byte
                        *
                        *	EXIT:	PSW	= 'Z' if
                        *				Time-Out
                        *				character ready
                        *			  'NZ' if
                        *				Baud-Rate changed
                        *
                        *	USES:	PSW,BC
                        *

28DC  3A E320           CBS	LDA	S.CDB
28DF  A7                	ANA	A
                        	ERRNZ	CDB.H85
28E0  C2 F328           	JNZ	CBS2			; Not an 8251

28E3  CD 1929           CBS1	CALL	CBS4
28E6  C8                	RZ				; Time-Out
28E7  DB FB             	IN	SC.UART+USR
28E9  E6 42             	ANI	USR.BD+USR.RXR		; Check for Break, OR character
28EB  CA E328           	JZ	CBS1
28EE  E6 40             	ANI	USR.BD			; Check for Break only
28F0  C3 0029           	JMP	CBS3

28F3  CD 1929           CBS2	CALL	CBS4
28F6  C8                	RZ				; Time-Out
28F7  DB ED             	IN	SC.ACE+UR.LSR
28F9  E6 19             	ANI	UC.BI+UC.DR+UC.FE	; Check: Break, Frame error, character
28FB  CA F328           	JZ	CBS2
28FE  E6 18             	ANI	UC.BI+UC.FE		; Check: Break, Frame error

2900  C8                CBS3	RZ				; No Break, so must be character

2901  F5                CBS.	PUSH	PSW			; Re-Determine Baud-Rate
2902  C5                	PUSH	B
2903  E5                	PUSH	H

2904  2A 8522           	LHLD	SB.BAU
2907  E5                	PUSH	H
2908  21 0000           	LXI	H,0
290B  22 8522           	SHLD	SB.BAU			; Over-Ride Default Baud-Rate
290E  CD 2E29           	CALL	FCU
2911  E1                	POP	H
2912  22 8522           	SHLD	SB.BAU			; Restore old Baud-Rate

2915  E1                	POP	H
2916  C1                	POP	B
2917  F1                	POP	PSW
2918  C9                	RET

2919  3A 1B20           CBS4	LDA	.TICCNT
291C  A7                	ANA	A
291D  CA 2229           	JZ	CBS5			; 1/2 Second Interval
2920  47                	MOV	B,A			; B = last TicCnt
2921  C9                	RET

2922  78                CBS5	MOV	A,B			; A = Last TicCnt
2923  A7                	ANA	A
2924  C2 2A29           	JNZ	CBS6			; This 1/2 Second Not counted yet
2927  F6 01             	ORI	1
2929  C9                	RET				; No Time-Out Yet

292A  06 00             CBS6	MVI	B,0			; Flag this TicCnt counted
292C  0D                	DCR	C			; Count the 1/2 second
292D  C9                	RET
292E                    	SPACE	4,10
                        **	FCU - FIND CONSOLE USART.
                        *
                        *	FCU FINDS AND CONFIGURES THE CONSOLE USART.
                        *
                        *	ENTRY	NONE
                        *	EXIT	NONE
                        *	USES	A,F,(BC),(HL)
                        *

292E  AF                FCU	XRA	A
292F  D3 E9             	OUT	SC.ACE+UR.IER		; OFF
2931  D3 FB             	OUT	SC.UART+USR		;  INTERRUPTS

                        *	SEE IF WE HAVE AN 8250

2933  3E 03             	MVI	A,UC.8BW
2935  D3 EB             	OUT	SC.ACE+UR.LCR
2937  DB EB             	IN	SC.ACE+UR.LCR
2939  FE 03             	CPI	UC.8BW			; SEE IF UNCHANGED
293B  3E 00             	MVI	A,CDB.H85
293D  21 0000           	LXI	H,0
2940  C2 6029           	JNE	FCU1			; IS 8251

2943  2A 8522           	LHLD	SB.BAU
2946  7C                	MOV	A,H
2947  B5                	ORA	L
2948  3E 01             	MVI	A,CDB.H84
294A  C2 6029           	JNZ	FCU1			; Default Baud-Rate Provided

294D  CD 8329           	CALL	ABR			; AUTO SET BAUD RATE
2950  7C                	MOV	A,H
2951  E6 80             	ANI	10000000B
2953  CA 5E29           	JZ	FCU0
2956  3A D720           	LDA	S.CONTY
2959  F6 08             	ORI	CTP.2SB
295B  32 D720           	STA	S.CONTY 		; SET TWO STOP BITS
295E  3E 01             FCU0	MVI	A,CDB.H84

                        *	HAVE TYPE AND BAUDRATE.
                        *	(A) = S.CDB VALUE
                        *	(HL) = BAUD RATE (0 IF 8251)

2960  22 E420           FCU1	SHLD	S.BAUD
2963  32 E320           	STA	S.CDB
2966  C3 622A           	JMP	SCU
2969                    	SPACE	4,10
                        **	RCC	- Read Console Character
                        *
                        *	RCC reads a console character from the console
                        *	flagged by S.CDB.  The difference between this
                        *	read and that of $ICTT is that the break status
                        *	of each of the UARTS is checked while waiting
                        *	for a character.
                        *
                        *	ENTRY:	BC	= Time-Out Counter
                        *		S.CDB set up
                        *
                        *	EXIT:	PSW	= 'C' if
                        *				Baud-Rate Changed
                        *			  'NC' if
                        *				Character
                        *				Time-Out
                        *			    C = Time-Out counter == 0 for Time-Out
                        *			    A  = Character read
                        *
                        *	USES:	PSW,BC
                        *

2969  CD DC28           RCC	CALL	CBS
296C  37                	STC
296D  C0                	RNZ				; No character read, UART re-initialized

296E  79                	MOV	A,C
296F  A7                	ANA	A
2970  C8                	RZ				; Time-Out

2971  C3 7827           	JMP	$ICTT			; Input the character
2974                    	XTEXT	CPDEHL			; Make sure only ABR uses this!
2974                    	SPACE	4,10
                        ***	CPDEHL - Compare (HL) to (DE)
                        *
                        *	Entry:	NONE
                        *	Exit:	'C' Set if (HL) < (DE)
                        *		'Z' Set if (HL) = (DE)
                        *		 else (HL) > (DE)
                        *	Uses:	A,F

2974  7C                CPDEHL	MOV	A,H
2975  BA                	CMP	D
2976  C0                	RNZ
2977  7D                	MOV	A,L
2978  BB                	CMP	E
2979  C9                	RET
297A                    	XTEXT	MCU
297A                    	SPACE	4,10
                        **	MCU - MAP LOWER CASE TO UPPER CASE.
                        *
                        *	MCU MAPS A LOWER CASE ALPHABETIC TO UPPER
                        *	CASE.
                        *
                        *	ENTRY	(A) = CHARACTER
                        *	EXIT	(A) = CHARACTER RESULT
                        *	USES	A,F

297A  FE 61             $MCU	CPI	'a'
297C  D8                	RC				; NOT LOWER CASE
297D  FE 7B             	CPI	'z'+1
297F  D0                	RNC				; NOT LOWER CASE
2980  D6 20             	SUI	'a'-'A'
2982  C9                	RET
2983                    	XTEXT	ABR
2983                    	SPACE	4,10
                        **	ABR - AUTO BAUD RATE SELECTION.
                        *
                        *	ABR READS CHARACTERS FROM THE SYSTEM CONSOLE ACE UNTIL
                        *	THE CURRENT BAUD RATE IS DETERMINED.
                        *
                        *	ENTRY	NONE
                        *	EXIT	(HL) = BAUD RATE DIVISOR
                        *		ACE SETUP WITH BAUD RATE, NO INTERRUPTS
                        *	USES	ALL

      = 2983            ABR	EQU	*

                        *	INITIALIZE LED DISPLAY FOR PROMPT

2983  3A 0820           ABR0.1	LDA	.MFLAG
2986  F5                	PUSH	PSW
2987  F6 02             	ORI	UO.DDU
2989  32 0820           	STA	.MFLAG
298C  01 0900           	LXI	B,9
298F  11 212A           	LXI	D,ABR.A
2992  21 0B20           	LXI	H,.ALEDS
2995  CD AA18           	CALL	$MOVE
2998  11 0B20           	LXI	D,.ALEDS
299B  3E 64             	MVI	A,100
      = 0260            .HORN	EQU	002140A
299D  CD 6002           	CALL	.HORN

29A0  21 2A2A           	LXI	H,TABLE

29A3  AF                ABR0.3	XRA	A
29A4  D3 E9             	OUT	SC.ACE+UR.IER
29A6  3E 10             	MVI	A,UC.LOO
29A8  D3 EC             	OUT	SC.ACE+UR.MCR		; SET LOOP BACK
29AA  3E 80             	MVI	A,UC.DLA
29AC  D3 EB             	OUT	SC.ACE+UR.LCR		; LINE CONTROL ACCESS
29AE  7E                	MOV	A,M
29AF  23                	INX	H
29B0  D3 E8             	OUT	SC.ACE+UR.DLL		; DIVISOR LEAST SIGNIFICANT
29B2  7E                	MOV	A,M
29B3  E6 7F             	ANI	177Q			; CLEAR STOP BITS FLAG
29B5  D3 E9             	OUT	SC.ACE+UR.DLM		; DIVISOR MOST SIGNIFICANT
29B7  BE                	CMP	M			; SEE IF 2 STOP BITS
29B8  23                	INX	H
29B9  3E 03             	MVI	A,UC.8BW		; ASSUME 8 BIT WORDS, 1 STOP
29BB  CA C029           	JE	ABR0.5
29BE  3E 07             	MVI	A,UC.8BW+UC.2SB 	; SET 2 STOP BITS
29C0  D3 EB             ABR0.5	OUT	SC.ACE+UR.LCR		; LINE CONTROL ACCESS
29C2  3E 6E             	MVI	A,AC.DLY
29C4  CD 2B00           	CALL	.DLY			; WAIT FOR 8250 TO SETTLE
29C7  DB EC             	IN	SC.ACE+UR.MCR
29C9  E6 EF             	ANI	377Q-UC.LOO
29CB  D3 EC             	OUT	SC.ACE+UR.MCR		; TURN OFF LOOP

                        *	WAIT FOR CHARACTER TO BE HIT

29CD  DB E8             ABR0	IN	SC.ACE+UR.RBR		; GOBBLE OVERRUN
29CF  DB ED             ABR1	IN	SC.ACE+UR.LSR
                        	ERRNZ	UC.OR-2
29D1  1F                	RAR
29D2  1F                	RAR
29D3  DA CD29           	JC	ABR0			; OVERRUN
29D6  17                	RAL
29D7  17                	RAL
29D8  E6 0D             	ANI	UC.DR+UC.PE+UC.FE
29DA  CA CF29           	JZ	ABR1			; NOTHING YET
29DD  F5                	PUSH	PSW
29DE  1A                	LDAX	D			; ECHO ' ' AS '.' ON LEDS
29DF  E6 7F             	ANI	01111111B		; TURN ON '.'
29E1  12                	STAX	D
29E2  13                	INX	D
29E3  F1                	POP	PSW
29E4  E6 08             	ANI	UC.FE
29E6  C2 FB29           	JNZ	ABR3			; USER IS SLOWER THAN THIS
29E9  DB E8             	IN	SC.ACE+UR.RBR		; GET DATA
29EB  E6 7F             	ANI	177Q			; TRIM
29ED  FE 20             	CPI	' '
29EF  CA 082A           	JE	ABR5
29F2  FE 0D             	CPI	CR			; also accept CR		/3.0a/
29F4  CA 082A           	JE	ABR5						;/3.0a/

                        *	USER IS FASTER THAN WE ARE. FOLLOW FASTER LINKAGE

29F7  6E                ABR2	MOV	L,M			; FOLLOW LINK
29F8  C3 A329           	JMP	ABR0.3			; TRY AGAIN

                        *	USER IS SLOWER THAN WE ARE. READ NEXT CHARACTER

29FB  3E 37             ABR3	MVI	A,110/2
29FD  CD 2B00           	CALL	.DLY			; WAIT FOR THINGS TO SETTLE OUT
2A00  DB E8             	IN	SC.ACE+UR.RBR
2A02  DB ED             	IN	SC.ACE+UR.LSR
2A04  23                	INX	H
2A05  C3 F729           	JMP	ABR2

                        *	FOUND THE BAUD RATE. RETURN WITH ANSWERS

2A08  11 0B20           ABR5	LXI	D,.ALEDS		; BLANK DISPLAY
2A0B  06 09             	MVI	B,9
2A0D  3E FF             	MVI	A,377A
2A0F  12                ABR5.1	STAX	D
2A10  13                	INX	D
2A11  05                	DCR	B
2A12  C2 0F2A           	JNZ	ABR5.1
2A15  2B                	DCX	H
2A16  56                	MOV	D,M
2A17  2B                	DCX	H
2A18  5E                	MOV	E,M
2A19  EB                	XCHG				; (HL) = BAUD RATE
2A1A  DB E8             	IN	SC.ACE+UR.RBR		; GOBBLE THE GARBAGE
2A1C  F1                	POP	PSW
2A1D  32 0820           	STA	.MFLAG
2A20  C9                	RET

                        *	'SPACE' for LEDS

2A21  A498908D 8CFFFFFF ABR.A	DB	244Q,230Q,220Q,215Q,214Q,377Q,377Q,377Q,377Q
2A29  FF
2A2A                    	SPACE	4,10
                        **	BAUD RATE SELECTION TREE.
                        *
                        *	Added 38400 baud						/3.0a/

      = 002A            .	SET	#*
                        	IFT	(256-.)<(14*4)
                        	ENDIF

      = 2A2A            TABLE	EQU	*			; START OF BAUD TABLE

2A2A  3000              	DW	000060A 		; 2400 BAUD
2A2C  2E                	DB	#T9600			; USER IS FASTER
2A2D  32                	DB	#T600			; USER IS SLOWER

                        *	2ND TRY GROUPS

2A2E  0C00              T9600	DW	000014A 		; 9600 BAUD
2A30  36                	DB	#T19200 		; USER IS FASTER
2A31  3A                	DB	#T4800			; USER IS SLOWER

2A32  C000              T600	DW	000300A 		; 600 BAUD
2A34  3E                	DB	#T1200			; USER IS FASTER
2A35  42                	DB	#T300			; USER IS SLOWER

                        *	3RD TRY GROUPS

2A36  0600              T19200	DW	000006A 		; 19200 BAUD
2A38  46                	DB	#T38400 		; USER IS FASTER		/3.0a/
2A39  2A                	DB	#TABLE			; USER IS SLOWER, IS ERROR

2A3A  1800              T4800	DW	000030A 		; 4800 BAUD
2A3C  4A                	DB	#T7200			; USER IS FASTER
2A3D  4E                	DB	#T3600			; USER IS SLOWER

2A3E  6000              T1200	DW	000140A 		; 1200 BAUD
2A40  52                	DB	#T1800			; USER IS FASTER
2A41  2A                	DB	#TABLE			; USER IS SLOWER, IS ERROR

2A42  8001              T300	DW	001200A 		; 300 BAUD
2A44  2A                	DB	#TABLE			; USER IS FASTER, IS ERROR
2A45  56                	DB	#T110			; USER IS SLOWER

                        *	4TH TRY GROUPS

2A46  0300              T38400	DW	000003A 		; 38400 baud			/3.0a/
2A48  2A                	DB	#TABLE			; USER IS FASTER, IS ERROR	/3.0a/
2A49  2A                	DB	#TABLE			; USER IS SLOWER, IS ERROR	/3.0a/

2A4A  1000              T7200	DW	000020A 		; 7200 BAUD
2A4C  2A                	DB	#TABLE			; USER IS FASTER, IS ERROR
2A4D  2A                	DB	#TABLE			; USER IS SLOWER, IS ERROR

2A4E  2000              T3600	DW	000040A 		; 3600 BAUD
2A50  2A                	DB	#TABLE			; USER IS FASTER, IS ERROR
2A51  2A                	DB	#TABLE			; USER IS SLOWER, IS ERROR

2A52  4000              T1800	DW	000100A 		; 1800 BAUD
2A54  2A                	DB	#TABLE			; USER IS FASTER, IS ERROR
2A55  2A                	DB	#TABLE			; USER IS SLOWER, IS ERROR

2A56  1784              T110	DW	204027A 		; 110 BAUD
2A58  5A                	DB	#T150			; USER IS FASTER
2A59  5E                	DB	#T75			; USER IS SLOWER

                        *	5TH TRY GROUPS

2A5A  0003              T150	DW	003000A 		; 150 BAUD
2A5C  2A                	DB	#TABLE			; USER IS FASTER, IS ERROR
2A5D  2A                	DB	#TABLE			; USER IS SLOWER, IS ERROR

2A5E  0006              T75	DW	006000A 		; 75 BAUD
2A60  2A                	DB	#TABLE			; USER IS FASTER, IS ERROR
2A61  2A                	DB	#TABLE			; USER IS SLOWER, IS ERROR

      = 002A            .	SET	*/256
                        	ERRNZ	TABLE/256-.		; MUST BE IN SAME PAGE
                        	ERRNZ	*-TABLE/4-14
2A62                    	XTEXT	SCU
2A62                    	SPACE	4,10
                        **	SCU - SETUP CONSOLE USART.
                        *
                        *	SCU CONFIGURES THE CONSOLE USART.
                        *
                        *	IF 8250
                        *	  THEN	PORT = 350-7Q
                        *	  ELSE	PORT = 372-3Q
                        *
                        *	ENTRY:	NONE
                        *	EXIT:	NONE
                        *	USES:	A,F,B,C,H,L

2A62  3A E320           SCU	LDA	S.CDB
2A65  FE 01             	CPI	CDB.H84
2A67  CA 8A2A           	JZ	SCU1			; IF 8250

                        *	PRESET 8251

2A6A  3E 81             	MVI	A,201Q
2A6C  D3 FB             	OUT	SC.UART+USR		; GET USART IN KNOWN STATE
2A6E  D3 FB             	OUT	SC.UART+USR
2A70  D3 FB             	OUT	SC.UART+USR
2A72  D3 FB             	OUT	SC.UART+USR
2A74  3E 40             	MVI	A,UCI.IR		; RESET
2A76  D3 FB             	OUT	SC.UART+USR
2A78  3A D720           	LDA	S.CONTY
2A7B  E6 08             	ANI	CTP.2SB
                        	ERRNZ	CTP.2SB*16+UMI.1B-UMI.2B
2A7D  07                	RLC
2A7E  07                	RLC
2A7F  07                	RLC
2A80  07                	RLC
2A81  F6 4E             	ORI	UMI.1B+UMI.L8+UMI.16X
2A83  D3 FB             	OUT	SC.UART+USR
2A85  3E 15             	MVI	A,UCI.ER+UCI.RE+UCI.TE
2A87  D3 FB             	OUT	SC.UART+USR
2A89  C9                	RET

                        *	IS 8250

2A8A  DB ED             SCU1	IN	SC.ACE+UR.LSR
2A8C  E6 40             	ANI	UC.TSE			; CHECK FOR SHIFT EMPTY
2A8E  CA 8A2A           	JZ	SCU1

2A91  AF                	XRA	A
2A92  D3 E9             	OUT	SC.ACE+UR.IER		; TURN OFF ANY INTERRUPTS
2A94  3E 17             	MVI	A,UC.LOO+UC.DTR+UC.RTS+UC.OU1			;/3.0a/
2A96  D3 EC             	OUT	SC.ACE+UR.MCR
2A98  2A E420           	LHLD	S.BAUD
2A9B  3E 80             	MVI	A,UC.DLA
2A9D  D3 EB             	OUT	SC.ACE+UR.LCR		; ACCESS DIVISOR LATCHES
2A9F  7D                	MOV	A,L
2AA0  D3 E8             	OUT	SC.ACE+UR.DLL		; SET LEAST SIGNIFICANT
2AA2  7C                	MOV	A,H
2AA3  E6 7F             	ANI	177Q			; TRIM STOP BITS
2AA5  D3 E9             	OUT	SC.ACE+UR.DLM		; SET MOST SIGNIFICANT
2AA7  3A D720           	LDA	S.CONTY
2AAA  E6 08             	ANI	CTP.2SB
2AAC  0F                	RRC
                        	ERRNZ	CTP.2SB/2-UC.2SB
                        	ERRNZ	UC.2SB-4		; (A) = UC.2SB IF 2 STOP BITS
2AAD  F6 03             	ORI	UC.8BW			; 8 BIT WORDS
2AAF  D3 EB             	OUT	SC.ACE+UR.LCR
2AB1  3E 6E             	MVI	A,AC.DLY
2AB3  CD 2B00           	CALL	.DLY
2AB6  DB E8             	IN	SC.ACE+UR.RBR		; GOBBLE ANY TRASH
2AB8  DB EC             	IN	SC.ACE+UR.MCR
2ABA  E6 EF             	ANI	377Q-UC.LOO
2ABC  D3 EC             	OUT	SC.ACE+UR.MCR
2ABE  C9                	RET
2ABF                    	STL	'BOOT MEMORY USAGE CALCULATIONS AND BUFFERS'
2ABF                    	EJECT
      = 0700            T0BOOTL EQU	*-T0BOOT+255/256*256	; T0BOOT LENGTH IN SECTORS

                        	ERRPL	SB.SDB-SB.BOO+T0BOOTL+255/256-DDF.BOL-1

                        	ERRPL	*-SB.ORG		; MUST BE BEFORE ORG ADDRESS

2ABF                    	NOTE	*-T0BOOT		; length (in bytes)

      = 2ABF            BLABEL	EQU	*			; LABEL BUFFER STARTS HERE

                        	ERRPL	BLABEL+256-SB.ORG	; ensure room for label data, too!

      = 2BBF            BUFF	EQU	BLABEL+256		; 10 SECTOR BUFFER
      = 35BF            BOOEND	EQU	10*256+BUFF		; BUFFER ENDS HERE

                        	ERRMI	INITVEC-*
2ABF  41414141 41414141 	DC	INITVEC-*,##INITVEC-*
2AC7  41414141 41414141
2ACF  41414141 41414141
2AD7  41414141 41414141
2ADF  41414141 41414141
2AE7  41414141 41414141
2AEF  41414141 41414141
2AF7  41414141 41414141
2AFF  41414141 41414141
2B07  41414141 41414141
2B0F  41414141 41414141
2B17  41414141 41414141
2B1F  41414141 41414141
2B27  41414141 41414141
2B2F  41414141 41414141
2B37  41414141 41414141
2B3F  41414141 41414141
2B47  41414141 41414141
2B4F  41414141 41414141
2B57  41414141 41414141
2B5F  41414141 41414141
2B67  41414141 41414141
2B6F  41414141 41414141
2B77  41414141 41414141
2B7F  41414141 41414141
2B87  41414141 41414141
2B8F  41414141 41414141
2B97  41414141 41414141
2B9F  41414141 41414141
2BA7  41414141 41414141
2BAF  41414141 41414141
2BB7  41414141 41414141
2BBF  41414141 41414141
2BC7  41414141 41414141
2BCF  41414141 41414141
2BD7  41414141 41414141
2BDF  41414141 41414141
2BE7  41414141 41414141
2BEF  41414141 41414141
2BF7  41414141 41414141
2BFF  41

2C00                    	STL	'INIT Vectors for Shared Routines'
2C00                    	EJECT
                        ***	INIT Vectors for Shared Routines
                        *

                        	ERRNZ	INITVEC-*						

                        *	ORG	INITVEC

                        	ERRNZ	*-$$VER
2C00  30                	DB	VERS

                        	ERRNZ	*-$$BITC
2C01  C3 F236           	JMP	BITC

                        	ERRNZ	*-$$BITS
2C04  C3 0137           	JMP	BITS

                        	ERRNZ	*-$$BUFF
2C07  003D              	DW	GRTAB

                        	ERRNZ	*-$$CHL
2C09  C3 9418           	JMP	$CHL

                        	ERRNZ	*-$$CNO
2C0C  C3 9B34           	JMP	CNO

                        	ERRNZ	*-$$CYS
2C0F  C3 A934           	JMP	CYS

                        	ERRNZ	*-$$DRVR
2C12  C3 0C35           	JMP	DRIVER

                        	ERRNZ	*-$$DRVR.
2C15  C3 2435           	JMP	DRIVER.

                        	ERRNZ	*-$$ITL.
2C18  C3 3F38           	JMP	$ITL.

                        	ERRNZ	*-$$MOVE
2C1B  C3 AA18           	JMP	$MOVE

                        	ERRNZ	*-$$TBRA
2C1E  C3 3E19           	JMP	$TBRA

                        	ERRNZ	*-$$TYPTX
2C21  C3 5E19           	JMP	$TYPTX

                        	ERRNZ	*-$$VSN
2C24  C3 E936           	JMP	VSN

                        	ERRNZ	*-$$RBS
2C27  C3 EE36           	JMP	RBS

                        	ERRNZ	*-$$MAX
2C2A                    	STL	'MAIN INITIALIZE ROUTINE'
2C2A                    	EJECT
                        ***	INIT - MAIN INITIALIZE LOOP.
                        *

2C2A                    	LOF	C			; RESTORE LISTING CONTROL

                        *	RESTART HERE TO INIT NEW DISK

2C2A  31 8022           RESTART LXI	SP,STACK

2C2D  CD A62C           	CALL	AMW			; ASK IF MORE WORK WANTED
2C30  C2 832C           	JNZ	EXIT			; ALL DONE

2C33  31 8022           INIT0	LXI	SP,STACK
2C36  CD FD2C           	CALL	PDN			; Parse Device Name
2C39  DA 2A2C           	JC	RESTART

2C3C  31 8022           INIT1	LXI	SP,STACK
2C3F  CD 992D           	CALL	RMI			; REQUEST MEDIA INSERTION
2C42  DA 332C           	JC	INIT0

2C45  CD B52E           	CALL	AAL			; ASK ABOUT LABEL
2C48  C2 3C2C           	JNZ	INIT1			; Not OKAY to INIT diskette

2C4B  CD C72F           	CALL	GVI			; GET VOLUME ID
2C4E  CD B030           	CALL	IDS			; INIT DISK SURFACE
2C51  DA 3C2C           	JC	INIT1			; Error Initializing Disk
2C54  CD FA30           	CALL	GBL			; GET BAD SECTOR LIST

2C57  CD D731           	CALL	FOV			; FORMAT VOLUME
2C5A  DA 3C2C           	JC	INIT1			; ERROR

2C5D  CD 5E19           	CALL	$TYPTX
2C60  0A                	DB	NL
2C61  20446973 6B20496E 	DB	' Disk Initialization complete.',ENL
2C69  69746961 6C697A61
2C71  74696F6E 20636F6D
2C79  706C6574 652E8A
2C80  C3 3C2C           	JMP	INIT1

                        *	EXIT

2C83  AF                EXIT	XRA	A
2C84  FF 00             EXIT.	SCALL	.EXIT			; LET HDOS HANDLE THE EXIT PARAMETERS
2C86                    	SPACE	4,10
                        **	ERROR - ERROR ENCOUNTERED.

2C86  CD 8E2C           ERROR	CALL	ERROR1
2C89  3E 01             	MVI	A,1			; Abort
2C8B  C3 842C           	JMP	EXIT.

2C8E  F5                ERROR1	PUSH	PSW
2C8F  CD 1037           	CALL	$CCO			; CLEAR CTL-O
2C92  CD 5E19           	CALL	$TYPTX
2C95  0A074572 726F7220 	DB	NL,BELL,'Error - ',' '+EOL
2C9D  2D20A0
2CA0  F1                	POP	PSW
2CA1  26 0A             	MVI	H,NL
2CA3  FF 2F             	SCALL	.ERROR
2CA5  C9                	RET
2CA6                    	STL	'AMW - ASK FOR MORE WORK'
2CA6                    	EJECT
                        **	AMW - ASK FOR MORE WORK.
                        *
                        *	AMW SEES IF THE USER WANTS TO CONTINUE THE PROCESS.
                        *
                        *	ENTRY	NONE
                        *	EXIT	'Z' CLEAR IF  NO MORE WORK
                        *		'Z' SET IF MORE WORK
                        *	USES	ALL

      = 2CA6            AMW	EQU	*

2CA6  CD 1037           AMW1	CALL	$CCO			; CLEAR CTL-O
2CA9  CD 5E19           	CALL	$TYPTX
2CAC  0A                	DB	NL
2CAD  446F2079 6F752068 	DB	'Do you have any more disks to initialize (YES/NO) <NO> '
2CB5  61766520 616E7920
2CBD  6D6F7265 20646973
2CC5  6B732074 6F20696E
2CCD  69746961 6C697A65
2CD5  20285945 532F4E4F
2CDD  29203C4E 4F3E20
2CE4  BF                	DB	'?'+EOL
2CE5  CD 3F38           	CALL	$ITL.
2CE8  DA A62C           	JC	AMW1			; CTL-D HIT

2CEB  7E                	MOV	A,M			; (A) = REPLY
2CEC  A7                	ANA	A
2CED  CA FA2C           	JZ	AMW2			; took the default

2CF0  CD A934           	CALL	CYS			; Check for Yes
2CF3  C8                	RE				; IS YES

2CF4  CD 9B34           	CALL	CNO			; Check for NO
2CF7  C2 A62C           	JNZ	AMW1			; Ask Again

2CFA  F6 01             AMW2	ORI	1			; ANSWER IS NO
2CFC  C9                	RET
2CFD                    	STL	'PDN	- Parse Device Name'
2CFD                    	EJECT
                        **	PDN	- Parse Device Name
                        *
                        *	PDN parses the device name, assuming the default of SY0:.
                        *
                        *	ENTRY:	NONE
                        *
                        *	EXIT:	PSW	= 'C' SET   if CTL-D hit
                        *			  'C' CLEAR if valid device input
                        *			   CRNDEV = address of device entry
                        *			   UNIT   = unit
                        *
                        *	USES:	ALL
                        *

2CFD  CD 1037           PDN	CALL	$CCO			; Clear CTL-O
2D00  CD 5E19           	CALL	$TYPTX
2D03  0A                	DB	NL
2D04  44657669 6365203C 	DB	'Device <SY0:> ?',' '+EOL
2D0C  5359303A 3E203FA0

2D14  CD 4538           	CALL	$ITL
2D17  D8                	RC				; CTL-D hit

2D18  21 9738           	LXI	H,ITLA			; HL = address of device specification
2D1B  01 902D           PDN.	LXI	B,PDNA			; Decode area
2D1E  11 932D           	LXI	D,PDNC			; Default device
2D21  CD BC34           	CALL	DDS
2D24  DA 6C2D           	JC	PDN3

2D27  11 902D           	LXI	D,PDNA
2D2A  21 E838           	LXI	H,DEVTAB

2D2D  D5                PDN1	PUSH	D
2D2E  11 1039           	LXI	D,DEVTABE
2D31  CD 7429           	CALL	CPDEHL
2D34  D1                	POP	D
2D35  D2 6C2D           	JNC	PDN3

2D38  0E 02             	MVI	C,2
2D3A  D5                	PUSH	D
2D3B  E5                	PUSH	H
2D3C  CD 3018           	CALL	$COMP
2D3F  E1                	POP	H
2D40  D1                	POP	D			; Save the pointers
2D41  CA 4B2D           	JZ	PDN2			; Found Device

                        *	Device not found in this entry

2D44  01 0A00           	LXI	B,DVT.ENL
2D47  09                	DAD	B
2D48  C3 2D2D           	JMP	PDN1

                        *	Device entry found

2D4B  22 8638           PDN2	SHLD	CRNDEV
2D4E  3A 922D           	LDA	PDNB
2D51  32 9638           	STA	UNIT
2D54  47                	MOV	B,A			; B  = unit number
2D55  CD 9C18           	CALL	$INDL
2D58  0400              	DW	DVT.ADR
2D5A  EB                	XCHG				; HL = device table pointer
2D5B  CD 4C37           	CALL	$INDLB
2D5E  0800              	DW	DEV.MNU
2D60  3D                	DCR	A
2D61  B8                	CMP	B
2D62  DA 6C2D           	JC	PDN3			; Unit Number is NOT valid

2D65  CD E135           	CALL	RPB			; Relocate Primary Boot
2D68  CD 6135           	CALL	IVP			; Initialize Volume Parameters
2D6B  C9                	RET

                        *	Illegal Device Specification

2D6C  CD 5E19           PDN3	CALL	$TYPTX
2D6F  0A                	DB	NL
2D70  496C6C65 67616C20 	DB	'Illegal Device Specification'
2D78  44657669 63652053
2D80  70656369 66696361
2D88  74696F6E
2D8C  8A                	DB	ENL
2D8D  C3 FD2C           	JMP	PDN			; get another device

2D90  5858              PDNA	DB	'XX'
2D92  00                PDNB	DB	0
                        	ERRNZ	IOC.UNI-IOC.DEV-2	; 2 byte device
                        	ERRNZ	IOC.DIR-IOC.UNI-1	; 1 byte unit

2D93  53593000 0000     PDNC	DB	'SY0',0,0,0		; Default device
2D99                    	STL	'RMI - REQUEST MEDIA INSERTION'
2D99                    	EJECT
                        **	RMI - REQUEST MEDIA INSERTION.
                        *
                        *	RMI PROMPTS THE USR TO LOAD THE DESIRED MEDIA.
                        *
                        *	WHEN IN PLACE, RMI CHECKS THE HOLE TIMINGS
                        *
                        *	ENTRY	NONE
                        *
                        *	EXIT	PSW	= 'C' SET   if ERROR
                        *			  'C' CLEAR if NO ERROR
                        *
                        *	USES	ALL
                        *

      = 2D99            RMI	EQU	*

                        *	Stuff Device Descriptors

2D99  2A 8638           	LHLD	CRNDEV
2D9C  CD 9C18           	CALL	$INDL
2D9F  0000              	DW	DVT.NAM
2DA1  EB                	XCHG
2DA2  22 E62D           	SHLD	RMIA
2DA5  3A 9638           	LDA	UNIT
2DA8  32 3121           	STA	AIO.UNI
2DAB  C6 30             	ADI	'0'
2DAD  32 E82D           	STA	RMIB

                        *	Prompt for the new volume

2DB0  CD 1037           RMI1	CALL	$CCO
2DB3  CD 5E19           	CALL	$TYPTX
2DB6  0A                	DB	NL
2DB7  20496E73 65727420 	DB	' Insert the volume you wish to initialize into '
2DBF  74686520 766F6C75
2DC7  6D652079 6F752077
2DCF  69736820 746F2069
2DD7  6E697469 616C697A
2DDF  6520696E 746F20
2DE6  5359              RMIA	DB	'SY'
2DE8  303A3B0A          RMIB	DB	'0:;',NL
2DEC  2072656D 656D6265 	DB	' remember, any data on this volume will be destroyed.',NL
2DF4  722C2061 6E792064
2DFC  61746120 6F6E2074
2E04  68697320 766F6C75
2E0C  6D652077 696C6C20
2E14  62652064 65737472
2E1C  6F796564 2E0A
2E22  0A                	DB	NL
2E23  48697420 52455455 	DB	'Hit RETURN when ready.',NL
2E2B  524E2077 68656E20
2E33  72656164 792E0A
2E3A  52656164 793FA0   	DB	'Ready?',' '+EOL

2E41  CD 4538           	CALL	$ITL
2E44  D8                	RC				; Abort

2E45  CD 3936           	CALL	SUBFUN			; Check Media Validity
2E48  00                	DB	INI.CMV
2E49  D0                	RNC				; Good

                        *	ERROR IN MEDIA FORMAT.

2E4A  CD 5E19           	CALL	$TYPTX
2E4D  0A072057 726F6E67 	DB	NL,BELL,' Wrong type of media, media inserted improperly, or'
2E55  20747970 65206F66
2E5D  206D6564 69612C20
2E65  6D656469 6120696E
2E6D  73657274 65642069
2E75  6D70726F 7065726C
2E7D  792C206F 72
2E82  0A206D65 64696120 	DB	NL,' media damaged. Please check it and try again.',ENL
2E8A  64616D61 6765642E
2E92  20506C65 61736520
2E9A  63686563 6B206974
2EA2  20616E64 20747279
2EAA  20616761 696E2E8A
2EB2  C3 B02D           	JMP	RMI1
2EB5                    	STL	'AAL - ASK ABOUT LABEL'
2EB5                    	EJECT
                        **	AAL - ASK ABOUT LABEL.
                        *
                        *	AAL ATTEMPTS TO READ THE VOLUME LABEL RECORD. IF SUCCESSFUL, THE
                        *	VOLUME # AND LABEL ARE PRINTED. THE USER GETS A CHANCE TO
                        *	CHICKEN OUT.
                        *
                        *	ENTRY	NONE
                        *
                        *	EXIT:	PSW	= 'Z' SET   if OKAY to init diskette
                        *			  'Z' CLEAR if NOT OKAY to init diskette
                        *
                        *	USES	ALL
                        *

2EB5  CD 0C35           AAL	CALL	DRIVER			; RESET DISK
2EB8  07                	DB	DC.ABT

2EB9  21 0000           	LXI	H,0
2EBC  CD 9B35           	CALL	MOUNT.. 		; Set Volume 0

2EBF  CD 5E19           	CALL	$TYPTX
2EC2  0A546865 20766F6C 	DB	NL,'The volume now in the drive ...',ENL
2ECA  756D6520 6E6F7720
2ED2  696E2074 68652064
2EDA  72697665 202E2E2E
2EE2  8A
2EE3  11 003E           	LXI	D,RGTAB 		; USE RGTAB FOR SCRATCH BUFFER
2EE6  01 0001           	LXI	B,256
2EE9  21 0900           	LXI	H,DDF.LAB
2EEC  CD 0C35           	CALL	DRIVER			; READ LABEL SECTOR
2EEF  02                	DB	DC.RER
2EF0  D2 252F           	JNC	AAL1			; OK

                        *	COULDNT READ IT

2EF3  CD 5E19           	CALL	$TYPTX
2EF6  41707061 72656E74 	DB	'Apparently has not been initialized before.',ENL
2EFE  6C792068 6173206E
2F06  6F742062 65656E20
2F0E  696E6974 69616C69
2F16  7A656420 6265666F
2F1E  72652E8A
2F22  C3 652F           	JMP	AAL2

                        *	COULD READ IT. TYPE DISK NUMBER AND LABEL

2F25  CD 5E19           AAL1	CALL	$TYPTX
2F28  69732076 6F6C756D 	DB	'is volume #',' '+EOL
2F30  652023A0

2F34  3A 093E           	lda	rgtab+LAB.VER		; version of INIT that made it	
2F37  FE 30             	cpi	3*16+0			; early version?
2F39  3A 003E           	lda	rgtab+LAB.SER
2F3C  5F                	mov	e,a
2F3D  16 00             	mvi	d,0			; (de) = short volume number
2F3F  DA 462F           	jc	aal1.5			; is before 3.0

2F42  2A 503E           	lhld	rgtab+LAB.LVN
2F45  EB                	xchg				; (de) = long volume number

2F46  3E 05             aal1.5	mvi	a,5
2F48  CD 4D38           	CALL	$TDD			; TYPE DECIMAL DIGITS
2F4B  CD 5E19           	CALL	$TYPTX
2F4E  0A204C61 62656C20 	DB	NL,' Label = ','"'+EOL
2F56  3D20A2
2F59  3E 3C             	MVI	A,LAB.LBL
2F5B  21 113E           	LXI	H,RGTAB+LAB.LAB
2F5E  CD 0938           	CALL	$TYPL.			; TYPE LABEL
2F61  CD 5E19           	CALL	$TYPTX
2F64  A2                	DB	'"'+EOL

                        *	GIVE CHANCE TO CHICKEN OUT

2F65  CD 1037           AAL2	CALL	$CCO			; CLEAR CTL-O
2F68  CD 5E19           	CALL	$TYPTX
2F6B  0A547970 65204E4F 	DB	NL,'Type NO to cancel, type YES to erase'
2F73  20746F20 63616E63
2F7B  656C2C20 74797065
2F83  20594553 20746F20
2F8B  65726173 65
2F90  20616E64 20696E69 	DB	' and initialize the disk. (YES/NO) ','?'+EOL
2F98  7469616C 697A6520
2FA0  74686520 6469736B
2FA8  2E202859 45532F4E
2FB0  4F2920BF
2FB4  CD 3F38           	CALL	$ITL.
2FB7  DA C42F           	JC	AAL3			; CTL-D hit

2FBA  CD A934           	CALL	CYS
2FBD  C8                	RZ				; IS OKAY TO INIT

2FBE  CD 9B34           	CALL	CNO
2FC1  C2 652F           	JNZ	AAL2			; Not a valid response

2FC4  F6 01             AAL3	ORI	1
2FC6  C9                	RET				; Exit without OK
2FC7                    	STL	'GVI - GET VOLUME ID.'
2FC7                    	EJECT
                        **	GVI - GET VOLUME ID.
                        *
                        *	GVI GETS A NEW VOLUME SERIAL NUMBER AND AN OPTIONAL VOLUME LABEL.
                        *
                        *	ENTRY	NONE
                        *	EXIT	LABEL+LAB.SER = VOLUME SERIAL #
                        *		LABEL+LAB.LAB = 60 CHARACTER VOLUME LABEL
                        *	USES	ALL

      = 2FC7            GVI	EQU	*

2FC7  CD 1037           	CALL	$CCO			; CLEAR CTL-O
2FCA  CD 5E19           	CALL	$TYPTX
2FCD  0A456E74 65722061 	DB	NL,'Enter a unique volume serial number from '
2FD5  20756E69 71756520
2FDD  766F6C75 6D652073
2FE5  65726961 6C206E75
2FED  6D626572 2066726F
2FF5  6D20
                        	IFT	VOLZERO
2FF7  30                	DB	'0'
                        	ELSE
                        	ENDIF
2FF8  20746F20 36353533 	DB	' to 65535:',' '+EOL				;/3.0a/
3000  353AA0
3003  CD 3E37           	CALL	$IDN			; INPUT DECIMAL NUMBER
3006  DA C72F           	JC	GVI			; BAD RANGE
                        	IFF	VOLZERO 					;/3.0a/
                        	ENDIF								/3.0a/

3009  7D                	MOV	A,L			; low order part		/3.0a/
300A  32 1139           	STA	LABEL+LAB.SER		; set it			/3.0a/
300D  22 6139           	SHLD	LABEL+LAB.LVN		; set long number, too. 	/3.0a/

                        *	GET LABEL

3010  CD 1037           GVI1	CALL	$CCO			; CLEAR CTL-O
3013  CD 5E19           	CALL	$TYPTX
3016  456E7465 72206120 	DB	'Enter a volume label of 60 characters or less:',NL
301E  766F6C75 6D65206C
3026  6162656C 206F6620
302E  36302063 68617261
3036  63746572 73206F72
303E  206C6573 733A0A
3045  20202020 20202020 	DB	'                              '
304D  20202020 20202020
3055  20202020 20202020
305D  20202020 2020
3063  20202020 20202020 	DB	'                              <',CR+EOL
306B  20202020 20202020
3073  20202020 20202020
307B  20202020 20203C8D

3083  CD 4538                   CALL    $ITL
3086  EB                	XCHG				; (DE) = LINE ADDRESS
3087  21 2239           	LXI	H,LABEL+LAB.LAB 	; (HL) = TO ADDRESS

                        *	COPY FROM LINE TO LABEL+LAB.LAB, BLANK FILL OUT TO 60 CHARACTERS

308A  06 3D             	MVI	B,61
308C  1A                GVI2	LDAX	D
308D  77                	MOV	M,A			; COPY
308E  13                	INX	D
308F  A7                	ANA	A
3090  CA A830           	JZ	GVI3			; END OF LINE
3093  23                	INX	H			; INCREMENT TO POINTER
3094  05                	DCR	B
3095  C2 8C30           	JNZ	GVI2			; MORE TO TO
3098  CD 5E19           	CALL	$TYPTX
309B  546F6F20 4C6F6E67 	DB	'Too Long.',ENL
30A3  2E8A
30A5  C3 1030           	JMP	GVI1

30A8  36 20             GVI3	MVI	M,' '			; BLANK REST OF LABEL
30AA  23                	INX	H
30AB  05                	DCR	B
30AC  C2 A830           	JNZ	GVI3
30AF  C9                	RET
30B0                    	STL	'IDS - INITIALIZE DISK SURFACE'
30B0                    	EJECT
                        **	IDS - INITIALIZE DISK SURFACE.
                        *
                        *	IDS IS CALLED TO INITIALIZE THE DISK SURFACE WITH RECORD LABELS,
                        *	AND A TEST PATTERN.
                        *
                        *	ENTRY	NONE
                        *
                        *	EXIT	PSW	= 'C'	if ERROR
                        *			  'NC'	if NO Error
                        *
                        *	USES	ALL
                        *

30B0  CD D730           IDS	CALL	IDS.
30B3  D0                	RNC				; No Errors

30B4  CD 5E19           	CALL	$TYPTX
30B7  0A07556E 61626C65 	DB	NL,BELL,'Unable to format this disk.',ENL
30BF  20746F20 666F726D
30C7  61742074 68697320
30CF  6469736B 2E8A
30D5  37                	STC				; Flag Error
30D6  C9                	RET
30D7                    	SPACE	4,10
30D7  CD 0C35           IDS.	CALL	DRIVER
30DA  07                	DB	DC.ABT

30DB  CD 3936           	CALL	SUBFUN
30DE  01                	DB	INI.IDS
30DF  D8                	RC

30E0  CD 0C35           	CALL	DRIVER			; Abort disk
30E3  07                	DB	DC.ABT
30E4  D8                	RC

30E5  CD 6036           	CALL	SVP

                        *	WRITE DUMMY BOOTSTRAP

30E8  CD 9635           	CALL	MOUNT.			; Set Volume 0
30EB  D8                	RC

30EC  01 0009           	LXI	B,T0BOOTL+SB.SDB-SB.BOO
30EF  11 8022           	LXI	D,SB.BOO
30F2  21 0000           	LXI	H,0
30F5  CD 2435           	CALL	DRIVER. 		; Write Boot
30F8  01                	DB	DC.WRI
30F9  C9                	RET
30FA                    	STL	'GBL - GET BAD SECTOR LIST.'
30FA                    	EJECT
                        **	GBL - GET BAD SECTOR LIST.
                        *
                        *	GBL GETS A LIST OF BAD SECTORS, AND FLAGS THE BYTES IN THE RGTAB.
                        *
                        *	ENTRY	NONE
                        *	EXIT	RGTAB SETUP
                        *	USES	ALL

      = 30FA            GBL	EQU	*

30FA  21 003E           	LXI	H,RGTAB
30FD  3A 9038           	LDA	NGROUPS 		; A  = Number of Valid groups
3100  36 01             GBL1	MVI	M,1			; FLAG UNUSED
3102  23                	INX	H
3103  3D                	DCR	A
3104  C2 0031           	JNZ	GBL1			; ZERO TABLE

3107  7D                GBL1.5	MOV	A,L
3108  A7                	ANA	A
3109  CA 1231           	JZ	GBL2			; This assumes RGTAB is 256 bytes
310C  36 FF             	MVI	M,377Q
310E  23                	INX	H
310F  C3 0731           	JMP	GBL1.5

      = 3112            GBL2	EQU	*

                        *	GET BAD SECTOR LIST

3112  CD 1037           GBL4	CALL	$CCO			; CLEAR CTL-O
3115  CD 5E19           	CALL	$TYPTX
3118  0A456E74 65722074 	DB	NL,'Enter the numbers of the bad sectors one at a time.'
3120  6865206E 756D6265
3128  7273206F 66207468
3130  65206261 64207365
3138  63746F72 73206F6E
3140  65206174 20612074
3148  696D652E
314C  20204869 74205245 	DB	'  Hit RETURN',NL
3154  5455524E 0A
3159  61667465 72206561 	DB	'after each entry, and when finished.',ENL
3161  63682065 6E747279
3169  2C20616E 64207768
3171  656E2066 696E6973
3179  6865642E 8A

317E  CD 1037           GBL5	CALL	$CCO			; CLEAR CTL-O
3181  CD 5E19           	CALL	$TYPTX
3184  53656374 6F723FA0 	DB	'Sector?',' '+EOL
318C  CD 3E37           	CALL	$IDN			; INPUT DECIMAL NUBER
318F  DA 7E31           	JC	GBL5			; Some error getting number
3192  EB                	XCHG				; DE = sector number
3193  2A 1D39           	LHLD	LABEL+LAB.SIZ
3196  2B                	DCX	H			; HL = Maximum Sector Number
3197  CD 7429           	CALL	CPDEHL
319A  D2 BC31           	JNC	GBL7			; HL >= DE

319D  CD 5E19           GBL6	CALL	$TYPTX
31A0  2020496C 6C656761 	DB	'  Illegal Sector Number.',ENL
31A8  6C205365 63746F72
31B0  204E756D 6265722E
31B8  8A
31B9  C3 7E31           	JMP	GBL5

31BC  7A                GBL7	MOV	A,D
31BD  B3                	ORA	E
31BE  C8                	RZ				; CARRIAGE RETURN

31BF  21 F5FF           	LXI	H,-11
31C2  19                	DAD	D
31C3  D2 9D31           	JNC	GBL6			; BAD NUMBER

                        *	FLAG SECTOR BAD

31C6  3A 1839           	LDA	LABEL+LAB.SPG		; A  = Sectors/group
31C9  42                	MOV	B,D
31CA  4B                	MOV	C,E			; BC = Sector Number
31CB  CD 5B35           	CALL	DU68			; HL = BC/A

31CE  11 003E           	LXI	D,RGTAB
31D1  19                	DAD	D
31D2  36 FF             	MVI	M,-1			; FLAG BAD
31D4  C3 7E31           	JMP	GBL5			; GET MORE
31D7                    	STL	'FOV - FORMAT VOLUME'
31D7                    	EJECT
                        **	FOV - FORMAT VOLUME.
                        *
                        *	FOV FORMATS THE NEW VOLUME.
                        *
                        *	IT ALLOCATES SPACE FOR THE DIRECTORY, BUILDS THE
                        *	DIRECTORY STRUCTURE, AND BUILDS THE
                        *	RGT AND THE GRT.
                        *
                        *	EXIT:	PSW	= 'C' SET   if ERROR
                        *			  'C' CLEAR if No ERROR
                        *

      = 31D7            FOV	EQU	*

                        *	FLAG (IN THE RGT) THE LOW SECTORS RESERVED FOR THE SYSTEM.

31D7  21 0000           	LXI	H,0
31DA  22 003E           	SHLD	RGTAB			; FIRST TWO BLOCKS ARE SPECIAL

31DD  3A 9138           	LDA	NSPCGRP 		; A  = Number of special groups
31E0  3D                	DCR	A
31E1  3D                	DCR	A			; First 2 already taken care of
31E2  21 023E           	LXI	H,RGTAB+2
31E5  CA EF31           FOV1	JZ	FOV2			; All done
31E8  36 FF             	MVI	M,377Q			; Flag Reserved
31EA  23                	INX	H
31EB  3D                	DCR	A
31EC  C2 E531           	JNZ	FOV1

31EF  CD 3132           FOV2	CALL	ADB			; ASSIGN DIRECTORY BLOCKS
31F2  D8                	RC				; Error

                        *	WRITE THE RGT

31F3  CD 8B35           	CALL	MOUNT

31F6  01 0001           	LXI	B,256
31F9  11 003E           	LXI	D,RGTAB
31FC  2A 1B39           	LHLD	LABEL+LAB.RGT		; HL = RGT address
31FF  CD 2435           	CALL	DRIVER. 		; WRITE IT
3202  01                	DB	DC.WRI

                        *	WRITE THE LABEL SECTOR

3203  2A C820           	LHLD	S.DATC
3206  22 1239           	SHLD	LABEL+LAB.IND

3209  CD 9635           	CALL	MOUNT.			; Set Volume to Zero

320C  01 0001           	LXI	B,256
320F  11 1139           	LXI	D,LABEL
3212  21 0900           	LXI	H,DDF.LAB
3215  CD 2435           	CALL	DRIVER. 		; WRITE LABEL
3218  01                	DB	DC.WRI

                        *	WRITE THE GRT

3219  CD E232           	CALL	BGT			; BUILD THE GRT FIRST
321C  CD 8B35           	CALL	MOUNT

321F  01 0001           	LXI	B,256
3222  11 003D           	LXI	D,GRTAB
3225  2A 1639           	LHLD	LABEL+LAB.GRT		; (HL) = GRT SECTOR INDEX
3228  CD 2435           	CALL	DRIVER. 		; WRITE IT
322B  01                	DB	DC.WRI

                        *	INITIALIZE THE DIRECTORY

322C  CD 3833           	CALL	IDD			; INITIALIZE DEVICE DIRECTORY
322F  A7                	ANA	A			; Clear ERROR
3230  C9                	RET
3231                    	STL	'FOV SUBROUTINES.'
3231                    	EJECT
                        **	ADB - ASSIGN DIRECTORY BLOCKS.
                        *
                        *	ADB LOCATES CONTIGUOUS SECTORS TO HOLD THE DIRECTORY
                        *	AND THE GRT TABLE.
                        *
                        *	ENTRY	NONE
                        *	EXIT	PSW	= 'C' SET   if ERROR
                        *			  'C' CLEAR if NO ERROR
                        *
                        *		GRTBLK = BLOCK INDEX OF GRT
                        *		DIRBLK = BLOCK INDEX OF DIRECTORY FIRST BLOCK
                        *		LABEL+LAB.GRT = GRT SECTOR INDEX
                        *		LABEL+LAB.DIS = DIRECTORY START SECTOR INDEX (NOT 1ST DIR SECTOR!)
                        *	USES	ALL

      = 3231            ADB	EQU	*

                        *	Compute Directory File Parameters

3231  3A 1839           	LDA	LABEL+LAB.SPG
3234  11 0B00           	LXI	D,22/2
                        	ERRNZ	DIS.ENL-DIS.ENT/DIRELEN-22
3237  CD 0719           	CALL	$MU86
323A  EB                	XCHG				; DE = direct. entries per volume block

323B  3A 9038           	LDA	NGROUPS
323E  2A 9138           	LHLD	NSPCGRP
3241  95                	SUB	L			; Don't count special groups in max. num. files
3242  4F                	MOV	C,A
3243  06 00             	MVI	B,0			; BC = number of groups = max. num. files
3245  C5                	PUSH	B
3246  CD 4618           	CALL	$DU66			; HL = number of dir. blocks = DE / SPG
3249  C1                	POP	B

324A  7D                	MOV	A,L
324B  3C                	INR	A			; Add one to round up
324C  3C                	INR	A			; Add one for GRT
324D  32 8F38           	STA	NDIRBLK

                        *	Find contiguous blocks for directory

3250  11 0300           	LXI	D,3
3253  CD 4618           	CALL	$DU66			; HL = groups/3
3256  11 003E           	LXI	D,RGTAB
3259  19                	DAD	D			; HL = address to start looking at

325A  0E 01             	MVI	C,1			; Flag 0 passes through entire GRT

325C  3A 8F38           ADB1	LDA	NDIRBLK
325F  47                	MOV	B,A			; B  = number of directory blocks sought
3260  22 E032           	SHLD	ADBA			; Save initial Table pointer

3263  7E                ADB2	MOV	A,M			; A  = RESERVATION BYTE
3264  23                	INX	H
3265  3D                	DCR	A
3266  C2 7032           	JNZ	ADB3			; RESERVED
3269  05                	DCR	B			; COUNT GOT ONE
326A  C2 6332           	JNZ	ADB2			; NEED MORE
326D  C3 B632           	JMP	ADB4			; GOT OUR BLOCKS

                        *	RAN INTO A BAD BLOCK. START LOOKING OVER AGAIN

3270  E5                ADB3	PUSH	H
3271  3A 9038           	LDA	NGROUPS 		; A  = max. group number + 1
3274  2A 8F38           	LHLD	NDIRBLK
3277  95                	SUB	L			; A  = A - NDIRBLK
3278  E1                	POP	H

3279  95                	SUB	L
327A  D2 5C32           	JNC	ADB1			; STILL ENOUGH FOR A CHANCE

327D  21 023E           	LXI	H,RGTAB+2
3280  0D                	DCR	C
3281  F2 5C32           	JP	ADB1			; Start from the beginning this time

3284  CD 5E19           	CALL	$TYPTX			; Unable to find enough in a row
3287  0720566F 6C756D65 	DB	BELL,' Volume too decrepit for use. Try another.',BELL,ENL
328F  20746F6F 20646563
3297  72657069 7420666F
329F  72207573 652E2054
32A7  72792061 6E6F7468
32AF  65722E07 8A
32B4  37                	STC				; Flag problems
32B5  C9                	RET

                        *	GOT THE TRACKS. (HL) = INDEX OF FIRST GRT+11

32B6  2B                ADB4	DCX	H			; (HL) = INDEX IF LAST GRT
32B7  7D                	MOV	A,L
32B8  32 8A38           	STA	GRTBLK			; use last block for GRT

32BB  26 00             	MVI	H,0
32BD  CD 8F34           	CALL	BTS			; HL = sector number
32C0  22 1639           	SHLD	LABEL+LAB.GRT		; SET GRT ADDRESS

32C3  3A 8F38           	LDA	NDIRBLK
32C6  3D                	DCR	A			; Count the GRT block
32C7  32 8F38           	STA	NDIRBLK

32CA  2A E032           	LHLD	ADBA			; L  = block number for first directory block

                        *	SETUP POINTERS FOR LABEL AND INIT PROGRAM.

32CD  7D                	MOV	A,L			; (A) = DIRECTORY BLOCK INDEX
32CE  32 8B38           	STA	DIRBLK
32D1  2A 8838           	LHLD	DBI
32D4  86                	ADD	M
32D5  6F                	MOV	L,A			; HL = index of first directory block

32D6  26 00             	MVI	H,0
32D8  CD 8F34           	CALL	BTS			; HL = sector index of directory
32DB  22 1439           	SHLD	LABEL+LAB.DIS

32DE  A7                	ANA	A			; Clear ERROR flag
32DF  C9                	RET

32E0  0000              ADBA	DW	0			; Save first directory block
32E2                    	SPACE	4,10
                        **	BGT - BUILD GRT TABLE.
                        *
                        *	BGT BUILDS THE GRT FROM THE RGT, ENTERING BLOCK CHAINS
                        *	FOR THE DIRECTORY, THE RGT AND THE GRT FILES.
                        *
                        *	FIRST, THE BLOCKS USED IN THE RGT, GRT, AND DIRECTORY
                        *	FILES ARE LINKED UP.
                        *
                        *	THEN, ALL FREE BLOCKS LEFT (INDEX = 1) ARE LINKED INTO
                        *	THE FREE CHAIN.
                        *
                        *	ENTRY	NONE
                        *	EXIT	NONE
                        *	USES	ALL

32E2  01 0001           BGT	LXI	B,256
32E5  11 003E           	LXI	D,RGTAB
32E8  21 003D           	LXI	H,GRTAB
32EB  CD AA18           	CALL	$MOVE			; COPY RGTAB INTO GRTAB
32EE  2A 1B39           	LHLD	LABEL+LAB.RGT
32F1  CD 2A36           	CALL	STB			; HL = RGT block number
32F4  11 003D           	LXI	D,GRTAB
32F7  19                	DAD	D			; HL = table address
32F8  36 00             	MVI	M,0			; Reserve the block for the RGT file

                        *	Link the directory blocks together in required order

32FA  3A 8F38           	LDA	NDIRBLK
32FD  47                	MOV	B,A			; B  = block count
32FE  2A 8838           	LHLD	DBI
3301  EB                	XCHG				; DE = Directory block interleave table
3302  2A 8B38           	LHLD	DIRBLK			; L  = first directory block
3305  26 3D             	MVI	H,GRTAB/256
3307  4D                	MOV	C,L			; C  = directory block base address
3308  1A                	LDAX	D
3309  13                	INX	D
330A  81                	ADD	C
330B  6F                	MOV	L,A			; HL = address of first directory block

330C  05                	DCR	B			; last block is special
330D  CA 1933           	JZ	BGT1.5			; only 1 block

3310  1A                BGT1	LDAX	D			; A  = block offset
3311  13                	INX	D
3312  81                	ADD	C			; A  = physical block number
3313  77                	MOV	M,A			; this block points the the next
3314  6F                	MOV	L,A			; HL = address of successor block
3315  05                	DCR	B
3316  C2 1033           	JNZ	BGT1			; more blocks to do

3319  36 00             BGT1.5	MVI	M,0			; last block points to 00 as final block
331B  7D                	MOV	A,L
331C  32 8C38           	STA	DIRLBLK 		; SET DIRECTORY LAST BLOCK
331F  3A 8A38           	LDA	GRTBLK
3322  6F                	MOV	L,A
3323  36 00             	MVI	M,0			; GRT BLOCK CHAINS TO NONE

                        *	CHAIN ALL UNUSED (001) BLOCKS TOGETHER.
                        *
                        *	PUT START POINTER IN BLOCK 00, LAST BLOCK POINTS TO 00

3325  0E 00             	MVI	C,0			; (C) = NEXT FREE BLOCK
3327  21 FF3D           	LXI	H,GRTAB+255		; WORK FROM THE BACK
332A  3E 01             BGT2	MVI	A,1
332C  BE                	CMP	M
332D  C2 3233           	JNE	BGT3			; NOT FREE
3330  71                	MOV	M,C			; LINK ON FRONT OF CHAIN
3331  4D                	MOV	C,L			; IS NOW FRONT OF CHAIN
3332  2D                BGT3	DCR	L
3333  C2 2A33           	JNZ	BGT2			; MORE TO GO
3336  71                	MOV	M,C			; SET POINTER IN GROUP 00
3337  C9                	RET
3338                    	SPACE	4,10
                        **	IDD - INITIALIZE DEVICE DIRECTORY.
                        *
                        *	IDD INITIALIZES THE DEVICE DIRECTORY BY WRITTING THE DIRECTORY
                        *	BLOCK 1 CLEAR, BLOCKS 3 - N EMPTY, AND BLOCK 2 CONTAINING
                        *	THE FILES
                        *
                        *	RGT	.SYS
                        *	GRT	.SYS
                        *	DIRECT	.SYS
                        *
                        *	THE DIRECTORYS BLOCKS ARE INTERNALLY LINKED TO FOLLOW THEIR POSITION
                        *	IN THE GRT.
                        *
                        *	ENTRY	NONE
                        *	EXIT	NONE
                        *	USES	ALL
                        *

3338  3E 02             IDD	MVI	A,2
333A  32 5334           	STA	IDDD			; SET COUNT FOR SECOND DIRECTORY BLOCK
333D  06 FF             	MVI	B,DF.EMP		; SET ENTRYS EMPTY
333F  CD 7534           	CALL	PDS			; PRESET DIRECTORY SECTOR
3342  3A 1839           	LDA	LABEL+LAB.SPG
3345  E6 FE             	ANI	377Q-1
3347  0F                	RRC
3348  32 5434           	STA	IDDE			; Initialize directory blocks per GRT block
334B  32 5534           	STA	IDDF			; Initialize number this GRT block

                        *	WRITE DIRECTORY BLOCKS, IN ORDER

334E  3E 17             	MVI	A,DIRELEN
3350  32 0C3C           	STA	IDDA+DIS.ENL		; SET DIRECTORY ENTRY LENGTH
3353  2A 1439           	LHLD	LABEL+LAB.DIS		; (HL) = INDEX OF FIRST BLOCK

3356  22 0D3C           IDD2	SHLD	DIS.SEC+IDDA		; SET IN DIRECTORY ENTRY
3359  CD 5634           	CALL	ANS			; Advance to the next sector
335C  22 0F3C           	SHLD	DIS.LNK+IDDA		; SET IN BLOCK
335F  21 5334           	LXI	H,IDDD
3362  35                	DCR	M			; COUNT SECTOR
3363  C2 E133           	JNZ	IDD4			; IS NOT SECTOR 2

                        *	IS SECTOR 2. ADD SPECIAL FILES TO THE END OF IT.

3366  2A 1B39           	LHLD	LABEL+LAB.RGT
3369  CD 2A36           	CALL	STB
336C  7D                	MOV	A,L
336D  32 0734           	STA	IDDCRGT+DIR.FGN 	; RGT start block
3370  32 0834           	STA	IDDCRGT+DIR.LGN 	; RGT last block
3373  3E 01             	MVI	A,1						;/3.0a/
3375  32 0934           	STA	IDDCRGT+DIR.LSI 	; only 1 sector in file 	/3.0a/

3378  2A C820           	LHLD	S.DATC
337B  22 0A34           	SHLD	IDDCRGT+DIR.CRD 	; SET CREATION DATES FOR ALL	/3.0a/
337E  22 2134           	SHLD	IDDCGRT+DIR.CRD 				;/3.0a/
3381  22 3834           	SHLD	IDDCDIR+DIR.CRD 				;/3.0a/

3384  21 0000           	LXI	H,0			; No access dates for any	/3.0a/
3387  22 0C34           	SHLD	IDDCRGT+DIR.ACD 				;/3.0a/
338A  22 2334           	SHLD	IDDCGRT+DIR.ACD 				;/3.0a/
338D  22 3A34           	SHLD	IDDCDIR+DIR.ACD 				;/3.0a/

3390  2A CA20           	lhld	S.TIME			; system time			/3.0a/
3393  22 0234           	shld	IDDCRGT+DIR.CTH 				;/3.0a/
3396  22 1934           	shld	IDDCGRT+DIR.CTH 				;/3.0a/
3399  22 3034           	shld	IDDCDIR+DIR.CTH 				;/3.0a/

                        *	SET DIRECTORY POINTERS TO GRT BLOCK AND DIRECTORY

339C  3A 8A38           	LDA	GRTBLK
339F  32 1E34           	STA	IDDCGRT+DIR.FGN 	; SET GRT BLOCK
33A2  32 1F34           	STA	IDDCGRT+DIR.LGN 	; ONLY ONE BLOCK IN FILE
33A5  3E 01             	MVI	A,1
33A7  32 2034           	STA	IDDCGRT+DIR.LSI 	; ONLY ONE SECTOR IN FILE

33AA  2A 1439           	LHLD	LABEL+LAB.DIS
33AD  CD 2A36           	CALL	STB			; HL = block number
33B0  7D                	MOV	A,L			; A  = group number direct. start
33B1  32 3534           	STA	IDDCDIR+DIR.FGN
33B4  3A 8C38           	LDA	DIRLBLK
33B7  32 3634           	STA	IDDCDIR+DIR.LGN 	; SET GROUP NUMBER OF LAST BLOCK
33BA  3A 1839           	LDA	LABEL+LAB.SPG
33BD  32 3734           	STA	IDDCDIR+DIR.LSI 	; SET LAST SECTOR INDEX

33C0  01 5C00           	LXI	B,IDDCL
33C3  11 F733           	LXI	D,IDDC
33C6  21 AF3B           	LXI	H,IDDB+IDDBL-IDDCL
33C9  CD AA18           	CALL	$MOVE			; MOVE ENTRYS INTO BLOCK
33CC  01 0002           	LXI	B,512
33CF  11 113A           	LXI	D,IDDA
33D2  2A 0D3C           	LHLD	DIS.SEC+IDDA
33D5  CD 2435           	CALL	DRIVER. 		; WRITE BLOCK AND EXIT
33D8  01                	DB	DC.WRI

                        *	HAVE WRITTEN 1ST AND 2ND DIRECTORY BLOCKS. FLAG
                        *	ALL REMAINING BLOCKS EMPTY

33D9  06 FE             	MVI	B,DF.CLR		; FLAG REST OF DIRECTORY EMPTY
33DB  CD 7534           	CALL	PDS			; PRESET DIRECTORY SECTOR
33DE  C3 EE33           	JMP	IDD5			; SKIP RE-WRITTING 2ND SECTOR

                        *	WRITE BLOCK TO DISK

33E1  01 0002           IDD4	LXI	B,512
33E4  11 113A           	LXI	D,IDDA
33E7  2A 0D3C           	LHLD	DIS.SEC+IDDA
33EA  CD 2435           	CALL	DRIVER. 		; WRITE BLOCK
33ED  01                	DB	DC.WRI

33EE  2A 0F3C           IDD5	LHLD	DIS.LNK+IDDA
33F1  7C                	MOV	A,H
33F2  B5                	ORA	L
33F3  C2 5633           	JNZ	IDD2			; NOT LAST ONE, DO SOME MORE
33F6  C9                	RET


                        **	DIRECTORY ENTRYS FOR SPECIAL FILES

      = 00F2            .	SET	DIF.SYS+DIF.LOC+DIF.WP+DIF.CNT+DIF.DL		;/3.0a/

      = 33F7            IDDC	equ	*

      = 33F7            IDDCRGT EQU	*
                        	ERRNZ	*-IDDCRGT-DIR.NAM				;/3.0a/
33F7  52475400 00000000 	DB	'RGT',0,0,0,0,0 	; RGT.SYS
                        	ERRNZ	*-IDDCRGT-DIR.EXT				;/3.0a/
33FF  535953            	DB	'SYS'
                        	ERRNZ	*-IDDCRGT-DIR.CTH				;/3.0a/
3402  0000              	dc	2,#0			; creation time 		/3.0a/
                        	ERRNZ	*-IDDCRGT-DIR.NOA				;/3.0a/
3404  00                	db	0			; number of accesses		/3.0a/
                        	ERRNZ	*-IDDCRGT-DIR.FLG				;/3.0a/
3405  F2                	db	.			; set flags			/3.0a/
                        	ERRNZ	*-IDDCRGT-DIR.USR				;/3.0a/
3406  FF                	db	377Q			; user mask			/3.0a/
                        	ERRNZ	*-IDDCRGT-DIR.FGN				;/3.0a/
                        	ERRNZ	DIR.LSI-DIR.LGN-1				;/3.0a/
                        	ERRNZ	DIR.LGN-DIR.FGN-1				;/3.0a/
3407  000000            	dc	3,#0			; FGN, LGN, LSI 		/3.0a/
                        	ERRNZ	*-IDDCRGT-DIR.CRD				;/3.0a/
                        	ERRNZ	DIR.ACD-DIR.CRD-2				;/3.0a/
340A  00000000          	dc	4,#0			; creation and last access	/3.0a/
                        	ERRNZ	*-IDDCRGT-DIRELEN				;/3.0a/

      = 340E            IDDCGRT equ	*
                        	ERRNZ	*-IDDCGRT-DIR.NAM				;/3.0a/
340E  47525400 00000000 	DB	'GRT',0,0,0,0,0 	; GRT.SYS
                        	ERRNZ	*-IDDCGRT-DIR.EXT				;/3.0a/
3416  535953            	DB	'SYS'
                        	ERRNZ	*-IDDCGRT-DIR.CTH				;/3.0a/
3419  0000              	dc	2,#0			; creation time 		/3.0a/
                        	ERRNZ	*-IDDCGRT-DIR.NOA				;/3.0a/
341B  00                	db	0			; number of accesses		/3.0a/
                        	ERRNZ	*-IDDCGRT-DIR.FLG				;/3.0a/
341C  F2                	db	.			; set flags			/3.0a/
                        	ERRNZ	*-IDDCGRT-DIR.USR				;/3.0a/
341D  FF                	db	377Q			; user mask			/3.0a/
                        	ERRNZ	*-IDDCGRT-DIR.FGN				;/3.0a/
                        	ERRNZ	DIR.LSI-DIR.LGN-1				;/3.0a/
                        	ERRNZ	DIR.LGN-DIR.FGN-1				;/3.0a/
341E  000000            	dc	3,#0			; FGN, LGN, LSI 		/3.0a/
                        	ERRNZ	*-IDDCGRT-DIR.CRD				;/3.0a/
                        	ERRNZ	DIR.ACD-DIR.CRD-2				;/3.0a/
3421  00000000          	dc	4,#0			; creation and last access date /3.0a/
                        	ERRNZ	*-IDDCGRT-DIRELEN				;/3.0a/

      = 00E2            .	SET	DIF.SYS+DIF.LOC+DIF.WP+DIF.DL			;/3.0a/

      = 3425            IDDCDIR equ	*
                        	ERRNZ	*-IDDCDIR-DIR.NAM				;/3.0a/
3425  44495245 43540000 	DB	'DIRECT',0,0		; DIRECT.SYS
                        	ERRNZ	*-IDDCDIR-DIR.EXT				;/3.0a/
342D  535953            	DB	'SYS'
                        	ERRNZ	*-IDDCDIR-DIR.CTH				;/3.0a/
3430  0000              	dc	2,#0			; creation time 		/3.0a/
                        	ERRNZ	*-IDDCDIR-DIR.NOA				;/3.0a/
3432  00                	db	0			; number of accesses		/3.0a/
                        	ERRNZ	*-IDDCDIR-DIR.FLG				;/3.0a/
3433  E2                	db	.			; set flags			/3.0a/
                        	ERRNZ	*-IDDCDIR-DIR.USR				;/3.0a/
3434  FF                	db	377Q			; user mask			/3.0a/
                        	ERRNZ	*-IDDCDIR-DIR.FGN				;/3.0a/
                        	ERRNZ	DIR.LSI-DIR.LGN-1				;/3.0a/
                        	ERRNZ	DIR.LGN-DIR.FGN-1				;/3.0a/
3435  000000            	dc	3,#0			; FGN, LGN, LSI 		/3.0a/
                        	ERRNZ	*-IDDCDIR-DIR.CRD				;/3.0a/
                        	ERRNZ	DIR.ACD-DIR.CRD-2				;/3.0a/
3438  00000000          	dc	4,#0			; creation and last access date /3.0a/
                        	ERRNZ	*-IDDCDIR-DIRELEN				;/3.0a/

343C  FE                	DB	DF.CLR			; LAST SPOT IN 2ND BLOCK IS EMPTY
343D  28632920 31393835 	DB	'(c) 1985 by WGP'
3445  20627920 574750
344C  00000000 000000   	dc	DIRELEN-1-15,#0 	; REST OF ENTRY MEANINGLESS	/3.0a/

      = 005C            IDDCL	EQU	*-IDDC
                        	ERRNZ	4*DIRELEN-IDDCL 	; SHOULD BE FOUR ENTRYS

3453  00                IDDD	DB	0			; DIRECTORY BLOCK COUNTER
3454  00                IDDE	DB	0			; Directory blocks per GRT block
3455  00                IDDF	DB	0			; Remaining directory blocks block
3456                    	SPACE	4,10
                        **	ANS	- Advance to Next Sector
                        *
                        *	ANS updates the pointer to the current sector, to
                        *	point to the next sector.
                        *
                        *	ENTRY:	HL	= current sector
                        *		IDDE, IDDF initialized
                        *
                        *	EXIT:	HL	= next sector
                        *		IDDF updated
                        *
                        *	USES:	PSW,HL
                        *

3456  3A 5534           ANS	LDA	IDDF
3459  3D                	DCR	A			; Count this directory block
345A  32 5534           	STA	IDDF
345D  CA 6334           	JZ	ANS1			; need a new block

                        *	More available directory blocks in this GRT block

3460  23                	INX	H
3461  23                	INX	H
3462  C9                	RET

3463  3A 5434           ANS1	LDA	IDDE
3466  32 5534           	STA	IDDF			; Initialize count for next GRT block
3469  CD 2A36           	CALL	STB			; HL = block number
346C  26 3D             	MVI	H,GRTAB/256
346E  6E                	MOV	L,M			; L  = next block number
346F  26 00             	MVI	H,0
3471  CD 8F34           	CALL	BTS			; convert it back to a sector number
3474  C9                	RET
3475                    	SPACE	4,10
                        **	PDS - PRESET DIRECTORY SECTOR.
                        *
                        *	PDS BUILDS A DIRECTORY BLOCK INTO *IDDB*  FULL OF DIRECTORY
                        *		ENTRYS IN THE FORMAT:
                        *
                        *	FLAG,0,0, . . . ,0
                        *
                        *	WHERE FLAG = SOME  SUPPLIED VALUE.
                        *
                        *	ENTRY	(B) = FLAG BYTE
                        *	EXIT	NONE
                        *	USES	ALL

3475  21 113A           PDS	LXI	H,IDDB
3478  11 FA01           	LXI	D,IDDBL
347B  70                PDS1	MOV	M,B			; SET FIRST BYTE
347C  23                	INX	H
347D  1B                	DCX	D

                        *	NOW ZERO REST OF ENTRY

347E  0E 16             	MVI	C,DIRELEN-1
3480  36 00             PDS2	MVI	M,0			; ZERO IT
3482  23                	INX	H
3483  1B                	DCX	D			; COUNT BYTE FROM DIRECTORY BLOCK
3484  0D                	DCR	C			; COUNT BYTE FROM DIRECTORY ENTRY
3485  C2 8034           	JNZ	PDS2
3488  7A                	MOV	A,D
3489  B3                	ORA	E
348A  C2 7B34           	JNZ	PDS1
348D  77                	MOV	M,A			; ZERO BYTE FOLLOWS ENTRYS
348E  C9                	RET				; EXIT
348F                    	STL	'Subroutines'
348F                    	EJECT
                        **	BTS	-  Block To Sector
                        *
                        *	BTS converts a block number to a sector number.
                        *
                        *	ENTRY:	HL	= block number
                        *
                        *	EXIT:	HL	= sector number
                        *
                        *	USES:	HL
                        *

348F  F5                BTS	PUSH	PSW
3490  D5                	PUSH	D
3491  EB                	XCHG				; DE = multiplicand
3492  3A 1839           	LDA	LABEL+LAB.SPG
3495  CD 0719           	CALL	$MU86			; HL = DE * A
3498  D1                	POP	D
3499  F1                	POP	PSW
349A  C9                	RET
349B                    	SPACE	4,10
                        **	CNO	-  Check NO
                        *
                        *	CNO checks a line of text to verify a  *NO*  answer.
                        *
                        *	ENTRY:	HL	= address of line
                        *
                        *	EXIT:	PSW	= 'Z' SET   if  NO
                        *			  'Z' CLEAR if NOT  NO
                        *
                        *	USES:	PSW
                        *

349B  C5                CNO	PUSH	B
349C  D5                	PUSH	D
349D  E5                	PUSH	H

349E  11 A634           	LXI	D,CNOA
34A1  0E 03             	MVI	C,CNOAL
34A3  C3 B134           	JMP	CYS1

34A6  4E4F00            CNOA	DB	'NO',0
      = 0003            CNOAL	EQU	*-CNOA
34A9                    	SPACE	4,10
                        **	CYS	-  Check YES
                        *
                        *	CYS inputs a line of text to verify a  *YES*  answer.
                        *	Any answer except "YES" is regarded as  *NO*.
                        *
                        *	ENTRY:	HL	= address of line
                        *
                        *	EXIT:	PSW	= 'Z' SET   if YES
                        *			  'Z' CLEAR if NO
                        *
                        *	USES:	PSW
                        *

34A9  C5                CYS	PUSH	B
34AA  D5                	PUSH	D
34AB  E5                	PUSH	H

34AC  11 B834           	LXI	D,CYSA
34AF  0E 04             	MVI	C,CYSAL
34B1  CD 3018           CYS1	CALL	$COMP

34B4  E1                	POP	H
34B5  D1                	POP	D
34B6  C1                	POP	B
34B7  C9                	RET

34B8  59455300          CYSA	DB	'YES',0
      = 0004            CYSAL	EQU	*-CYSA
34BC                    	XTEXT	DDS
34BC                    	SPACE	4,10
                        **	DDS	-  Decode Device Specification
                        *
                        *	DDS decodes the device specification, returning a two character
                        *	device name, and one byte unit number.
                        *
                        *
                        *	ENTRY:	BC	= Address of destination fields
                        *		DE	= Address of default
                        *		HL	= Address of string specifier
                        *
                        *	EXIT:	PSW	= 'C' SET   if ERROR
                        *			  'C' CLEAR if NO ERROR
                        *
                        *	USES:	ALL
                        *

      = 34BC            DDS	EQU	*

                        *	Initialize the fields to the defaults

34BC  C5                	PUSH	B
34BD  CD 0435           	CALL	DDS3
34C0  CD 0435           	CALL	DDS3
34C3  1A                	LDAX	D
34C4  D6 30             	SUI	'0'
34C6  02                	STAX	B
34C7  C1                	POP	B

34C8  7E                	MOV	A,M
34C9  A7                	ANA	A
34CA  C8                	RZ				; took the default

                        *	Check the supplied name

34CB  CD CE37           	CALL	$SOB			; skip the whitespace
34CE  CD F534           	CALL	DDS2
34D1  D8                	RC				; Not alpha
34D2  CD F534           	CALL	DDS2
34D5  D8                	RC				; Not alpha

34D6  7E                	MOV	A,M
34D7  FE 3A             	CPI	':'
34D9  3E 00             	MVI	A,0			; assume unit 0
34DB  CA E734           	JZ	DDS1			; default to unit 0

                        *	Check for a valid digit

34DE  7E                	MOV	A,M
34DF  D6 30             	SUI	'0'
34E1  D8                	RC				; Not digit
34E2  FE 08             	CPI	7+1
34E4  3F                	CMC
34E5  D8                	RC				; digit too large
34E6  23                	INX	H

34E7  02                DDS1	STAX	B
34E8  03                	INX	B
34E9  7E                	MOV	A,M
34EA  23                	INX	H
34EB  FE 3A             	CPI	':'
34ED  37                	STC
34EE  C0                	RNZ				; requires ':'

34EF  7E                	MOV	A,M
34F0  A7                	ANA	A
34F1  37                	STC
34F2  C0                	RNZ				; require 'NULL'

34F3  A7                	ANA	A			; Clear ERROR flag
34F4  C9                	RET

34F5  7E                DDS2	MOV	A,M
34F6  23                	INX	H
34F7  CD 7A29           	CALL	$MCU
34FA  FE 41             	CPI	'A'
34FC  D8                	RC				; Not alpha

34FD  FE 5B             	CPI	'Z'+1
34FF  3F                	CMC
3500  D8                	RC				; Not alpha

3501  02                	STAX	B
3502  03                	INX	B			; replace the default char
3503  C9                	RET

3504  1A                DDS3	LDAX	D
3505  13                	INX	D
3506  CD 7A29           	CALL	$MCU			; Map to upper case
3509  02                	STAX	B
350A  03                	INX	B
350B  C9                	RET
                        	ERRNZ	IOC.UNI-IOC.DEV-2	; 2 byte device
                        	ERRNZ	IOC.DIR-IOC.UNI-1	; 1 byte unit
350C                    	SPACE	4,10
                        **	DRIVER
                        *
                        *	DRIVER calls the device driver for the currently seclected
                        *

350C  E3                DRIVER	XTHL
350D  7E                	MOV	A,M			; A  = driver request
350E  23                	INX	H
350F  E3                	XTHL

3510  E5                DRIVER1	PUSH	H
3511  F5                	PUSH	PSW
3512  D5                	PUSH	D
3513  2A 8638           	LHLD	CRNDEV
3516  CD 9C18           	CALL	$INDL
3519  0400              	DW	DVT.ADR
351B  EB                	XCHG				; HL = address of device table entry
351C  11 0300           	LXI	D,DEV.JMP
351F  19                	DAD	D			; HL = address of jump vector
3520  D1                	POP	D
3521  F1                	POP	PSW
3522  E3                	XTHL				; restore original HL
3523  C9                	RET				; enter the device driver

3524  E3                DRIVER.	XTHL
3525  7E                	MOV	A,M			; A  = driver request
3526  23                	INX	H
3527  E3                	XTHL
3528  CD 1035           	CALL	DRIVER1
352B  D0                	RNC				; No error

352C  CD 5E19           	CALL	$TYPTX
352F  07556E61 626C6520 	DB	BELL,'Unable to read or write this diskette.',BELL,ENL
3537  746F2072 65616420
353F  6F722077 72697465
3547  20746869 73206469
354F  736B6574 74652E07
3557  8A
3558  C3 2A2C           	JMP	RESTART
355B                    	SPACE	4,10
                        **	DU68	- Divide Unsigned (16 bit/8 bit)
                        *
                        *	DU68 performs a 16 bit X 8 bit unsigned division.
                        *
                        *	ENTRY:	A	= divisor
                        *		BC	= dividend
                        *
                        *	EXIT:	See $DU66
                        *
                        *	USES:	ALL
                        *

355B  5F                DU68	MOV	E,A
355C  16 00             	MVI	D,0
355E  C3 4618           	JMP	$DU66
3561                    	SPACE	4,10
                        **	IVP	- Initialize Volume Parameters
                        *
                        *	IVP initializes the volume parameters in the label
                        *	sectors.  This routine must be called after the boot
                        *	device is mounted, since relocating the primary boot
                        *	device destroys the default area.
                        *
                        *	ENTRY:	none
                        *
                        *	EXIT:	None
                        *
                        *	USES:	All
                        *

3561  01 1D00           IVP	LXI	B,IVPAL 					;/3.0a/
3564  11 6E35           	LXI	D,IVPA
3567  21 8322           	LXI	H,SB.VER
356A  CD AA18           	CALL	$MOVE
356D  C9                	RET

      = 356E            IVPA	EQU	*
      = 12EB            .	SET	*-SB.VER

                        	ERRNZ	*-.-SB.VER
356E  30                	DB	VERS			; Version of INIT that initialized the disk

                        	ERRNZ	*-.-SB.FLG
356F  00                	DB	0			; Flags

                        	ERRNZ	*-.-SB.BAU
3570  0000              	DW	0			; Baud Rate

                        	ERRNZ	*-.-SB.DAT
3572  6218              IVPB	DW	030142A 		; Default Date			/3.0a/

3574  00000000 00000000 	DW	0,0,0,0,0,0,0,0,0,0,0
357C  00000000 00000000
3584  00000000 0000
358A  00                	DB	0

                        	ERRNZ	*-.-SB.BPE
      = 001D            IVPAL	EQU	*-IVPA
358B                    	SPACE	4,10
                        **	MOUNT
                        *
                        *	MOUNT issues the mount system call to the device driver.
                        *	In the case of the H17, this sets up the all important
                        *	volume number.
                        *
                        *	ENTRY:	L	= Volume Number
                        *
                        *	EXIT:	NONE
                        *
                        *	USES:	ALL
                        *

358B  F5                MOUNT	PUSH	PSW
358C  3A 1139           	LDA	LABEL+LAB.SER
358F  6F                	MOV	L,A			; L = Volume Number
3590  F1                	POP	PSW

3591  CD 2435           MOUNT1	CALL	DRIVER.
3594  08                	DB	DC.MOU
3595  C9                	RET

3596  2E 00             MOUNT.	MVI	L,0			; Used for forcing volume 0
3598  C3 9135           	JMP	MOUNT1

359B  CD 0C35           MOUNT.. CALL	DRIVER			; Mount without error detection
359E  08                	DB	DC.MOU
359F  C9                	RET
35A0                    	SPACE	4,10
                        **	MSU	- Map System Unit
                        *
                        *	MSU maps the system unit to match the performance of
                        *	ISY in HDOS.SYS.  That is, it corrects for the fact
                        *	that a unit other than 0 may have been booted from.
                        *	This may seem like somewhatof a kludge, but it seems
                        *	reasonable.  After mapping the unit, it calls the
                        *	SY: subfunction processor, and then un-maps the unit
                        *	after the subfunction processor exits.
                        *
                        *	NOTE:	The sub-function processor temporarily zeroes
                        *		the boot unit so that if the function processor
                        *		calls the driver, the unit will not be mapped
                        *		twice.  After processing the sub-function, the
                        *		mapping factor is restored.
                        *
                        *	ENTRY:	AIO.UNI	= Unit Number
                        *
                        *	EXIT:	AIO.UNI = Unit Number, with MSUA called
                        *
                        *	USES:	NONE
                        *

35A0  E5                MSU	PUSH	H
35A1  F5                	PUSH	PSW
35A2  2A E620           	LHLD	S.DLINK
35A5  AF                	XRA	A
35A6  CD 7837           	CALL	$INDSB			; No more mapping of system device
35A9  0400              	DW	M.SUNI			;  because already mapped here
35AB  3A 3121           	LDA	AIO.UNI
35AE  67                	MOV	H,A
35AF  F1                	POP	PSW
35B0  E3                	XTHL				; Save current device specification

35B1  F5                	PUSH	PSW
35B2  D5                	PUSH	D
35B3  E5                	PUSH	H

35B4  3A 9338           	LDA	SYMNU
35B7  57                	MOV	D,A			; D = max num of units
35B8  3A 3121           	LDA	AIO.UNI
35BB  2A 9238           	LHLD	SUNIT
35BE  85                	ADD	L			; A = AIO.UNI+SUNIT
35BF  92                	SUB	D
35C0  D2 C435           	JNC	MSU1
35C3  82                	ADD	D			; A = A mod D

      = 35C4            MSU1	EQU	*

35C4  32 3121           	STA	AIO.UNI

35C7  E1                	POP	H
35C8  D1                	POP	D
35C9  F1                	POP	PSW

35CA  CD FFFF           	CALL	-1
      = 35CB            MSUA	EQU	*-2

35CD  E3                	XTHL
35CE  F5                	PUSH	PSW
35CF  7C                	MOV	A,H
35D0  32 3121           	STA	AIO.UNI 		; Replace the original value
35D3  3A 9238           	LDA	SUNIT
35D6  2A E620           	LHLD	S.DLINK
35D9  CD 7837           	CALL	$INDSB
35DC  0400              	DW	M.SUNI			; Restore original mapping factor
35DE  F1                	POP	PSW
35DF  E1                	POP	H			; Restore exit HL
35E0  C9                	RET
35E1                    	SPACE	4,10
                        **	RPB	- Relocate Primary Boot
                        *
                        *	RPB relocates the primary boot to the beggining of the boot
                        *	track.
                        *
                        *	ENTRY:	CRNDEV	= pointer to internal device table entry
                        *
                        *	EXIT:	Primary Boot Relocated
                        *
                        *	USES:	ALL
                        *

35E1  01 0002           RPB	LXI	B,SB.SDB-SB.BOO 	; BC = move COUNT
      = 0200            .	SET	SB.SDB-SB.BOO/256*256
                        	ERRNZ	SB.SDB-SB.BOO-. 	; Must be a multiple of 256
35E4  2A 8638           	LHLD	CRNDEV
35E7  CD 9C18           	CALL	$INDL			; DE = FROM address
35EA  0600              	DW	DVT.PAR
35EC  21 8022           	LXI	H,SB.BOO		; HL = DESTINATION address
35EF  CD AA18           	CALL	$MOVE

                        *	Relocate the Primary Boot

35F2  2A 8638           	LHLD	CRNDEV
35F5  E5                	PUSH	H
35F6  CD 9C18           	CALL	$INDL
35F9  0600              	DW	DVT.PAR
35FB  EB                	XCHG
35FC  CD 9418           	CALL	$CHL			; HL = - HL
35FF  11 8022           	LXI	D,SB.BOO
3602  19                	DAD	D
3603  44                	MOV	B,H
3604  4D                	MOV	C,L			; BC = Relocation Constant
3605  E1                	POP	H

3606  CD 9C18           	CALL	$INDL
3609  0800              	DW	DVT.PIC
360B  EB                	XCHG				; HL = PIC Table address

360C  5E                RPB1	MOV	E,M
360D  23                	INX	H
360E  56                	MOV	D,M			; DE = Relocation Address
360F  23                	INX	H

3610  7A                	MOV	A,D
3611  B3                	ORA	E
3612  C8                	RZ				; At the end of the PIC table

3613  E5                	PUSH	H
3614  21 8024           	LXI	H,SB.SDB
3617  CD 7429           	CALL	CPDEHL
361A  E1                	POP	H
361B  DA 0C36           	JC	RPB1			; Address is not in PRIMARY Boot

361E  EB                	XCHG				; HL = address of word to relocate
361F  7E                	MOV	A,M
3620  81                	ADD	C
3621  77                	MOV	M,A
3622  23                	INX	H
3623  7E                	MOV	A,M
3624  88                	ADC	B
3625  77                	MOV	M,A			; Relocate the word
3626  EB                	XCHG
3627  C3 0C36           	JMP	RPB1			; Relocate the next word
362A                    	SPACE	4,10
                        **	STB	- Sector To Block
                        *
                        *	STB converts a sector number to the corresponding block number.
                        *
                        *	ENTRY:	HL	= sector number
                        *
                        *	EXIT:	HL	= block number
                        *
                        *	USES:	HL
                        *

362A  F5                STB	PUSH	PSW
362B  C5                	PUSH	B
362C  D5                	PUSH	D
362D  44                	MOV	B,H
362E  4D                	MOV	C,L			; BC = block number
362F  3A 1839           	LDA	LABEL+LAB.SPG
3632  CD 5B35           	CALL	DU68			; HL = BC/A
3635  D1                	POP	D
3636  C1                	POP	B
3637  F1                	POP	PSW
3638  C9                	RET
3639                    	SPACE	4,10
                        **	SUBFUN	-  Sub-Function
                        *
                        *	SUBFUN is the INIT sub-function processor
                        *

3639  E3                SUBFUN	XTHL
363A  7E                	MOV	A,M			; A  = sub-function
363B  23                	INX	H
363C  E3                	XTHL

363D  E5                	PUSH	H
363E  D5                	PUSH	D
363F  F5                	PUSH	PSW

3640  2A 9438           	LHLD	SYPTR
3643  EB                	XCHG
3644  2A 8638           	LHLD	CRNDEV
3647  CD 7429           	CALL	CPDEHL
364A  21 A035           	LXI	H,MSU
364D  CA 5C36           	JZ	SUBFUN1 		; Processing device SY:

3650  2A 8638           	LHLD	CRNDEV
3653  CD 9C18           	CALL	$INDL
3656  0600              	DW	DVT.PAR
3658  21 0002           	LXI	H,SB.SDB-SB.BOO
365B  19                	DAD	D			; The sub-functions begin there

365C  F1                SUBFUN1	POP	PSW
365D  D1                	POP	D
365E  E3                	XTHL
365F  C9                	RET				; enter the drivers sub-processor
3660                    	SPACE	4,10
                        **	SVP	- Set-Up Volume Parameters
                        *
                        *	SVP sets up the volume parameters in the label sector.
                        *
                        *	ENTRY:	NONE
                        *
                        *	EXIT:	LABEL Device Dependant volume parameters initialized
                        *
                        *	USES:	ALL
                        *

      = 3660            SVP	EQU	*

                        *	Fetch Device Dependant Parameters

3660  CD 3936           	CALL	SUBFUN			; HL = address of the parameters
3663  03                	DB	INI.PAR

3664  EB                	XCHG				; DE = current volume parameters
3665  21 1D39           	LXI	H,LABEL+LAB.VPR
3668  01 0500           	LXI	B,LAB.VPL
366B  CD AA18           	CALL	$MOVE

366E  1A                	ldax	d			; get sectors/track		/3.0a/
                        	ERRNZ	LAB.SPT-LAB.AUX 				;/3.0a/
                        	ERRNZ	LAB.AXL-1					;/3.0a/
366F  32 6039           	sta	label+LAB.SPT		; set in aux. parameters	/3.0a/

                        *	Compute the rest

3672  2A 1D39           	LHLD	LABEL+LAB.SIZ		; HL = volume size
3675  11 FF00           	LXI	D,255			; This assumes the sector size is 256
3678  19                	DAD	D
3679  7C                	MOV	A,H			; A  = cluster factor
367A  3C                	INR	A
367B  E6 FE             	ANI	377Q-1			; Force cluster to a multiple of 2
367D  32 1839           	STA	LABEL+LAB.SPG		; Stuff sector/group value

3680  2A 1D39           	LHLD	LABEL+LAB.SIZ
3683  44                	MOV	B,H
3684  4D                	MOV	C,L			; BC = volume size
3685  CD 5B35           	CALL	DU68			; HL = number of groups = BC/A

3688  7C                	MOV	A,H
3689  A7                	ANA	A
368A  C2 C136           	JNZ	SVP2			; Too many groups (should never happen)

368D  7D                	MOV	A,L
368E  32 9038           	STA	NGROUPS 		; Save the number of groups
3691  CD 8F34           	CALL	BTS			; HL = first illegal sect. num. = Num. of sect.
3694  22 1D39           	SHLD	LABEL+LAB.SIZ		; Update size to the HDOS size

                        *	Compute Low-Order Space Reservation

3697  21 0A00           	LXI	H,DDF.USR		; Reserve the system data area
369A  3A 1839           	LDA	LABEL+LAB.SPG
369D  3D                	DCR	A
369E  CD 3A18           	CALL	$DADA			; Round up to a totally free block
36A1  CD 2A36           	CALL	STB
36A4  7D                	MOV	A,L
36A5  FE 02             	CPI	2
36A7  D2 AC36           	JNC	SVP1			; More than 2 are reserved

36AA  3E 02             	MVI	A,2			; Force the reservation of at least 2 groups
      = 36AC            SVP1	EQU	*

36AC  32 9138           	STA	NSPCGRP 		; Reserve these groups as special

36AF  6F                	MOV	L,A
36B0  26 00             	MVI	H,0			; HL = RGT block number
36B2  CD 8F34           	CALL	BTS			; Use this sector for the RGT
36B5  22 1B39           	SHLD	LABEL+LAB.RGT		; Save the RGT address in the label

                        *	Fetch the Interleave pointer

36B8  CD 3936           	CALL	SUBFUN
36BB  02                	DB	INI.DBI
36BC  22 8838           	SHLD	DBI			; Save directory block interleave

36BF  A7                	ANA	A			; Clear any errors
36C0  C9                	RET

36C1  CD 5E19           SVP2	CALL	$TYPTX
36C4  0A                	DB	NL
36C5  546F6F20 6D616E79 	DB	'Too many groups on this volume.',ENL
36CD  2067726F 75707320
36D5  6F6E2074 68697320
36DD  766F6C75 6D652E8A
36E5  C3 2A2C           	JMP	RESTART
36E8  C9                	RET
36E9                    	SPACE	4,10
                        **	VSN	- Volume Serial Number
                        *
                        *	VSN returns the volume serial number
                        *
                        *	ENTRY:	NONE
                        *
                        *	EXIT:	A	= volume serial number
                        *
                        *	USES:	PSW
                        *

36E9  3A 1139           VSN	LDA	LABEL+LAB.SER
36EC  A7                	ANA	A
36ED  C9                	RET
36EE                    	SPACE	4,10
                        **	RBS - Request Buffer Space
                        *
                        *	RBS returns the high memory limit used by INIT
                        *	(or the start of free memory).
                        *
                        *	Entry:	None
                        *	Exit:	(hl) = FWA free memory
                        *	Uses:	H,L

36EE  2A 8438           RBS	LHLD	BUFLIM			; FWA
36F1  C9                	RET
36F2                    	STL	'COMMON DECKS'
36F2                    	EJECT
36F2                    	XTEXT	SAVALL
36F2                    SAVALL	SPACE	3,10
                        **	$RSTALL - RESTORE ALL REGISTERS.
                        *
                        *	$RSTALL RESTORES ALL THE REGISTERS OFF THE STACK, AND
                        *	RETURNS TO THE PREVIOUS CALLER.
                        *
                        *	ENTRY	(SP) = PSW
                        *		(SP+2) = BC
                        *		(SP+4) = DE
                        *		(SP+6) = HL
                        *		(SP+8) = RET
                        *	EXIT	TO *RET*, REGISTERS RESTORED
                        *	USES	ALL

      = 1927            $RSTALL EQU	031047A 		; IN H17 ROM
36F2                    	SPACE	3,10
                        **	$SAVALL - SAVE ALL REGISTERS ON STACK.
                        *
                        *	$SAVALL SAVES ALL THE REGISTERS ON THE STACK.
                        *
                        *	ENTRY	NONE
                        *	EXIT	(SP) = PSW
                        *		(SP+2) = BC
                        *		(SP+4) = DE
                        *		(SP+6) = HL
                        *	USES	H,L

      = 192C            $SAVALL EQU	031054A 		; IN H17 ROM
36F2                    	XTEXT	BITC
36F2                    	SPACE	4,10
                        **	BITC	-  BIT CLEAR
                        *
                        *	BITC CLEARS THE SPECIFIED BIT IN THE ACCUMULATOR.
                        *
                        *	ENTRY:	A	= ORIGINAL  A
                        *		B	= BIT NUMBER TO CLEAR ( 7=HIGH,...,0=LOW )
                        *
                        *	EXIT:	A	= ORIGINAL  A WITH BIT(B) CLEARED
                        *
                        *	USES:	PSW
                        *

36F2  C5                BITC	PUSH	B

36F3  F5                	PUSH	PSW
36F4  04                	INR	B
36F5  3E 7F             	MVI	A,01111111B
36F7  07                BITC1	RLC
36F8  05                	DCR	B
36F9  C2 F736           	JNZ	BITC1

36FC  4F                	MOV	C,A
36FD  F1                	POP	PSW
36FE  A1                	ANA	C

36FF  C1                	POP	B
3700  C9                	RET
3701                    	XTEXT	BITS
3701                    	SPACE	4,10
                        ***	BITS - BIT SET.
                        *
                        *	BITS SETS THE SPECIFIED BIT IN THE ACCUMULATOR.
                        *
                        *	ENTRY:	(A)  =	ORIGINAL (A)
                        *		(B)  =	NUMBER OF BIT TO SET (7=HIGH, ... ,0=LOW)
                        *	EXIT:	(A)  =	ORIGINAL (A) WITH BIT (B) SET
                        *	USES:	A,F

3701  C5                BITS	PUSH	B

3702  F5                	PUSH	PSW
3703  3E 80             	MVI	A,10000000B
3705  04                	INR	B
3706  07                BITS1	RLC
3707  05                	DCR	B
3708  C2 0637           	JNZ	BITS1

370B  4F                	MOV	C,A
370C  F1                	POP	PSW
370D  B1                	ORA	C

370E  C1                	POP	B
370F  C9                	RET
3710                    	XTEXT	CCO
3710                    CCO	SPACE	4,10
                        **	$CCO - CLEAR CONTROL-O
                        *
                        *	$CCO IS CALLED TO CLEAR THE EFFECT OF THE CTL-O CHARACTER.
                        *
                        *	ENTRY	NONE
                        *	EXIT	NONE
                        *	USES	NONE


3710  CD 2C19           $CCO	CALL	$SAVALL 		; SAVE REGISTERS
3713  3E 04             	MVI	A,I.CONFL
3715  01 0100           	LXI	B,CO.FLG		; CLEAR CO.FLG
3718  FF 06             	SCALL	.CONSL
371A  C3 2719           	JMP	$RSTALL 		; RESTORE REGISTERS AND RETURN
371D                    	XTEXT	CDEHL
371D                    CDEHL	SPACE	4,10
                        **	$CDEHL - COMPARE (DE) TO (HL)
                        *
                        *	$CDEHL COMPARES (DE) TO (HL) FOR EQUALITY.
                        *
                        *	ENTRY	NONE
                        *	EXIT	'Z' SET IF (DE) = (HL)
                        *	USES	A,F

      = 188E            $CDEHL	EQU	030216A 		; IN H17 ROM
371D                    	XTEXT	CHL
371D                    CHL	SPACE	4,10
                        **	$CHL - COMPLEMENT (HL).
                        *
                        *	(HL) = -(HL)		TWO'S COMPLEMENT
                        *
                        *	ENTRY	NONE
                        *	EXIT	NONE
                        *	USES	A,F,H,L

      = 1894            $CHL	EQU	030224A 		; IN H17 ROM
371D                    	XTEXT	DTB
371D                    	SPACE	4,10
                        **	$DTB - DELETE TRAILING BLANKS.
                        *
                        *	$DTB DELETES THE TRAILING BLANKS FROM A CODED LINE.
                        *
                        *	ENTRY	(HL) = LINE FWA
                        *	EXIT	(A) = LENGTH OF RESULT (ENCLUDING 00 TERMINATOR BYTE)
                        *	USES	A,F

371D  D5                $DTB	PUSH	D			; SAVE (DE)
371E  54                	MOV	D,H
371F  5D                	MOV	E,L			; (DE) = FWA
3720  1B                	DCX	D			; (DE) = FWA-1
3721  7E                $DTB1	MOV	A,M
3722  23                	INX	H
3723  A7                	ANA	A			; FIND END OF LINE
3724  C2 2137           	JNZ	$DTB1
3727  2B                	DCX	H			; (HL) = ADDRESS OF TERMINATING BYTE

                        *	GOT END OF LINE. DELETE TRAILING BLANKS

3728  2B                $DTB2	DCX	H			; BACKUP ONE CHARACTER
3729  CD 8E18           	CALL	$CDEHL
372C  CA 3537           	JE	$DTB3			; GONE PAST FRONT OF LINE, IS ALL BLANKS
372F  7E                	MOV	A,M
3730  FE 20             	CPI	' '
3732  CA 2837           	JE	$DTB2			; GOT BLANK

                        *	HAVE TRIMED LINE. COMPUTE LENGTH

3735  23                $DTB3	INX	H
3736  36 00             	MVI	M,0			; TERMINATE LINE
3738  7D                	MOV	A,L
3739  93                	SUB	E			; (A) = LENGTH +1 (FOR 00 BYTE)
373A  EB                	XCHG
373B  23                	INX	H			; (HL) = LINE FWA
373C  D1                	POP	D			; RESTORE (DE)
373D  C9                	RET
373E                    	XTEXT	DU66
373E                    DU66	SPACE	4,10
                        **	$DU66 - UNSIGNED 16 / 16 DIVIDE.
                        *
                        *	(HL) = (BC)/(DE)
                        *
                        *	ENTRY	(BC), (DE) PRESET
                        *	EXIT	(HL) = RESULT
                        *		(DE) = REMAINDER
                        *	USES	ALL

      = 1846            $DU66	EQU	030106A 		; IN H17 ROM
373E                    	XTEXT	HLIHL
373E                    HLIHL	SPACE	4,10
                        **	$HLIHL - LOAD HL INDIRECT THROUGH HL.
                        *
                        *	(HL) = ((HL))
                        *
                        *	ENTRY	NONE
                        *	EXIT	NONE
                        *	USES	A,H,L

      = 1889            $HLIHL	EQU	030211A 		; IN H17 ROM
373E                    	XTEXT	IDN
373E                    	SPACE	4,10
                        **	$IDN - INPUT DECIMAL NUMBER.
                        *
                        *	$IDN IS CALLED TO INPUT A DECIMAL NUMBER FROM THE CONSOLE.
                        *
                        *	AN ENTIRE LINE IS ACCEPTED, AND THEN THE NUMBER IS DECODED.
                        *
                        *	RUBOUTS AND BACKSPACES MAY BE USED DURING ENTRY.
                        *
                        *	ENTRY	NONE
                        *	EXIT	'C' CLEAR IF OK
                        *		 (HL) = NUMBER
                        *		'C' SET IF SOME ERROR
                        *	USES	ALL

373E  21 9738           $IDN	LXI	H,ITLA
3741  CD A537           	CALL	$RTL			; READ LINE
3744  C3 1F38           	JMP	$PDD			; PACK DECIMAL DIGITS
3747                    	XTEXT	ILDEHL
3747                    	SPACE	4,10
                        ***	ILDEHL - INDEXED LOAD OF (DE) FROM (HL).
                        *
                        *	LOAD (DE) WITH THE FULL WORD VALUE POINTED TO BY (HL).
                        *
                        *	ENTRY:	(HL) = ADDRESS OF VALUE
                        *	EXIT:	(DE) = ((HL))
                        *		(HL) = (HL) + 2
                        *	USES:	D,E

3747  5E                ILDEHL	MOV	E,M
3748  23                	INX	H
3749  56                	MOV	D,M
374A  23                	INX	H
374B  C9                	RET
374C                    	XTEXT	INDL
374C                    INDL	SPACE	4,10
                        **	$INDL - INDEXED LOAD.
                        *
                        *	$INDL LOADS DE WITH THE TWO BYTES AT (HL)+DISPLACMENT
                        *
                        *	THIS ACTS AS AN INDEXED FULL WORD LOAD.
                        *
                        *	(DE) = ( (HL) + DSPLACEMENT )
                        *
                        *	ENTRY	((RET)) = DISPLACMENT (FULL WORD)
                        *		(HL) = TABLE ADDRESS
                        *	EXIT	TO (RET+2)
                        *	USES	A,F,D,E

      = 189C            $INDL	EQU	030234A 		; IN H17 ROM
374C                    	XTEXT	INDXX
374C                    	SPACE	4,10
                        **	$INDLB	-  INDEXED LOAD BYTE
                        *
                        *	BYTE INDEXED LOAD PRIMITIVE
                        *
                        *	ENTRY:	HL = BASE ADDRESS
                        *		(RET) = FULL WORD RELOCATION
                        *	EXIT:	A = ( HL + (RET) )
                        *	USES:	A

374C  EB                $INDLB	XCHG				; DE = BASE
374D  E3                	XTHL				; SAVE	.DE.
374E  D5                	PUSH	D			; SAVE	BASE
374F  C5                	PUSH	B			; SAVE	.BC.

3750  4E                	MOV	C,M
3751  23                	INX	H
3752  46                	MOV	B,M			; BC = OFFSET
3753  23                	INX	H			; HL =	.RET.

3754  EB                	XCHG				; HL = BASE
3755  09                	DAD	B			; HL = BASE + OFFSET
3756  7E                	MOV	A,M			; A  = ( BASE + OFFSET )
3757  EB                	XCHG				; HL =	.RET.

3758  C1                	POP	B			; RESTORE  .BC.
3759  D1                	POP	D			; RESTORE  BASE
375A  E3                	XTHL				; HL = .DE. ; (SP) = .RET.
375B  EB                	XCHG				; DE = .DE. ; HL = BASE
375C  C9                	RET
375D                    	SPACE	4,10
                        **	$INDS	-  INDEXED STORE
                        *
                        *	INDEXED STORE PRIMITIVE.
                        *
                        *	ENTRY:	HL = BASE ADDRESS
                        *		DE = VALUE TO STORE
                        *	EXIT:	( HL + (RET) ) = DE
                        *	USES:	NONE

375D  CD 1B38           $INDS	CALL	XCHGBC
3760  E3                	XTHL				; SAVE	.BC.
3761  D5                	PUSH	D
3762  CD 4737           	CALL	ILDEHL			; DE = OFFSET
3765  CD 1B38           	CALL	XCHGBC			; BC = .RET.
3768  EB                	XCHG				; DE = BASE ; HL = OFFSET
3769  19                	DAD	D			; HL = BASE + OFFSET
376A  EB                	XCHG
376B  E3                	XTHL				; SAVE	BASE
376C  EB                	XCHG				; DE = VALUE
376D  CD 8937           	CALL	ISDEHL
3770  E1                	POP	H			; HL = BASE
3771  CD 1B38           	CALL	XCHGBC
3774  E3                	XTHL				; RESTORE  .BC.
3775  C3 1B38           	JMP	XCHGBC
3778                    	SPACE	4,10
                        **	$INDSB	-  INDEXED BYTE STORE
                        *
                        *	INDEXED BYTE STORE.
                        *
                        *	ENTRY:	A = VALUE TO STORE
                        *		HL = BASE ADDRESS
                        *		(RET) = OFFSET
                        *	EXIT:	NONE
                        *	USES:	PSW

3778  EB                $INDSB	XCHG				; DE = BASE
3779  E3                	XTHL				; SAVE	.DE.
377A  D5                	PUSH	D			; SAVE	BASE
377B  C5                	PUSH	B			; SAVE	.BC.

377C  4E                	MOV	C,M
377D  23                	INX	H
377E  46                	MOV	B,M			; BC = OFFSET
377F  23                	INX	H			; HL =	.RET.

3780  EB                	XCHG				; HL = BASE
3781  09                	DAD	B			; HL = BASE + OFFSET
3782  77                	MOV	M,A			; ( BASE + OFFSET ) = A
3783  EB                	XCHG

3784  C1                	POP	B			; RESTORE  .BC.
3785  D1                	POP	D			; RESTORE  BASE
3786  E3                	XTHL				; HL = .DE. ; (SP) = .RET.
3787  EB                	XCHG				; DE = .DE. ; HL = BASE
3788  C9                	RET
3789                    	XTEXT	ISDEHL
3789                    	SPACE	4,10
                        **	ISDEHL	-  INDEXED STORE OF DE AT HL
                        *
                        *	STORE 'DE' AT THE ADDRESS POINTED TO BY 'HL', AND INCREMENT 'HL'
                        *	BY 2.
                        *
                        *	ENTRY:	DE = VALUE
                        *		HL = ADDRESS OF VALUE
                        *	EXIT:	(HL) = DE
                        *		HL = HL + 2
                        *	USES:	HL

3789  73                ISDEHL	MOV	M,E
378A  23                	INX	H
378B  72                	MOV	M,D
378C  23                	INX	H
378D  C9                	RET
378E                    	XTEXT	MLU
378E                    	SPACE	4,10
                        **	MLU - MAP LOWER CASE LINE TO UPPER CASE.
                        *
                        *	MLU MAPS THE LOWER CASE ALPHABETICS IN A LINE TO UPPER CASE.
                        *
                        *	ENTRY	(HL)  = LINE FWA
                        *	EXIT	NONE
                        *	USES	NONE

378E  F5                $MLU	PUSH	PSW	;SAVE (PSW)
378F  E5                	PUSH	H	;SAVE FWA
3790  2B                	DCX	H	;ANTICIPATE INX H
3791  23                $MLU1	INX	H
3792  7E                	MOV	A,M	;(A)= CHARACTER
3793  CD 7A29           	CALL	$MCU	;MAP CHAR TO UPPER
3796  77                	MOV	M,A
3797  A7                	ANA	A
3798  C2 9137           	JNZ	$MLU1	;MORE TO GO
379B  E1                	POP	H	;RESTORE (HL)
379C  F1                	POP	PSW	;RESTORE (PSW)
379D  C9                	RET
379E                    	XTEXT	RTL
379E                    	SPACE	4,10
                        **	$RTL - READ TEXT LINE.
                        *
                        *	$RTL READS A LINE FROM THE TERMINAL.
                        *
                        *	CHARACTER ARE ACCEPTED FROM THE TERMINAL, RUBOUT AND BACKSPACE
                        *	CHARACTERS ARE PROCESSED. WHEN A CARRIAGE RETURN IS ENTERED,
                        *	$RTL RETURNS.
                        *
                        *	ENTRY	(HL) = BUFFER FWA
                        *	EXIT	'C' CLEAR IF OK
                        *		 DATA IN BUFFER
                        *		 (A) = TEXT LENGTH
                        *		'C' SET IF CTL-D STRUCK
                        *	USES	A,F

379E  CD A537           $RTL.	CALL	$RTL			; $RTL IN UPPER CASE
37A1  D8                	RC				; CTL-D
37A2  C3 8E37           	JMP	$MLU			; MAP LINE TO UPPER CASE

      = 37A5            $RTL	EQU	*

37A5  E5                	PUSH	H			; SAVE FWA
37A6  FF 01             $RTL1	SCALL	.SCIN
37A8  DA A637           	JC	$RTL1
37AB  FE 04             	CPI	CTLD
37AD  CA C237           	JE	$RTL2			; CTL-D STRUCK
37B0  77                	MOV	M,A
37B1  23                	INX	H
37B2  FE 0A             	CPI	NL
37B4  C2 A637           	JNE	$RTL1
37B7  2B                	DCX	H
37B8  36 00             	MVI	M,0
37BA  23                	INX	H

                        *	ALL DONE. COMPUTE LENGTH

37BB  EB                	XCHG				; (DE) = LWA+1
37BC  E3                	XTHL				; (HL) = FWA
37BD  7B                	MOV	A,E
37BE  95                	SUB	L			; (A) = LENGTH
37BF  A7                	ANA	A			; CLEAR CARRY
37C0  D1                	POP	D			; RESTORE (DE)
37C1  C9                	RET

                        *	CTL-D STRUCK

37C2  E1                $RTL2	POP	H			; (HL) = FWA
37C3  37                	STC
37C4  C9                	RET
37C5                    	XTEXT	WER
37C5                    WER	SPACE	4,10
                        **	$WER - WRITE ENABLE RAM.
                        *
                        *	$WER IS CALLED TO ENABLE WRITTING TO THE H17 CONTROLLER'S
                        *	RAM AREA.
                        *
                        *	ENTRY	NONE
                        *	EXIT	NONE
                        *	USES	NONE

      = 19A1            $WER	EQU	031241A 		; IN H17 ROM
37C5                    	SPACE	4,10
                        **	$WDR - WRITE DISABLE RAM.
                        *
                        *	$WDR IS CALLED TO DISABLE WRITTING TO THE H17 CONTROLLER'S
                        *	RAM AREA.
                        *
                        *	ENTRY	NONE
                        *	EXIT	NONE
                        *	USES	NONE

      = 1992            $WDR	EQU	031222A 		; IN H17 ROM
37C5                    	XTEXT	RCHAR
37C5                    RCHAR	SPACE	4,10
                        **	$RCHAR - READ SINGLE CHARACTER FROM CONSOLE.
                        *
                        *	ENTRY	NONE
                        *	EXIT	(A) = CHARACTER
                        *	USES	A,F

37C5  FF 01             $RCHAR	SCALL	.SCIN
37C7  DA C537           	JC	$RCHAR	;NOT READY
37CA  C9                	RET

37CB  FF 02             $WCHAR	SCALL	.SCOUT
37CD  C9                	RET
37CE                    	XTEXT	SOB
37CE                    	SPACE	4,10
                        **	$SOB - SKIP OVER BLANKS.
                        *
                        *	$SOB IS CALLED TO SKIP AN ARBITRARILY LONG STRING OF BLANKS AND TABS.
                        *
                        *	ENTRY	(HL) = FWA OF (POSSIBLE) BLANK STRING
                        *	EXIT	(HL) = LWA+1 OF BLANK STRING (UNCHANGED IF NO BLANKS)
                        *		(A) = FIRST NON-BLANK, NON-TAB CHARACTER EEN
                        *	USES	A,F,H,L

37CE  2B                $SOB	DCX	H			; PRE-DECREMENT
37CF  23                $SOB1	INX	H
37D0  7E                	MOV	A,M
37D1  FE 20             	CPI	' '
37D3  CA CF37           	JE	$SOB1			; GOT BLANK
37D6  FE 09             	CPI	TAB
37D8  CA CF37           	JE	$SOB1			; GOT TAB
37DB  C9                	RET
37DC                    	XTEXT	TBLS
37DC                    TBLS	SPACE	4,10
                        **	$TBLS - TABLE SEARCH
                        *
                        *	TABLE FORMAT
                        *
                        *	DB	KEY1,VAL1,
                        *	.	.
                        *	.	.
                        *	DB	KEYN,VALN
                        *	DB	0
                        *
                        *	ENTRY	(A) = PATTERN
                        *		(H,L) = TABLE FWA
                        *	EXIT	(A) = PATTERN IF FOUND
                        *		'Z' SET IF FOUND
                        *		'Z' CLEAR IF NOT FOUND OR PATTERN=0
                        *	USES	A,F,H,L

37DC  C5                $TBLS	PUSH	B
37DD  A7                	ANA	A						;/3.0a/
37DE  CA F037           	JZ	TBL2
37E1  47                	MOV	B,A
37E2  7E                TBL1	MOV	A,M			; (A) = CHARACTER
37E3  23                	INX	H
37E4  B8                	CMP	B
37E5  CA F237           	JZ	TBL3			; IF MATCH
37E8  A7                	ANA	A
37E9  23                	INX	H			; SKIP PAST
37EA  C2 E237           	JNZ	TBL1			; IF NOT END OF TABLE
37ED  2B                	DCX	H
37EE  2B                	DCX	H
37EF  AF                	XRA	A			; SET TO ZERO FOR OLD USERS
37F0  FE 01             TBL2	CPI	1			; CLEAR ZERO

                        *	DONE

37F2  C1                TBL3	POP	B
37F3  C9                	RET
37F4                    	XTEXT	TBRA
37F4                    TBRA	SPACE	4,10
                        **	$TBRA - BRANCH RELATIVE THOUGH TABLE.
                        *
                        *	$TBRA USES THE SUPPLIED INDEX TO SELECT A BYTE FROM THE
                        *	JUMP TABLE. THE CONTENTS OF THIS BYTE ARE ADDED TO THE
                        *	ADDRESS OF THE BYTE, YEILDING THE PROCESSOR ADDRESS.
                        *
                        *	CALL	$TBRA
                        *	DB	LAB1-*		INDEX = 0 FOR LAB1
                        *	DB	LAB2-*		INDEX = 1 FOR LAB2
                        *	DB	LABN-*		INDEX = N-1 FOR LABN
                        *
                        *	ENTRY	(A) = INDEX
                        *		(RET) = TABLE FWA
                        *	EXIT	TO COMPUTED ADDRESS
                        *	USES	F,H,L

      = 193E            $TBRA	EQU	031076A 		; IN H17 ROM
37F4                    	XTEXT	TYPCH
37F4                    TYPCH	SPACE	4,10
                        **	$TYPCH - TYPE SINGLE CHARACTER.
                        *
                        *	ENTRY	(RET) = CHARACTER
                        *	EXIT	TO (RET)+1
                        *		(A) = CHARACTER TYPED

37F4  E3                $TYPCH	XTHL				; (HL) = RETURN ADDRESS
37F5  7E                	MOV	A,M			; (A) = CHARACTER
37F6  23                	INX	H
37F7  E3                	XTHL				; RESTORE ADVANCED EXIT ADDRESS
                        *	JMP	$TYPC.
                                ERRNZ   *-$TYPC.
37F8                            SPACE   4,10
                        **	$TYPC. - TYPE SINGLE CHARACTER.
                        *
                        *	ENTRY	(A) = CHARACTER
                        *	EXIT	TO (RET)

37F8  FF 02             $TYPC.	SCALL	.SCOUT
37FA  C9                	RET
37FB                    	XTEXT	TYPT2
37FB                    TYPT2	SPACE	4,10
                        **	$TYPTX - TYPE TEXT.
                        *
                        *	$TYPTX IS CALLED TO TYPE A BLOCK OF TEXT ON THE SYSTEM CONSOLE.
                        *
                        *	IMBEDDED ZER0 BYTES INDICATE A CARRIAGE RETURN LINE FEED,
                        *	A BYTE WITH THE 200Q BIT SET IS THE LAST BYTE IN THE MESSAGE.
                        *
                        *	ENTRY	(RET) = TEXT
                        *	EXIT	TO (RET+LENGTH)
                        *	USES	A,F

      = 195E            $TYPTX	EQU	031136A 		; IN H17 ROM

      = 1964            $TYPTX. EQU	031144A 		; IN H17 ROM
      = 0001            $CMP$	EQU	1			; NO COMPRESSED TEXT
37FB                    	XTEXT	TYPLN
37FB                    TYPLN	SPACE	4,10
                        **	$TYPLN - TYPE LINE.
                        *
                        *	$TYPLN IS CALLED TO TYPE A LINE OF TEXT. ZERO BYTES ARE
                        *	TAKEN AS CRLF (WITH THE PROPER PADDING)
                        *
                        *	CALL	$TYPLN
                        *	DB	N		BYTE COUNT OF FOLLOWING MESSAGE
                        *	DB	'N-CHARACTER MESSAGE'
                        *
                        *	ENTRY	(RET) = TEXT COUNT
                        *		(RET)+1 - (RET)+N = TEXT
                        *	EXIT	TO (RET)+N+1
                        *	USES	A,F
                        *

37FB  E3                $TYPLN. XTHL				; (H,L) = COUNT ADDRESS
37FC  7E                	MOV	A,M			; (A) = COUNT
37FD  23                	INX	H			; (H,L)  = TEXT ADDRESS
37FE  E5                	PUSH	H			; SAVE TEXT FWA
37FF  CD 3A18           	CALL	$DADA			; CALCULATE RETURN ADDRESS
3802  E3                	XTHL				; (HL) = TEXT ADDRE
3803  CD 0938           	CALL	$TYPL.			; OUTPUT LINE
3806  E1                	POP	H			; (HL) = RETURN ADDRESS
3807  E3                	XTHL				; RESTORE (HL), SET RETURN ADDRESS
3808  C9                	RET
3809                    	SPACE	4,10
                        **	$TYPL. - TYPE LINE.
                        *
                        *	ENTRY	(HL) = ADDRESS
                        *		(A) = COUNT
                        *	EXIT	NONE
                        *	USES	A,F,H,L

      = 3809            $TYPL.	EQU	*

3809  A7                	ANA	A
380A  C8                	RZ				; NOTHING TO TYPE
380B  F5                	PUSH	PSW			; SAVE COUNT
380C  7E                	MOV	A,M			; (A) = CHARACTER
380D  23                	INX	H
380E  A7                	ANA	A
                        	IF	$CMP$			; IF HAVE COMPRESSED SPACES
                        	ENDIF
380F  CC 7E38           	CZ	$CRLF
3812  CD F837           	CALL	$TYPC.			; TYPE CHARACTER
3815  F1                TPL1	POP	PSW
3816  3D                	DCR	A
3817  C2 0938           	JNZ	$TYPL.
381A  C9                	RET

                        	IF	$CMP$			; IF COMPRESSED TEXT
                        	ENDIF
381B                    	XTEXT	UDD
381B                    UDD	SPACE	4,10
                        **	$UDD - UNPACK DECIMAL DIGITS.
                        *
                        *	UDD CONVERTS A 16 BIT VALUE INTO A SPECIFIED NUMBER OF
                        *	DECIMAL DIGITS. THE RESULT IS ZERO FILLED.
                        *
                        *	ENTRY	(B,C) = ADDRESS VALUE
                        *		(A) = DIGIT COUNT
                        *		(H,L) = MEMORY ADDRESS
                        *	EXIT	(HL) = (HL) + (A)
                        *	USES	ALL

      = 196F            $UDD	EQU	031157A 		; IN H17 ROM
381B                    	XTEXT	XCHGBC
381B                    	SPACE	4,10
                        ***	XCHGBC - Exchange (HL) with (BC).
                        *
                        *	Entry:	NONE
                        *	Exit:	(HL) = (BC)
                        *		(BC) = (HL)
                        *	Uses:	B,C,H,L
                        *
                        *	Note:	Whoever wrote the original version of this routine
                        *		(that distributed by Heath), really ought to be shot.

381B  C5                XCHGBC	PUSH	B			; Put (BC) on stack
381C  E3                	XTHL				; Swap it with (HL)
381D  C1                	POP	B			; Pop new (BC)
381E  C9                	RET
381F                    	XTEXT	PDD
381F                    	SPACE	4,10
                        **	$PDD - PACK DECIMAL DIGITS.
                        *
                        *	$PDD PACKS A STRING OF DECIMAL DIGITS INTO A DECIMAL INTEGER.
                        *
                        *	THE CHARACTERS MUST BE IN MEMORY, AND BE IMMEDIATELY FOLLOWED BY A
                        *	00 BYTE.
                        *
                        *	ENTRY	(HL) = ADDRESS OF CHARACTERS
                        *	EXIT	'C' CLEAR IF OK
                        *		 (HL) = NUMBER
                        *		'C' SET IF ERROR
                        *	USES	A,F,D,E,H,L

381F  EB                $PDD	XCHG				; (DE) = TEXT ADDRESS
3820  21 0000           	LXI	H,0			; (HL) = ACCUM

3823  1A                $PDD1	LDAX	D
3824  13                	INX	D			; ADVANCE ADDRESS
3825  A7                	ANA	A
3826  C8                	RZ				; ALL DONE
3827  D6 30             	SUI	'0'
3829  D8                	RC				; TOO SMALL
382A  FE 0A             	CPI	10
382C  3F                	CMC
382D  D8                	RC				; TOO SMALL
382E  D5                	PUSH	D			; SAVE (DE)
382F  EB                	XCHG
3830  CD D418           	CALL	$MU10
3833  D1                	POP	D
3834  D8                	RC				; OVERFLOW
3835  85                	ADD	L
3836  6F                	MOV	L,A
3837  3E 00             	MVI	A,0
3839  8C                	ADC	H
383A  67                	MOV	H,A
383B  D2 2338           	JNC	$PDD1			; NOT OVERFLOW
383E  C9                	RET
383F                    	XTEXT	MU10
383F                    MU10	SPACE	4,10
                        **	$MU10 - MULTIPLY UNSIGNED 16 BIT QUANTITY BY 10.
                        *
                        *	(HL) = (DE)*10
                        *
                        *	ENTRY	(DE) = MULTIPLIER
                        *	EXIT	'C' CLEAR IF OK
                        *		 (HL) = PRODUCT
                        *		'C' SET IF ERROR
                        *	USES	D,E,H,L,F

      = 18D4            $MU10	EQU	030324A 		; IN H17 ROM
383F                    	XTEXT	ITL
383F                    	SPACE	4,10
                        **	$ITL - INPUT TEXT LINE.
                        *
                        *	$ITL INPUTS A LINE FROM THE TERMINAL.
                        *
                        *	CHARACTER ARE ACCEPTED FROM THE TERMINAL, RUBOUT AND BACKSPACE
                        *	CHARACTERS ARE PROCESSED. WHEN A CARRIAGE RETURN IS ENTERED,
                        *	$ITL RETURNS.
                        *
                        *	ENTRY	NONE
                        *	EXIT	(HL) = #ITLA
                        *		(A) = TEXT LENGTH
                        *	USES	A,F,H,L

383F  CD 4538           $ITL.	CALL	$ITL			; INPUT LINE IN UPPER CASE
3842  C3 8E37           	JMP	$MLU			; MAP LINE TO UPPER

3845  21 9738           $ITL	LXI	H,ITLA
3848  C3 A537           	JMP	$RTL			; READ TEXT LINE
384B                    	XTEXT	TDD
384B                    	SPACE	4,10
                        **	$TDD - TYPE DECIMAL DIGITS.
                        *
                        *	$TDD TYPES A 16 BIT VALUE AS 1 TO 5 DECIMAL DIGITS.
                        *
                        *	ENTRY	(D,E) = VALUE
                        *		(A) = DIGIT COUNT
                        *	EXIT	VALUE TYPED.
                        *	USES	A,B,C,F

384B  3E 05             $TDD.	MVI	A,5
384D  E5                $TDD	PUSH	H
384E  F5                TDD1	PUSH	PSW
384F  21 7238           	LXI	H,TDDA-2
3852  07                	RLC				; (A) = DIGIT NUMBER*2
3853  CD 4118           	CALL	$DADA.
3856  7E                	MOV	A,M
3857  23                	INX	H
3858  66                	MOV	H,M
3859  6F                	MOV	L,A			; (HL) = MULTIPLE OF 10
385A  EB                	XCHG				; (DE) = DEVISOR, (HL) = VALUE
385B  3E FF             	MVI	A,377Q
385D  19                TDD2	DAD	D
385E  3C                	INR	A
385F  DA 5D38           	JC	TDD2			; IF MORE TO GO
3862  C6 30             	ADI	'0'
3864  CD F837           	CALL	$TYPC.			; TYPE DIGIT
3867  7D                	MOV	A,L
3868  93                	SUB	E
3869  5F                	MOV	E,A			; REMOVE EXTRA SUBTRACTION
386A  7C                	MOV	A,H
386B  9A                	SBB	D
386C  57                	MOV	D,A
386D  F1                	POP	PSW
386E  3D                	DCR	A
386F  C2 4E38           	JNZ	TDD1			; IF MORE DIGITS
3872  E1                	POP	H
3873  C9                	RET

3874  FFFF              TDDA	DW	-1
3876  F6FF              	DW	-10
3878  9CFF              	DW	-100
387A  18FC              	DW	-1000
387C  F0D8              	DW	-10000
387E                    	XTEXT	DADA
387E                    DADA	SPACE	4,10
                        **	$DADA - PERFORM (H,L) = (H,L) + (0,A)
                        *
                        *	ENTRY	(H,L) = BEFORE VALUE
                        *		(A) = BEFORE VALUE
                        *	EXIT	(H,L) = (H,L) + (0,A)
                        *		'C' SET IF OVERFLOW
                        *	USES	F,H,L

      = 183A            $DADA	EQU	030072A 		; IN H17 ROM
387E                    	XTEXT	CRLF
387E                    CRLF	SPACE	4,10
                        **	$CRLF - TYPE CARRIAGE RETURN/ LINE FEED
                        *
                        *	$CRLF IS USED TO GENERATE PADDED CRLF'S.
                        *
                        *	ENTRY	NONE
                        *	EXIT	(A) = 0
                        *	USES	A,F

387E  3E 0A             $CRLF	MVI	A,NL
3880  FF 02             	SCALL	.SCOUT
3882  AF                	XRA	A
3883  C9                	RET
3884                    	STL	'DATA AND CONSTANTS'
3884                    	EJECT

                        **	Data and Constants

3884  BD42              BUFLIM	DW	RMEML			; Buffer Limit
3886  E838              CRNDEV	DW	DEVTAB			; Current Device Pointer
3888  0000              DBI	DW	0			; Pointer to dir. block interleave
388A  00                GRTBLK	DB	0			; BLOCK NUMBER CONTAINING GRT
388B  00                DIRBLK	DB	0			; BLOCK NUMBER OF FIRST DIRECTORY BLOCK
388C  00                DIRLBLK DB	0			; BLOCK NUMBER OF LAST DIRECTORY BLOCK
388D  0000              MEMLIM	DW	0			; Memory Limit
388F  00                NDIRBLK DB	0			; Number of Directory Blocks
3890  00                NGROUPS DB	0			; Number of Valid Groups
3891  00                NSPCGRP DB	0			; Number of Special Groups (>=2)
3892  00                SUNIT	DB	0			; System Unit
3893  00                SYMNU	DB	0			; SY: Maximum Number of Units
3894  0000              SYPTR	DW	0			; SY: Internal Device Table Ptr.
3896  00                UNIT	DB	0			; Unit Number

3897  00000000 00000000 LINE	DC	81,#*-LINE					;/3.0a/
389F  00000000 00000000
38A7  00000000 00000000
38AF  00000000 00000000
38B7  00000000 00000000
38BF  00000000 00000000
38C7  00000000 00000000
38CF  00000000 00000000
38D7  00000000 00000000
38DF  00000000 00000000
38E7  00
      = 0050            LINEL	EQU	*-LINE-1
      = 3897            ITLA	EQU	LINE			; USE LINE FOR BUFFER
38E8                    	SPACE	4,10
                        **	DEVTAB	-  Device Table
                        *

      = 38E8            DEVTAB	EQU	*
      = 38E8            .	SET	*

      = 0000            DVT.NAM	EQU	*-.
38E8  78783A00          	DB	'xx',':',0		; Device Name

      = 0004            DVT.ADR EQU	*-.
38EC  0000              	DW	0			; Device Table Entry Address

      = 0006            DVT.PAR EQU	*-.
38EE  0000              	DW	0			; Parameter File Pointer

      = 0008            DVT.PIC EQU	*-.
38F0  0000              	DW	0			; PIC Table Address

      = 000A            DVT.ENL EQU	*-.			; Device Table Entry Length

38F2  00000000 00000000 	DC	DVT.MAX-1*DVT.ENL,#0	; Room for more device entries	/3.0a/
38FA  00000000 00000000
3902  00000000 00000000
390A  00000000 0000

3910  00                DEVTABE DB	0			; Zero at the end of the list
3911                    	SPACE	4,10
                        **	DISK LABEL

      = 3911            LABEL	EQU	*

                        	ERRNZ	*-LABEL-LAB.SER
3911  00                	DB	0			; SERIAL NUMBER
                        	ERRNZ	*-LABEL-LAB.IND
3912  0000              	DW	0			; CREATION DATE
                        	ERRNZ	*-LABEL-LAB.DIS
3914  0000              	DW	0			; INDEX OF FIRST DIRECTORY SECTOR
                        	ERRNZ	*-LABEL-LAB.GRT
3916  0000              	DW	0			; GRT TABLE INDEX
                        	ERRNZ	*-LABEL-LAB.SPG
3918  00                	DB	0			; SECTORS PER GROUP
                        	ERRNZ	*-LABEL-LAB.VLT
3919  00                	DB	LAB.DAT 		; VOLUME TYPE
                        	ERRNZ	*-LABEL-LAB.VER
391A  30                	DB	VERS			; VERSION OF INIT TO INIT DISK

                        	ERRNZ	*-LABEL-LAB.RGT
391B  0000              	DW	0			; Sector Address of RGT

                        	ERRNZ	*-LABEL-LAB.VPR
                        	ERRNZ	*-LABEL-LAB.SIZ
391D  0000              	DW	0			; Volume Size
                        	ERRNZ	*-LABEL-LAB.PSS
391F  0000              	DW	0			; Physical Sector Size
                        	ERRNZ	*-LABEL-LAB.VFL
3921  00                	DB	0			; Device dependant flags
                        	ERRNZ	*-LABEL-LAB.VPR-LAB.VPL

                        	ERRNZ	*-LABEL-LAB.LAB
3922  00000000 00000000 	DC	60,#0			; LABEL 			/3.0a/
392A  00000000 00000000
3932  00000000 00000000
393A  00000000 00000000
3942  00000000 00000000
394A  00000000 00000000
3952  00000000 00000000
395A  00000000
395E  0000              	DB	0,0			; END OF LABEL

                        	ERRNZ	*-LABEL-LAB.AUX
3960  00                	DC	LAB.AXL,#0		; Reserve Space for Aux. Param	/3.0a/

3961  20202020          	DB	'    '
3965  0D0A              	DB	CR,LF
3967  53797374 656D2043 	DB	'System Copyright (c) Heath Co., 1977, 79'
396F  6F707972 69676874
3977  20286329 20486561
397F  74682043 6F2E2C20
3987  31393737 2C203739
398F  0D0A              	DB	CR,LF
3991  20627920 4A474C2C 	DB	' by JGL, 1977'
3999  20313937 37
399E  2F676320          	DB	'/gc '
39A2  0D0A              	DB	CR,LF						;/3.0a/
39A4  20627920 5747502C 	DB	' by WGP, 1985' 				;/3.0a/
39AC  20313938 35
39B1  00                	DB	0			; END OF LABEL			/3.0a/

39B2  A1A1A1A1 A1A1A1A1 PATCH	DC	LABEL-*+256,#*-LABEL	; PATCH AREA			/3.0a/
39BA  A1A1A1A1 A1A1A1A1
39C2  A1A1A1A1 A1A1A1A1
39CA  A1A1A1A1 A1A1A1A1
39D2  A1A1A1A1 A1A1A1A1
39DA  A1A1A1A1 A1A1A1A1
39E2  A1A1A1A1 A1A1A1A1
39EA  A1A1A1A1 A1A1A1A1
39F2  A1A1A1A1 A1A1A1A1
39FA  A1A1A1A1 A1A1A1A1
3A02  A1A1A1A1 A1A1A1A1
3A0A  A1A1A1A1 A1A1A1

3A11                    	STL	'Overlaid One-Time Code'
3A11                    	EJECT
      = 3A11            OVRLAY	EQU	*			; Start of buffers initially code

                        **	PRS - PRESET PROGRAM.
                        *
                        *	PRS PERFORMS ANY INITIALIZATION TASKS, AND  INFORMS THE
                        *	USER OF THE FACTS OF LIFE CONCERNING INITIALIZATION/.
                        *
                        *	ENTRY	NONE
                        *	EXIT	TO SYSTEM IF USER CHICKENS OUT
                        *		TO CALLER IF OK
                        *	USES	ALL

3A11  CD 1037           PRS	CALL	$CCO			; CLEAR CTL-O
3A14  CD 5E19           	CALL	$TYPTX
3A17  0A090909 20202020 	DB	NL,TAB,TAB,TAB,'    ','INIT'
3A1F  494E4954
3A23  0A090909 56657273 	DB	NL,TAB,TAB,TAB,'Version:  ',VERS/16+'0','.',VERS&00001111B+'0'
3A2B  696F6E3A 2020332E
3A33  30
3A34  0A090920 20202020 	DB	NL,TAB,TAB,'     ','Issue:  # 50.07.00'
3A3C  49737375 653A2020
3A44  23203530 2E30372E
3A4C  3030
3A4E  0A                	DB	NL
3A4F  0A095468 69732020 	DB	NL,TAB,'This  program is used to initialize HDOS floppy'
3A57  70726F67 72616D20
3A5F  69732075 73656420
3A67  746F2069 6E697469
3A6F  616C697A 65204844
3A77  4F532066 6C6F7070
3A7F  79
3A80  20646973 6B732E   	DB	' disks.'
3A87  0A497420 69732020 	DB	NL,'It is  a  stand-alone utility,  and  will destroy any'
3A8F  61202073 74616E64
3A97  2D616C6F 6E652075
3A9F  74696C69 74792C20
3AA7  20616E64 20207769
3AAF  6C6C2064 65737472
3AB7  6F792061 6E79
3ABD  2066696C 6573206F 	DB	' files on'
3AC5  6E
3AC6  0A746865 20646973 	DB	NL,'the disks it initializes.  Do not attempt to use this'
3ACE  6B732069 7420696E
3AD6  69746961 6C697A65
3ADE  732E2020 446F206E
3AE6  6F742061 7474656D
3AEE  70742074 6F207573
3AF6  65207468 6973
3AFC  20207072 6F677261 	DB	'  program'
3B04  6D
3B05  0A756E74 696C2079 	DB	NL,'until you have studied the appropriate manual.'
3B0D  6F752068 61766520
3B15  73747564 69656420
3B1D  74686520 61707072
3B25  6F707269 61746520
3B2D  6D616E75 616C2E
3B34  8A                	DB	ENL

3B35  CD 1037           PRS1	CALL	$CCO			; CLEAR CTL-O
3B38  CD 5E19           	CALL	$TYPTX
3B3B  0A50726F 63656564 	DB	NL,'Proceed (YES/NO) <NO> ','?'+EOL
3B43  20285945 532F4E4F
3B4B  29203C4E 4F3E20BF
3B53  CD 3F38           	CALL	$ITL.

3B56  7E                	MOV	A,M
3B57  A7                	ANA	A
3B58  CA 832C           	JZ	EXIT			; WANTS TO EXIT
3B5B  CD 9B34           	CALL	CNO
3B5E  CA 832C           	JZ	EXIT			; Wants to Exit

3B61  CD A934           	CALL	CYS
3B64  C2 353B           	JNZ	PRS1			; Not a legal answer

3B67  C9                	RET				; Wants to proceed
3B68                    	SPACE	4,10
                        **	PRSS	- Preset Preset
                        *
                        *	PRSS is the initial preset code executed only once
                        *	when INIT is entered.
                        *

3B68  FF 09             PRSS	SCALL	.VERS
3B6A  DA B43B           	JC	PRSS1			; NO .VERS SYSTEM CALL
3B6D  FE 30             	CPI	VERS
3B6F  C2 B43B           	JNZ	PRSS1			; VERSIONS DO NOT MATCH

3B72  21 0000           	LXI	H,0
3B75  39                	DAD	SP			; HL = Stack
3B76  CD CE37           	CALL	$SOB			; Skip blanks
3B79  F9                	SPHL				; Save New Stack
3B7A  7E                	MOV	A,M
3B7B  A7                	ANA	A
3B7C  CA 853B           	JZ	PRSS0			; Null Line
3B7F  11 8022           	LXI	D,STACK
3B82  CD 7429           	CALL	CPDEHL
3B85  CC 113A           PRSS0	CZ	PRS			; Make sure we really want this!

3B88  CD BA3B           	CALL	FDP			; fetch device parameters
3B8B  CD E53D           	CALL	PSD			; Patch System Device

3B8E  3E FF             	MVI	A,377Q
3B90  FF 26             	SCALL	.CLOSE			; CLOSE THE CHANNEL WE CAME IN ON
3B92  AF                	XRA	A
3B93  32 D620           	STA	S.CSLMD 		; SETUP CONSOLE MODE

3B96  CD A83E           	CALL	$DOS			; DISMOUNT OPERATING SYSTEM
3B99  DA 862C           	JC	ERROR			; ERROR

                        *	Check for data passed on the command line

3B9C  21 0000           	LXI	H,0
3B9F  39                	DAD	SP			; HL = SP
3BA0  7E                	MOV	A,M
3BA1  A7                	ANA	A
3BA2  CA 332C           	JZ	INIT0			; Null Line on Stack, ask user for device
3BA5  11 8022           	LXI	D,STACK
3BA8  CD 7429           	CALL	CPDEHL
3BAB  CA 332C           	JZ	INIT0			; Ask user for device

                        *	Force a default device specification from the command line

3BAE  CD 1B2D           	CALL	PDN.
3BB1  C3 3C2C           	JMP	INIT1			; do it!

                        *	Error

3BB4  3E 28             PRSS1	MVI	A,EC.NCV
3BB6  37                	STC
3BB7  C3 862C           	JMP	ERROR
3BBA                    	SPACE	4,10
                        **	FDP	-  Fetch Device Parameters
                        *
                        *	FDP fetches all of the data from each of the device
                        *	parameter files
                        *

3BBA  2A EC20           FDP	LHLD	S.DFWA

                        *	Fetch parameter files

3BBD  7E                FDP1	MOV	A,M
                        	ERRNZ	DEV.NAM
3BBE  FE 00             	CPI	DV.EL
3BC0  CA DB3B           	JZ	FDP3			; At the end of the device list

3BC3  FE 01             	CPI	DV.NU
3BC5  CA D43B           	JZ	FDP2			; device entry not in use

3BC8  CD 4C37           	CALL	$INDLB
3BCB  0600              	DW	DEV.FLG
3BCD  E6 01             	ANI	DT.DD
3BCF  E5                	PUSH	H
3BD0  C4 DF3B           	CNZ	FDP5			; fetch all of the parameters
3BD3  E1                	POP	H

3BD4  11 0E00           FDP2	LXI	D,DEVELEN
3BD7  19                	DAD	D
3BD8  C3 BD3B           	JMP	FDP1

                        *	Flag the end of the device list for sure

3BDB  CD 443D           FDP3	CALL	FDP9
3BDE  C9                	RET
3BDF                    	SPACE	4,10
                        **	FDP5
                        *
                        *	really fetch the data
                        *
                        *	Fixed bug so that SY: is found if it is not first		/2.1b/
                        *	in list in search by PSD.
                        *

3BDF  CD B93D           FDP5	CALL	FMM

3BE2  CD 9C18           	CALL	$INDL
3BE5  0000              	DW	DEV.NAM
3BE7  EB                	XCHG
3BE8  22 7D3D           	SHLD	FDPC			; set device name in file look-up
3BEB  22 B53D           	SHLD	FDPF			; set .loadd name
3BEE  EB                	XCHG

3BEF  E5                	PUSH	H
3BF0  2A 8638           	LHLD	CRNDEV
3BF3  CD 5D37           	CALL	$INDS			; set name in internal device table
3BF6  0000              	DW	DVT.NAM
3BF8  11 3A00           	LXI	D,':'						;/2.1b/
3BFB  CD 5D37           	CALL	$INDS			; set rest of name		/2.1b/
3BFE  0200              	DW	DVT.NAM+2					;/2.1b/
                        	ERRNZ	DVT.ADR-DVT.NAM-4				;/2.1b/
3C00  D1                	POP	D
3C01  CD 5D37           	CALL	$INDS			; set device table address
3C04  0400              	DW	DVT.ADR

                        *	Check for table overflow

3C06  2A 8638           	LHLD	CRNDEV
3C09  11 1039           	LXI	D,DEVTABE
3C0C  CD 7429           	CALL	CPDEHL
3C0F  D2 4A3D           	JNC	FDP10			; Table overflow

                        *	Read the Device driver parameter file

3C12  11 843D           	LXI	D,FDPD			; DE = address of defaults
3C15  21 733D           	LXI	H,FDPB			; HL = file block
3C18  CD 6F3F           	CALL	$FOPER.
3C1B  DA 9D3C           	JC	FDP6

3C1E  CD 763E           	CALL	VFT			; Verify File Type, and find Parameters
3C21  DA C43C           	JC	FDP7

3C24  01 0600           	LXI	B,PIC.COD
3C27  11 8A3D           	LXI	D,FDPE
3C2A  21 733D           	LXI	H,FDPB
3C2D  CD C53F           	CALL	$FREAB. 		; Read the header information
3C30  DA C43C           	JC	FDP7

3C33  3A 8A3D           	LDA	FDPE+PIC.ID
3C36  FE FF             	CPI	377Q
3C38  C2 C43C           	JNZ	FDP7			; The file is not in BINARY format

3C3B  3A 8B3D           	LDA	FDPE+PIC.ID+1
3C3E  FE 01             	CPI	FT.PIC
3C40  C2 C43C           	JNZ	FDP7			; The file is not in PIC format

3C43  2A 8C3D           	LHLD	FDPE+PIC.LEN		; HL = length of entire record
3C46  EB                	XCHG
3C47  2A 8438           	LHLD	BUFLIM
3C4A  19                	DAD	D
3C4B  EB                	XCHG				; DE = Prospective buffer end
3C4C  2A 8D38           	LHLD	MEMLIM
3C4F  CD 7429           	CALL	CPDEHL
3C52  3E 11             	MVI	A,EC.NEM
3C54  DA 862C           	JC	ERROR

3C57  2A 8438           	LHLD	BUFLIM
3C5A  EB                	XCHG				; DE = FWA for current entry
3C5B  22 8438           	SHLD	BUFLIM			; Allocate the new memory

3C5E  2A 8638           	LHLD	CRNDEV
3C61  CD 5D37           	CALL	$INDS			; Save FWA of Parameter file
3C64  0600              	DW	DVT.PAR

                        *	Read the rest of the file

3C66  2A 8C3D           	LHLD	FDPE+PIC.LEN
3C69  01 FAFF           	LXI	B,-PIC.COD					;/2.1b/
3C6C  09                	DAD	B			; Subtract bytes already read	/2.1b/
3C6D  44                	MOV	B,H
3C6E  4D                	MOV	C,L			; BC = byte count
3C6F  21 733D           	LXI	H,FDPB
3C72  CD C53F           	CALL	$FREAB.
3C75  DA C43C           	JC	FDP7			; Error

3C78  21 733D           	LXI	H,FDPB
3C7B  CD 1C3F           	CALL	$FCLO.
3C7E  DA C43C           	JC	FDP7

3C81  CD 333E           	CALL	RDP			; Relocate device parameters

                        *	Load device driver

3C84  CD D03D           	CALL	FNM			; reduce memory consumption
3C87  21 B53D           	LXI	H,FDPF
3C8A  FF 32             	SCALL	.LOADD			; load device driver
3C8C  DA F53C           	JC	FDP8			; ERROR

                        *	Advance current device table

3C8F  2A 8638           	LHLD	CRNDEV
3C92  11 0A00           	LXI	D,DVT.ENL
3C95  19                	DAD	D
3C96  22 8638           	SHLD	CRNDEV

3C99  CD 443D           	CALL	FDP9

3C9C  C9                	RET

                        *	Parameter file not found

3C9D  CD 443D           FDP6	CALL	FDP9
3CA0  CD 5E19           	CALL	$TYPTX
3CA3  4E6F2049 4E495420 	DB	'No INIT parameter file found,',' '+EOL
3CAB  70617261 6D657465
3CB3  72206669 6C652066
3CBB  6F756E64 2CA0
3CC1  C3 583E           	JMP	TDI

                        *	Illegal format for parameter file, or error while reading data

3CC4  CD 323D           FDP7	CALL	FDP9..
3CC7  CD 5E19           	CALL	$TYPTX
3CCA  496C6C65 67616C20 	DB	'Illegal format for INIT parameter file,',' '+EOL
3CD2  666F726D 61742066
3CDA  6F722049 4E495420
3CE2  70617261 6D657465
3CEA  72206669 6C652CA0
3CF2  C3 583E           	JMP	TDI

                        *	Error fetching the device driver

3CF5  CD 443D           FDP8	CALL	FDP9
3CF8  CD 6419           	CALL	$TYPTX.
3CFB  4E6F7420 656E6F75 	DB	'Not enough memory for device driver and parameters,',' '+EOL
3D03  6768206D 656D6F72
3D0B  7920666F 72206465
3D13  76696365 20647269
3D1B  76657220 616E6420
3D23  70617261 6D657465
3D2B  72732CA0
3D2F  C3 583E           	JMP	TDI

                        *	Flag the end of the devices

3D32  21 733D           FDP9..	LXI	H,FDPB
3D35  CD 1C3F           	CALL	$FCLO.

3D38  2A 8638           FDP9.	LHLD	CRNDEV
3D3B  CD 9C18           	CALL	$INDL
3D3E  0400              	DW	DVT.ADR
3D40  EB                	XCHG
3D41  22 8438           	SHLD	BUFLIM			; return the buffer space

3D44  2A 8638           FDP9	LHLD	CRNDEV
3D47  AF                	XRA	A
3D48  77                	MOV	M,A
3D49  C9                	RET


                        *	Table overflow

3D4A  CD 443D           FDP10	CALL	FDP9
3D4D  CD 5E19           	CALL	$TYPTX
3D50  496E7465 726E616C 	DB	'Internal device table overflow,',' '+EOL
3D58  20646576 69636520
3D60  7461626C 65206F76
3D68  6572666C 6F772CA0
3D70  C3 583E           	JMP	TDI

      = 3D73            FDPB	EQU	*
3D73  01                	DB	CN.FDP			; channel
3D74  00                	DB	0			; flags
3D75  BD40              	DW	FDPBUF
3D77  BD40              	DW	FDPBUF
3D79  BD40              	DW	FDPBUF
3D7B  BD42              	DW	FDPBUF+FDPBUFL
3D7D  78782E44 564400   FDPC	DB	'xx.DVD',0		; parameter file name

3D84  53593000 0000     FDPD	DB	'SY0',0,0,0		; parameter file defaults

3D8A  00000000 00000000 FDPE	DC	DVD.STE,#0		; temp holding for parameter file descriptors
3D92  00000000 00000000
3D9A  00000000 00000000
3DA2  00000000 00000000
3DAA  00000000 00000000
3DB2  000000

3DB5  78783A00          FDPF	DB	'xx:',0 		; Device name for load
3DB9                    	SPACE	4,10
                        **	FMM	- Fetch Maximum Memory
                        *
                        *	FMM requests the maximum allowable memory.
                        *
                        *	ENTRY:	NONE
                        *	EXIT:	NONE
                        *	USES:	NONE
                        *

3DB9  CD 2C19           FMM	CALL	$SAVALL
3DBC  21 FFFF           	LXI	H,-1
3DBF  FF 2A             	SCALL	.SETTP
3DC1  11 F6FF           	LXI	D,-10
3DC4  19                	DAD	D
3DC5  22 8D38           	SHLD	MEMLIM
3DC8  FF 2A             	SCALL	.SETTP
3DCA  DA 862C           	JC	ERROR			; Should never happen
3DCD  C3 2719           	JMP	$RSTALL
3DD0                    	SPACE	4,10
                        **	FNM	-  Fetch Minimal Memory
                        *
                        *	FNM reduces the allocated memory to the minimal amount
                        *	as defined by BUFLIM.
                        *
                        *	ENTRY:	BUFLIM initializes
                        *	EXIT:	NONE
                        *	USES:	NONE
                        *

3DD0  CD 2C19           FNM	CALL	$SAVALL	
3DD3  2A 8438           	LHLD	BUFLIM
3DD6  11 0A00           	LXI	D,10
3DD9  19                	DAD	D
3DDA  22 8D38           	SHLD	MEMLIM
3DDD  FF 2A             	SCALL	.SETTP
3DDF  DA 862C           	JC	ERROR
3DE2  C3 2719           	JMP	$RSTALL
3DE5                    	SPACE	4,10
                        **	PSD	-  Patch System Driver
                        *
                        *	PSD patches the system disk subfunction caller to
                        *	perform any mappings left over from boot.  See MSU.
                        *
                        *	ENTRY:	Internal Table Initialized
                        *
                        *	EXIT:	NONE
                        *
                        *	USES:	ALL
                        *

3DE5  21 E838           PSD	LXI	H,DEVTAB

3DE8  0E 04             PSD1	MVI	C,PSDAL
3DEA  11 2F3E           	LXI	D,PSDA
3DED  E5                	PUSH	H
3DEE  CD 3018           	CALL	$COMP
3DF1  E1                	POP	H
3DF2  CA 033E           	JZ	PSD2			; Have found SY:

3DF5  01 0A00           	LXI	B,DVT.ENL
3DF8  09                	DAD	B
3DF9  11 1039           	LXI	D,DEVTABE
3DFC  CD 7429           	CALL	CPDEHL
3DFF  DA E83D           	JC	PSD1			; Not to the end of the table yet

3E02  C9                	RET				; Entry Not found

3E03  22 9438           PSD2	SHLD	SYPTR			; Save Device pointer for later
3E06  E5                	PUSH	H
3E07  CD 9C18           	CALL	$INDL
3E0A  0600              	DW	DVT.PAR
3E0C  EB                	XCHG
3E0D  01 0002           	LXI	B,SB.SDB-SB.BOO
3E10  09                	DAD	B			; Use the Subfunction Entry-Point
3E11  22 CB35           	SHLD	MSUA
3E14  E1                	POP	H			; HL = Internal Device Entry

3E15  CD 9C18           	CALL	$INDL
3E18  0400              	DW	DVT.ADR
3E1A  EB                	XCHG
3E1B  CD 4C37           	CALL	$INDLB
3E1E  0800              	DW	DEV.MNU
3E20  32 9338           	STA	SYMNU			; Save Maximum number of units

3E23  2A E620           	LHLD	S.DLINK
3E26  CD 4C37           	CALL	$INDLB			; Save System Boot Unit
3E29  0400              	DW	M.SUNI
3E2B  32 9238           	STA	SUNIT

3E2E  C9                	RET

3E2F  53593A00          PSDA	DB	'SY:',0
      = 0004            PSDAL	EQU	*-PSDA
3E33                    	SPACE	4,10
                        **	RDP	-  Relocate Device Paramters
                        *
                        *	RDP relocates the Device Parameters.
                        *
                        *	ENTRY:	NONE
                        *
                        *	EXIT:	Device Parameters Relocated
                        *
                        *	USES:	NONE
                        *

3E33  2A 8638           RDP	LHLD	CRNDEV
3E36  CD 9C18           	CALL	$INDL
3E39  0600              	DW	DVT.PAR 		; DE = Parameter Address

3E3B  21 80DD           	LXI	H,-SB.BOO
3E3E  19                	DAD	D
3E3F  44                	MOV	B,H
3E40  4D                	MOV	C,L			; BC = Displacement

3E41  D5                	PUSH	D
3E42  2A 8E3D           	LHLD	FDPE+PIC.PTR
3E45  19                	DAD	D			; HL = Address of PIC Table
3E46  11 FAFF           	LXI	D,-PIC.COD
3E49  19                	DAD	D			; Account for Table space elsewhere
3E4A  EB                	XCHG
3E4B  2A 8638           	LHLD	CRNDEV
3E4E  CD 5D37           	CALL	$INDS			; Save PIC Table Address
3E51  0800              	DW	DVT.PIC
3E53  EB                	XCHG				; HL = Address of PIC Table
3E54  D1                	POP	D

3E55  C3 7D1B           	JMP	REL.			; Relocate it!
3E58                    	SPACE	4,10
                        **	TDI	-  Type Device Ignored
                        *
                        *	TDI types the device ignored error message, and identifies
                        *	the ignored device.
                        *

3E58  2A 7D3D           TDI	LHLD	FDPC
3E5B  22 683E           	SHLD	TDIA
3E5E  CD 5E19           	CALL	$TYPTX
3E61  64657669 636520   	DB	'device '
3E68  78783A20 69676E6F TDIA	DB	'xx: ignored',ENL
3E70  7265648A
3E74  A7                	ANA	A
3E75  C9                	RET
3E76                    	SPACE	4,10
                        **	VFT	- Verify File Type
                        *
                        *	VFT verifies that the Driver/Init File is of the required
                        *	type.
                        *
                        *	ENTRY:	File open with file block FDPB
                        *
                        *	EXIT:	PSW	= 'C' CLEAR if File OK
                        *			    File positioned at beginning of
                        *			    parameters, file buffer cleared
                        *			  'C' SET   if File NOT OK
                        *	USES:	ALL
                        *

3E76  01 2B00           VFT	LXI	B,DVD.STE
3E79  11 8A3D           	LXI	D,VFTA
3E7C  21 733D           	LXI	H,FDPB
3E7F  CD C53F           	CALL	$FREAB. 		; Read the header information
3E82  D8                	RC

3E83  3A 8A3D           	LDA	VFTA+PIC.ID
3E86  FE FF             	CPI	377Q
3E88  37                	STC
3E89  C0                	RNZ				; The File is NOT in BINARY format

3E8A  3A 8B3D           	LDA	VFTA+PIC.ID+1
3E8D  FE 01             	CPI	FT.PIC
3E8F  37                	STC
3E90  C0                	RNZ				; The file is NOT in PIC format

3E91  2A 9D3D           	LHLD	VFTA+DVD.INP
3E94  7C                	MOV	A,H
3E95  B5                	ORA	L
3E96  37                	STC
3E97  C8                	RZ				; No INIT parameter file present

3E98  44                	MOV	B,H
3E99  4D                	MOV	C,L
3E9A  3A 733D           	LDA	FDPB+FB.CHA
3E9D  FF 27             	SCALL	.POSIT			; Position at the beginning of parameters
3E9F  D8                	RC
3EA0  21 733D           	LXI	H,FDPB
3EA3  CD 053F           	CALL	$FCLEAR 		; Clear up the buffers

3EA6  A7                	ANA	A			; Clear 'C'
3EA7  C9                	RET

      = 3D8A            VFTA	EQU	FDPE			; Use FDPE buffer
3EA8                    	EJECT
3EA8                    	STL	'Overlaid One-Time Common Decks'
3EA8                    	EJECT
3EA8                    	XTEXT	DOS
3EA8                    	SPACE	4,10
                        **	$DOS - DISMOUNT OPERATING SYSTEM.
                        *
                        *	$DOS dismounts all units of all directory devices.
                        *
                        *	THE USER IS MESSAGED ABOUT THE DISKS, AND THE OPERATING
                        *	SYSTEM IS NOTIFIED.
                        *
                        *
                        *	ENTRY	NONE
                        *	EXIT	'C' CLEAR IF NO ERROR
                        *		'C' SET   IF	ERROR
                        *		 (A)  = ERROR CODE
                        *	USES	ALL
                        *

3EA8  CD 5E19           $DOS	CALL	$TYPTX
3EAB  0A074469 736D6F75 	DB	NL,BELL,'Dismounting All Disks:',NL,ENL
3EB3  6E74696E 6720416C
3EBB  6C204469 736B733A
3EC3  0A8A

3EC5  CD 023F           	CALL	$DOS.
3EC8  D8                	RC

3EC9  CD 5E19           	CALL	$TYPTX
3ECC  0A52656D 6F766520 	DB	NL,'Remove the Disk(s). Hit RETURN when ready:',' '+200Q
3ED4  74686520 4469736B
3EDC  2873292E 20486974
3EE4  20524554 55524E20
3EEC  7768656E 20726561
3EF4  64793AA0

3EF8  CD C537           DOS1	CALL	$RCHAR			; READ CHARACTER
3EFB  FE 0A             	CPI	NL
3EFD  C2 F83E           	JNE	DOS1

3F00  A7                	ANA	A			; CLEAR CARRY
3F01  C9                	RET
3F02                    	SPACE	4,10
3F02  FF 86             $DOS.	SCALL	.DAD			; Dismount all Disks
3F04  C9                	RET
3F05                    	XTEXT	FCLEAR
3F05                    FCLEAR	SPACE	4,10
                        **	$FCLEAR - CLEAR FILE BLOCK.
                        *
                        *	$FCLEAR CLEARS OUT A FILE BLOCK BY SETTING THE POINTERS TO
                        *	EMPTY, AND CLEARING ANY ERROR OR EOF FLAGS.
                        *
                        *	THE DISK (OR WHATEVER) FILE IS NOT POSITIONED, READ, WRITEN
                        *	OPENED OR CLOSED.
                        *
                        *	ENTRY	(HL) = FB ADDRESS
                        *	EXIT	NONE
                        *	USES	A,F,B,C

      = 3F05            $FCLEAR	EQU	*

3F05  E5                	PUSH	H			; SAVE FILE BLOCK ADDRESS
                        	ERRNZ	FB.FLG-FB.CHA-1
3F06  23                	INX	H
                        	ERRNZ	FB.FWA-FB.FLG-1
3F07  23                	INX	H			; (HL) = #FB.FWA
3F08  4E                	MOV	C,M
3F09  23                	INX	H
3F0A  46                	MOV	B,M			; (BC) = FB.FWA
3F0B  23                	INX	H
                        	ERRNZ	FB.PTR-FB.FWA-2
3F0C  71                	MOV	M,C			; SET FB.PTR = FB.FWA
3F0D  23                	INX	H
3F0E  70                	MOV	M,B
3F0F  23                	INX	H
                        	ERRNZ	FB.LIM-FB.PTR-2
3F10  71                	MOV	M,C			; SET FB.LIM = FB.FWA
3F11  23                	INX	H
3F12  70                	MOV	M,B
3F13  E1                	POP	H			; (HL) = FB FWA
3F14  C9                	RET
3F15                    	XTEXT	FCLO
3F15                    	SPACE	4,10
                        **	$FCLO - CLOSE FILE BLOCK.
                        *
                        *	$FCLO IS CALLED TO TERMINATE PROCESSING THROUGH A FILE
                        *	BLOCK.
                        *
                        *	ENTRY	(HL) = FILE BLOCK ADDRESS
                        *	EXIT	TO $FERROR IF ERROR
                        *		 TO CALLER IF OK
                        *	USES	A,F,B,C,D,E

3F15  CD 1C3F           $FCLO	CALL	$FCLO.
3F18  D0                	RNC				; NO ERROR
3F19  C3 862C           	JMP	$FERROR

3F1C  E5                $FCLO.	PUSH	H			; SAVE FILE BLOCK ADDRESS
                        	ERRNZ	FB.FLG-1
3F1D  23                	INX	H			; (HL) = #FB.FLG
3F1E  7E                	MOV	A,M
3F1F  36 00             	MVI	M,0			; CLEAR FLAG
3F21  A7                	ANA	A
3F22  CA 583F           	JZ	$FCLO4			; FILE NOT OPEN
3F25  E6 04             	ANI	FT.OW
3F27  CA 523F           	JZ	$FCLO3			; NO WRITING, NO FLUSHING NEEDED

                        *	WAS OPEN FOR WRITE. SEE IF NEED FLUSH THE LAST SECTOR

3F2A  CD 9C18           	CALL	$INDL
3F2D  0300              	DW	FB.PTR-FB.FLG
3F2F  D5                	PUSH	D			; SAVE (FB.PTR)
3F30  CD 9C18           	CALL	$INDL			; (DE) = (FB.FWA)
3F33  0100              	DW	FB.FWA-FB.FLG
3F35  E1                	POP	H			; (HL) = (FB.PTR)
3F36  7D                	MOV	A,L
3F37  93                	SUB	E
3F38  4F                	MOV	C,A
3F39  7C                	MOV	A,H
3F3A  9A                	SBB	D
3F3B  47                	MOV	B,A			; (BC) = AMOUNT IN BLOCK
3F3C  B1                	ORA	C
3F3D  CA 523F           	JZ	$FCLO3			; NONE TO FLUSH

                        *	NEED TO FLUSH BUFFER
                        *
                        *	(BC) = DATA AMOUNT
                        *	(DE) = FWA
                        *	(HL) = LWA+1

3F40  79                	MOV	A,C
3F41  A7                	ANA	A
3F42  CA 4D3F           	JZ	$FCLO2			; DONT HAVE PARTIAL SECTOR

                        *	ZERO FILL PARTIAL SECTOR

3F45  36 00             $FCLO1	MVI	M,0
3F47  23                	INX	H
3F48  0C                	INR	C
3F49  C2 453F           	JNZ	$FCLO1
3F4C  04                	INR	B			; COUNT ANOTHER FULL SECTOR
3F4D  E1                $FCLO2	POP	H			; (HL) = FB FWA
3F4E  7E                	MOV	A,M			; (A) = CHANNEL NUMBER
                        	ERRNZ	FB.CHA
3F4F  E5                	PUSH	H
3F50  FF 05             	SCALL	.WRITE			; FLUSH

                        *	READY TO CLOSE FILE.
                        *
                        *	'C' SET IF ERROR
                        *	 (A) = ERROR CODE

3F52  E1                $FCLO3	POP	H			; (HL) = FILE BLOCK ADDRESS
3F53  D8                	RC				; ERROR
                        	ERRNZ	FB.CHA
3F54  7E                	MOV	A,M			; (A) = CHANNEL NUMBER
3F55  E5                	PUSH	H
3F56  FF 26             	SCALL	.CLOSE			; CLOSE CHANNEL
3F58  E1                $FCLO4	POP	H			; (HL) = FILE BLOCK ADDRESS
3F59  C9                	RET
      = 2C86            $FERROR	EQU	ERROR
3F5A                    	XTEXT	FOPE
3F5A                    	SPACE	4,10
                        **	$FOPEx - OPEN FILE BLOCK FOR I/O
                        *
                        *	$FOPEx IS CALLED BEFORE ANY I/O IS DONE VIA A
                        *	FILE BLOCK. $FOPEx SETS UP THE FILE BLOCK, AND OPENS
                        *	THE FILE VIA *HDOS*.
                        *
                        *	ENTRY	(DE) = ADDRESS OF DEFAULT BLOCK
                        *		(HL) = ADDRESS OF FILE BLOCK
                        *	EXIT	TO $FERROR IF ERROR
                        *		TO CALLER IF OK
                        *	USES	A,F,B,C,D,E

3F5A  CD 6F3F           $FOPER	CALL	$FOPER.
3F5D  D0                	RNC
3F5E  C3 862C           	JMP	$FERROR 		; IN ERROR

3F61  CD 723F           $FOPEW	CALL	$FOPEW.
3F64  D0                	RNC
3F65  C3 862C           	JMP	$FERROR 		; IN ERROR

3F68  CD 753F           $FOPEU	CALL	$FOPEU.
3F6B  D0                	RNC
3F6C  C3 862C           	JMP	$FERROR 		; IN ERROR

3F6F  3E 02             $FOPER. MVI	A,FT.OR 		; FILE TYPE OF OPEN FOR READ
3F71  01                	DB	001Q			; LXI,B TO SKIP NEXT MVI

3F72  3E 04             $FOPEW. MVI	A,FT.OW 		; OPEN FOR WRITE
3F74  01                	DB	001Q			; LXI,B TO SKIP NEXT MVI

3F75  3E 06             $FOPEU.	MVI	A,FT.OR+FT.OW

                        *	(A) = FILE FLAGS

3F77  E5                	PUSH	H			; SAVE FILE BLOCK ADDRESS
3F78  F5                	PUSH	PSW			; SAVE NEW FLAGS
                        	ERRNZ	FB.CHA
3F79  46                	MOV	B,M			; (B) = CHANNEL NUMBER
3F7A  C5                	PUSH	B			; SAVE CHANNEL NUMBER
                        	ERRNZ	FB.FLG-FB.CHA-1
3F7B  23                	INX	H
3F7C  4F                	MOV	C,A			; (C) = NEW FILE FLAGS
3F7D  7E                	MOV	A,M			; (A) = CURRENT TYPE
3F7E  A7                	ANA	A
3F7F  79                	MOV	A,C			; (A) = NEW FLAGS TO BE SET
3F80  CA 8A3F           	JZ	$FOPE1			; NOT ALREADY OPEN

                        *	ALREADY OPEN. SQUACK

3F83  C1                	POP	B			; RESTORE (BC)
3F84  F1                	POP	PSW			; DISCARD NEW FLAGS
3F85  E1                	POP	H			; (HL) = FB ADDRESS
3F86  3E 19             	MVI	A,EC.FAO		; FILE ALREADY OPEN
3F88  37                	STC
3F89  C9                	RET

                        	ERRNZ	FB.FWA-FB.FLG-1
3F8A  23                $FOPE1	INX	H			; (HL) = #FB.FWA
3F8B  4E                	MOV	C,M
3F8C  23                	INX	H
3F8D  46                	MOV	B,M			; (BC) = FB.FWA
3F8E  23                	INX	H
                        	ERRNZ	FB.PTR-FB.FWA-2
3F8F  71                	MOV	M,C			; SET FB.PTR = FB.FWA
3F90  23                	INX	H
3F91  70                	MOV	M,B
3F92  23                	INX	H
                        	ERRNZ	FB.LIM-FB.PTR-2
3F93  71                	MOV	M,C			; SET FB.LIM = FB.FWA
3F94  23                	INX	H
3F95  70                	MOV	M,B
3F96  23                	INX	H
                        	ERRNZ	FB.NAM-FB.LIM-4
3F97  23                	INX	H
3F98  23                	INX	H			; (HL) = #FB.NAM

                        *	FILE BLOCK POINTERS SETUP. OPEN FILE

3F99  E5                	PUSH	H			; SAVE NEW ADDRESS FOR NAME
3F9A  21 B33F           	LXI	H,$FOPEB
3F9D  A7                	ANA	A					;/78.10.GC/
3F9E  CA A53F           	JZ	$FOPE2
                        	ERRNZ	.EXIT
3FA1  CD DC37           	CALL	$TBLS			; FIND CODE
3FA4  7E                	MOV	A,M
3FA5  32 AB3F           $FOPE2	STA	$FOPEA			; SET SYSCALL CODE
3FA8  E1                	POP	H			; (HL) = #FB.NAM
3FA9  F1                	POP	PSW			; (A) = CHANNEL NUMBER
3FAA  FF 00             	SCALL	.EXIT
      = 3FAB            $FOPEA	EQU	*-1			; SYSCALL CODE
3FAC  D1                	POP	D			; (D) = NEW FLAG
3FAD  E1                	POP	H			; (HL) = FILE BLOCK ADDRESS
3FAE  D8                	RC				; EXIT IF ERROR
3FAF  23                	INX	H
                        	ERRNZ	FB.FLG-1
3FB0  72                	MOV	M,D			; SET NEW FLAGS
3FB1  2B                	DCX	H			; RESTORE (HL)
3FB2  C9                	RET

3FB3  0222              $FOPEB	DB	FT.OR,.OPENR		; TABLE OF SYSCALL CODES
3FB5  0423              	DB	FT.OW,.OPENW
3FB7  0624              	DB	FT.OR+FT.OW,.OPENU
3FB9  00                	DB	0			; SHOULD NOT OCCUR
3FBA                    	XTEXT	FREAB
3FBA                    FREAB	SPACE	4,10
                        **	$FREAB - READ BYTES FROM FILE BUFFER.
                        *
                        *	$FREAB IS CALLED TO READ A NUMBER OF BYTES FROM A FILE BUFFER.
                        *
                        *	ENTRY	(BC) = BYTE COUNT
                        *		(DE) = FWA FOR BYTES
                        *		(HL) = ADDRESS OF FILE BUFFER
                        *	EXIT	TO *FERROR* IF ERROR
                        *		TO CALLER IF OK
                        *		 (BC) = UNREAD BYTE COUNT (ONLY IF EOF)
                        *		 (DE) = ADDRESS OF FIRST UNUSED BYTE
                        *		 'C' SET IF EOF DURING READ
                        *	USES	A,F,B,C,D,E

3FBA  CD C53F           $FREAB	CALL	$FREAB.
3FBD  D0                	RNC				; RETURN IF OK
3FBE  FE 01             	CPI	EC.EOF
3FC0  C2 862C           	JNE	$FERROR 		; ERROR IS NOT EOF
3FC3  37                	STC
3FC4  C9                	RET				; ERROR IS SIMPLY EOF


3FC5  AF                $FREAB. XRA	A
3FC6  32 8F40           	STA	EOFFLG			; CLEAR EOF FLAG
3FC9  E5                	PUSH	H
3FCA  CD 2340           	CALL	CBT			; COPY BUFFER POINTERS TO TEMP CELLS

                        *	COPY DATA FROM BUFFER TO TARGET

3FCD  D5                $REAB2	PUSH	D			; SAVE TARGET ADDRESS
3FCE  3A 8640           	LDA	T.FLG
3FD1  E6 02             	ANI	FT.OR
3FD3  3E 09             	MVI	A,EC.FNO		; ASSUME FILE NOT OPEN FOR READ
3FD5  37                	STC
3FD6  CA 1E40           	JZ	$REAB8			; NOT OPEN FOR READ
3FD9  78                	MOV	A,B
3FDA  B1                	ORA	C
3FDB  CA 1E40           	JZ	$REAB8			; ALL DONE

                        *	COMPUTE MIN( DATA IN BUFFER, DATA REQUESTED)

3FDE  2A 8940           $REAB3	LHLD	T.PTR
3FE1  EB                	XCHG				; (DE) = (FB.PTR) = ADDRESS OF DATA
3FE2  2A 8B40           	LHLD	T.LIM			; (HL) = LIMIT ADDRESS
3FE5  7D                	MOV	A,L
3FE6  93                	SUB	E
3FE7  6F                	MOV	L,A
3FE8  7C                	MOV	A,H
3FE9  9A                	SBB	D
3FEA  67                	MOV	H,A			; (HL) = NUMBER OF BYTES IN BUFFER
3FEB  79                	MOV	A,C
3FEC  95                	SUB	L			; COMPARE REQUESTED TO AVAILABLE
3FED  78                	MOV	A,B
3FEE  9C                	SBB	H
3FEF  D2 F43F           	JNC	$REAB4			; MORE REQUESTED THEN AVAILABLE
3FF2  60                	MOV	H,B
3FF3  69                	MOV	L,C			; LIMIT TRANSFER TO REQUEST COUNT
3FF4  7C                $REAB4	MOV	A,H
3FF5  B5                	ORA	L
3FF6  C2 0240           	JNZ	$REAB6			; SOME IN BUFFER

                        *	BUFFER IS EMPTY. RE-FILL IT

3FF9  CD 5340           	CALL	$FFB			; FILL FILE BUFFER
3FFC  DA 1E40           	JC	$REAB8			; ERROR CONDITION
3FFF  C3 DE3F           	JMP	$REAB3			; COUNT NEW DATA

                        *	GOT THE DATA. MOVE IT FROM BUFFER TO TARGET
                        *
                        *	(BC) = REQUESTED COUNT
                        *	(DE) = FROM
                        *	(HL) = COUNT
                        *	((SP)) = TO

4002  79                $REAB6	MOV	A,C
4003  95                	SUB	L
4004  4F                	MOV	C,A
4005  78                	MOV	A,B
4006  9C                	SBB	H
4007  47                	MOV	B,A			; REMOVE BYTES FROM REQUEST COUNT
4008  C5                	PUSH	B
4009  E3                	XTHL				; (HL) = REMAINING REQUEST COUNT
400A  C1                	POP	B			; (BC) = COUNT FOR THIS COPY
400B  E3                	XTHL				; (HL) = TARGET ADDR, ((SP)) = REMAINING
400C  1A                $REAB7	LDAX	D
400D  77                	MOV	M,A
400E  13                	INX	D
400F  23                	INX	H
4010  0B                	DCX	B
4011  78                	MOV	A,B
4012  B1                	ORA	C
4013  C2 0C40           	JNZ	$REAB7			; MORE TO GO
4016  EB                	XCHG
4017  22 8940           	SHLD	T.PTR			; UPDATE POINTER
401A  C1                	POP	B			; (BC) = REMAINING COUNT
401B  C3 CD3F           	JMP	$REAB2			; SEE IF MORE IN BUFFER

                        *	READ COMPLETE.
                        *
                        *	(PSW) = COMPLETION FLAGS

401E  D1                $REAB8	POP	D			; RESTORE TARGET ADDRESS
401F  E1                	POP	H
4020  C3 3940           	JMP	CTB			; COPY TEMP POINTERS BACK TO BLOCK, EXIT
4023                    	XTEXT	FUTIL
4023                    	SPACE	4,10
                        **	$FUTIL - UTILITY ROUTINES FOR FILE BLOCK ROUTINES.

                        **	CBT - COPY BLOCK POINTERS TO TEMP CELLS.
                        *
                        *	ENTRY	(HL) = FILE BLOK FWA
                        *	EXIT	NONE
                        *	USES	A,F,H,L

4023  D5                CBT	PUSH	D
4024  C5                	PUSH	B			; SAVE REGISTERS
                        	ERRNZ	TLEN-10 		; ASSUME 10 BYTES TO MOVE
4025  11 8540           	LXI	D,T.CHA 		; (DE) = TARGET FOR MOVE
4028  06 05             	MVI	B,10/2
402A  7E                CBT1	MOV	A,M			; COPY FILE BUFFER INTO WORK AREA
402B  12                	STAX	D
402C  23                	INX	H
402D  13                	INX	D
402E  7E                	MOV	A,M
402F  12                	STAX	D
4030  23                	INX	H
4031  13                	INX	D
4032  05                	DCR	B
4033  C2 2A40           	JNZ	CBT1			; MORE TO GO
4036  C1                	POP	B
4037  D1                	POP	D			; (DE) = DATA TARGET ADDRESS
4038  C9                	RET


                        **	CTB - COPY TEMP CELLS BACK TO FILE BLOCK.
                        *
                        *	ENTRY	(HL) = FILE BLOCK ADDRESS
                        *	EXIT	NONE
                        *	USES	NONE

4039  F5                CTB	PUSH	PSW
403A  D5                	PUSH	D
403B  C5                	PUSH	B
403C  E5                	PUSH	H			; SAVE REGISTERS
403D  06 04             	MVI	B,8/2
403F  11 8540           	LXI	D,T.CHA
4042  1A                CTB1	LDAX	D
4043  77                	MOV	M,A
4044  13                	INX	D
4045  23                	INX	H
4046  1A                	LDAX	D
4047  77                	MOV	M,A
4048  13                	INX	D
4049  23                	INX	H
404A  05                	DCR	B
404B  C2 4240           	JNZ	CTB1			; RESTORE FILE BUFFER VALUES
404E  E1                	POP	H
404F  C1                	POP	B
4050  D1                	POP	D
4051  F1                	POP	PSW
4052  C9                	RET
4053                    	SPACE	4,10
                        **	$FFB - FILL FILE BUFFER.
                        *
                        *	$FFB FILLS THE FILE BUFFER BY READING FROM THE FILE.
                        *
                        *	ENTRY	NONE
                        *	EXIT	'C' SET IF READ INCOMPLETE
                        *		 (A) = ERROR CODE
                        *		'C' CLEAR IF READ COMPLETEE
                        *		 DATA IN BUFFER
                        *	USES	A,F,D,E,H,L

4053  3A 8F40           $FFB	LDA	EOFFLG
4056  1F                	RAR
4057  D8                	RC				; EOF

                        *	CAN READ MORE. DO SO

4058  C5                	PUSH	B			; SAVE COUNT
4059  2A 8740           	LHLD	T.FWA
405C  22 8940           	SHLD	T.PTR			; CLEAR REMOVAL POINTER
405F  EB                	XCHG
4060  2A 8D40           	LHLD	T.LWA
4063  22 8B40           	SHLD	T.LIM			; SET DATA LIMIT
4066  7D                	MOV	A,L
4067  93                	SUB	E
4068  4F                	MOV	C,A
4069  7C                	MOV	A,H
406A  9A                	SBB	D
406B  47                	MOV	B,A			; (BC) = ROOM IN BUFFER
406C  3A 8540           	LDA	T.CHA
406F  FF 04             	SCALL	.READ			; READ BUFFER
4071  50                	MOV	D,B			; (D) = SECTORS UNREAD
4072  C1                	POP	B			; (BC) = DESIRED COUNT
4073  D0                	RNC				; GOT THE DATA

                        *	ERROR ON READ. SEE IF EOF

4074  17                	RAL
4075  32 8F40           	STA	EOFFLG			; SET EOF, WE HOPE
4078  FE 03             	CPI	EC.EOF*2+1
407A  1F                	RAR
407B  C0                	RNE				; IS NOT EOF, RETURN NOW!
407C  3A 8C40           	LDA	T.LIM+1
407F  92                	SUB	D
4080  32 8C40           	STA	T.LIM+1 		; SET AMOUNT OF DATA WE DID GET
4083  A7                	ANA	A
4084  C9                	RET				; EXIT WITH DATA


                        **	TEMP CELLS TO HOLD FILE BLOCK POINTERS DURING I/O

                        	ERRNZ	FB.CHA
4085  00                T.CHA	DB	0			; CHANNEL NUMBER
                        	ERRNZ	*-T.CHA-FB.FLG
4086  00                T.FLG	DB	0			; FLAG BYTE
                        	ERRNZ	*-T.CHA-FB.FWA
4087  0000              T.FWA	DW	0
                        	ERRNZ	*-T.CHA-FB.PTR
4089  0000              T.PTR	DW	0
                        	ERRNZ	*-T.CHA-FB.LIM
408B  0000              T.LIM	DW	0
                        	ERRNZ	*-T.CHA-FB.LWA
408D  0000              T.LWA	DW	0
      = 000A            TLEN	EQU	*-T.CHA 		; LENGTH OF TEMP CELLS

408F  00                EOFFLG	DB	0
4090                    	STL	'Overlaid PRSS Buffers'
4090                    	EJECT
                        **	"what" identification

4090  40282329 48444F53 	DB	'@(#)HDOS 3.0 Disk Initialization Utility',NL
4098  20332E30 20446973
40A0  6B20496E 69746961
40A8  6C697A61 74696F6E
40B0  20557469 6C697479
40B8  0A
40B9  0100              	DW	.DATE.
40BB  0200              	DW	.TIME.

      = 40BD            MEML	EQU	*			; MAX MEMORY FOR LOAD

                        **	Overlaid PRSS Buffers
                        *

      = 40BD            FDPBUF	EQU	*
40BD   (0200)           	DS	512			; FDP Buffer
      = 0200            FDPBUFL	EQU	*-FDPBUF


      = 42BD            RMEML	EQU	*			; RUNNING MEMORY MAX LEN
42BD                    	STL	'Overlaid Buffers'
42BD                    	EJECT
3A11                    	ORG	OVRLAY			; reuse the ephemeral code space

                        **	DIRECTORY SECTOR

      = 3A11            IDDA	EQU	*			; DIRECTORY SECTOR FWA

3A11   (01FA)           IDDB	DS	22*DIRELEN		; SPACE FOR REST OF BLOCK
      = 01FA            IDDBL	EQU	*-IDDB
3C0B   (0001)           	DS	1			; SPACE FOR 00 BYTE
                        	ERRNZ	*-IDDA-DIS.ENL
3C0C   (0001)           	DS	1			; LENGTH OF ENTRYS (DIRELEN)
                        	ERRNZ	*-IDDA-DIS.SEC
3C0D   (0002)           	DS	2			; SECTOR NUMBER OF BEGINNING OF THIS BLOCK
                        	ERRNZ	*-IDDA-DIS.LNK
3C0F   (0002)           	DS	2			; SECTOR NUMBER OF BEGINNING OF NEXT BLOCK
                        	ERRNZ	*-IDDA-512		; SHOULD FILL BLOCK

                        **	RGTAB AND GRTAB MUST BE ON EVEN PAGE BOUNDARYS.

3C11   (00EF)           	DS	*+255/256*256-*

                        	ERRNZ	#*
3D00   (0100)           GRTAB	DS	256			; GRT TABLE
                        	ERRNZ	#*
3E00   (0100)           RGTAB	DS	256			; RGT TABLE

                        	ERRMI	MEML-*						;/3.0a/
40BD                    	ORG	MEML			; get back to the end		/3.0a/

40BD   (3B68)           	END	PRSS

00000 Total Errors


00006 Total Warnings

$$BITC             2C01    $$BITS             2C04    $$BUFF             2C07
$$CHL              2C09    $$CNO              2C0C    $$CYS              2C0F
$$DRVR             2C12    $$DRVR.            2C15    $$ITL.             2C18
$$MAX              2C2A E  $$MOVE             2C1B    $$RBS              2C27
$$TBRA             2C1E    $$TYPTX            2C21    $$VER              2C00
$$VSN              2C24    $CCO               3710    $CDEHL             188E E
$CHL               1894 E  $CMP$              0001 E  $COMP              1830 E
$CRLF              387E    $DADA              183A E  $DADA.             1841 E
$DOS               3EA8    $DOS.              3F02    $DTB               371D
$DTB1              3721    $DTB2              3728    $DTB3              3735
$DU66              1846 E  $FCLEAR            3F05 E  $FCLO              3F15
$FCLO.             3F1C    $FCLO1             3F45    $FCLO2             3F4D
$FCLO3             3F52    $FCLO4             3F58    $FERROR            2C86 E
$FFB               4053    $FOPE1             3F8A    $FOPE2             3FA5
$FOPEA             3FAB E  $FOPEB             3FB3    $FOPER             3F5A
$FOPER.            3F6F    $FOPEU             3F68    $FOPEU.            3F75
$FOPEW             3F61    $FOPEW.            3F72    $FREAB             3FBA
$FREAB.            3FC5    $HLIHL             1889 E  $ICTT              2778
$ICTT.             2782    $ICTT..            2798    $IDN               373E
$INDL              189C E  $INDLB             374C    $INDS              375D
$INDSB             3778    $ITL               3845    $ITL.              383F
$MCU               297A    $MLU               378E    $MLU1              3791
$MOVE              18AA E  $MU10              18D4 E  $MU86              1907 E
$PDD               381F    $PDD1              3823    $RCHAR             37C5
$REAB2             3FCD    $REAB3             3FDE    $REAB4             3FF4
$REAB6             4002    $REAB7             400C    $REAB8             401E
$RSTALL            1927 E  $RTL               37A5 E  $RTL.              379E
$RTL1              37A6    $RTL2              37C2    $SAVALL            192C E
$SOB               37CE    $SOB1              37CF    $TBLS              37DC
$TBRA              193E E  $TDD               384D    $TDD.              384B
$TYPC.             37F8    $TYPCH             37F4    $TYPEC.            27E1
$TYPET             27C4    $TYPET.            27CA    $TYPET1            27DA
$TYPL.             3809 E  $TYPLN.            37FB    $TYPTX             195E E
$TYPTX.            1964 E  $UDD               196F E  $WCHAR             37CB
$WDR               1992 E  $WER               19A1 E  .                  38E8 S
..CLRCO            007C    ..CONSL            0079    ..PRINT            0076
..SCIN             0070    ..SCOUT            0073    .ABUSS             2014 E
.ALEDS             200B E  .CHFLG             0030    .CLEAR             002D
.CLEARA            002E    .CLOSE             0026    .CLRCO             0007
.CONSL             0006    .CRC16             000B    .CRCSUM            2017 E
.CTL2FL            2036 E  .CTLC              0021    .CTLFLG            2009 E
.DAD               0086    .DATE.             0001 E  .DECODE            002B
.DELET             0028    .DELETE            0028 E  .DISMT             0031
.DLEDS             2011 E  .DLY               002B E  .DMNMS             0083
.DMOUN             0081    .DMOUNT            0081 E  .DSPMOD            2007 E
.DSPROT            2006 E  .ERROR             002F    .EXIT              0000
.GDA               000A    .HORN              0260 E  .IOWRK             2002 E
.LINK              0020    .LOADD             0032    .LOADO             0008
.MFLAG             2008 E  .MONMS             0082    .MOUNT             0080
.NAME              002C    .NMIRET            2034 E  .OPENC             0025
.OPENR             0022    .OPENU             0024    .OPENW             0023
.POSIT             0027    .PRINT             0003    .READ              0004
.REGI              2005 E  .REGPTR            201D E  .RENAM             0029
.RENAME            0029 E  .RESET             0084    .RESNMS            0085
.SCIN              0001    .SCOUT             0002    .SETTOP            002A E
.SETTP             002A    .START             2000 E  .SYSRES            000C
.TICCNT            201B E  .TIME.             0002 E  .TPERRX            2019 E
.UIVEC             201F E  .VERS              0009    .WRITE             0005
AAL                2EB5    AAL1               2F25    AAL1.5             2F46
AAL2               2F65    AAL3               2FC4    ABR                2983 E
ABR.A              2A21    ABR0               29CD    ABR0.1             2983
ABR0.3             29A3    ABR0.5             29C0    ABR1               29CF
ABR2               29F7    ABR3               29FB    ABR5               2A08
ABR5.1             2A0F    ABS.COD            0008    ABS.ENT            0006
ABS.ID             0000    ABS.LDA            0002    ABS.LEN            0004
AC.DLY             006E E  ADB                3231 E  ADB1               325C
ADB2               3263    ADB3               3270    ADB4               32B6
ADBA               32E0    AIO.CGN            2127    AIO.CHA            214E
AIO.CNT            2149    AIO.CSI            2128    AIO.DDA            2121 E
AIO.DES            212D    AIO.DEV            212F    AIO.DIR            2132
AIO.DTA            212B    AIO.EOF            214B    AIO.EOM            214A
AIO.FLG            2123    AIO.GRT            2124    AIO.LGN            2129
AIO.LSI            212A    AIO.SPG            2126    AIO.TFP            214C
AIO.UNI            2131    AIO.VEC            2120    AMW                2CA6 E
AMW1               2CA6    AMW2               2CFA    ANS                3456
ANS1               3463    B.END              0080 E  B.INT0             0000
B.INT1             0008    B.INT2             0010    B.INT3             0018
B.INT4             0020    B.INT5             0028    B.INT6             0030
B.INT7             0038    B.NMI              0066    B.NMIFL            0069
B.SCALL            003B    BATBUF             0054    BATGNS             0052
BATNAME            0040    BATPTR             0056    BATSEC             0051
BELL               0007 E  BFLG.A             0001 E  BGT                32E2
BGT1               3310    BGT1.5             3319    BGT2               332A
BGT3               3332    BITC               36F2    BITC1              36F7
BITS               3701    BITS1              3706    BKSP               0008 E
BLABEL             2ABF E  BOOEND             35BF E  BOOT.P             0001 E
BOOTA              1F5A E  BOOTAL             0058 E  BS                 0008 E
BTS                348F    BUFF               2BBF E  BUFLIM             3884
C.STX              0002 E  C.SYN              0016 E  CB.CLI             0040 E
CB.MTL             0020 E  CB.SPK             0080 E  CB.SSI             0010 E
CB2.CLI            0002 E  CB2.ORG            0020 E  CB2.SID            0040 E
CB2.SSI            0001 E  CBS                28DC    CBS.               2901
CBS1               28E3    CBS2               28F3    CBS3               2900
CBS4               2919    CBS5               2922    CBS6               292A
CBT                4023    CBT1               402A    CDB.H84            0001 E
CDB.H85            0000 E  CFF                19EC E  CLOCK              1C19 E
CN.170M            000C E  CN.174M            0003 E  CN.ABO             0080 E
CN.BAU             0040 E  CN.FDP             0001 E  CN.MEM             0020 E
CN.PRI             0010 E  CND.H17            0000 E  CND.H47            0001 E
CND.NDI            0000 E  CNO                349B    CNOA               34A6
CNOAL              0003 E  CO.FLG             0001 E  CPDEHL             2974
CR                 000D E  CRNDEV             3886    CS.FLG             0080 E
CSL.CHR            0001 E  CSL.ECH            0080 E  CSL.RAW            0004 E
CSL.WRP            0002 E  CSLIBUF            003E    CTB                4039
CTB1               4042    CTLA               0001 E  CTLB               0002 E
CTLC               0003 E  CTLD               0004 E  CTLE               0005 E
CTLO               000F E  CTLP               0010 E  CTLQ               0011 E
CTLR               0012 E  CTLS               0013 E  CTLX               0018 E
CTLZ               001A E  CTP.2SB            0008 E  CTP.BKM            0002 E
CTP.BKS            0080 E  CTP.FF             0040 E  CTP.HHS            0004 E
CTP.MLI            0020 E  CTP.MLO            0010 E  CTP.TAB            0001 E
CYS                34A9    CYS1               34B1    CYSA               34B8
CYSAL              0004 E  D.CON              2048    D.RAM              20A0
D.VEC              2058    DBI                3888    DC.ABT             0007
DC.CLO             0006    DC.DSF             000E    DC.INT             000D
DC.LOD             0009    DC.MAX             000F    DC.MOU             0008
DC.OPR             0003    DC.OPU             0005    DC.OPW             0004
DC.RDY             000A    DC.REA             0000    DC.RER             0002
DC.SET             000B    DC.UNL             000C    DC.WRI             0001
DCA                1A02 E  DDF.BOL            0009 E  DDF.BOO            0000
DDF.LAB            0009    DDF.USR            000A    DDS                34BC E
DDS1               34E7    DDS2               34F5    DDS3               3504
DEBUG              0001 E  DEL                007F E  DEV.DDA            0004
DEV.DVG            000D    DEV.DVL            000B    DEV.FLG            0006
DEV.JMP            0003    DEV.MNU            0008    DEV.MUM            0007
DEV.NAM            0000    DEV.RES            0002    DEV.UNT            0009
DEVELEN            000E E  DEVTAB             38E8 E  DEVTABE            3910
DF.CLR             00FE E  DF.EMP             00FF E  DIF.ARC            0008 E
DIF.BAD            0004 E  DIF.CNT            0010 E  DIF.DL             0002 E
DIF.LOC            0040 E  DIF.SYS            0080 E  DIF.USR            0001 E
DIF.WP             0020 E  DIR.ACD            0015    DIR.CRD            0013
DIR.CTH            000B    DIR.CTM            000C    DIR.EXT            0008
DIR.FGN            0010    DIR.FLG            000E    DIR.LGN            0011
DIR.LSI            0012    DIR.NAM            0000    DIR.NOA            000D
DIR.USR            000F    DIRBLK             388B    DIRELEN            0017 E
DIRIDL             000B E  DIRLBLK            388C    DIS.ENL            01FB
DIS.ENT            0000 E  DIS.LNK            01FE    DIS.SEC            01FC
DM.MR              0000 E  DM.MW              0001 E  DM.RR              0002 E
DM.RW              0003 E  DOS1               3EF8    DR.FX              0004 E
DR.IM              0001 E  DR.PR              0002 E  DR.SPL             00E0 E
DR.UNL             0008 E  DRIVER             350C    DRIVER.            3524
DRIVER1            3510    DT.CH              0010 E  DT.CR              0002 E
DT.CW              0004 E  DT.DD              0001 E  DT.FX              0020 E
DT.P3              0040 E  DT.RN              0008 E  DT.UL              0080 E
DU68               355B    DV.EL              0000 E  DV.NU              0001 E
DVD.CAP            0007    DVD.DVD            0006    DVD.ENT            0200 E
DVD.INP            0013    DVD.MNU            0009    DVD.MUM            0008
DVD.SET            0012    DVD.SPL            0016    DVD.STE            002B E
DVD.UFL            000A    DVD.V30            0015    DVDFLV             00C7 E
DVT.ADR            0004 E  DVT.ENL            000A E  DVT.MAX            0004 E
DVT.NAM            0000 E  DVT.PAR            0006 E  DVT.PIC            0008 E
EC.CNA             0004    EC.CNR             0034    EC.CUI             0037
EC.DDA             0017    EC.DFM             0031    EC.DIF             000F
EC.DIW             001D    EC.DNI             0025    EC.DNL             002F
EC.DNP             0030    EC.DNR             0026    EC.DNS             0005
EC.DSC             0027    EC.EOF             0001    EC.EOM             0002
EC.FAO             0019    EC.FAP             0016    EC.FIX             002D
EC.FL              0018    EC.FNF             000C    EC.FNO             0009
EC.FNR             001C    EC.FOD             0023    EC.FUC             000B
EC.ICN             000E    EC.IDF             0032    EC.IDN             0006
EC.IFC             0010    EC.IFN             0007    EC.ILA             002E
EC.ILC             0003    EC.ILO             0020    EC.ILR             000A
EC.ILV             001F    EC.IOI             002A    EC.IS              001A
EC.ITS             0033    EC.LAD             002C    EC.LBO             0036
EC.NCV             0028    EC.NEM             0011    EC.NOS             0029
EC.NPM             0024    EC.NRD             0008    EC.NVM             0022
EC.OTL             002B    EC.RF              0012    EC.SDR             0035
EC.UNA             001E    EC.UND             000D    EC.UUN             001B
EC.VPM             0021    EC.WF              0013    EC.WP              0015
EC.WPV             0014    ENL                008A E  EOFFLG             408F
EOL                0080 E  ERR.FNO            19E4 E  ERR.ILR            19E8 E
ERROR              2C86    ERROR1             2C8E    ESC                001B E
EXIT               2C83    EXIT.              2C84    F.2MHZ             0000 E
F.4MHZ             0001 E  F.6MHZ             0002 E  F.8080             0000 E
F.8085             0040 E  F.CLK              0003 E  F.CPU              00C0 E
F.H19              0010 E  F.H8               0000 E  F.H89              0004 E
F.MACH             000C E  F.OCPU             00C0 E  F.OMACH            000C E
F.TERM             0030 E  F.TTY              0000 E  F.Z100             0008 E
F.Z80              0080 E  FALSE              0000 E  FB.CHA             0000
FB.FLG             0001    FB.FWA             0002    FB.LIM             0006
FB.LWA             0008    FB.NAM             000A    FB.NAML            0011 E
FB.PTR             0004    FBENL              001B E  FCU                292E
FCU0               295E    FCU1               2960    FDP                3BBA
FDP1               3BBD    FDP10              3D4A    FDP2               3BD4
FDP3               3BDB    FDP5               3BDF    FDP6               3C9D
FDP7               3CC4    FDP8               3CF5    FDP9               3D44
FDP9.              3D38    FDP9..             3D32    FDPB               3D73 E
FDPBUF             40BD E  FDPBUFL            0200 E  FDPC               3D7D
FDPD               3D84    FDPE               3D8A    FDPF               3DB5
FF                 000C E  FFB                1A5B E  FFL                1A85 E
FMM                3DB9    FNM                3DD0    FOV                31D7 E
FOV1               31E5    FOV2               31EF    FT.ABS             0000 E
FT.BAC             0003 E  FT.DD              0001 E  FT.OC              0010 E
FT.OR              0002 E  FT.OU              0008 E  FT.OW              0004 E
FT.PIC             0001 E  FT.REL             0002 E  GBL                30FA E
GBL1               3100    GBL1.5             3107    GBL2               3112 E
GBL4               3112    GBL5               317E    GBL6               319D
GBL7               31BC    GRTAB              3D00    GRTBLK             388A
GVI                2FC7 E  GVI1               3010    GVI2               308C
GVI3               30A8    HDOS30             24CA    HOSBASE            0000 E
I.CONFL            0004 E  I.CONTY            0001 E  I.CONWI            0003 E
I.CSLMD            0000 E  I.CUSOR            0002 E  ICTT1              278A
ICTT2              2791    ICTT3              27A5    IDD                3338
IDD2               3356    IDD4               33E1    IDD5               33EE
IDDA               3A11 E  IDDB               3A11    IDDBL              01FA E
IDDC               33F7 E  IDDCDIR            3425 E  IDDCGRT            340E E
IDDCL              005C E  IDDCRGT            33F7 E  IDDD               3453
IDDE               3454    IDDF               3455    IDS                30B0
IDS.               30D7    ILDEHL             3747    INI.CMV            0000
INI.DBI            0002    INI.IDS            0001    INI.MAX            0004 E
INI.PAR            0003    INIT0              2C33    INIT1              2C3C
INITVEC            2C00 E  IOC.CGN            0008    IOC.CSI            0009
IOC.DDA            0002    IOC.DES            000E    IOC.DEV            0010
IOC.DIL            0011 E  IOC.DIR            0013    IOC.DRL            0008 E
IOC.DTA            000C    IOC.FLG            0004    IOC.GRT            0005
IOC.LGN            000A    IOC.LNK            0000    IOC.LSI            000B
IOC.SPG            0007    IOC.SQL            0003 E  IOC.UNI            0012
IOCCTD             0001 E  IOCELEN            002A E  IP.CON             00F2 E
IP.PAD             00F0 E  ISDEHL             3789    ITLA               3897 E
IVP                3561    IVPA               356E E  IVPAL              001D E
IVPB               3572    LAB.AUX            004F E  LAB.AXL            0001 E
LAB.DAT            0000 E  LAB.DIS            0003    LAB.GRT            0005
LAB.IND            0001    LAB.LAB            0011    LAB.LBL            003C E
LAB.LVN            0050    LAB.NOD            0002 E  LAB.PSS            000E
LAB.RGT            000A    LAB.SER            0000    LAB.SIZ            000C
LAB.SPG            0007    LAB.SPT            004F    LAB.SYS            0001 E
LAB.VER            0009    LAB.VFL            0010    LAB.VLT            0008
LAB.VPL            0005 E  LAB.VPR            000C E  LABEL              3911 E
LCF                274F E  LDE..              2831    LDE3               2842
LF                 000A E  LINE               3897    LINEL              0050 E
LSF                26B4    LSF1               26F4    LSF3               2711
LSF4               2724    M.CSL              0002    M.FOX              00C3 E
M.PAM8             0011 E  M.SUNI             0004    M.SYDD             0005
M.SYSM             0000    MEML               40BD E  MEMLIM             388D
MI.JMP             00C3 E  MOUNT              358B    MOUNT.             3596
MOUNT..            359B    MOUNT1             3591    MSD                28A3
MSD.               28D1    MSU                35A0    MSU1               35C4 E
MSUA               35CB E  NDIRBLK            388F    NGROUPS            3890
NL                 000A E  NSPCGRP            3891    NUL                0000 E
NUL2               0000 E  NULL               0080 E  OP.CTL             00F0 E
OP.DIG             00F0 E  OP.SEG             00F1 E  OP2.CTL            00F2 E
OVRLAY             3A11 E  PATCH              39B2    PDI                1B65 E
PDN                2CFD    PDN.               2D1B    PDN1               2D2D
PDN2               2D4B    PDN3               2D6C    PDNA               2D90
PDNB               2D92    PDNC               2D93    PDS                3475
PDS1               347B    PDS2               3480    PIC.COD            0006
PIC.ID             0000    PIC.LEN            0002    PIC.PTR            0004
PRS                3A11    PRS1               3B35    PRSS               3B68
PRSS0              3B85    PRSS1              3BB4    PSD                3DE5
PSD1               3DE8    PSD2               3E03    PSDA               3E2F
PSDAL              0004 E  QUOTE              0027 E  RBS                36EE
RCC                2969    RDP                3E33    READD              2865
READD1             2866    READERR            286A    READR              289E
REL                1B7F E  REL.               1B7D E  RESTART            2C2A
RGTAB              3E00    RMEML              42BD E  RMI                2D99 E
RMI1               2DB0    RMIA               2DE6    RMIB               2DE8
RPB                35E1    RPB1               360C    RUBOUT             007F E
S.BATCH            0008 E  S.BAUD             20E4    S.BDA              2150
S.BITS             0062    S.BOOTF            211C    S.BREAK            0020 E
S.CAADR            20DB    S.CACC             2106    S.CCTAB            20DD
S.CDB              20E3    S.CFWA             20EA    S.CLKTR            20CD
S.CODE             2107    S.CONFL            20DA    S.CONTY            20D7
S.CONWI            20D9    S.COUNT            0060    S.CSLMD            20D6
S.CUSOR            20D8    S.CVEC             0070    S.CVECL            000F E
S.DATC             20C8    S.DATE             20BF    S.DDDTA            20F6
S.DDGRP            20F4    S.DDLDA            20F0    S.DDLEN            20F2
S.DDOPC            20F8    S.DFBLK            006A    S.DFWA             20EC
S.DIREA            210E    S.DLINK            20E6    S.DLY              002B
S.ECHO             0004 E  S.EDLIN            005E    S.EXITA            2040
S.EXITC            0010 E  S.FASER            210B    S.FCI              2111
S.FLAG             007F    S.FMASK            0005    S.GUP              2117
S.HIMEM            20CE    S.INIT             0080 E  S.INT              20E3
S.JUMPS            2108    S.LABEL            0003    S.LWA              0006
S.MOUNT            211A    S.OSI              2156    S.OSO              2157
S.OSZ              2158    S.PATH             005A    S.PRMT             005C
S.READ             19BD E  S.REV              000B    S.RFWA             20EE
S.SCI              2114    S.SCR              2151    S.SDD              2108
S.SHIFT            0061    S.SOVR             2176    S.SYSCM            0001 E
S.SYSM             20D0    S.TABUF            0040 E  S.TFWA             20E8
S.TIME             20CA    S.USRM             20D2    S.VAL              20BF
S.VFLG             0002 E  S.WRITE            19D8 E  SB.BAU             2285
SB.BOO             2280    SB.BPE             22A0 E  SB.DAT             2287
SB.DRV             22A0    SB.FLG             2284    SB.ORG             3000 E
SB.SDB             2480 E  SB.VER             2283    SC.ACE             00E8 E
SC.UART            00FA E  SCU                2A62    SCU1               2A8A
STACK              2280 E  STACKL             010A E  STB                362A
SUBBUF             0058    SUBFUN             3639    SUBFUN1            365C
SUNIT              3892    SVP                3660 E  SVP1               36AC E
SVP2               36C1    SYDD               2058 E  SYDRV              24F9
SYDVD              24EA    SYMNU              3893    SYPTR              3894
SYSCALL            00FF E  SYSHLT             26F0    T.CHA              4085
T.FLG              4086    T.FWA              4087    T.LIM              408B
T.LWA              408D    T.PTR              4089    T0BOOT             2480
T0BOOT0            2528    T0BOOT1            2549    T0BOOT2            25F5
T0BOOT3            2602    T0BOOT4            25FD    T0BOOT5            260F
T0BOOT8            2621    T0BOOT9            2675    T0BOOTL            0700 E
T0BOOTX            24FB    T0BOOTY            251A    T110               2A56
T1200              2A3E    T150               2A5A    T1800              2A52
T19200             2A36    T300               2A42    T3600              2A4E
T38400             2A46    T4800              2A3A    T600               2A32
T7200              2A4A    T75                2A5E    T9600              2A2E
TAB                0009 E  TABLE              2A2A E  TBL1               37E2
TBL2               37F0    TBL3               37F2    TDD1               384E
TDD2               385D    TDDA               3874    TDI                3E58
TDIA               3E68    TFE                1B9B E  TFN                27AA
TFN1               27B9    TLEN               000A E  TPL1               3815
TRUE               0001 E  TTDRV              24E8    TTDVD              24D9
TYPEC0             27F0    TYPEC1             27F8    TYPEC2             2805
TYPEC2A            2814    TYPEC2B            281B    TYPEC3             281E
TYPEC4             2824    UC.2SB             0004 E  UC.5BW             0000 E
UC.6BW             0001 E  UC.7BW             0002 E  UC.8BW             0003 E
UC.BI              0010 E  UC.CTS             0010 E  UC.DCS             0001 E
UC.DDR             0002 E  UC.DLA             0080 E  UC.DR              0001 E
UC.DRL             0008 E  UC.DSR             0020 E  UC.DTR             0001 E
UC.EDA             0001 E  UC.EPS             0010 E  UC.FE              0008 E
UC.IID             0006 E  UC.IIP             0001 E  UC.LOO             0010 E
UC.MSI             0008 E  UC.OR              0002 E  UC.OU1             0004 E
UC.OU2             0008 E  UC.PE              0004 E  UC.PEN             0008 E
UC.RI              0040 E  UC.RLS             0080 E  UC.RSI             0004 E
UC.RTS             0002 E  UC.SB              0040 E  UC.SKP             0020 E
UC.TER             0004 E  UC.THE             0020 E  UC.TRE             0002 E
UC.TSE             0040 E  UCI.ER             0010 E  UCI.IE             0002 E
UCI.IR             0040 E  UCI.RE             0004 E  UCI.RO             0020 E
UCI.TE             0001 E  UDR                0000 E  UMI.16X            0002 E
UMI.1B             0040 E  UMI.1X             0001 E  UMI.2B             00C0 E
UMI.64X            0003 E  UMI.HB             0080 E  UMI.L5             0000 E
UMI.L6             0004 E  UMI.L7             0008 E  UMI.L8             000C E
UMI.PA             0010 E  UMI.PE             0020 E  UNIT               3896
UNT.DIS            0006    UNT.FLG            0000    UNT.GRT            0002
UNT.GTS            0004    UNT.SIZ            0008 E  UNT.SPG            0001
UO.CLK             0001 E  UO.DDU             0002 E  UO.HLT             0080 E
UO.NFR             0040 E  UR.DLL             0000 E  UR.DLM             0001 E
UR.IER             0001 E  UR.IIR             0002 E  UR.LCR             0003 E
UR.LSR             0005 E  UR.MCR             0004 E  UR.MSR             0006 E
UR.RBR             0000 E  UR.THR             0000 E  USERFWA            2280 E
USR                0001 E  USR.BD             0040 E  USR.FE             0020 E
USR.OE             0010 E  USR.PE             0008 E  USR.RXR            0002 E
USR.TXE            0004 E  USR.TXR            0001 E  VERS               0030 E
VFL.80T            0002 E  VFL.DTD            0002 E  VFL.FIX            0004 E
VFL.NSD            0001 E  VFT                3E76    VFTA               3D8A E
VOLZERO            0001 E  VSN                36E9    XCHGBC             381B
