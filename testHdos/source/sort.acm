	SPACE	4,10
**	$SORT - SORT FIXED LENGTH RECORDS ON MULTIPLE KEYS.	/3.0a/
*
*	SHELL/METZNER SORT ROUTINE
*	SORT THE ENTRIES BASED ON SORT TABLE
*
*	BEFORE ENTERING *SORT* USER MUST SET UP A FIELD TABLE
*	AND A SORT TABLE
*
*	FIELD TABLE DESCRIBES THE FIELDS IN EACH RECORD
*	FIELD TABLE TAKES THE FOLLOWING FORM:
*	(OFFSET FROM RECORD START),(LENGTH OF FIELD)
*
*	FIELDS	DB	0,8		FILENAME
*		DB	8,3		EXTENSION
*		DB	19,0		CREATION DATE
*		DB	21,0		LAST ACCESS DATE
*		DB	13,1		ACCESS COUNT
*
*	A FIELD LENGTH OF 0 TELLS $SORT THAT WE HAVE A TWO BYTE WORD
*	IN LO.HI FORMAT TO SORT ON. ANY OTHER LENGTH SIGNIFIES A STRING
*	OF CHARACTERS OR BYTES. MAXIMUM FIELD LENGTH IS, THEREFORE, 255.
*
*	SORT TABLE DESCRIBES WHICH FIELDS TO SORT ON.
*	SORT TABLE MUST CONTAIN (# OF FIELDS)+1 BYTES
*	SORT TABLE MUST TERMINATE WITH A ZERO BYTE.
*
*	SORTAB	DB	1,2,3,4,5,0
*
*	IF A SORT TABLE ENTRY HAS THE HI BIT SET THEN THAT FIELD WILL
*	BE SORTED IN REVERSE.  IT IS POSSIBLE TO DO A DOUBLE REVERSE
*	WHICH YIELDS A NORMAL SORT (NEATO, AIN'T IT).
*
*	USAGE:
*
*	CALL	$SORT
*	DW	FWA RECORD TABLE
*	DW	RECORD LENGTH
*	DW	RECORD COUNT
*	DW	FIELD TABLE
*	DW	SORT TABLE
*
*	ENTRY:	((SP)) = RET
*		(RET)+0 = FWA RECORD TABLE
*		(RET)+2 = RECORD LENGTH
*		(RET)+4 = RECORD COUNT
*		(RET)+6 = FIELD TABLE
*		(RET)+8 = SORT TABLE
*
*	EXIT:	TO (RET)+10
*	USES:	ALL

*	$SORT = ENTRY FOR ASCENDING SORT

$SORT	MVI	A,353Q		XCHG INSTRUCTION
	DB	46Q		FAKE MVI H,

*	$SORT. = ENTRY FOR DESCENDING SORT
*		IF YOU ENTER HERE AND ASK FOR A REVERSE FIELD, YOU GET
*		A NORMAL SORT ON THAT FIELD.

$SORT.	XRA	A
	STA	COMPX
	POP	H		GET RETURN PTR
	MOV	E,M
	INX	H
	MOV	D,M		(DE) = FWA RECORD TABLE
	INX	H
	XCHG			SAVE PTR
	SHLD	RECTAB
	XCHG			GET PTR
	MOV	A,M		(A) = RECORD LENGTH
	INX	H		SKIP HI BYTE (LIMIT IS 256 BYTES)
	INX	H		CALLER MUST INSURE THIS LIMIT IS WATCHED!
	STA	SWP1
	STA	SWP2
	STA	SWP3
	STA	INDX
	MOV	E,M
	INX	H
	MOV	D,M		(DE) = RECORD COUNT
	INX	H
	XCHG			SAVE PTR
	SHLD	RECCNT
	SHLD	VAR.M		PRIME M AT FIRST
	XCHG			GET PTR
	MOV	E,M
	INX	H
	MOV	D,M		(DE) = FIELD TABLE
	INX	H
	XCHG			SAVE PTR
	SHLD	FLDTAB
	XCHG			GET PTR
	MOV	E,M
	INX	H
	MOV	D,M		(DE) = SORT TABLE
	INX	H
	PUSH	D
	XTHL			SAVE RETURN ADDR
	SHLD	SRTBX

SORT1	LHLD	VAR.M
	ANA	A		CLEAR CARRY
	MOV	A,H
	RAR
	MOV	H,A
	MOV	A,L
	RAR
	MOV	L,A
	SHLD	VAR.M		M=M/2
	ORA	H
	RZ			SORT IS DONE!

	CALL	$CHL
	XCHG			(DE) = -M
	LHLD	RECCNT
	DAD	D
	SHLD	VAR.K		K=N-M
	LXI	H,1		J=1

SORT2	SHLD	VAR.J		SAVE NEW J

SORT3	SHLD	VAR.I		SAVE NEW I
	XCHG
	LHLD	VAR.M
	DAD	D		(DE)=I, (HL)=I+M
	CALL	INDEX
	XCHG			DE=PTR TO ENTRY (I+M)
	CALL	INDEX		HL=PTR TO ENTRY (I)
	CALL	COMPARE
	JNC	SORT4
	CALL	SWAP		EXCHANGE THE ENTRIES
	LHLD	VAR.M
	CALL	$CHL		(HL) = -M
	XCHG
	LHLD	VAR.I
	XCHG			DE=I
	DAD	D
	JNC	SORT4		'NC' IMPLIES I-M<0
	MOV	A,H
	ORA	L
	JNZ	SORT3		CONTINUE IF NZ

SORT4	LHLD	VAR.J
	INX	H
	XCHG			(DE)=J+1
	LHLD	VAR.K		(HL)=K
	CALL	CPDEHL
	XCHG
	JC	SORT1		J>K
	JMP	SORT2

*	COMPARE - COMPARE TWO ENTRIES FOR SORTING
*	ENTER:	(DE)=START OF FIRST ENTRY IN MEMORY
*		(HL)=START OF SECOND ENTRY IN MEMORY
*	EXIT:	'C' SET IF ENTRIES SHOULD BE SWAPPED
*	USES:	A,F,B,C

COMPARE LXI	B,*-*		FIELD SEQUENCE FOR FILES
SRTBX	EQU	*-2

COMP1	LDAX	B		GET NEXT SORT FIELD #
	INX	B
	ANA	A
	RZ			ZERO IS LAST
	ANI	200Q
	JZ	COMP1.1
	MVI	A,353Q		XCHG INST.
	DB	376Q		FAKE CPI
COMP1.1 XRA	A
	STA	COMPY
	STA	COMPZ
	PUSH	B
	PUSH	D
	PUSH	H
	PUSH	H
	LXI	H,*-*		FIELD DESCRIPTION FOR FILES
FLDTAB	EQU	*-2
	DCX	B
	LDAX	B		GET BACK SORT FIELD #
	ANI	177Q		STRIP HI BIT
	DCR	A		RELATIVE TO 0
	ADD	A		X 2
	CALL	$DADA.		INDEX INTO FIELD DESCRIPTIONS
	MOV	C,M
	MVI	B,0		BC=OFFSET VALUE
	INX	H
	MOV	A,M
	POP	H
	PUSH	PSW		SAVE FIELD LENGTH
	DAD	B		ADD OFFSET TO HL
	XCHG
	DAD	B		ADD OFFSET TO DE
COMPX	XCHG			MAJOR REVERSE SORT
	POP	PSW
	ANA	A
	JNZ	COMP2

	CALL	$HLIHL		GET 16 BIT WORD
	XCHG
	CALL	$HLIHL		GET 16 BIT WORD
COMPY	NOP			FIELD REVERSE SORT
	CALL	CPDEHL
	JMP	COMP3

COMP2	MOV	C,A
	MVI	B,0		BC=FIELD LENGTH
COMPZ	NOP			FIELD REVERSE SORT
	CALL	$COMP

COMP3	POP	H
	POP	D
	POP	B
	RNZ
	JMP	COMP1		USE NEXT FIELD IF EQUAL

*	SWAP - EXCHANGE TWO ENTRIES
*
*	ENTRY:	(DE) = ONE RECORD
*		(HL) = ANOTHER RECORD
*	EXIT:	RECORDS SWAPPED
*	USES:	ALL

SWAP	PUSH	D
	PUSH	H
	LXI	B,*-*
SWP1	EQU	*-2

	LXI	H,LABEL
	CALL	$MOVE		MOVE (DE) TO (SAVE)
	POP	D		GET OLD HL
	POP	H		GET OLD DE
	PUSH	D		SAVE OLD HL
	LXI	B,*-*
SWP2	EQU	*-2

	CALL	$MOVE		MOVE (HL) TO (DE)
	POP	H		GET OLD HL
	LXI	B,*-*
SWP3	EQU	*-2

	LXI	D,LABEL
	JMP	$MOVE		MOVE (SAVE) TO (HL)

*	INDEX - RETURN MEMORY LOCATION OF RECORD
*
*	ENTRY:	(HL) = DESIRED ENTRY INDEX (FIRST ONE = 1)
*	EXIT:	(HL) = ADDRESS OF DESIRED ENTRY
*	USES:	A,F,H,L

INDEX	PUSH	D		SAVE (DE)
	XCHG			(DE) = INDEX
	DCX	D		MAKE RELATIVE TO 0
	MVI	A,0		RECORD LENGTH
INDX	EQU	*-1

	CALL	$MU86		(HL) = INDEX X RECORD LENGTH
	LXI	D,*-*
RECTAB	EQU	*-2		START OF RECORD TABLE

	DAD	D
	POP	D
	RET

*	VARIABLE STORAGE CELLS

VAR.I	DW	0
VAR.J	DW	0
VAR.K	DW	0
VAR.M	DW	0
RECCNT	DW	0
