	TITLE	'ONECOPY - ONE DRIVE COPY UTILITY'

***	ONECOPY - SINGLE DRIVE PERIHPERAL INTERCHANGE PROGRAM.
*
*	J.G. LETWIN, 11/1977 FOR *HEATH* COMPANY
*
*	COPYRIGHT 1977 BY HEATH COMPANY
*
*	G.A. Chandler,	78/09	Maintenence Release
*			79/04
*
*			79/11	50.05.00
*			80	50.06.00
*				 /2.0a/ = /80.09.gc/
*				 /2.0b/ = /80.10.gc/
*
*	R.L. Musgrave,	86/09	50.07.00
	SPACE	4,10
***	USE:
*
*	SOURCE1 [,SOURCE2,...,SOURCEN] [/SWITCH1.../SWITCHN]
*
*	SWITCHES:
*
*	/L[IST]		LIST
*	/B[RIEF]	BRIEF LIST
*	/V[ERSION]	ONECOPY VERSION NUMBER
*	/ID		SAME AS /V + SOME DATA				/3.0a/
*	/M[OUNT]	MOUNT DEVICE
*
*	/S[YSTEM]	INCLUDE SYSTEM FILES
*	/ALL[OCATE]	SHOW ALLOCATED SIZE
*	/SU[PRESS]	SUPRESS
*	/Q[UERY]	INCLUDE ONLY THOSE FILES YOU TAG		/3.0a/
	SPACE	4,10
**	SYSTEM EQUIVALENCES

CN.SOU	EQU	0		SOURCE CHANNEL NUMBER
CN.DES	EQU	1		DESTINATION CHANNEL NUMBER
CN.DIR	EQU	2		DIRECTORY CHANNEL NUMBER

**	PROGRAM ERROR CODES

PEC.DF	EQU	200Q		DEVICE FORMAT ERROR
PEC.DNC	EQU	201Q		DEVICES NOT CONSISTANT
PEC.TFI	EQU	203Q		TARGET FILE ILLEGAL
PEC.CS	EQU	204Q		CONTRADICTORY SWITCHES
PEC.IUW	EQU	205Q		ILLEGAL USE OF WILDCARD
PEC.IDF	EQU	206Q		ILLEGAL DESTINATION FILE FORMAT
PEC.SFI	EQU	207Q		SOURCE FILE ILLEGAL
PEC.FCI	EQU	210Q		FILE CONCATINATION ILLEGAL

	NOTE	MEML-USERFWA
	NOTE	FDN-PATCH-64

	XTEXT	DIRDEF
	XTEXT	DIFDEF
	XTEXT	OVLDEF
	XTEXT	DEVDEF
	XTEXT	IOCDEF
	XTEXT	DISDEF
	XTEXT	FBDEF
	XTEXT	ECDEF
	XTEXT	HOSEQU
	XTEXT	HOSDEF
	XTEXT	ASCII
	XTEXT	ESINT
	XTEXT	ESVAL
	XTEXT	DDDEF
	XTEXT	DDFDEF
	XTEXT	LABDEF
	XTEXT	FILDEF
	XTEXT	ABSDEF
	STL	'MAIN ROUTINE'
	EJECT
	ORG	USERFWA

OCFWA	EQU	*

*	Since this code overlays PRS, it is included here

PRS3	CALL	GETLAB		Get Label
	RC
	LXI	B,256
	LXI	D,LABEL
	LXI	H,SLABEL
	CALL	$MOVE		Save Current Label

	CALL	MND		Mount New Disk
	JC	ERROR
	LDA	LABEL+LAB.SER
	STA	VOLSER		Set Current Volume Number
	JMP	START

PIP	EQU	*

*	COMMAND INTERPRETATION COMES HERE

RESTART	EQU	*

	LDA	MODE
	ANA	A
	JNZ	EXIT		ENTERED WITH COMMAND, WILL NOW EXIT
START	LXI	SP,STACK	CLEAN STACK
	CALL	PIP1		EXECUTE COMMAND

*	COMMANDS EXIT HERE IF NO ERRORS FOUND

	JMP	RESTART

*	GET READY TO PROCESS COMMAND

PIP1	CALL	SDD		SET DEFAULT DEFAULT

*	CLEAR CHANNELS AND FILE BUFFER

	SCALL	.CLEARA 	CLEAR CHANNELS
	XRA	A
	STA	DESTFB+FB.FLG	FLAG FILE NOT OPEN

*	CLEAR DYNAMIC BUFFERS

	LXI	H,0
	SHLD	BUFSIZ		EMPTY BUFFER
	SHLD	NAMTLEN		CLEAR NAMTAB
	SHLD	NAMTMAX		CLEAR NAMTAB AREA
	LXI	H,BUFF
	SHLD	BUFPTR		SET BUFFER AGAINST END OF NAMTAB

*	INPUT COMMAND LINE

	CALL	$CCO		CLEAR CONTROL-O
	LDA	MODE
	ANA	A
	CZ	ACL		ACCEPT COMMAND LINE (UNLESS WAS PASSED ONE BY CALLER)
	JC	EXIT		EOF
	LXI	H,LINE		(HL) = COMMAND ADDRESS
	LXI	D,PIPA		(DE) = SWITCH LIST
	ERRNZ	I.COP
	XRA	A		(A) = #I.COP
	STA	COMAND		ASSUME COPY COMMAND
	STA	SUPRES		CLEAR /SU FLAG
	STA	ALLOCA		Clear /ALL flag
	STA	QUERY		Clear /Q flag
	INR	A		FLAG NO /S FLAG
	STA	SYSTEM		CLEAR /S FLAG
	CALL	$DRS		DETECT AND REMOVE SWITCHES
	JC	ERROR		ERROR
	LDA	COMAND
	CALL	$TJMP		PROCESS COMMAND
	EJECT
**	COMMAND LIST

PIPB	DS	0		COMMAND PROCESSOR TABLE
I.COP	EQU	*-PIPB/2		COMMAND INDEX
	DW	COPY
I.LIS	EQU	*-PIPB/2		COMMAND INDEX
	DW	LIST		/L
I.BRE	EQU	*-PIPB/2		COMMAND INDEX
	DW	BRIEF		/B
I.VER	EQU	*-PIPB/2		COMMAND INDEX
	DW	VERSN		/V
I.ID	EQU	*-PIPB/2		COMMAND INDEX
	DW	ID		/ID
I.MOU	EQU	*-PIPB/2		COMMAND INDEX
	DW	MOUNT		/M

*	CTL-D HIT

EXIT	XRA	A
	SCALL	.EXIT		EXIT
CCHIT	SPACE	3,10
**	CCHIT - CTL-C HIT
*
*	ENTRY	FROM SYSTEM

CCHIT	CALL	$TYPTX
	DB	'^','C'+200Q
	SCALL	.CLRCO		CLEAR CONSOLE TYPEAHEAD
	JMP	RESTART		GET NEW COMMAND
	STL	'SWITCH PROCESSING TABLES AND ROUTINES'
	EJECT
***	SWITCH PROCESSING TABLES AND ROUTINES.
*
*	COMMAND SWITCHES ARE PROCESSED VIA THE ROUTINE $DRS, 'DECODE AND
*	REMOVE SWITCHES'. $DRS IS SUPPLIED WITH A SWITCH DESCRIPTION
*	TABLE, WHICH CONTAINS THE ADDRESSES OF ROUTINES
*	WHICH ARE ENVOKED WHEN THE SWITCHES ARE ENCOUNTERED.

**	SWITCH TABLE

PIPA	DS	0		FWA SWITCH TABLE

	DB	'L'		/LIST
	DB	'I'+200Q,'S'+200Q,'T'+200Q,200Q
	DW	SW.LIS		PROCESS LIST

	DB	'B'		/BRIEF
	DB	'R'+200Q,'I'+200Q,'E'+200Q,'F'+200Q,200Q
	DW	SW.BRE		PROCESS BRIEF

	DB	'V'		/VERSION
	DB	'E'+200Q,'R'+200Q,'S'+200Q,'I'+200Q,'O'+200Q,'N'+200Q,200Q
	DW	SW.VER		PROCESS VERSION

	DB	'ID'		/ID
	DB	200Q
	DW	SW.ID		PROCESS ID

	DB	'M'		/MOUNT
	DB	'O'+200Q,'U'+200Q,'N'+200Q,'T'+200Q,200Q
	DW	SW.MOU		PROCESS MOUNT

	DB	'S'		/SYSTEM
	DB	'Y'+200Q,'S'+200Q,'T'+200Q,'E'+200Q,'M'+200Q,200Q
	DW	SW.SYS		PROCESS SYSTEM

	DB	'ALL'		/ALLOCATE
	DB	'O'+200Q,'C'+200Q,'A'+200Q,'T'+200Q,'E'+200Q,200Q
	DW	SW.ALL		PROCESS ALLOCATE

	DB	'SU'		/SUPRESS
	DB	'P'+200Q,'R'+200Q,'E'+200Q,'S'+200Q,'S'+200Q,200Q
	DW	SW.SUP		PROCESS SUPRESS

	DB	'Q'		/QUERY
	DB	'U'+200Q,'E'+200Q,'R'+200Q,'Y'+200Q,200Q
	DW	SW.QUE		PROCESS QUERY

	DB	0		END OF TABLE
	EJECT
SWIT1	SPACE	3,10
*	SWIT1 - PROCESS MAJOR FUNCTION SWITCH.
*
*	SWIT1 IS ENTERED TO PROCESS SWITCHES WHICH DETERMINE THE FUNCTION
*	PIP IS TO PERFORM. I.E. 'VERB' SWITCHES, SUCH
*	AS /DELETE (AS OPOSED TO 'MODIFIER' SWITCHES, LIKE /SYSTEM)

SWIT1	LXI	B,COMAND
	PUSH	PSW		SAVE COMMAND
	LDAX	B		(A) = PREVIOUS COMMAND
	ANA	A
	MVI	A,PEC.CS	CONTRADICTORY SWITCHES
	JNZ	ERROR		IF SO
	POP	PSW		(A) = NEW CODE
	STAX	B		STORE IT
	RET
SW.ALL	SPACE	4,10
**	SW.ALL - /ALLOCATE Switch Detected

SW.ALL	MVI	A,1
	STA	ALLOCA
	RET
SW.SYS	SPACE	3,10
**	SW.SYS - /SYSTEM Switch Detected

SW.SYS	XRA	A		SET /S FLAG
	STA	SYSTEM
	RET
SW.SUP	SPACE	4,10
**	SW.SUP - /SUPRESS Switch Detected

SW.SUP	MVI	A,1
	STA	SUPRES
	RET
SW.QUE	SPACE	4,10
**	SW.QUE - /QUERY Switch Detected

SW.QUE	MVI	A,1
	STA	QUERY
	RET
SW.BRE	SPACE	3,10
**	SW.BRE - /BRIEF Switch Detected

SW.BRE	LDA	COMAND		ALLOW TO SUPERCEDE /LIST
	ANA	A
	JZ	SW.BRE1		NO OTHER COMMAND
	ERRNZ	I.LIS-1
	DCR	A
	MVI	A,PEC.CS	ASSUME CONTRADICTORY SWITCHES
	JNZ	ERROR
SW.BRE1	MVI	A,I.BRE		IS /BREIF
	STA	COMAND
	RET
SW.LIS	SPACE	3,10
**	SW.LST - /LIST Switch Detected

SW.LIS	LDA	COMAND
	ANA	A
	JZ	SW.LIS1		NO FUNCTION
	ERRNZ	I.BRE-2
	ERRNZ	I.LIS-1
	SUI	3
	CMC
	RNC			ALREADY HAVE ONE SPECIFIED, I.BRE OVERRULES
SW.LIS1	MVI	A,I.LIS		/LIST
	STA	COMAND
	RET
SW.VER	SPACE	3,10
**	SW.VER - /VERSION Switch Detected

SW.VER	MVI	A,I.VER
	JMP	SWIT1
SW.ID	SPACE	3,10
**	SW.ID - /ID Switch Detected

SW.ID	MVI	A,I.ID
	JMP	SWIT1
SW.MOU	SPACE	3,10
**	SW.MOU - /MOUNT Switch Detected

SW.MOU	MVI	A,I.MOU
	JMP	SWIT1
	STL	'ACL - ACCEPT COMMAND LINE.'
	EJECT
ACL	SPACE	4,10
***	ACL - ACCEPT COMMAND LINE.
*
*	ACL PROMPTS FOR AND READS A COMMAND LINE FROM
*	THE CONSOLE.
*
*	ENTRY	NONE
*	EXIT	'C' CLEAR, GOT LINE
*		 'LINE' = COMMAND LINE
*		'C' SET IF EOF
*	USES	ALL

ACL	CALL	$GNL		GUARANTEE NEW LINE
	CALL	$TYPTX
	DB	NL,'O:',' '+200Q
	ERRNZ	I.CSLMD
	XRA	A		(A) = I.CSLMD
	MOV	B,A		CLEAR SPECIAL MODES
	MVI	C,CSL.ECH+CSL.RAW+CSL.CHR
	SCALL	.CONSL
	LXI	H,LINE
	JMP	$RTL.		READ UPPER CASE LINE AND EXIT
	STL	'MOUNT - MOUNT A DIFFERENT DISK'
	EJECT
MOUNT	SPACE	4,10
***	MOUNT - MOUNT A DIFFERENT DISK.
*
*	MOUNT CAUSES A NEW DISK TO BE MOUNTED.
*
*	INSERT THE DISK IN SY0, THEN TYPE
*
*	/MOUNT

MOUNT	LXI	H,SLABEL
	MVI	B,0		Count of 256
	CALL	$ZERO		Zero the old label

	LXI	D,MOUNTA
	JMP	MAD		MOUNT ALTERNATE DISK

MOUNTA	DB	NL,'Insert New Disk',':'+200Q
	STL	'ONECOPY - COPY FILES BETWEEN VOLUMES.'
	EJECT
ONECOPY	SPACE	4,10
***	ONECOPY - COPY FILES BETWEEN TWO VOLUMES, WITH ONLY ONE
*	DRIVE.
*
*	(AND FOR MY NEXT TRICK...)
*
*	ONECOPY COPIES FILES BETWEEN TWO VOLUMES BY ALTERNATING BETWEEN
*	TWO PHASES, THE READ PHASE AND THE WRITE PHASE. 
*
*	READ PHASE:
*
*	DURING THE READ PHASE, THE SOURCE DISK IS MOUNTED. SOURCE FILES ARE
*	OPENED IN THE ORDER OF THEIR APPEARANCE. FOR EACH OPENED
*	FILE, A 'FILE DESCRIPTOR NODE' *FDN* IS ADDED  TO  THE ACTIVE
*	CHAIN. THEN, AS MUCH AS THE FILE AS POSSIBLE IS READ INTO MEMORY.
*
*	THE PROCESS CONTINUES UNTIL
*		1) THERE IS NO MORE FREE RAM
*		2) OR, THERE ARE NO MORE FILE DESCRIPTOR NODES IN THE FREE CHAIN
*		3) OR, THERE ARE NO MORE FILES IN NAMTAB (INPUT FILE LIST)
*
*
*	WRITE PHASE
*
*	DURING THE WRITE PHASE, THE DESTINATION DISK IS MOUNTED. THE NODES
*	ARE TAKEN FROM THE ACTIVE CHAIN, AND PROCESSED. IF THE FILE HAD
*	BEEN PARTIALLY WRITTEN THE LAST PASS, IT IS  RE-OPENED AND POSITIONED.
*	IF THERE IS NOT MORE DATA TO READ FOR A PROCESSED
*	NODE, IT IS REMOVED, AND THE CORRESPONDING ENTRY IN NAMTAB IS DELETED.
*
*	WRITE PHASE CONTINUES UNTIL
*
*		1) THERE ARE NO MORE FILE NODES IN THE ACTIVE LIST
*		2) OR, THE FIRST (AND ONLY) ENTRY IN THE LIST HAS NO
*		   MORE DATA IN MEMORY, BUT HAS NOT BEEN COMPLETELY READ.

COPY	EQU	*		CALLED 'COPY' BY MAINLINE CODE
OCOPY	EQU	*
	CALL	IFL		INITIALIZE  FDN LISTS
	XRA	A
	STA	OCOPYC		CLEAR FILE COUNT
	STA	VOLFLAG		FLAG SOURCE  VOLUME MOUNTED
	LDA	LABEL+LAB.SER	A  = Volume Label
	STA	VOLSER		SET VOLUME SERIAL NUMBER
	CALL	DDF		DECODE DESTINATION FILE
	JC	ERROR		ERROR
	STA	OCOPYA		SAVE DESTIONATION TYPE
	CALL	SDD		RESET DEFAULT DEFAULTS
	XRA	A		ALLOW *.*
	CALL	BSL		BUILD SOURCE FILE LIST
	JC	ERROR
	CALL	$MOVEL
	DW	OCOPYDL
	DW	DESTFB+FB.NAM
	DW	OCOPYD		SAVE WILDCARD DESTINATION
	CALL	EBM		EXPAND BUFFER TO MAX

*	MAKE SURE HE'S NOT TRYING TO CONCATINATE

	LDA	OCOPYA
	ANA	A
	JZ	OCOPY1		HAVE WILDCARDS
	LHLD	NAMTLEN		NO WILDCARDS, ONLY LET HIM SPEFICY ONE SOURCE
	LXI	D,-FB.NAML
	DAD	D
	MOV	A,H
	ORA	L
	MVI	A,PEC.FCI	FILE CONCATINATION IS ILLEGAL
	JNZ	ERROR

*	START READ PHASE

OCOPY1	LDA	BUFPTR+1	(A) = BUFFER FWA/256
	INR	A		ROUND UP TO NEXT PAGE
	STA	OBUFPTR		SET SECTOR BUFFER  FWA/256
	LDA	VOLFLAG
	ANA	A
	JZ	OCOPY2		SOURCE IS MOUNTED
	LXI	D,OCOPYF
	CALL	MAD		MOUNT ALTERNATE DISK
OCOPY2	CALL	RPH		READ PHASE
	LDA	FDNHEAD
	ANA	A
	JZ	OCOPY6		NO FILES ARE READ, ERGO NONE ARE LEFT
	LDA	VOLFLAG
	ANA	A
	JNZ	OCOPY3
	LXI	D,OCOPYG
	CALL	MAD		MOUNT ALTERNATE DISK
OCOPY3	CALL	WPH		WRITE PHASE
	JMP	OCOPY1

*	ALL DONE, FINISH MESSAGE

OCOPY6	LDA	OCOPYC		(A) = FILE COUNT
	MVI	B,0		(BC) = COUNT OF FILES COPIED
	MOV	C,A

*	TYPE FILE COUNT

	MVI	A,3
	LXI	H,OCOPYE
	CALL	$UDDS		UNPACK COUNT INTO MESSAGE
	CALL	$TYPTX
	DB	NL		for aesthetics
OCOPYE	DB	'XXX'
	DB	' Files Copied',ENL
	RET

OCOPYA	DB	0		DESTINATION FILE WILDCARD FLAG (=0 IF WC)
OCOPYC	DB	0		FILES COPIED COUNT
OCOPYD	DC	FB.NAML,#0	HOLD AREA FOR WILDCARD DESTINATION
OCOPYDL	EQU	*-OCOPYD
OCOPYF	DB	NL,'Insert Source',':'+200Q
OCOPYG	DB	NL,'Insert Destination',':'+200Q
	STL	'ONECOPY SUBROUTINES'
	EJECT
RPH	SPACE	4,10
**	RPH - READ PHASE.
*
*	RPH  HANDLES THE READ PHASE OF THE COPY PROCESS.
*
*	IT IS ENTERED WITH THE NAMTAB AND FDN TABLE SETUP, AND
*	WITH THE SOURCE DISK MOUNTED.
*
*	READ PHASE:
*
*	DURING THE READ PHASE, THE SOURCE DISK IS MOUNTED. SOURCE FILES ARE
*	OPENED IN THE ORDER OF THEIR APPEARANCE. FOR EACH OPENED
*	FILE, A 'FILE DESCRIPTOR NODE' *FDN* IS ADDED  TO  THE ACTIVE
*	CHAIN. THEN, AS MUCH AS THE FILE AS POSSIBLE IS READ INTO MEMORY.
*
*	THE PROCESS CONTINUES UNTIL
*		1) THERE IS NO MORE FREE RAM
*		2) OR, THERE ARE NO MORE FILE DESCRIPTOR NODES IN THE FREE CHAIN
*		3) OR, THERE ARE NO MORE FILES IN NAMTAB (INPUT FILE LIST)
*
*	ENTRY	NONE
*	EXIT	NONE
*	USES	ALL

RPH	EQU	*

*	SEE IF ANY MEMORY TO HAVE

	CALL	CBR		COMPUTE BUFFER ROOM
	RZ			NONE

*	SEE IF WE NEED TO READ SOME MORE INTO A PART-COPIED FILE

	LXI	H,FDNHEAD
	MOV	L,M		(HL) = ADDRESS IF FIRST NODE
	MOV	A,L
	ANA	A
	JZ	RPH1		IS NO FIRST NODE, ERGO NO FILE
	INX	H
	ERRNZ	FDN.STA-1
	MOV	A,M		(A) = .STA
	ANI	ST.OPR
	LXI	D,NAMTAB
	JNZ	RPH2.5		FILE IS INCOMPLETELY READ

*	SEE IF ANY FREE FILE DESCRIPTOR NODES TO USE

RPH1	LDA	FDNFRE
	ANA	A
	RZ			NO MORE

*	SEE IF THERE IS A FILE IN NAMTAB WITHOUT AN ENTRY IN FNDLIST.
*	SINCE THE FIRST ENTRY IN FDNLIST CORRESPONDS TO THE FIRST IN
*	NAMTAB, ETC., WE'LL JUST RUN DOWN FDNLIST UNTIL THE END, AND
*	THE NEXT NAMTAB FILE WILL BE THE ONE WE WANT...

	LXI	B,FB.NAML	(BC) = ENTRY SIZE IN NAMTAB
	LXI	D,-FB.NAML		(DE) = POINTER INTO NAMTAB
	LXI	H,FDNHEAD
	MOV	A,L		START WITH FDNHEAD
RPH2	MOV	L,A		FOLLOW LINK
	MOV	A,M		(A) = NEXT NODE
	XCHG
	DAD	B		ADVANCE POINTER INTO NAMTAB
	XCHG
	ANA	A
	JNZ	RPH2		LINK SOME MORE
	PUSH	H		(HL) = ADDRESS OF LAST NODE
	LHLD	NAMTLEN
	CALL	$CDEHL		SEE IF HAVE ACCOUNTED FOR ALL NAMTAB ENTRYS
	POP	H
	RE			FILES ALL USED UP

*	HAVE ROOM FOR DATA, HAVE A NODE FOR THE FILE COUNTS, AND
*	HAVE A FILE NAME. ALL SET FOR BUSINESS..
*
*	(DE) = INDEX INTO NAMTAB FOR FILE
*	(HL) = NODE ADDRESS OF LAST ENTRY IN LIST
*
*	CHAIN THE FIRST FREE NODE ONTO THE END OF THE LIST

	LDA	FDNFRE
	MOV	M,A		CHAIN TO  NEW END  NODE
	MOV	L,A
	MOV	A,M		(A) =  NEXT NODE IN FREE CHAIN
	STA	FDNFRE
	MVI	B,FDNELEN
	PUSH	H		SAVE NODE ADDRESS
	CALL	$ZERO		ZERO ENTIRE NODE, ENCLUDING CHAIN (AT END,  NOW)
	LXI	B,NAMTAB
	XCHG
	DAD	B		(HL) = ADDRESS OF NAMTAB ENTRY
	SHLD	NAMTPTR		POINTER TO CURRENT NAMTAB ENTRY
	XCHG
	POP	H
	ERRNZ	FDN.STA-1
	INX	H		(HL) = ADDR OF FDN.STA OF NODE

*	READY TO OPEN FILE
*
*	(DE) = NAMTAB ENTRY ADDRESS
*	(HL) = #FDN.STA OF ENTRY

RPH2.5	PUSH	H		SAVE ADDRESS
	XCHG
	XRA	A
	ERRNZ	CN.SOU		(A) = SOURCE CHANNEL NUMBER
	SCALL	.OPENR		OPEN
	JC	NAMERR		ERROR
	POP	D
	CALL	RPHX		PRINT FILE NAME, GET SOURCE DATE & TIME /3.0a/
	LDAX	D		(A) = FDN.STA
	ANI	ST.OPR
	PUSH	D		SAVE ADDRESS
	JNZ	RPH3		ALREADY OPENED IN PREVIOUS PASSES

*	FIRST TIME THIS FILE HAS BEEN OPENED. SEE IF CONTIGUOUS

	PUSH	H
	LXI	H,OCOPYC
	INR	M
	POP	H
	LDAX	D
	ORI	ST.OPR		SET OPEN FOR READ
	STAX	D
	LHLD	S.CFWA		(HL) = CHANNEL 0 FWA
	ERRNZ	IOCCTD-1	WE NEED TO CHAIN ONE TO GET TO USER #0
	CALL	$HLIHL
	ERRNZ	CN.SOU		ASSUME WE WANT CHANNEL 0
	CALL	$INDL
	DW	IOC.DIR+DIR.FLG
	MOV	A,E		(A) = DIR.FLG
	ANI	0 DIF.CNT	* * PATCH * *
	JZ	RPH3		NOT CONTIG

*	IS CONTIG. GET FILE SIZE

	CALL	$INDL
	DW	IOC.GRT
	PUSH	D		SAVE GRT ADDRESS
	CALL	$INDL
	DW	IOC.DIR+DIR.FGN	(E) = DIR.FGN
	MOV	A,E
	POP	H		(HL) = GRT TABLE ADDRESS
	CALL	CFS.		COMPUTE BLOCK SIZE
	POP	H		(HL) = ADDRESS OF FDN.STA
	PUSH	H
	MOV	A,M		(A) = FDN.STA
	ORI	ST.CNT		FLAG CONTIG
	MOV	M,A
	INX	H
	ERRNZ	FDN.SIZ-FDN.STA-1
	MOV	M,E		SET BLOCK COUNT

*	READY TO READ DATA. POSITION FILE (IN CASE SOME WAS READ IN
*	PREVIOUS PASSES) AND COMPUTE THE MAX POSSIBLE READ COUNT
*
*	((SP)) = ADDRESS OF FDN.STA FOR NODE

RPH3	POP	H		(HL) = ADDRESS OF FDN.STA
	PUSH	H
	CALL	$INDL
	DW	FDN.AMR-FDN.STA	(DE) = AMOUNT READ (IN SECTORS)
	MOV	B,D
	MOV	C,E		(BC) = AMOUNT READ
	MVI	A,CN.SOU
	SCALL	.POSIT			POSIT
	JC	IERR3		POSIT BLEW UP
	CALL	CBR		COMPUTE BUFFER ROOM
	XCHG			(D) = POINTER/256, (E) = LIMIT/256
	POP	H		(HL) = #FDN.STA
	LXI	B,FDN.ADR-FDN.STA
	DAD	B		(HL) = #FDN.ADR
	MOV	M,D		SET ADDRESS/256
	PUSH	H		SAVE #FDN.ADR
	MVI	E,0		(DE) = ADDRESS
	MOV	B,A		(B) = SECTORS OF RAM AVAILABLE
	MOV	C,E		(C) = 0
	PUSH	B		SAVE TRY COUNT
	MVI	A,CN.SOU
	SCALL	.READ		READ THE STUFF

*	COMPUTE THE AMOUNT READ (IN CASE OF EOF)

	POP	D		(DE) = TRY COUNT
	JNC	RPH4		GOT  ALL WE TRYED
	CPI	EC.EOF
	JNE	NAMERR		NOT JUST EOF, GOT TROUBLES
	MOV	A,D
	SUB	B		REMOVE AMOUNT WE DIDNT GET
	MOV	D,A
	POP	H		(HL) = #FDN.ADR
	PUSH	H
	LXI	B,FDN.STA-FDN.ADR
	DAD	B
	MOV	A,M		(A) = FDN.STA
	ANI	377Q-ST.OPR	EOF, NOT OPEN FOR READ ANYMORE
	MOV	M,A		POST READ COMPLETE FOR THIS GUY

*	STORE RESULTS OF READ IN NODE
*
*	(D) = SECTORS READ
*	((SP)) = #FDN.ADR

RPH4	POP	H		(HL) = #FDN.ADR
	INX	H
	ERRNZ	FDN.AIM-FDN.ADR-1	(HL) = ADDRESS IF AMOUNT IN MEMORY BYTE
	MOV	M,D		STORE SECTORS IN MEMORY COUNT
	LXI	B,FDN.AMR-FDN.AIM
	DAD	B		(HL) = #FDN.AMR (AMOUNT READ)
	MOV	A,M		(A) = AMOUNT READ BEFORE
	ADD	D		ADD NEW AMOUNT
	MOV	M,A
	INX	H
	MOV	A,M
	ACI	0		PROPIGATE FOR VERY LARGE FILES
	MOV	M,A
	LXI	H,OBUFPTR
	MOV	A,M
	ADD	D		ADVANCE FREE RAM POINTER BY AMOUNT READ
	MOV	M,A
	MVI	A,CN.SOU
	SCALL	.CLOSE		CLOSE FILE
	JMP	RPH		SEE IF MORE TO READ

*	PRINT FILE NAME

RPHX	PUSH	H
	PUSH	B
	PUSH	D

	LHLD	NAMTPTR
RPHX0	MOV	A,M
	INX	H
	ANA	A
	JZ	RPHX1
	SCALL	.SCOUT
	JMP	RPHX0

RPHX1	CALL	$CRLF

*	GET SOURCE DATE & TIME

	LHLD	S.CFWA			CHANNEL POINTER -1
	CALL	$HLIHL			CHANNEL POINTER  0 = CN.SOU
	LXI	D,IOC.DIR+DIR.CTH
	DAD	D
	PUSH	H
	CALL	$HLIHL
	SHLD	RPH.TIM 		SAVE SOURCE TIME
	POP	H
	LXI	D,DIR.CRD-DIR.CTH
	DAD	D
	CALL	$HLIHL
	SHLD	RPH.DAT 		SAVE SOURCE DATE

*	SAVE DATE & TIME IN NODE TABLE

	POP	D
	PUSH	D
	LXI	H,FDN.DAT-FDN.STA
	DAD	D
	LXI	D,*-*
RPH.DAT EQU	*-2
	CALL	ISDEHL
	ERRNZ	FDN.TIM-FDN.DAT-2
	LXI	D,*-*
RPH.TIM EQU	*-2
	CALL	ISDEHL

	POP	D
	POP	B
	POP	H
	RET
WPH	SPACE	4,10
**	WPH - WRITE PHASE.
*
*	WPH HANDLES THE WRITE PHASE PROCESSING. IT IS ENTERED WITH
*	THE FDN CHAIN SETUP, THE NAMTAB SETUP, AND
*	THE DESTINATION DISK MOUNTED.
*
*
*	WRITE PHASE
*
*	DURING THE WRITE PHASE, THE DESTINATION DISK IS MOUNTED. THE NODES
*	ARE TAKEN FROM THE ACTIVE CHAIN, AND PROCESSED. IF THE FILE HAD
*	BEEN PARTIALLY WRITTEN THE LAST PASS, IT IS  RE-OPENED AND POSITIONED.
*	IF THERE IS NOT MORE DATA TO READ FOR A PROCESSED
*	NODE, IT IS REMOVED, AND THE CORRESPONDING ENTRY IN NAMTAB IS DELETED.
*
*	WRITE PHASE CONTINUES UNTIL
*
*		1) THERE ARE NO MORE FILE NODES IN THE ACTIVE LIST
*		2) OR, THE FIRST (AND ONLY) ENTRY IN THE LIST HAS NO
*		   MORE DATA IN MEMORY, BUT HAS NOT BEEN COMPLETELY READ.
*
*	ENTRY	NONE
*	EXIT	NONE
*	USES	ALL

WPH	EQU	*

*	SEE IF MORE TO WRITE

	LXI	H,FDNHEAD
	MOV	L,M
	MOV	A,L		(A) = FIRST NODE INDEX
	ANA	A
	RZ			NO MORE
	CALL	$INDL
	DW	FDN.AIM		(E) = AMOUNT IN MEMORY FOR THIS GUY
	MOV	A,E
	ANA	A
	JNZ	WPH0		GOT DATA

*	NO DATA IN NODE. IF STILL READING, RETURN FOR MORE

	INX	H
	MOV	A,M
	DCX	H
	ANI	ST.OPR
	RNZ			STILL READING, GET MORE
	XCHG			(DE) = ADDRESS
	JMP	WPH4		REMOVE NODE, AM DONE WITH FILE

*	HAVE DATA TO WRITE. SEE IF WE HAVE OPENED THIS FILE BEFORE.,
*	OR IF THIS IS THE FIRST TIME

WPH0	PUSH	H		SAVE NODE POINTER
	INX	H
	ERRNZ	FDN.STA-1
	MOV	A,M		(A) = FDN.STA
	ANI	ST.OPW
	JNZ	WPH2		OPENED BEFORE
	ERRNZ	ST.OPW-1
	INR	M		SET '1' BIT

*	BUILD NAME INTO DESTFB

	PUSH	H		SAVE NODE ADDRESS
	LXI	B,OCOPYD
	LXI	D,NAMTAB
	LXI	H,DESTFB+FB.NAM
	CALL	MWN		MERGE WILDCARD NAME
	POP	H

*	IS 1ST TIME FOR THIS FILE. IF CONTIGUOUS FLAG, OPEN THE FILE
*	FOR CONTIGUOUS

	MOV	A,M		(A) = FLAG BYTE
	ANI	ST.CNT
	JNZ	WPH1		IS CONTIG
	LXI	H,DESTFB+FB.NAM
	MVI	A,CN.DES
	SCALL	.OPENW		JUST OPEN FOR WRITE
	JC	DESTERR		ERROR
	JMP	WPH3		WRITE THE DATA

*	IS CONTIG FILE. OPEN IN CONTIG MODE

WPH1	INX	H
	ERRNZ	FDN.SIZ-FDN.STA-1
	MOV	C,M		(C) = COUNT (IN BLOCKS)
	MVI	B,0
	LXI	H,DESTFB+FB.NAM
	MVI	A,CN.DES
	PUSH	B		SAVE COUNT
	SCALL	.DELET		DELETE OLD ONE
	JNC	WPH1.5		DELETED
	CPI	EC.FNF
	JNE	ERROR		MUST BE WRITE PROTECTED, OR  SOMETHING...
WPH1.5	POP	B		(BC) = COUNT
	LXI	H,DESTFB+FB.NAM
	MVI	A,CN.DES
	SCALL	.OPENC		OPEN CONTIG
	JC	DESTERR
	JMP	WPH3

*	THIS FILE HAS ALREADY BEEN PARTIALLY WRITTEN. OPEN IN UPDATE MODE
*	SO WE CAN EXTEND IT.

WPH2	LXI	H,DESTFB+FB.NAM
	MVI	A,CN.DES
	SCALL	.OPENU		OPEN FOR UPDATE
	JC	DESTERR		PROBLEMS
	POP	H
	PUSH	H		(HL) = #FDN.STA
	CALL	$INDL
	DW	FDN.AMW		(DE) = AMOUNT WRITTEN
	MOV	B,D
	MOV	C,E		(BC) = SECTORS WRITTEN
	MVI	A,CN.DES
	SCALL	.POSIT		POSITION FOR EXTEND
	JC	IERR1		COULDNT GET THERE!

*	FILE OPEN AND POSITIONED. WRITE DATA

WPH3	POP	H
	PUSH	H		(HL) = #FDN.LNK
	CALL	$INDL
	DW	FDN.ADR		(E) = ADDR/256, (D) = CNT/256
	MOV	B,D
	MOV	D,E
	MVI	E,0		(DE) = ADDRESS
	MOV	C,E		(BC) = COUNT
	MVI	A,CN.DES
	PUSH	B		SAVE WRITE COUNT
	SCALL	.WRITE		WRITE IT
	JC	DESTERR		PROBABLY OUT OF ROOM
	POP	B
	POP	H
	PUSH	H
	PUSH	B
	CALL	WPHX		FORCE SOURCE DATE & TIME		/3.0a/
	MVI	A,CN.DES
	SCALL	.CLOSE		CLOSE IT
	JC	DESTERR
	POP	B		(B) = SECTORS WRITTEN
	POP	H
	PUSH	H		(HL) = #FDN.LNK
	LXI	D,FDN.AMW-FDN.LNK
	DAD	D		(HL) = FDN.AMW
	MOV	A,M
	ADD	B
	MOV	M,A
	INX	H
	MOV	A,M
	ACI	0		INCREMENT AMOUNT WRITTEN
	MOV	M,A

*	CLEAR 'IN MEMORY' COUNT IN NODE. IF THE FILE HAS NO MORE TO
*	READ, REMOVE IT FROM THE CHAIN AND NAMTAB

	POP	D		(DE) = FDN.LNK
WPH4	LXI	H,FDN.AIM
	DAD	D
	MVI	M,0		CLEAR AMOUNT IN MEMORY
	XCHG			(HL) = FDN.LNK
	INX	H
	ERRNZ	FDN.STA-FDN.LNK-1
	MOV	A,M		(A) = FDN.STA
	ANI	ST.OPR
	RNZ			STILL READING, AM DONE FOR THIS PHASE

*	UNLINK NODE FROM LIST

	DCX	H
	MOV	A,M
	STA	FDNHEAD		UNLINK FROM ACTIVE LIST
	LDA	FDNFRE
	MOV	M,A		PUT THIS GUY ON HEAD OF FREE LIST
	MOV	A,L
	STA	FDNFRE
	CALL	REN		REMOVE ENTRY FROM NAMTAB
	JMP	WPH		TRY TO WRITE THE NEXT GUY

*	FORCE SOURCE DATE & TIME

WPHX	PUSH	B
	PUSH	D
	PUSH	H

	LXI	D,FDN.DAT-FDN.LNK
	DAD	D
	CALL	ILDEHL
	XCHG
	SHLD	WPH.DAT
	XCHG
	ERRNZ	FDN.TIM-FDN.DAT-2
	CALL	ILDEHL
	XCHG
	SHLD	WPH.TIM

	LHLD	S.CFWA			CHANNEL POINTER -1
	CALL	$HLIHL			CHANNEL POINTER  0
	CALL	$HLIHL			CHANNEL POINTER  1 = CN.DES
	LXI	D,IOC.DIR+DIR.CTH
	DAD	D

	LDA	LABEL+LAB.VER
	CPI	30H
	JC	WPHX.			NO TIME ON PRE 3.0 MEDIA

	LXI	D,*-*
WPH.TIM EQU	*-2
	CALL	ISDEHL			FORCE DEST TIME

WPHX.	LXI	D,DIR.CRD-DIR.CTH-2
	DAD	D
	LXI	D,*-*
WPH.DAT EQU	*-2
	CALL	ISDEHL			FORCE DEST DATE

	POP	H
	POP	D
	POP	B
	RET
CBR	SPACE	4,10
**	CBR - COMPUTE BUFFER ROOM.
*
*	CBR COMPUTES THE NUMBER OF SECTORS WORTH OF RAM
*	STILL FREE.
*
*	ENTRY	NONE
*	EXIT	(A) = SECTORS OF RAM FREE
*		'Z' SET IFF (A)  = 0
*		(H) = BUFPTR/256
*		(L) = OBUFLIM/256
*	USES	A,F

CBR	LHLD	OBUFLIM
	ERRNZ	OBUFPTR-OBUFLIM-1
	MOV	A,L
	SUB	H
	RET
IFL	SPACE	4,10
**	IFL - INITIALIZE FDN LIST.
*
*	IFL CHAINS ALL THE FDN NODES TO THE FREE LIST. THIS
*	CLEANUP IS NECESSARY IN CASE A CTL-C OR SOMETHING
*	LEFT THE LIST GARBAGED.
*
*	ENTRY	NONE
*	EXIT	NONE
*	USES	ALL

IFL	LXI	H,FDN.1
	MOV	A,L		(A) = FIRST LINK
	STA	FDNFRE
	XRA	A
	STA	FDNHEAD		NONE IN LIST
	MVI	B,FDNCNT-1	(B) = NUMBER OF NODES-1
IFL1	MVI	A,FDNELEN
	ADD	L		(A) = #ADDR OF NEXT NODE
	MOV	M,A		SET LINK
	MOV	L,A		FORWARD TO NEXT LINK
	DCR	B
	JNZ	IFL1		MORE TO GO
	MVI	M,0		LAST ONE CHAINS NOWHERE
	RET
MAD	SPACE	4,10
**	MAD - MOUNT ALTERNATE DISK.
*
*	MAD DISMOUNTES THE CURRENT DISK, HAS THE USER INSERT THE
*	OTHER DISK, AND MOUNTS IT.
*
*	ENTRY	(DE) = PROMPT PATTERNS FOR PANEL AND CONSOLE
*	EXIT	(HL) = #VOLFLAG
*	USES	ALL

MAD	EQU	*

*	DISMOUNT CURRENT DISK

	PUSH	D		SAVE ENTRY PARAMETERS IN CASE OF RETRY
	PUSH	D		SAVE ENTRY PARAMETERS OVER SYDD CALL
	LXI	H,MNDA		DEVICE SPECIFICATION
	SCALL	.DMNMS		DISMOUNT WITHOUT MESSAGE
	JC	ERROR		IF ERROR

*	SETUP PROMPT ON FP LEDS AND CONSOLE FOR NEW DISK

MAD0	POP	H		(DE) = PROMPT
	SCALL	.PRINT		CONSOLE PROMPT

	CALL	$TYPTX
	DB	BELL+200Q	BEEP CONSOLE, TOO

*	WAIT FOR SIGNAL THAT NEW DISK IS IN

MAD3	MVI	A,DC.RDY
	CALL	SYDD
	JNC	MAD3		Wait for device to go non-ready

MAD4	MVI	A,DC.RDY
	CALL	SYDD
	JC	MAD4		Wait for device to go ready

*	READ NEW DISK'S LABEL

	CALL	GETLAB
	JC	ERROR

*	SEE IF LABEL CHANGED FROM BEFORE

	MVI	C,0		Compare 256
	LXI	D,SLABEL	DE = address of last label
	LXI	H,LABEL 	HL = Address of current label
	CALL	$COMP		See if the label changed
	POP	D		RESTORE ENTRY PARAMETERS

	LXI	H,VOLSER
	LDA	LABEL+LAB.SER
	JNE	MAD4.5		IS THE RIGHT DISK
	PUSH	D		SAVE PARAMS AS IN BEGINNING
	PUSH	D		SAVE FOR RETRY
	JMP	MAD0		IT WAS NOT THE RIGHT DISK

MAD4.5	MOV	M,A		SET NEW SERIAL
	LXI	H,VOLFLAG
	MOV	A,M
	CMA
	MOV	M,A		COMPLEMENT VOLUME FLAG

	LXI	B,256
	LXI	D,LABEL
	LXI	H,SLABEL
	CALL	$MOVE		Save Current Label

	CALL	MND		MOUNT NEW DISK
	CALL	$TYPTX		Show user that disk is OK
	DB	ENL
	RET
MND	SPACE	4,10
**	MND	- MOUNT NEW DISK
*
*	MOUNT NEW DISK ONTO DEVICE SSECIFIED IN MNDA
*
*
*	ENTRY	NONE
*
*	EXIT	LABEL	= LABEL SECTOR
*
*	USES	ALL
*

MND	LXI	H,MNDA
	SCALL	.MONMS		MOUNT WITHOUT MESSAGE
	JC	ERROR		IF ERROR IN MOUNT
	RET

MNDA	DB	'SY0:',0
GETLAB	SPACE	4,10
**	GETLAB	- GET LABEL
*
*	GETLAB READS THE DISK LABEL
*
*	NOTE:	This routine leaves the volume mounted as
*		zero.
*
*	ENTRY	NONE
*
*	EXIT	LABEL IN LABEL
*		(PSW)	= 'C' CLEAR IF NO ERROR
*			= 'C' SET   IF    ERROR
*			   (A)  = ERROR CODE
*
*	USES	ALL
*

GETLAB	LXI	H,0
	MVI	A,DC.MOU
	CALL	SYDD		Mount the Disk as volume 0
	RC			Some type of problem

	LXI	H,DDF.LAB
	LXI	D,LABEL
	LXI	B,256
	MVI	A,DC.RER
	JMP	SYDD
	STL	'LIST - LIST DIRECTORY CONTENTS'
	EJECT
***	LIST - INDEX DIRECTORY.
*
*	DEST=SOURCE/LIST
*		   /BRIEF
*
*	THESE SWITCHES CAUSE THE DIRECTORY CONTENTS OF THE SPECIFIED FILE(S)
*	TO BE LISTED
*
*	IN /LI FIRM, THE OUTPUT IS:
*
*	NAME	EXT	SIZE	  DATE		FLAGS
*	XXX	.XXX	 NNN	DD-MMM-YY	CWS
*	 .	 .	 .	   .		 .
*	 .	 .	 .	   .		 .
*	 .	 .	 .	   .		 .
*		NNN FILES USING MMM SECTORS, XXX FREE
*
*	IN /BR FORM, ONLY THE NAME AND EXTENSION ARE LISTED,
*	4 ACROSS THE PAGE.
*
*	SPECIAL CONSIDERATIONS:
*
*	A NULL NAME OR EXTENSION IS TAKEN AS '*' (WILDCARD)
*
*	IMPLIMENTATION:
*
*	A FILE LIST OF SOURCE FILES IS BUILT. THE DEVICE DIRECTORY FILE
*	IS THEN READ, AND EACH FILE IN IT IS CHECKED FOR A MATCH
*	AGAINST ANY SOURCE SPECIFICATIONS. ELIGIBLE FILES ARE LISTED.

LIST	LXI	H,0
	JMP	LIST1

BRIEF	LXI	H,1
*	JMP	LIST1

LIST1	SHLD	LSTA		(LSTA) = 0 IF LIST, 1 IF /BRIEF
	ERRNZ	LSTB-LSTA-1	LSTB = FILE COUNT
	LXI	H,0
	SHLD	LSTC		CLEAR SECTORS USED COUNT
	CALL	$MOVEL
	DW	9,S.DATE,LSTG1	SET DATE IN HEADING

*	BUILD LIST OF SPECIFICATIONS

	CALL	BLS		BUILD LIST OF SOURCE SPECS
	JC	ERROR		ERROR IN LIST
	LXI	B,3
	LXI	H,DIRNAM
	CALL	$MOVE		MOVE DEVICE CODE INTO DIRECT.SYS NAME
	LXI	H,DIRNAM+2
	MOV	A,M		SEE IF UNIT NUMBER OMITTED
	ANA	A
	JNZ	LIST1.5		SPECIFIED
	MVI	M,'0'		DONT ALLOW NULL NUMBER

*	GET ADDRESS OF DEVICE'S GRT

LIST1.5	LXI	H,DIRNAM	(HL) = # OF XXX:DIRECT.SYS (XXX = DEVICE)
	LXI	B,LSTD		(BC) = ADDRESS FOR RETURN INFO
	SCALL	.DECODE 	DECODE NAME
	JC	ERROR		UNKNOWN DEVICE
	LDA	LSTD+0
	ANI	DT.DD
	MVI	A,EC.DNS
	JZ	ERROR		NOT DIRECTORY DEVICE
	LHLD	LSTD+17 	(HL) = DEV TBL ADDR

	LXI	D,DEV.UNT
	DAD	D
	LDA	LSTD+3
	CALL	S.GUP		HL = UNIT TABLE POINTER

	CALL	$INDLB
	DW	UNT.SPG
	STA	LSTF		SAVE  SECTORS PER GROUP

	CALL	$INDL
	DW	UNT.GRT
	XCHG
	SHLD	LSTE		SAVE  GRT ADDRESS
	XCHG

*	OPEN DEVICE'S DIRECTORY

	LXI	H,DIRNAM
	MVI	A,CN.DIR
	SCALL	.OPENR
	MVI	A,PEC.DF	DEVICE FORMAT ERROR
	JC	ERROR		CANT OPEN DIRECTORY

*	GENERATE HEADING

	LXI	B,1		(BC) = TEXT COUNT
	LXI	D,LSTG		(DE) = TEXT ADDRESS
	LDA	LSTA
	ANA	A
	JNZ	LIST2		IS SHORT
	MVI	C,LSTGL		PRINT FULL HEADING
LIST2	MOV	A,C
	XCHG			(HL) = LINE ADDRESS
	CALL	$TYPCC		PRINT ON CONSOLE

*	READ DIRECTORY BLOCKS, LOOKING FOR FILE MATCHES

LIST3	LXI	B,512
	CALL	GDWP		DE = DIRECTORY WORKSPACE POINTER
	MVI	A,CN.DIR
	PUSH	D
	SCALL	.READ
	POP	D		DE = DIRECOTRY WORKSPACE
	JC	LIST9		ALL DONE

*	CHECK NEXT ENTRY IN NAMTAB AGAINST DIRECTORY ENTRY.
*	(DE) = DIRECTORY BUFFER POINTER

LIST4	LDAX	D		(A) = FIRST CHARACTER OF NAME
	ANA	A
	JZ	LIST3		END OF THIS BUFFER
	INR	A
	ERRNZ	DF.EMP-377Q
	JZ	LIST7		THIS ENTRY IS EMPTY
	INR	A
	JZ	LIST9		NO MORE ENTRYS IN DIRECTORY
	XCHG
	CALL	CFE		CHECK FILE ELIGIBILITY
	XCHG
	JNE	LIST7		NOT ELIGIBLE
	LXI	H,NAMTAB

LIST5	PUSH	H
	PUSH	D		SAVE ADDRESS OF FILE AND PATTERN
	CALL	CAD		CONVERT ASCII NAMTAB ENTRY TO DIRECTORY FORMAT
	LXI	D,PIO.DIR+DIR.NAM	(DE) = NAMTAB PATTERN
	POP	H
	PUSH	H		(HL) = DIRECTORY PATTERN
	MVI	B,8+3		CHECK FOR MATCH
	CALL	CWM		CHECK FOR WILDCARD MATCH
LIST6	POP	D
	POP	H
	JE	LIST8		GOT FILE TO LIST
	LXI	B,FB.NAML
	DAD	B		ADVANCE PAST ENTRY IN NAMTAB

*	SEE IF AT END OF NAMTAB

	PUSH	D
	XCHG			(DE) = NEW ADDRESS
	LHLD	NAMTLEN
	LXI	B,NAMTAB
	DAD	B		(HL) = LWA+1 OF TABLE
	XCHG
	CALL	$CDEHL		COMPARE
	POP	D
	JNE	LIST5		MORE IN TABLE

*	FILE DOESNT MATCH ANY SELECTED FILE. PASS TO NEXT ONE

LIST7	XCHG			(HL) = DIR BUFFER ADDRESS

	PUSH	H
	CALL	GDWP.		HL = DIRECTORY WORKSPACE PTR.
	CALL	$INDLB		A  = DIR. ENTRY LENGTH
	DW	DIS.ENL
	POP	H

	CALL	$DADA.		ADVANCE
	MOV	A,M
	ANA	A
	XCHG
	JNZ	LIST4		TRY THIS ONE
	JMP	LIST3		READ ANOTHER BLOCK

*	HAVE FILE TO LIST

LIST8	PUSH	D		SAVE DIR POINTER
	LDA	LSTF		(A) = SECTORS PER GROUP THIS DEVICE
	CALL	PFI		PRINT FILE INFO
	POP	D
	LXI	H,LSTB
	INR	M		COUNT FILE
	JMP	LIST7		ADVANCE TO NEXT FILE

*	ALL DONE. CLOSE DIRECTORY FILE

LIST9	MVI	A,CN.DIR
	SCALL	.CLOSE		CLOSE FILE
	LXI	B,1		ASSUME SHOFT FORM, JUST WRITE NL
	LDA	LSTA		(A) = FORM FLAG
	ANA	A
	JNZ	LIST10		IS SHORT, NO TRAILER

*	PRINT SUMMARY:
*
*	NNN FILES, USING XXX SECTORS. YYY FREE

	LDA	LSTB
	MOV	C,A
	MVI	B,0		(BC) = FILE COUNT
	MVI	A,3
	LXI	H,LSTH1
	CALL	$UDDS		FILE COUNT

	LHLD	LSTC
	MOV	B,H
	MOV	C,L		(BC) = SECTOR COUNT
	LXI	H,LSTH2
	MVI	A,5
	CALL	$UDDN		USED COUNT

	LHLD	LSTE
	MOV	A,M
	CALL	CFS		FOLLOW GRT CHAIN
	LDA	LSTF
	CALL	$MU86		(HL) = SECTORS FREE
	MOV	B,H
	MOV	C,L
	LXI	H,LSTH3
	MVI	A,5
	CALL	$UDDN		UNPACK FREE

	LXI	B,LSTHL
LIST10	LXI	D,LSTH
	LDA	SUPRES
	ANA	A
	RNZ			NOT TO SUMMARYIZE
	MOV	A,C		(A) = COUNT
	XCHG			(HL) = ADDRESS
	JMP	$TYPCC		TYPE TEXT AND EXIT

LSTA	DB	0		<>0 IF SHORT FORM

LSTB	DB	0		FILE COUNT
LSTC	DW	0		SECTORS USED
LSTD	DC	24,#0		FILE NAME DECODE AREA
LSTE	DW	0		GRT ADDRESS
LSTF	DB	0		SECTORS PER GROUP FOR THIS DEVICE
LSTG	DB	NL,'Name',TAB,'.Ext',32,32,'Size',32,32,32,'Created'
	DB	32,32,32,32,'Time',32,32,32,'Flags---',TAB,TAB,'Date:',32
LSTG1	DATE
	DB	NL,NL
LSTGL	EQU	*-LSTG

LSTH	DB	NL		FIRST CHARACTER MUST BE <NL>
LSTH1	DB	'NNN Files, Using '
LSTH2	DB	'MMMMM Sectors ('
LSTH3	DB	'XXXXX Free)',NL
LSTHL	EQU	*-LSTH
BLS	SPACE	4,10
**	BLS - BUILD LIST OF SOURCE FILES.
*
*	BLS BUILDS A LIST OF SOURCE FILES INTO *NAMTAB*
*	NULL FIELDS ARE SET TO WILDCARDS. BLS REQUIRES THAT ALL
*	FILES SPECIFIED HAVE THE SAME DEVICE.
*
*	IF THE COMMAND LINE CONTAINS NO FILES, BUT CONTAINS AT LEAST
*	ONE BLANK (AS WOULD BE THE CASE IN PROCESSING THE /LIST SWITCH, SINCE
*	THE '/LIST' IS REPLACED WITH BLANKS) A FILE NAME OF ????????.???
*	IS DECODED.
*	ENTRY	NAMTAB EMPTY
*	EXIT	'C' CLEAR IF OK
*		(DE) = #BLSA = 3 CHARACTER DEVICE NAME
*		'C' SET IF ERROR
*		 (A) = ERROR MESSAGE
*	USES	ALL

BLS	CALL	$MOVEL
	DW	3,BLSC,BLSA	SET INITIAL DEFAULT DEVICE
	LXI	H,0
	SHLD	NAMTLEN		CLEAR NAMTAB
	MVI	A,377Q
	STA	BLSB		FLAG PROCESSING OF FIRST FILE NAME
	CALL	LSN		LOCATE SOURCE NAMES

*	CRACK THE NEXT NAME

BLS1	MOV	A,M
	LXI	D,BLSA		(DE) = DEFAULT ADDRESS
	ANA	A
	RZ			NO MORE NAMES
	CALL	$SOB		SEE IF ALL NULL
	MOV	A,M
	ANA	A
	JNZ	BLS2		NOT ALL NULL
	LXI	H,BLSC		USE DEFAULT DEVICE
BLS2	CALL	CAD.		CONVERT ASCII NAME TO DIRECTORY FORMAT
	RC			ERROR

*	IF FIRST NAME, RECORD DEVICE
*	IF NOT FIRST, COMPARE DEVICE AGAINST FIRST DEVICE

	PUSH	H
	LXI	D,PIO.DEV
	LXI	H,BLSA
	LXI	B,3		SETUP COUNT, FROM AND TO

BLS3	CALL	$COMP		SEE IF THIS DEVICE SAME AS PREVIOUS
	JE	BLS4		OK
	MVI	A,PEC.DNC	MULTIPLE DEVICES ARE ILLEGAL
	STC
	POP	H
	RET			RETURN WITH ERROR

*	GOT NAME DECODED. ENTER IN NAMTAB

BLS4	CALL	AEN		ADD ENTRY TO NAMTAB
	POP	H
	CALL	SFS		SKIP FILE SEPERATOR (BLANKS AND/OR COMMA)
	JMP	BLS1		SEE IF MORE

BLSA	DB	'SY0',200Q,200Q,200Q
BLSB	DB	0		FIRST FILE NAME FLAG
BLSC	DB	'SY0:',0		DEFAULT DEVICE
PFI	SPACE	4,10
**	PFI - PRINT FILE INFO.
*
*	PFI DECODES A DIRECTORY ENTRY INTO A CODED LINE, THEN
*	WRITES IT TO 'DESTFB'.
*
*	THE PRODUCED FORMAT DEPENDS UPON THE LISTING FORMAT FLAG,
*	LSTA.
*
*	SHORT FORM:
*
*	NAME	.EXT	(TAB)
*
*	LONG FORM:
*
*	NAME	.EXT	SIZE	DATE	TIME	FLAGS	(NL)
*
*	ENTRY	(A) = SECTORS PER GROUP FOR THIS DEVICE
*		(DE) = DIRECTORY ENTRY POINTER
*	EXIT	IF LONG FORM, SECTOR COUNT IS ACCUMULATED IN LSTC
*	USES	ALL

PFI	STA	PFIC		SAVE SECTORS PER GROUP
	LXI	H,PFIA
	MVI	C,8
	CALL	PFI20		COPY NAME
	JZ	PFI1		ALL 8 CHARACTERS
	MVI	M,TAB
	INX	H
PFI1	MVI	M,'.'
	INX	H
	MVI	C,3
	CALL	PFI20		COPY EXTENSION
	LDA	LSTA
	ANA	A
	JNZ	PFI1.2		/B
	INR	C		+ 1 SPACE
PFI1.1	CALL	PFI41
	DCR	C
	JNZ	PFI1.1
	JMP	PFI3

*	IS SHORT FORM. SEE IF NEED TO END LINE

PFI1.2	MVI	M,TAB
	INX	H
	INR	A
	CPI	5
	JNE	PFI2		NOT TIME YET
	DCX	H
	MVI	M,NL
	INX	H		TIME TO END LINE
	MVI	A,1
PFI2	STA	LSTA		RESET COUNT
	JMP	PFI6		OUTPUT TO FILE

*	IS LONG FORM, DECODE FILE SIZE

PFI3	LXI	B,DIR.FGN-DIR.EXT-3
	XCHG			(DE) = LINE ADDR, (HL) = #PIO.DIR+DIR.EXT+3
	DAD	B		(HL) = #DIR.FGN
	MOV	A,M		(A) = (DIR.FGN)
	INX	H
	INX	H
	MOV	C,M		(C) = DIR.LSI = SECTORS USED IN LAST GROUP
	ERRNZ	DIR.LSI-DIR.FGN-2
	XCHG			(DE) = ADDRESS OF LSI
	PUSH	D		SAVE #DIR.LSI
	PUSH	H		SAVE LINE ADDRESS
	LHLD	LSTE
	MOV	L,A
	MOV	A,M
	CALL	CFS		COMPUTE FILE ISZE
	LDA	PFIC		(A) = SECTORS PER GROUP
	MOV	B,A
	CALL	$MU86	(HL) = SECTORS USED (EXCEPT FOR THOSE IN LAST GROUP)

	LDA	ALLOCA
	ANA	A
	JZ	PFI3.5
	MOV	C,B		Use Group Size instead if /ALL
PFI3.5	EQU	*

	MVI	B,0
	DAD	B		(HL) = SECTORS USED
	MOV	B,H
	MOV	C,L		(BC) = SECTORS USED COUNT
	LHLD	LSTC
	DAD	B
	SHLD	LSTC		ACCUMULATE COUNT OF SECTORS
	POP	H		(HL) = LINE ADDRESS
	MVI	A,5		5 DIGITS MAX
	CALL	$UDDS		UNPACK COUNT
	CALL	PFI42
	POP	D		(DE) = #DIR.LSI

*	TYPE CREATION DATE

	XCHG
	ERRNZ	DIR.CRD-DIR.LSI-1
	INX	H		(HL) = #DIR.CRD
	PUSH	H
	CALL	$HLIHL
	XCHG
	CALL	$DAD		DECODE AUGUSTAN DATE

*	DECODE TIME

	CALL	PFI42
	XCHG
	POP	H		(HL) = #DIR.CRD
	PUSH	H
	LXI	B,DIR.CTH-DIR.CRD
	DAD	B
	XCHG			(DE) => HOURS BYTE IN BCD, (HL) = LINE

	LDAX	D		If hours set to 377Q
	CPI	377Q		  then don't show time
	JE	PFI.NT

	CALL	PFI50		DECODE BCD
	PUSH	D		HOURS
	PUSH	H		LINE
	DCX	H
	DCX	H
	PUSH	H		LINE-2

	LXI	H,T.AP		SET AM OR PM
	LDAX	D
	STA	PFIT
	CPI	12H
	JNC	T.PM
T.AM	MVI	M,'a'
	JMP	T.0

T.PM	MVI	M,'p'
	SUI	12H
	DAA
	STA	PFIT
	LXI	D,PFIT
	POP	H		LINE-2
	PUSH	H		LINE-2
	CALL	PFI50		DECODE ADJUSTED HOURS

T.0	LDA	PFIT		IF HOUR = '00' THEN MAKE IT '12'
	POP	H		LINE-2
	ANA	A
	JNZ	T.1
	MVI	M,'1'
	INX	H
	MVI	M,'2'
	DCX	H
T.1	MVI	A,'0'		IF FIRST CHAR IS '0' REPLACE WITH ' '
	CMP	M
	JNE	T.2
	MVI	M,' '
T.2	POP	H		LINE
	POP	D		HOURS
	MVI	M,':'
	INX	H
	INX	D
	ERRNZ	DIR.CTM-DIR.CTH-1
	CALL	PFI50		DECODE BCD
	MVI	M,'z'		SET AM OR PM
T.AP	EQU	*-1
	INX	H
	JMP	PFI.F

PFI.NT	CALL	PFI43
	CALL	PFI43

PFI.F	CALL	PFI42

*	DECODE FLAGS

	XCHG			(DE) = LINE ADDRESS
	POP	H		(HL) = #DIR.CRD
	LXI	B,DIR.FLG-DIR.CRD
	DAD	B		(HL) = ADDRESS OF DIRFLG
	MOV	A,M		(A) = FLAGS
	XCHG			(HL) = LINE ADDRESS
	ANA	A
	JZ	PFI5		NO FLAGS

	LXI	D,PFIB
	MVI	C,8
PFI31	ADD	A
	PUSH	PSW
	LDAX	D
	JC	PFI32
	MVI	A,' '
PFI32	MOV	M,A
	INX	H
	INX	D
	POP	PSW
	DCR	C
	JNZ	PFI31

PFI5	MVI	M,NL
	INX	H

*	LINE ALL BUILT. WRITE TO DESTFB

PFI6	LXI	D,-PFIA
	DAD	D
	MOV	A,L		(A) = COUNT
	LXI	H,PFIA
	JMP	$TYPCC		TYPE LINE AND EXIT
PFI20	SPACE	3,10
**	PFI20 - COPY FILE NAME.
*
*	PFI20 COPIES A NAME FILED FROM THE DIRECTORY ENTRY TO A CODED
*	LINE
*
*	EENTRY	(DE) = DIRECTORY ADDRESS
*		(C) = NAME LENGTH
*		(HL) = LINE ADDRESS
*	EXIT	(DE) = (DE) + (C)
*		'Z' SET IF MAX CHARACTERS COPIED
*	USES	A,F,C,D,E,H,L

PFI19	MOV	M,A		COPY
	INX	H
	INX	D
	DCR	C
	RZ			ALL COPIED
PFI20	LDAX	D
	ANA	A
	JNZ	PFI19		GOT CHAR

*	NO NAME. (C) = COUNT LEFT

	MOV	A,E
	ADD	C
	MOV	E,A
	MOV	A,D
	ACI	0
	MOV	D,A
	ORA	E		CLEAR 'Z'
	RET

*	PUT SPACES IN CODED LINE

PFI43	MVI	M,' '
	INX	H
PFI42	MVI	M,' '
	INX	H
PFI41	MVI	M,' '
	INX	H
	RET

*	DECODE BCD BYTE

PFI50	LDAX	D		GET BYTE
	ANI	0F0H		MASK OFF HI DIGIT
	RRC			ROTATE
	RRC
	RRC
	RRC
	ADI	'0'		MAKE ASCII
	MOV	M,A		STUFF IT
	INX	H
	LDAX	D		GET BYTE
	ANI	0FH		MASK OFF LOW DIGIT
	ADI	'0'		MAKE ASCII
	MOV	M,A		STUFF IT
	INX	H
	RET

PFIA	DS	0		BUFFER AREA FOR LINE BUILD
	DB	'FILENAME.EXT.NNNNN..DD-MMM-YY..HH:MMz..SLWCABDU',0
PFIB	DB	'SLWCABDU'	CODES
	ERRNZ	DIF.SYS-200Q
	ERRNZ	DIF.LOC-100Q
	ERRNZ	DIF.WP-40Q
	ERRNZ	DIF.CNT-20Q
	ERRNZ	DIF.ARC-10Q
	ERRNZ	DIF.BAD-4
	ERRNZ	DIF.DL-2
	ERRNZ	DIF.USR-1

PFIC	DB	0		SECTORS PER GROUP FOR THIS DEVICE
PFIT	DB	0		TEMP TIME BYTE
	STL	'VERSN	- ONECOPY VERSION INFORMATION'
	EJECT
***	VERSN	- PIP VERSION INFORMATION
*
*	/V[ERSION]
*	/ID
*
*	PRINT THE ONECOPY VERSION INFORMATION

VERSN	EQU	*

	CALL	CTS		CHECK FOR TARGET FILE SPECIFICATION
	STC
	JNZ	ERROR		TARGET FILE SPECIFICATION ILLEGAL
	LXI	H,LINE
	CALL	$SOB		SKIP OVER ALL THE BLANKS ($DRS TURNS SWITCHES
	MOV	A,M		 TO BLANKS)
	ANA	A
	MVI	A,PEC.SFI	SOURCE FILE ILLEGAL
	STC
	JNZ	ERROR		ONLY ALLOW SWITCH ON LINE
	CALL	$TYPTX
	DB	NL,'ONECOPY',TAB,'Version: '
	DB	VERS/16+'0','.',VERS&00001111B+'0'
	DB	' as of '
	DATE
	DB	ENL

	RET

*	/ID Entry Point

ID	CALL	VERSN			; Show version info
	LXI	B,OCFWA
	LXI	H,VERSV0
	CALL	$UOW.
	LXI	B,MEML-1
	LXI	H,VERSV1
	CALL	$UOW.
	LHLD	BUFPTR
	MOV	B,H
	MOV	C,L
	LXI	H,VERSV2
	CALL	$UOW.
	CALL	EBM
	LHLD	BUFPTR
	LXI	D,377Q		ROUND UP
	DAD	D
	LDA	OBUFLIM 	LAST SECTOR NUMBER
	SUB	H		MINUS BUFFER SECTOR
	MVI	B,0
	MOV	C,A
	MVI	A,3
	LXI	H,VERSV3
	CALL	$UDDN

	CALL	$TYPTX
	DB	'FWA = '
VERSV0	DB	'000.000',TAB,'LWA = '
VERSV1	DB	'000.000',TAB,'Buffer = '
VERSV2	DB	'000.000','   Size = '
VERSV3	DB	'nnn sectors',ENL
	JMP	SBE			; shrink buffer and return
	STL	'ERROR PROCESSING'
	EJECT
**	ERROR PROCESSING ROUTINES
*
	SPACE	3,10
***	NAMERR - FILE TYPE ERROR, OCCURRED ON FILE WHOSE NAME
*	IS NEXT UP IN NAMTAB.
*
*	PROCESS VIA $FERROR

NAMERR	LHLD	NAMTPTR
	LXI	B,-FB.NAM
	DAD	B
	JMP	$FERROR
DESTERR	SPACE	4,10
**	ERROR ON FILE IN DESTFB

DESTERR LXI	H,DESTFB
	JMP	$FERROR
INTERR	SPACE	4,10
**	INTERNAL ERRORS. SHOULD NOT OCCUR.

IERR1	MVI	A,'1'

	DB	21H		FAKE LXI H,

IERR2	MVI	A,'2'

	DB	21H		FAKE LXI H,

IERR3	MVI	A,'3'

	STA	IERRN		SAVE CODE

	CALL	$TYPTX
	DB	BELL,NL,'ONECOPY INTERNAL ERROR #'
IERRN	DB	'n',ENL

	MVI	A,1
	SCALL	.EXIT		ABORT
ERROR	SPACE	4,10
**	ERROR - GENERAL AND SYNTAX ERRORS NOT DIRECTLY ASSOCIATED
*	WITH A VALID FILE NAME.

ERROR	PUSH	PSW		SAVE CODE
	CALL	$TYPTX
	DB	BELL,'ERROR -',' '+200Q
	POP	PSW
	ANA	A
	JM	ERROR1		IS PRODUCT ERROR
	MVI	H,NL		USE NL AS MESSAGE TRAIL CHAR
	SCALL	.ERROR		LOOK UP SYSTEM ERROR
	JMP	RESTART

*	IS PRODUCT ERROR

ERROR1	LXI	H,ERRORA
ERROR2	CMP	M
	INX	H
	JNE	ERROR2		FIND ERROR MESSAGE
	CALL	$TYPTX
	DB	BELL,'ONECOPY Error #',' '+200Q
	SCALL	.PRINT		PRINT MESSAGE
	JMP	RESTART

ERRORA	DS	0		ERROR MESSAGES
	DB	PEC.DF,'01',ENL
	DB	PEC.DNC,'02',ENL
	DB	PEC.TFI,'03',ENL
	DB	PEC.CS,'04',ENL
	DB	PEC.IUW,'05',ENL
	DB	PEC.IDF,'06',ENL
	DB	PEC.SFI,'07',ENL
	DB	PEC.FCI,'08',ENL
	STL	'SUBROUTINES'
	EJECT
AEN	SPACE	4,10
**	AEN - ADD ENTRY TO 'NAMTAB'
*
*	AEN EXPANDS THE FILE INFO IN PIO.XXX INTO A FILE DESCRIPTOR
*	AND ENTERS IT IN THE NAMTAB TABLE.
*
*	ENTRY	NONE
*	EXIT	'C' SET IF WILDCARD
*	USES	ALL

AEN	LXI	H,AENA
	CALL	CDA		CONVERT DIRECTORY FORMAT TO ASCII FORMAT
	SUI	1		'C' SET IF WILDCARD
	PUSH	PSW		SAVE FLAG
	JC	AEN1		Ignore Query for wild card names
	CALL	CQF		Check Query Flag
	JNZ	AEN2		Don't copy this file
AEN1	LHLD	NAMTLEN
	LXI	B,FB.NAML
	DAD	B		INCREASE SIZE
	SHLD	NAMTLEN
	XCHG			(DE) = NEW LENGTH
	LHLD	NAMTMAX
	MOV	A,L		SEE IF WILL OVERFLOW
	SUB	E
	MOV	A,H
	SBB	D
	CC	INA		INCREASE NAMTAB ALLOCATION
	LXI	H,NAMTAB-FB.NAML
	DAD	D		(HL) = *TO* ADDRESS
	LXI	D,AENA		(DE) = *FROM* ADDRESS
	CALL	$MOVE		MOVE ENTRY IN
AEN2	POP	PSW		(PSW) = WILDCARD FLAG
	RET

AENA	DC	FB.NAML,#0
BSL	SPACE	4,10
**	BSL - BUILD SOURCE FILE LIST.
*
*	BSL CRACKS THE LIST OF THE SOURCE FILES FROM THE COMMAND LINE AND
*	BUILDS THEM INTO THE NAMTAB MANAGED TABLE.
*	WILD CARDS ENCOUNTERED ARE EXPANDED.
*
*	ENTRY	(A) <> 0 IF TO ASK ABOUT '*.*' USE
*	EXIT	'C' CLEAR IF OK
*		'C' SET IF ERROR
*		 (A) = CODE
*	USES	ALL

BSL	STA	BSLA		SAVE ASK FLAG
	CALL	LSN		LOCATE SOURCE NAME

*	GO THROUGH SOURCE LIST CRACKING NAMES

BSL1	MOV	A,M
	ANA	A
	RZ			ALL DONE
	LXI	D,DEFALT
	CALL	CAD		CONVERT ASCII NAME TO DIRECTORY FORMAT
	RC			ERROR
	CALL	SND		SET NEW DEFAULTS
	PUSH	H		SAVE LINE ADDRESS
	LDA	BSLA
	ANA	A
	CNZ	CCW		CHECK FOR COMPLETE WILDCARD (*.*)
	JC	RESTART 	USER CHICKENED OUT
	CALL	EWS		EXPAND WILDCARD SPECIFICATION
BSL2	POP	H		RESTORE LINE ADDRESS
	RC			USER REFUSED *.*
	CALL	SFS		SKIP FILE SEPERATOR (BLANKS AND/OR COMMA)
	JMP	BSL1		DO MORE

BSLA	DB	0		<>0 IF TO CHECK FOR *.*
CCW	SPACE	4,10
**	CCW - CHECK FOR COMPLETE WILDCARD.
*
*	CCW IS CALLED WITH A NAME CRACKED INTO PIO.XXX, TO SEE IF
*	IT IS A *.* SPECIFICATION.
*
*	IF SO, CCW ASKS,
*
*	DELETE ALL FILES ON DEV: ?!? (Y/N)
*
*	THE USER REPLY IS ACCEPTED AND DECODED.
*
*	ENTRY	NONE
*	EXIT	'C' CLEAR IF NOT *.*, OR 'Y' REPLIED
*		'C' SET IF *.* AND NOT 'Y'
*	USES	A,F,B,H,L

CCW	LXI	H,PIO.DIR+DIR.NAM
	RET			FORGET IT
CFE	SPACE	4,10
**	CFE - CHECK FILE ELIGIBILITY.
*
*	CFE CHECKS TO SEE IF A WILDCARD-SELECTED FILE IS ELIGIBLE
*	FOR PROCESSING. IF THE FILE IS FLAGGED SYSTEM, AND /S IS NOT
*	SPECIFIED, THE FILE IS NOT ELIGIBLE.
*
*	ENTRY	(HL) = DIRECTORY ENTRY POINTER
*	EXIT	'Z' SET IF ELIGIBLE
*	USES	A,F

CFE	PUSH	H
	MVI	A,DIR.FLG
	CALL	$DADA.
	MOV	A,M		(A) = FLAG
	ANI	DIF.SYS
	POP	H
	RZ			ELIGIBLE
	LDA	SYSTEM		CHECK /S FLAG
	ANA	A	
	RET
CFS	SPACE	4,10
**	CFS - COMPUTE FILE SIZE
*
*	CFS COMPUTES THE SIZE OF A FILE. THE DEVICE'S GRT MUST BE IN
*	THE 'GRT' BUFFER.
*
*	ENTRY	(A) = FIRST GROUP NUMBER
*	EXIT	(DE) = SIZE
*	USES	ALL

CFS	LHLD	LSTE
CFS.	LXI	D,0
CFS1	ANA	A
	RZ			ALL DONE
	MOV	L,A
	MOV	A,M		(A) = NEXT GRT
	INX	D
	JMP	CFS1		TRY AGAIN
CTS	SPACE	4,10
**	CTS	-  CHECK TARGET FILE SPECIFICATION
*
*	CTS CHECKS FOR A TARGET FILE SPECIFICATION
*
*
*	ENTRY	NONE
*
*	EXIT	(PSW)	= 'Z' SET IF NO TARGET FILE
*			= 'Z' CLEAR IF    TARGET FILE
*			   (A)  = PEC.TFI ERROR CODE
*
*	USES	(PSW),(HL)

CTS	CALL	LSN		(HL) = ADDRESS OF FIRST SOURCE NAME
	LXI	D,-LINE
	DAD	D		(HL) == 0 IF NO '=' IN COMMAND LINE
	MOV	A,L
	ORA	H
	RZ			NO TARGET FILE
	MVI	A,PEC.TFI	TARGET FILE ILLEGAL
	RET			TARGET FILE SPECIFIED
CWM	SPACE	4,10
**	CWM - CHECK WILDCARD MATCH.
*
*	CWM CHECKS TO SEE IF A WILDCARDED FIELD MATCHES A NON-WILDCARDED
*	FIELD.
*
*	ENTRY	(DE) = ADDRESS OF WC NAME
*		(HL) = ADDRESS OF NON/WC NAME
*		(B) = NUMBER OF CHARACTERS TO CHECK
*	EXIT	'Z' SET IF MATCH
*		 (HL) = (HL)+(B)
*		 (DE) = (DE) = (B)
*		'Z' CLEAR IF NO MATCH
*	USES	A,F,B,D,E,H,L

CWM	LDAX	D
	ANA	A
	JM	CWM1		IS MATCH
	CMP	M
	RNE			NO MATCH
CWM1	INX	D
	INX	H		ADVANCE ADDRESSES
	DCR	B
	JNZ	CWM		GO FOR MORE
	RET			GOT MATCH
DDF	SPACE	4,10
**	DDF - DECODE DESTINATION FILE.
*
*	DDF DECODES THE DESTINATION FILE NAME FROM THE COMMAND LINE.
*
*	IF NO DESTINATION NAME IS SPECIFIED, IT DEFAULTS TO
*
*	KB:PIPDEST.JGL
*
*	ENTRY	NONE
*	EXIT	'C' CLEAR IF OK
*		 (A) = 0 IF NAME HAS WILDCARDS
*		 (A) = 1 IF NO WILDCARD USED
*		 DESTFB+FB.NAM CONTAINS A COMPLETE DESTINATION FILE NAME
*		 (HL) = COMMAND LINE POINTER UDPATED
*		'C' SET IF ERROR
*		 (A) = CODE
*	USES	ALL

DDF	LXI	D,LINE
	MOV	H,D
	MOV	L,E		(HL) = COMMAND POINTER
DDF1	LDAX	D
	INX	D
	CPI	'='
	JE	DDF2		HAVE A SOURCE FILE
	ANA	A
	JNZ	DDF1		MORE TO CHECK
DDF1.0	LXI	H,DDFA		USE DEFAULT

*	(HL) = ADDRESS FOR NAME

DDF2	LXI	D,DEFALT
	CALL	CAD		CONVERT ASCII NAME TO DIRECTORY FORMAT
	RC			ERROR
	JZ	DDF1.0		NO FILE NAME SPECIFIED, USE DEFAULT
	MOV	A,M
	CPI	'='
	MVI	A,PEC.IDF	ASSUME ILLEGAL DESTINATION FORMAT
	STC
	RNE			MUST HAVE '='

*	HAVE NAME DECODED. EXPAND INTO DESTFB+FB.NAM

	LXI	H,DESTFB+FB.NAM
	CALL	CDA		CONVERT DIRECTORY FORMAT TO ASCII FORMAT
	PUSH	PSW		SAVE CODE
	MVI	C,3
	LXI	D,DDFB
	LXI	H,DESTFB+FB.NAM
	CALL	$COMP		SEE IF DEVICE IS SY0
	JNE	DDF3		IS ERROR
	POP	PSW
	RET			RETURN WITH 'C' CLEAR

DDF3	POP	PSW		ERROR, ILLEGAL DEVICE CODE
	MVI	A,EC.DNS
	STC
	RET

DDFA	DB	'SY0:*.*=',0	DEFAULT TARGET FOR ONECOPY
DDFB	DB	'SY0'		REQUIRED DEVICE SPECIFICATION FOR ONECOPY
CAD	SPACE	4,10
**	CAD - CONVERT ASCII FILE NAME INTO DIRECTORY FORMAT.
*
*	CAD CRACKS AN ALPHANUMERIC FILE DESCRIPTION, OF THE FORM
*
*	DEV:NAME.EXT
*
*	INTO THE PIO.XXX FIELDS.
*
*	THE DEFAULT BLOCK DETERMINES THE VALUES FOR THE DEVICE AND EXTENSION
*	FIELDS, IF THEY ARE UNSPECIFIED. IF *CAD* IS ENTERED
*	AT *CAD*, AN UNSPECIFIED NAME FIELD IS RETURNED AS ZERO BYTES.
*	IF ENTERED AT *CAD.*, AN UNSPECIFIED NAME FIELD IS
*	RETURNED AS 200Q (MATCH-ONE) BYTES.
*
*	ENTRY	(DE) = POINT TO DEFAULT BLOCK
*		(HL) = POINTER TO TEXT
*	EXIT	'C' SET IF ERROR
*		 (A) = ERROR CODE
*		'C' CLEAR IF OK
*		 (HL) = POINTS PAST FILE NAME
*		 'Z' SET IF NULL NAME
*		 'Z' CLEAR IF NON-NULL
*		  PIO.DIR.NAM = NAME
*		  PIO.DIR.EXT = EXTENSION
*		  PIO.DEV = DEVICE CODE
*		  PIO.UNI = UNIT NUMBER (ASCII DIGIT)
*	USES	ALL

CAD	XRA	A		SET TO NULLS
	JMP	CAD0

CAD.	MVI	A,200Q
CAD0	PUSH	H
	STA	CADA		SAVE DEFAULT VALUE

*	SET DEFAULTS IN PIO.xxx

	LXI	H,PIO.DEV
	LXI	B,3
	CALL	$MOVE		SET DEFALUT DEVICE
	LXI	B,3
	LXI	H,PIO.DIR+DIR.EXT
	CALL	$MOVE		SET DEFAULT EXTENSION
	POP	H
	CALL	$SOB		SKIP BLANKS
	MVI	B,0
	CPI	'?'
	JE	CAD1		IS '?'
	CPI	'*'
	JE	CAD1		IS '*'
	CPI	'.'
	JE	CAD1		IS '.'
	CPI	'A'
	JC	CAD4		NOT NAME
	CPI	'Z'+1
	JNC	CAD4		NOT NAME

*	HAVE ALPHA STRING. CRACK IT

CAD1	CALL	DNT		DECODE NEXT TOKEN
	JC	CAD5		ERROR
	CPI	':'
	JNE	CAD2		NOT DEVICE

*	HAVE EXPLICIT DEVICE

	INX	H		SKIP ':'
	MVI	A,3
	CMP	C
	JC	CAD5		TOO MANY CHARACTERS
	MVI	A,PIO.UNI-PIO.DEV-1
	CMP	C
	JNC	CAD5		Too Few characters

	MVI	A,'0'
	STA	PIO.UNI 	Assume Unit 0
	MVI	B,0		BC = Move Count
	PUSH	H		SAVE (HL)
	LXI	H,PIO.DEV
	CALL	$MOVE		SET EXPLICIT DEVICE
	POP	H
	CALL	DNT		DECODE NEXT TOKEN
	JC	CAD5		ERROR

*	DECODE NAME

CAD2	LXI	B,8		(BC) = COUNT
	PUSH	H		SAVE TEXT ADDR

*	SEE IF NAME IS  UNSPECIFIED

	LXI	H,PIO.DIR+DIR.NAM
	PUSH	H		SAVE ADDRESS OF DIR.NAM
	CALL	$MOVE		MOVE IN NAME
	POP	H		(HL) = #PIO.DIR+DIR.NAM
	MOV	A,M
	ANA	A
	JNZ	CAD2.6		IS SPECIFIED
	LDA	CADA		(A) = FILL CHARACTER
	MVI	C,8		(C) = COUNT
CAD2.4	MOV	M,A
	INX	H
	DCR	C
	JNZ	CAD2.4
CAD2.6	POP	H
	MOV	A,M		(A) = DELIMITER
	CPI	'.'
	JNE	CAD3		NOT EXTENSION

*	HAVE EXPLICIT EXTENSION

	INX	H
	CALL	DNT
	JC	CAD5		ERROR
	MVI	A,3
	CMP	C
	JC	CAD5		TOO LONG
	LXI	B,3
	PUSH	H		SAVE TEXT POINTER
	LXI	H,PIO.DIR+DIR.EXT
	CALL	$MOVE		MOVE EXTENSION
	POP	H

*	DONE WITH NAME. MUST HAVE LEGIT DELIMITER

CAD3	MVI	B,1		(B) = NAME PRESENT FLAG

*	END OF NAME. EXIT
*	(B) = 0 IF NULL, (B) <> 0 IF NON-NULL

CAD4	CALL	$SOB		SKIP BLANKS
	MOV	A,M		(A) = NEXT CHARACTER
	CALL	$CFD		CHECK FILE NAME DELIMITER
	RC			ERROR
	MOV	A,B
	ANA	A		SET 'Z' IF NULL
	RET

*	ERROR

CAD5	MVI	A,EC.IFN	ILLEGAL FILE NAME
	STC
	RET

CADA	DB	0		FILL CHARACTER FOR OMITTED NAME FIELD
CQF	SPACE	4,10
**	CQF - Check Query Flag
*
*	CQF checks the query flag, and if it is set, asks
*	the user if the file is to be transfered by typing
*	the filename followed by a question mark.  If the
*	response begins with a 'Y' the file is transfered,
*	else, it is to be ignored.
*
*	ENTRY:	PIO.XXX = File Specification
*
*	EXIT:	PSW	= 'Z'  if     to Copy
*			  'NZ' if NOT to Copy
*
*	USES:	ALL

CQF	LDA	QUERY
	ANA	A
	RZ			NO Query, so transfer file
	CPI	'N'
	JE	CQFN

	CALL	CQF.
	PUSH	PSW
	CALL	$CRLF
	POP	PSW
	RET

CQF.	CALL	TFNS		Type the file name padded with spaces
	CALL	$TYPTX
	DB	' ?',' '+200Q
	SCALL	.CLRCO		Clear the console

	XRA	A		A = I.CSLMD
	MVI	B,CSL.CHR
	MVI	C,CSL.ECH+CSL.CHR
	SCALL	.CONSL		Set CHAR/ECHO

CQFX	SCALL	.SCIN
	JC	CQFX
	CALL	$MCU
	CPI	'Y'
	RE			Transfer this file
	CPI	'N'
	JE	CQFN
	CPI	'*'		Special marker ?
	JNE	CQF1		Oops
CQFX.	SCALL	.SCIN		Yes, get Y or N
	JC	CQFX.
	CALL	$MCU
	CPI	'Y'
	JE	CQFY
	CPI	'N'
	JNE	CQF1
	STA	QUERY		Don't transfer any of the rest either
CQFN	ORI	1		'NZ' => DON'T transfer this file
	RET

CQFY	XRA	A		Set 'Z'
	STA	QUERY		Transfer all of the rest also
	RET

CQF1	CALL	$TYPTX		Illegal Character Entered
	DB	BELL,'? (Y)es (N)o (*Y) (*N)',ENL
	JMP	CQF.
DNT	SPACE	4,10
**	DNT - DECODE NEXT TOKEN.
*
*	DNT COPIES THE NEXT ALPHANUMERIC FIELD INTO A ZERO-FILLED WORK AREA.
*
*	ENTRY	(HL) = TEXT POINTER
*	EXIT	'C' SET IF ERROR
*		'C' CLEAR IF OK
*		(A) = DELIMTER CHARACTER
*		(HL) UPDATED TO DELIMITER CHARACTER
*		(DNTA) = STRING
*		(C) = LENGTH
*		(DE) = #DNTA
*	USES	ALL

DNT	LXI	D,DNTA
	MVI	C,9		(C) = SIZE OF DNTA
	MOV	B,C		(B) = MAX ALLOWED +1
	XRA	A
DNT1	STAX	D		ZERO BUFFER
	INX	D
	DCR	C
	JNZ	DNT1
	LXI	D,DNTA

*	COPY CHARACTERS

DNT2	MOV	A,M
	CPI	'?'
	MVI	A,200Q
	JE	DNT3		IS MATCHONE
	MOV	A,M
	CPI	'*'
	JE	DNT5		IS WILDCARD
	CPI	'0'
	JC	DNT4		NOT ALPHANUMERIC
	CPI	'9'+1
	JC	DNT3		NUMERIC
	CPI	'A'
	JC	DNT4		DELIMITER
	CPI	'Z'+1
	JNC	DNT4		DELIMITER

*	HAVE GOOD CHARACTER

DNT3	STAX	D		STORE CHAR
	INX	D
	INX	H
	INR	C		COUNT
	DCR	B		LIMIT DECREMENT
	JNZ	DNT2		NOT OVERFLOW

*	OVERFLOW

	STC			FLAG ERR
	RET

*	IS '*' WILDCARD

DNT5	MVI	A,200Q
	STAX	D
	INX	D
	DCR	B
	JNZ	DNT5		FILL WITH MATCH ONE
	INX	H		SKIP '*'

*	END OF STRING

DNT4	ANA	A		CLEAR 'C'
	LXI	D,DNTA		SET POINTER
	RET

DNTA	DATE			WORK AREA
EBM	SPACE	4,10
**	EBM - EXPAND BUFFER TO MAXIMUM.
*
*	EBM IS CALLED TO EXPAND THE BUFFER 'BUF' TO THE MAXIMUM SIZE.
*
*	ENTRY	NONE
*	EXIT	(BUFSIZ) = BUFFER SIZE (MULTIPLE OF 256)
*	USES	ALL

EBM	LHLD	S.SYSM
	LXI	D,-6
	DAD	D		(HL) = NEW ADDRESS SOUGHT
	SCALL	.SETTP
	JC	IERR1		INTERNAL ERROR 1
	LHLD	S.USRM
	MOV	A,H		(A) = LIMIT/256
	STA	OBUFLIM		SET LIMIT
	RET
CDA	SPACE	4,10
**	CDA - CONVERT DIRECTORY FORMAT TO ASCII.
*
*	CDA COPIES A DIRECTORY ENTRY FROM PIO.XXX TO A TARGET FIELD.
*	THE DEVICE SPECIFICATION (IN PIO.DEV AND PIO.UNI) IS ALSO ENCODED.
*	THE TARGET FIELD IS LEFT IN THE FORM:
*
*	DEV:NAME.XXX <00>
*
*	ENTRY	(HL) = FWA NAME FIELD
*	EXIT	(A) = 0, HAVE WILDCARD
*		    = 1, NO WILDCARDS USED
*		'C' CLEAR
*	USES	ALL

CDA	LXI	B,3*256		(B) = CHARACTER COUNT, (C) = WILDCARD FLAG
	LXI	D,PIO.DEV
	CALL	CDA5		COPY IT
	MVI	M,':'
	INX	H
	MVI	B,8
	LXI	D,PIO.DIR+DIR.NAM
	CALL	CDA5		COPY IT
	MVI	M,'.'
	INX	H
	MVI	B,3
	ERRNZ	DIR.EXT-DIR.NAM-8
	CALL	CDA5		COPY IT
	MVI	M,0		FLAG END OF NAME
	MOV	A,C		(A) (BIT 7) = 1 IF WILDCARDS
	RLC
	CMA
	ANI	1		=0 IF WILDCARD
	RET
CDA5	SPACE	2,10
**	CDA5 - CONVERT DIRECTORY FIELD TO ASCII.
*
*	ZEROS ARE IGNORED, 200Q WILDCARDS ARE MAPPED TO '?'
*
*	ENTRY	(DE) = FROM
*		(HL) = T0
*		(B) = COUNT
*		(C) = ORA ACCUMULATOR
*	EXIT	(DE) ADVANCED
* 		(HL) = (HL)+(B)
*		(C) = (C) .OR. (FROM CHARACTERS PROCESSED)
*	USES	ALL

CDA5	LDAX	D		(A) = CHARACTER
	ORA	C
	MOV	C,A
	LDAX	D
	INX	D
	ANA	A
	JZ	CDA7		IS 00
	JP	CDA6		NOT 200Q
	MVI	A,'?'
CDA6	MOV	M,A
	INX	H		INCREMENT TO
CDA7	DCR	B
	JNZ	CDA5		IF MORE TO GO
	RET
EWS	SPACE	4,10
**	EWS - EXPAND WILDCARD SPECIFICATION.
*
*	DWS ENTERS THE FILE NAME IN PIO.XXX INTO THE MANAGED TABLE
*	NAMTAB. IF THE FILE NAME CONTAINS WILDCARDS, THE DIRECTORY
*	IS READ FOR ELIGIBLE FILES.
*
*	ENTRY	PIO.XXX = FILE NAME
*	EXIT	'C' CLEAR IF OK
*		'C' SET IF ERROR
*	USES	ALL

EWS	CALL	AEN		TRY TO ENTER IT
	RNC			NO WILDCARDS, AM DONE

*	IS WILDCARD. LOOK UP DEVICE TYPE

	LHLD	NAMTLEN
	LXI	D,NAMTAB-FB.NAML
	DAD	D		(HL) = ADDRESS OF LAST ENTRY
	CALL	CAD		CONVERT ASCII NAME TO DIRECTORY FORMAT
	RC			ERROR
	LHLD	NAMTLEN
	LXI	D,-FB.NAML
	DAD	D
	SHLD	NAMTLEN		REMOVE WILDCARD FROM TABLE
	CALL	$MOVEL
	DW	3,PIO.DEV,DIRNAM	SET DIRECTORY NAME IN XXX:DIRECT.SYS
	CALL	$MOVEL
	DW	8+3,PIO.DIR+DIR.NAM,EWSC	SAVE WILDCARD PATTERN
	LXI	B,EWSB
	LXI	H,DIRNAM
	SCALL	.DECODE 	GET INFORMATION ABOUT DEVICE
	RC			ERROR
	LDA	EWSB		SEE IF A DIRECTORY DEVICE
	ANI	DT.DD
	MVI	A,EC.DNS		ASSUME DEVICE NOT SUITABLE
	STC
	RZ			ERROR

*	IS DIRECTORY DEVICE. OPEN DIRECTORY

	LXI	H,DIRNAM
	MVI	A,CN.DIR
	SCALL	.OPENR
	MVI	A,PEC.DF
	RC			DEVICE FORMAT FAILURE

*	READ DIRECTORY ENTRYS FOR MATCH

EWS1	CALL	GDWP		DE = DIRECTORY WORKSPACE PTR
	LXI	B,512
	MVI	A,CN.DIR
	PUSH	D		SAVE ADDRESS
	SCALL	.READ		READ BLOCK
	POP	H		(HL) = DIRECTORY ADDRESS
	JC	EWS7		ALL DONE

*	LOOK AT DIRECTORY BLOCK FOR MATCHES

	PUSH	H
	CALL	GDWP.
	CALL	$INDLB
	DW	DIS.ENL 	A  = DIRECTORY ENTRY LENGTH
	POP	H

	MOV	C,A		(C) = LENGTH

*	CHECK NEXT ENTRY

EWS3	MOV	A,M		(A) = 1ST CHAR THIS ENTRY
	ANA	A
	JZ	EWS1		END OF BLOCK
	ERRNZ	DF.EMP-377Q
	INR	A
	JZ	EWS6		ENTRY EMPTY
	ERRNZ	DF.CLR-376Q
	INR	A
	JZ	EWS7		END OF LIST
	CALL	CFE		CHECK FOR FILE ELIGIBILITY
	JNZ	EWS6		NOT TO PROCESS
	PUSH	H
	LXI	D,EWSC
	MVI	B,8+3
	CALL	CWM		CHECK WILDCARD MATCH
	JNZ	EWS4		NO MATCH

*	HAVE MATCH. ADD TO LSIT

	POP	D		(DE) = FROM
	PUSH	D
	PUSH	B		SAVE (C)
	LXI	B,8+3
	LXI	H,PIO.DIR+DIR.NAM
	CALL	$MOVE
	CALL	AEN		ADD TO TABLE
	POP	B		RESTORE (C)

*	LOOKUP NEXT ENTRY

EWS4	POP	H
EWS6	MVI	B,0
	DAD	B		POINT TO NEXT
	JMP	EWS3

*	ALL DONE. CLOSE DIRECTORY FILE

EWS7	MVI	A,CN.DIR
	SCALL	.CLOSE
	RET

EWSA	DB	'SY0',200Q,200Q,200Q

EWSB	DC	30,#0

EWSC	DC	8+3,#0		WILDCARD PATTERN FOR DIRECTORY SEARCH
GDWP	SPACE	4,10
**	GDWP	-  GET DIRECTORY WORKSPACE POINTER
*
*	GDWP GETS THE DIRECTORY WORKSPACE POINTER
*
*	ENTRY:	NONE
*
*	EXIT:	DE	= DIRECTORY WORKSPACE POINTER
*
*	USES:	DE

GDWP	XCHG
	CALL	GDWP.		HL = DIRECTORY WORKSPACE POINTER
	XCHG
	RET

GDWP.	LHLD	S.SCR		HL = SYSTEM SCRATCH
	RET
INA	SPACE	4,10
**	INA - INCREASE NAMTAB ALLOCATION.
*
*	INA IS CALLED TO INCREASE THE NAMTAB ALLOCATION. THE
*	BUFFER AREA IS MOVED UP TO MAKE ROOM.
*
*	ENTRY	NONE
*	EXIT	NONE
*	USES	A,F,H,L

INA	LXI	H,NAMTMAX+1
	INR	M		INCREMENT LENGTH
	LXI	H,BUFPTR+1
	INR	M		MOVE BUFFER
	LHLD	BUFSIZ
	MOV	A,H
	ORA	L
	MVI	A,EC.NEM	FLAG OUT OF MEMORY IF BUFFER NOT EMPTY
	JNZ	ERROR
	PUSH	B
	PUSH	D
	CALL	SBE		NOTIFY SYSTEM
	POP	D
	POP	B
	RET
LSN	SPACE	4,10
**	LSN - LOCATE SOURCE NAME
*
*	LSN SCANS THE COMMAND LINE FOR THE FIRST SOURCE FILE NAME.
*
*	ENTRY	NONE
*	EXIT	(HL) = 1ST FILE NAME FWA
*	USES	A,F,H,L

LSN	LXI	H,LINE
LSN1	MOV	A,M
	INX	H
	CPI	'='
	RE			GOT IT
	ANA	A
	JNZ	LSN1		MORE LINE
	LXI	H,LINE	IS NO =
	RET
MWN	SPACE	4,10
**	MWN - MERGE WILDCARD NAMES.
*
*	MWN MERGES A COMPLETELY SPECIFIED FILENAME WITH A WILDCARDED COMPLETELY
*	SPECIFIED FILE NAME.
*
*	BOTH FILE NAMES SHOULD HAVE THE SAME DEVICE SPECIFICATION.
*
*	FILE NAME FORMAT:
*
*	DEV:NAMEXXXX.EXT 00
*
*	ENTRY	(BC) = ADDRESS OF WILDCARDED ASCII NAME
*		(DE) = ADDRESS OF NON-WC ASCII NAME
*		(HL) = ADDRESS FOR RESULTANT ASCII NAME
*	EXIT	NONE
*	USES	ALL

MWN	PUSH	H		SAVE TARGET ADDRESS
	PUSH	B		SAVE WC PATTERN
	XCHG			(HL) = MASTER NAME
	CALL	CAD		CONVERT TO DIRECTORY FORMAT
	CALL	$MOVEL
	DW	8+3,PIO.DIR,MWNA	(MWNA) = DECODED MASTER
	POP	H		(HL) = WC PATTERN
	CALL	CAD		(PIO.DIR) = WC PATTERN
	LXI	D,MWNA		(DE) = MASTER PATTERN
	LXI	H,PIO.DIR	(DE) = WC PATTERN ADDRESS
	MVI	C,8+3		MERGE NAME AND EXTENSION

*	MERGE NAMES

MWN1	MOV	A,M		(A) = WC PATTERN
	ANA	A
	JP	MWN2		USE THIS
	LDAX	D		IS MATCH CHARACTER, USE MASTER INSTEAD
MWN2	MOV	M,A		STORE CHARACTER
	INX	D
	INX	H
	DCR	C
	JNZ	MWN1		MERGE TILL DONE
	POP	H		(HL) = TARGET ADDRESS
	JMP	CDA		CONVERT DIRECTORY FORMAT TO ASCII
REN	SPACE	4,10
**	REN - REMOVE ENTRY FROM *NAMTAB*
*
*	REN REMOVES THE FIRST 'FB.NAML' BYTES FROM NAMTAB.
*
*	THE AMOUNT (FB.NAML) IS REMOVED FROM THE SIZE OF THE TABLE. THE
*	TABLE IS NOT CHECKED FOR UNDERFLOW, THE CALLER MUST GUARANTEE THE
*	PRESENSE OF AT LEAST FB.NAML BYTES IN NAMTAB.
*
*	ENTRY	NONE
*	EXIT	NONE
*	USES	ALL

REN	LHLD	NAMTLEN
	LXI	D,-FB.NAML
	DAD	D		REMOVE COUNT FROM LEN
	SHLD	NAMTLEN
	MOV	B,H
	MOV	C,L		(BC) = REMAINING LENGTH
	LXI	D,NAMTAB+FB.NAML	(DE) = START OF 2ND ENTRY
	LXI	H,NAMTAB
	JMP	$MOVE		MOVE DOWN AND RETURN
SBE	SPACE	4,10
**	SBE - SET BUFFER EMPTY.
*
*	THE SYSTEM IS NOTIFIED.
*
*	ENTRY	NONE
*	EXIT	NONE
*	USES	ALL

SBE	LXI	H,0
	SHLD	BUFSIZ
	LHLD	BUFPTR		(HL) = BUFFER FWA (AND LWA!)
	INX	H
	INX	H
	SCALL	.SETTP
	RNC			OK
	JMP	ERROR		NOT ENOUGH ROOM
SDD	SPACE	4,10
**	SDD - SET DEFAULT DEFAULT.
*
*	SDD IS CALLED TO SETUP THE CURRENT DEFAULT DEVICE
*	AND EXTENSION TO 'SY0' AND <NULL>, RESPECTIVELY.
*
*	ENTRY	NONE
*	EXIT	NONE
*	USES	NONE

SDD	CALL	$SAVALL
	CALL	$MOVEL
	DW	6,SDDA,DEFALT	SET DEFAULT DEFAULT
	JMP	$RSTALL		RESTORE AND RETURN

SDDA	DB	'SY0',0,0,0	DEFAULT DEFAULT VALUES
SFS	SPACE	4,10
**	SFS - SKIP FILE SEPERATOR.
*
*	SFS IS CALLED TO SKIP OVER THE CHARACTERS SEPERATING ONE
*	FILE NAME FROM ANOTHER ON THE LINE. THE FILES MAY BE SEPERATED
*	BY BLANKS OR A COMMA ALONE, OR BY BLANKS WITH A COMMA. THE
*	SYNTAX IS
*
*	<BLANKS> <,> <BLANKS>
*
*	ONE, TWO OR ALL THREE FIELDS MAY BE PRESENT.
*
*	ENTRY	(HL) = POINT TO START OF SEP FIELD
*	EXIT	(HL) ADVANCED PAST SEPERATOR FIELD
*	USES	A,F,H,L

SFS	CALL	$SOB		SKIP BLANKS
	MOV	A,M
	CPI	','
	JNE	SFS1		NOT ,
	INX	H		SKIP ,
SFS1	JMP	$SOB		GET ANY MORE BLANKS AND EXIT
SND	SPACE	4,10
**	SND - SET NEW DEFAULTS.
*
*	SND IS CALLED TO SET A NEW DEFAULT DEVICE AND EXTENSION
*	IN THE 'DEFALT' AREA.
*
*	ENTRY	PIO.DEV = DEVICE CODE
*		PIO.UNI = UNIT #
*		PIO.DIR+DIR.EXT = EXTENSION
*	EXIT	NONE
*	USES	NONE

SND	CALL	$SAVALL		SAVE REGS
	ERRNZ	PIO.UNI-PIO.DEV-2
	CALL	$MOVEL
	DW	3
	DW	PIO.DEV
	DW	DEFALT
	CALL	$MOVEL
	DW	3
	DW	PIO.DIR+DIR.EXT
	DW	DEFALT+3
	JMP	$RSTALL		RETURN
	STL	'COMMON DECKS'
	EJECT
	XTEXT	CFD
	XTEXT	TYPCC
	XTEXT	WER
	XTEXT	ZERO
	XTEXT	MU86
	XTEXT	CCO
	XTEXT	GNL
	XTEXT	MLU
	XTEXT	MCU
	XTEXT	RTL
	XTEXT	MOVE
	XTEXT	CHL
	XTEXT	SOB
	XTEXT	DADA
	XTEXT	TJMP
	XTEXT	CRLF
	XTEXT	TYPT2
	XTEXT	COMP
	XTEXT	SAVALL
	XTEXT	CDEHL
	XTEXT	UDD
	XTEXT	DU66
	XTEXT	DADA2
	XTEXT	HLIHL
	XTEXT	ILDEHL
	XTEXT	INDL
	XTEXT	INDXX
	XTEXT	ISDEHL
	XTEXT	DAD
	XTEXT	UDDX
	XTEXT	UOW
	XTEXT	TFNS
	XTEXT	MOVEL
	XTEXT	RCHAR
	XTEXT	XCHGBC
	XTEXT	DRS
	XTEXT	FERROR
	STL	'PATCH AREA'
	EJECT
PATCH	DC	64,#0AAH	PATCH AREA

*	Auxiliary Patch Area (Round up 1 page)

	DC	*+255/256*256-*,#0BBH

	STL	'ONECOPY SPECIAL DATA STRUCTURES'
	EJECT

**	FDN - FILE DESCRIPTOR NODES.
*
*	THESE NODES ARE USED TO KEEP TRACK OF FILES WHICH ARE BEING
*	HELD IN MEMORY WHILE TRANSFERING.

FDN	DS	0		START OF TYPICAL NODE
FDN.LNK	EQU	*-FDN		LINK TO NEXT NODE IN CHAIN
	DS	1		ALL IN SAME PAGE,  JUST KEEP PAGE INDEX
FDN.STA	EQU	*-FDN		STATUS BYTE
ST.CNT	EQU	DIF.CNT		IS CONTIGUOUS
ST.OPR	EQU	00000010B	IS BEING READ
ST.OPW	EQU	00000001B	OPEN FOR WRITE
	DS	1		STATUS BYTE
FDN.SIZ	EQU	*-FDN		TOTAL SIZE OF FILE (IF ST.CNT SET)
	DS	1		SIZE IN GROUPS
FDN.AMR	EQU	*-FDN		AMOUNT ALREADY READ
	DS	2		 IN SECTORS
FDN.AMW	EQU	*-FDN		AMOUNT ALREADY WRITTEN
	DS	2		 IN SECTORS
FDN.ADR	EQU	*-FDN		ADDRESS IN BUFFER
	DS	1		 ADDRESS/256 (MUST BE EVEN PAGE)
FDN.AIM	EQU	*-FDN		AMOUNT IN MEMORY
	DS	1		 IN SECTORS
FDN.DAT EQU	*-FDN		DATE OF SOURCE FILE
	DS	2
FDN.TIM EQU	*-FDN		TIME OF SOURCE FILE
	DS	2
FDNELEN	EQU	*-FDN		ENTRY  LENGTH

	ORG	FDN		ORG BACK OVER DEFINITION AREA

**	TABLE. A LINK OF 0 IS A NULL LINK.
*
*	THE ENTIRE GROUP OF NODES MUST RESIDE
*	IN THE SAME PAGE

FDNFWA	EQU	*		START OF NODES

FDNFRE	DB	#FDN.1		START OF FREE CHAIN
FDNHEAD	DB	0			ACTIVE LIST NOW EMPTY

FDN.1	DS	0
	DB	#FDN.2		FDN.LNK
	DB	0		FDN.STA
	DB	0		FDN.SIZ
	DW	0		FDN.AMR
	DW	0		FDN.AMW
	DB	0		FDN.ADR
	DB	0		FDN.AIM
	DW	0		FDN.DAT
	DW	0		FDN.TIM

FDN.2	DS	0
	DB	#FDN.3		FDN.LNK
	DB	0		FDN.STA
	DB	0		FDN.SIZ
	DW	0		FDN.AMR
	DW	0		FDN.AMW
	DB	0		FDN.ADR
	DB	0		FDN.AIM
	DW	0		FDN.DAT
	DW	0		FDN.TIM

FDN.3	DS	0
	DB	#FDN.4		FDN.LNK
	DB	0		FDN.STA
	DB	0		FDN.SIZ
	DW	0		FDN.AMR
	DW	0		FDN.AMW
	DB	0		FDN.ADR
	DB	0		FDN.AIM
	DW	0		FDN.DAT
	DW	0		FDN.TIM

FDN.4	DS	0
	DB	#FDN.5		FDN.LNK
	DB	0		FDN.STA
	DB	0		FDN.SIZ
	DW	0		FDN.AMR
	DW	0		FDN.AMW
	DB	0		FDN.ADR
	DB	0		FDN.AIM
	DW	0		FDN.DAT
	DW	0		FDN.TIM

FDN.5	DS	0
	DB	#FDN.6		FDN.LNK
	DB	0		FDN.STA
	DB	0		FDN.SIZ
	DW	0		FDN.AMR
	DW	0		FDN.AMW
	DB	0		FDN.ADR
	DB	0		FDN.AIM
	DW	0		FDN.DAT
	DW	0		FDN.TIM

FDN.6	DS	0
	DB	#FDN.7		FDN.LNK
	DB	0		FDN.STA
	DB	0		FDN.SIZ
	DW	0		FDN.AMR
	DW	0		FDN.AMW
	DB	0		FDN.ADR
	DB	0		FDN.AIM
	DW	0		FDN.DAT
	DW	0		FDN.TIM

FDN.7	DS	0
	DB	#FDN.8		FDN.LNK
	DB	0		FDN.STA
	DB	0		FDN.SIZ
	DW	0		FDN.AMR
	DW	0		FDN.AMW
	DB	0		FDN.ADR
	DB	0		FDN.AIM
	DW	0		FDN.DAT
	DW	0		FDN.TIM

FDN.8	DS	0
	DB	0		FDN.LNK
	DB	0		FDN.STA
	DB	0		FDN.SIZ
	DW	0		FDN.AMR
	DW	0		FDN.AMW
	DB	0		FDN.ADR
	DB	0		FDN.AIM
	DW	0		FDN.DAT
	DW	0		FDN.TIM

FDNCNT	EQU	*-FDN.1/FDNELEN		NUMBER OF NODES

.	SET	*/256
	ERRNZ	FDNFWA/256-.	MUST BE ALL IN SAME PAGE
	STL	'DATA AND FILE BUFFERS'
	EJECT

VOLFLAG DB	0		=0 IF READING FROM SOURCE, =377Q IF WRITING TO DEST
VOLSER	DB	0		SERIAL NUMBER OF CURRENT DISK

OBUFLIM	DB	0		BUFFER LIMIT/256
OBUFPTR	DB	0		NEXT FREE PAGE IN BUFFER/256

ALLOCA	DB	0		/ALL flag (<>0 if /ALL specified)
COMAND	DB	0		COMMAND IN PROGRESS
MODE	DB	0		<>0 IF LINE PASSED ON STACK
SUPRES	DB	0		/SUP flag (<>0 if /SU specified)
QUERY	DB	0		/Q flag (<>0 if /Q specified)
SYSTEM	DB	1		/S flag (=0 if /S specified)

DIRNAM	DB	'XXX:DIRECT.SYS',0	DIRECTORY FILE NAME

BUFPTR	DW	BUFF		POINTER TO START  OF BUFFER
BUFSIZ	DW	0		BUFFER LENGTH
	SPACE	3,10
**	FILE BLOCKS

DESTFB	DS	0		DUMY BUFFER
	DB	200		ILLEGAL CHANNEL NUMBER
	DB	0		FLAGS
	DW	0
	DW	0
	DW	0
	DW	0		END OF BLOCK
	DC	FB.NAML,#0	NAME AREA
	SPACE	3,10
NAMTLEN	DW	0		NAME TABLE POINTER
NAMTMAX	DW	0		MAXIMUM SIZE OF NAME TABLE
NAMTPTR	DW	0		POINTER TO ACTIVE ELEMENT IN NAMTAB

	STL	'PRS - PRESET PROGRAM (OVERLAID BY BUFFERS).'
	EJECT
PRS	SPACE	4,10
***	PRS - PRESET PIP PROGRAM.
*
*	PRS IS CALLED TO PERFORM ONE-TIME-ONLY PRESETTING OF
*	THE PROGRAM ENVIRONMENT.
*
*	THE CODE IS OVERLAID BY BUFFERS AND WORK AREAS WHEN PIP IS RUNNING.
*	DO NOT USE ANY OF THE BUFFERS AND WORK AREAS IN *PRS*
*
*
*	ENTRY	NONE
*
*	EXIT	IF  CORRECT VERSION OF HDOS
*		    NONE
*		  ELSE
*		    EXIT TO HDOS
*
*	USES	ALL

ENTRY	EQU	*		INITIAL ENTRY POINT
PRS	SCALL	.VERS
	JC	PRS1		ERROR IN GETTING VERSION
	CPI	VERS
	JNZ	PRS1		NOT CORRECT VERSION OF HDOS
	LXI	H,RMEML		(HL) = RUN-TIME HIGH MEMORY
	SCALL	.SETTP		SET HI MEMORY
	JC	PRS2		IF  ERROR
	LXI	H,CCHIT
	MVI	A,CTLC
	SCALL	.CTLC		SET CTL-C PROCESSING
	MVI	A,377Q
	SCALL	.CLOSE		CLOSE OVERLAY CHANNEL
	CALL	$DOS		DISMOUNT OPERATING SYSTEM
	JC	PRS2		IF ERROR
	CALL	$TYPTX
	DB	NL,TAB,TAB,TAB,32,32,32,'ONECOPY'
	DB	NL,TAB,TAB,TAB,'Version:',32,32,VERS/16+'0','.',VERS&0FH+'0'
	DB	NL,TAB,TAB,32,32,32,32,32,32,'Issue:',32,32,'#50.07.00'
	DB	NL,NL,'ONECOPY is used to copy files for systems with only one'
	DB	' floppy drive.',NL,'Read the appropriate manual before using.'
	DB	NL,NL,'Insert the initial source disk. '
	DB	' Hit RETURN when ready:',' '+200Q
	CALL	GDWP.
	CALL	$RTL		GET CR

	JMP	PRS3		Jump the the rest of the code

PRS1	MVI	A,EC.NCV	NOT CORRECT VERSION
	STC
PRS2	MVI	H,NL
	SCALL	.ERROR
	JMP	EXIT

	XTEXT	DOS
	SPACE	4,8
**	"what" identification

	DB	'@(#)HDOS 3.0 Onecopy Utility',NL
	DW	.DATE.
	DW	.TIME.

MEML	EQU	*		MEMORY LENGTH
	STL	'RUN-TIME WORK AREAS'
	EJECT
**	THE FOLLOWING BUFFERS AND AREAS OVERLAY THE PRS CODE.
*
*	*PRS* MAY NOT USE ANY CELLS BELOW *LINE*, AT THE
*	RISK OF SMASHING ITSELF

DEFALT	EQU	PRS		DEFAULT BLOCK

MWNA	EQU	DEFALT+6	MWN WORK AREA

SLABEL	EQU	MWNA+FB.NAML	Saved Label Sector
LABEL	EQU	SLABEL+256	Label Sector

PIO.	SPACE	3,10
**	PIO.XXX - IMAGE OF SYSTEM AIO.XXX AREA
*
*	THESE CELLS MIRROR THE SYSTEM AIO.XXX AREA

PIO.DEV EQU	LABEL+256	DEVICE CODE
PIO.UNI EQU	PIO.DEV+2	UNIT NUMBER (0-9)

PIO.DIR EQU	PIO.UNI+1	DIRECTORY ENTRY

LINE	EQU	PIO.DIR+DIRELEN COMMAND BUFFER

NAMTAB	EQU	LINE+101	NAME TABLE

BUFMINL	EQU	512		MINIMUM SIZE FOR BUFFER (WHEN IN USE)
BUFF	EQU	NAMTAB		BUFFER AREA STARTS AFTER NAMTAB

RMEML	EQU	NAMTAB		INITIAL RUNNING MEMORY LENGTH

	END	ENTRY
