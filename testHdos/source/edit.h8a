	TITLE	'EDIT - HDOS TEXT EDITOR'
	SPACE	4,10
***	EDIT - HEATH HDOS TEXT EDITOR.
*
*	ADAPTED FROM 'HOS8 - WINTEK TEXT EDITOR'
*
*	J. G. LETWIN, 12/12/77,  FOR *HEATH* CORPORATION
*
*	COPYRIGHT 12/1977, 79/05	BY *HEATH* CORPORATION.
*
*	G. Chandler		79/05	--.04.--
*				79/12	--.05.--
*				80/02
*	W. Zurney		80/08	--.06.--
*	B. Parrott		86/09	--.07.--
*
EDIT	SPACE	4,10
***	EDIT PERFORMS SIMPLE LINE AND STRING EDITING FUNCTIONS.
*
*	SEE THE 'EDIT' USERS MANUAL FOR INSTRUCTIONS.
	SPACE	4,10
	STL	'ASSEMBLY CONSTANTS.'
	EJECT
****	ASSEMBLY CONSTANTS.
	XTEXT	ASCII
OPTION	SPACE	4,10
**	COMMAND OPTIONS.

OPT.A	EQU	1		PRINT LINE AFTER PROCESS
OPT.B	EQU	2		PRINT LINE BEFORE PROCESSING
MACH	SPACE	3,10
**	MACHINE INSTRUCTIONS.

MI.LDA	EQU	072Q
MI.NOP	EQU	000Q
MI.RET	EQU	311Q

****
	SPACE	3,10
	XTEXT	FBDEF
	XTEXT	HOSDEF
	XTEXT	HOSEQU
	XTEXT	ESVAL
	XTEXT	ABSDEF
	XTEXT	ECDEF
	XTEXT	FILDEF
	XTEXT	DIRDEF
	XTEXT	OVLDEF
	XTEXT	IOCDEF
	XTEXT	HOSBASE
	STL	'MAIN LOOP.'
	EJECT
	ORG	USERFWA

START	EQU	*
RESTART	EQU	*		RESTART ADDRESS

*	ENTER HERE FOR RUBOUT AND COMMANDS DONE.

EDIX	MVI	A,CSL.CHR+CSL.ECH	CHARACTER MODE, NO ECHO
	STA	S.CSLMD		CLEAR TERMINAL CONTRL
	EI
	CALL	CBE		CHECK FOR BUFFER EMPTY
	CALL	MAM		SET MAXIMUM MEMORY
	CALL	$CCO		CLEAR CTL-O
	CALL	$GNL		GUARANTEE NEW LINE
	CALL	$TYPTX
	DB	'-','-'+200Q
	XRA	A
	STA	LINE		NULL LINE
	STA	CCFLG		CLEAR CTL-C DISABLE FLAG
	STA	CCPEND		CLEAR PENDING CTL-C
	CALL	ECC		ENABLE CTL-C
	XRA	A
EDT0	STA	PROCHA		CLEAR PROBATATION CHARACTER

*	RE-ENTER HERE FOR BACKSPACE AND ILLEGAL CHARACTERS

EDI1	LXI	H,LINE
	SHLD	LINPTR
	XRA	A
	STA	ENCA		CLEAR HELD CHARACTER
	LXI	SP,STACK	RESTORE STACK

*	DECODE COMMAND

	CALL	DCR		DECODE COMMAND RANGE
	CALL	DCN		DECODE COMMAND NAME
	CALL	DCQ		DECODE COMMAND QUALIFIER
	CALL	DCO		DECODE COMMAND OPTION
	LHLD	CRFPTR
	SHLD	WRKPTR

*	PROCESS COMMAND

	LDA	CMDGRP		SEE WHICH GROUP IS COMMAND
	ANA	A
	LDA	PATCNT
	JNZ	EDI1.5		IS IN FULL RANGE
	ADI	CMDDSP		IS IN NO-DATA GROUP
EDI1.5	LXI	H,EDIX
	PUSH	H		SET 'RETURN ADDRESS'
	CALL	$TJMP		JUMP TO PROCESSOR

*	THE FOLLOWING COMMANDS MAY BE USED ONLY IF DATA PRESENT.

CMDADR	DS	0		START OF TABLE
	DW	PRINT		PRINT
	DW	DELETE		DELETE
	DW	EDITC		EDIT
	DW	REPLAC		REPLACE
	DW	WRITE		WRITE
	DW	XPRINT		XPRINT

*	THE FOLLOWING COMMANDS MAY ALWAYS BE USED

CMDDSP	EQU	*-CMDADR/2
	DW	INSERT		INSERT
	DW	READ		READ
	DW	PURGE		PURGE
	DW	FLUSH		FLUSH
	DW	NEXT		NEXT
	DW	SEARCH		SEARCH
	DW	NEWIN		NEWIN
	DW	NEWOUT		NEWOUT
	DW	XOUT		XOUT
	DW	USE		USE
	DW	BYE		BYE
INTRPT	SPACE	4,10
**	CTL-C INTERRUPT RECEIVED.
*

INTRPT	CALL	$TYPTX
	DB	'^','C'+200Q
INTRPT. LDA	CCFLG
	ANA	A
	JNZ	INT1
	SCALL	.CLRCO
	LHLD	XOUTFB+FB.FWA
	SHLD	XOUTFB+FB.PTR	ZERO THE  *XOUT*  BUFFER PTR.
	JMP	EDIX		CTL-C ALLOWED

INT1	MVI	A,1
	STA	CCPEND		FLAG PENDING CTLC
	RET			DISCARD FOR NOW
REFUSE	SPACE	4,10
**	REFUSE - REFUSE ENTERED CHARACTER.
*
*	REFUSE IS CALLED WHEN AN ILLEGAL ENTRY IS DETECTED.
*	IT TYPES A BELL, REMOVES THE LAST CHARACTER FROM THE INPUT
*	LINE, AND RE-PARSES THE COMMAND.

REFUSE	CALL	$TYPTX
	DB	BELL+200Q
	LXI	H,LINE
	CALL	SNL		SCAN TO END
	DCX	H		BACKSPACE TO LAST CHARACTER
	DCX	H		HAVE ADVANCED PAST LAST CHARACTER
	XRA	A
	MOV	M,A
	JMP	EDT0		CLEAR PROBATION (BAD) CHARACTER
EXIT	SPACE	4,10
**	EXIT - CTL-D STRUCK (END OF FILE ON CONSOLE)
*
*	SEE IF USER REALLY WANTS TO EXIT...

EXIT	CALL	AYS		ARE YOU SURE?
	JC	EXIT1		CTL-D AGAIN
	JNE	RESTART		NOT SURE

EXIT1	XRA	A
	SCALL	.EXIT		EXIT WITH EVERYTHING OPEN
	STL	'DCR - DECODE COMMAND RANGE.'
	EJECT
DCR	SPACE	4,10
**	DCR - DECODE COMMAND RANGE.
*
*	DCR IS CALLED TO DETERMINE THE COMMAND RANGE.
*
*	CAN BE EITHER
*
*	=			PREVIOUS RANGE
*	' '			ALL TEXT
*	EXPR			LINE EXPRESSION
*
*	ENTRY	NONE
*	EXIT	CRFPTR,CRLPTR,WRKPTR SETUP
*	USES	ALL

DCR	EQU	*
	LHLD	PCFPTR
	SHLD	CRFPTR
	LHLD	PCLPTR
	SHLD	CRLPTR		SET DEFAULT RANGE TO RANGE OF PREVIOUS
	MOV	A,H
	ORA	L
	RZ			IF NO DATA, DONT ALLOW RANGE
	LHLD	FILPTR
	CALL	ENC		EXAMINE NEXT CHARACTER
	CPI	' '
	JNE	DCR1		NOT BLANK

*	IS BLANK. ENTIRE RANGE.

	SHLD	CRFPTR
	LHLD	LALPTR
	MOV	A,H
	ORA	L
	CNZ	SLB		SCAN LINE BACKWARDS (IF ANY TEXT)
	SHLD	CRLPTR
	JMP	GNC		READ BLANK AND EXIT

DCR1	CPI	'='
	JE	GNC		IS OLD RANGE. READ = AND EXIT
	MOV	A,H
	ORA	L
	RZ			NO TEXT, DONT ALLOW EXPRESSION

*	MUST BE EXPRESSION

	CALL	DRE		DECODE RANGE EXPRESSION
	SHLD	CRFPTR		SET FIRST COMMAND
	SHLD	CRLPTR		ASSUME IS ONE LINE COMMAND
	CALL	ENC
	CPI	','
	RNE			NO 2ND EXPRESSION
	CALL	GNC		READ ,
	PUSH	H		SAVE BEGINNING OF RANGE
	CALL	DRE		DECODE RANGE EXPRESSION
	SHLD	CRLPTR		SET LAST
	POP	D		(DE) = FIRST

*	MAKE SURE 1ST IS LESS THAN OR EQUAL TO LAST

	MOV	A,L
	SUB	E
	MOV	A,H
	SBB	D
	RNC			IS OK
	CALL	$TYPTX
	DB	NL,BELL,'First <= Las','t'+200Q
	JMP	REFUSE
DRE	STL	'DRE - DECODE RANGE EXPRESSION.'
	EJECT
DRE	SPACE	4,10
**	DRE - DECODE RANGE EXPRESSION.
*
*	DRE DECODES A COMMAND RANGE EXPRESSION.
*
*	TOKENS VALID AS 1ST TOKEN, ONLY
*
*	NULL	CURRENT 1ST LINE
*	$	LAST LINE IN BUFFER
*	^	1ST LINE IN BUFFER
*
*	TOKENS VALID ANYWHERE
*
*	'STR' LINE CONTAINING STRING
*
*	TOKENS NOT VALID AT HEAD OF STRING
*
*	NNN	LINE COUNT
*
*	OPERATORS
*
*	+	SCAN FORWARD
*	-	SCAN BACKWARDS
*
*	ENTRY	NONE
*	EXIT	(HL) = RESULTANT LINE POINTER
*	USES	ALL

DRE	EQU	*
	MVI	A,-1
	STA	SRCDIR		SET INITIAL DIRECTION FORWARD

*	DECODE INITIAL TOKEN.

	CALL	ENC		PEEK AT CHARACTER
	LHLD	FILPTR
	CPI	'^'
	JE	DRE1		START AT TOP
	LHLD	LALPTR		ASSUME LAST
	PUSH	PSW		SAVE (A)
	CALL	SLB		SCAN LINE BACKWARDS
	POP	PSW
	CPI	'$'
	JE	DRE1		NOT TO START AT BOTTOM
	LHLD	CRFPTR
	CPI	QUOTE
	JE	DRE7		IS QUOTED STRING
DRE1	CZ	GNC		ACCEPT CHARACTER OF $ OR ARROW

DRE3	SHLD	WRKPTR		SET CURRENT LINE ADDRESS

*	DECODE OPERATOR

DRE4	CALL	ENC		EXAMINE NEXT CHARACTER
	SUI	'+'
	JZ	DRE5		IS FORWARD SEARCH
	CPI	'-'-'+'
	JE	DRE5		IS BACKWARD SEARCH
	LHLD	WRKPTR		(HL) = LINE RANGE
	RET			EXIT WITH LINE POINTER

DRE5	DCR	A
	STA	SRCDIR
	CALL	GNC		READ + OR -

**	DECODE NEXT TOKEN.

	CALL	ENC		EXAMINE CHARACTER
	CPI	QUOTE
	JE	DRE8		QUOTED STRING

*	HAVE NNN - STEP OVER LINES

	CALL	DDN		MUST BE DECIMAL NUMBER
DRE6	MOV	A,B
	ORA	C
	JZ	DRE3		HAVE STEPPED ENOUGH LINES
	DCX	B
	CALL	MLP		MOVE LINE POINTER
	SHLD	WRKPTR
	JMP	DRE6

*	HAVE STRING VALUE.

DRE7	SHLD	WRKPTR
DRE8	LXI	H,QUALS		USE QUALS AREA FOR SCRATCH
	CZ	RQS		READ QUOTED STRING
	CALL	LQS		LOCATE QUOTED STRING
	JE	DRE4		FOUND
	CALL	MLP		MOVE LINE POINTER
	ORA	H
	JMP	DRE7		SEARCH AGAIN
MLP	SPACE	4,10
**	MLP - MOVE LINE POINTER.
*
*	MLP MOVES THE LINE POINTER FORWARDS OR BACKWARDS ONE LINE,
*	DEPENDING UPON 'SRCDIR'.
*
*	IF SRCDIR <  0, FORWARDS
*	IF SRCDIR => 0, BACKWARDS
*
*	IF RUN OFF THE NED OF TEXT, EXIT TO 'REFUSE'
*
*	ENTRY	(HL) = LINE POINTER
*	EXIT	(HL) = NEW LINE POINTER
*	USES	A,F

MLP	PUSH	D
	LHLD	WRKPTR
	LDA	SRCDIR
	ANA	A
	JP	MLP1		BACKWARDS
	CALL	SNL		SCAN TO NEXT LINE
	XCHG
	LHLD	LALPTR
	XCHG
	CALL	$CDEHL		COMPARE TO BOTTOM
	POP	D
	JE	REFUSE		IF ALREADY AT BOTTOM
	RET

*	BACKWARDS

MLP1	XCHG
	LHLD	FILPTR
	XCHG
	CALL	$CDEHL		SEE IF AT TOP
	JE	REFUSE
	POP	D
	JMP	SLB		SCAN LINE BACKWARDS AND RETURN
	STL	'DCN - DECODE COMMAND NAME.'
	EJECT
**	DCN - DECODE COMMAND NAME.
*
*	DCN DECODES AND COMPLETES THE COMMAND NAME.
*
*	ENTRY	NONE
*	EXIT	(A) = COMMAND INDEX

DCN	EQU	*
	CALL	ENC		PRE-READ 1ST COMMAND CHARACTER
	LHLD	LINPTR
	DCX	H
	SHLD	DCNA		SET LINE POINTER
	XRA	A
	STA	ENCA
	JMP	CMD3

*	INPUT 1 CHARACTER

CMD2	CALL	GNC		GET NEXT CHARACTER

*	CLEAR NXTCHA, PATCNT

CMD3	LXI	H,377000A
	SHLD	NXTCHA

	LXI	D,CMDTAB
	LHLD	CRFPTR
	MOV	A,H
	ORA	L		SEE IF ANY DATA
	STA	CMDGRP		SET COMMAND GROUP
	JNZ	CMD4		HAVE DATA
	LXI	D,CMDTAB.	RESTRICT COMMAND RANGE

*	CHECK AGAINST NEXT COMMAND DESCRIPTION.

CMD4	LXI	H,PATCNT
	INR	M
	XCHG
	CALL	SNL		SCAN FOR NEW LINE
	XCHG
	LXI	B,0		(BC) = COMMAND TEXT ADDRESS
DCNA	EQU	*-2
	LDAX	D
	ANA	A
	JNZ	CMD5		HAVE COMMAND ELEMENT

*	NO MORE COMMANDS. HAVE:
*
*	1) NO MATCHES, OR
*	2) A UNIQUE NEXT CHARACTER

	LDA	NXTCHA
	ANA	A
	JZ	REFUSE		NO MATCHES - ILLEGAL
	LHLD	LINPTR
	MOV	M,A
	INX	H
	MVI	M,0
	STA	PROCHA
	JMP	CMD2

*	CHECK NEXT TABLE ELEMENT FOR MATCH

CMD5	LDAX	B		(A) = NEXT LINE CHARACTER
	ANA	A
	JNZ	CMD7		IF SOME

*	NO MORE TEXT. SEE IF CAN ANTICIPATE NEXT CHARACTER

	LDA	PROCHA
	ANA	A
	CNZ	$WCHAR
CMD6	XRA	A
	STA	PROCHA		CLEAR PROBATION CHARACTER
CMD6.5	MOV	H,B
	MOV	L,C		(HL) = NEW LINE POINTER
	SHLD	LINPTR		SKIP OVER CHARACTERS ACCEPTED
	LDAX	D		(A) = COMMAND ELEMENT
	ANA	A
	RZ			EXIT IF ENTIRE COMMAND MATCHED
	LXI	H,NXTCHA

*	SEE IF THIS IS THE FIRST COMPLETION CHARACTER,
*	OR IF IT IS THE SAME CHARACTER AS PREVIOUSLY FOUND

	CMP	M
	JE	CMD4		SAME AS PREVIOUS, CAN COMPLETE
	PUSH	D
	MOV	D,A
	ADD	M
	MOV	M,A
	CMP	D		SEE IF NXTCHA WAS 0
	POP	D
	JE	CMD4		CAN COMPLETE
	JMP	CMD2		CANNOT COMPLETE

*	HAVE PATTERN AND TEXT. SEE IF MATCH.

CMD7	LDAX	D
	ANA	A
	JZ	CMD6.5		TOTAL MATCH - PRETEND RAN OUT OF TEXT
	MOV	H,A		(H) = NEXT REQUIRED CHARACTER
	LDAX	B		(A) = NEXT TEXT ELEMENT
	CALL	$MCU		MAP CHARACTER TO UPPER CASE
	INX	B		ASSUME MATCH
	CMP	H
	JNE	CMD4		NO MATCH
	INX	D
	JMP	CMD5
	STL	'DCQ - DECODE COMMAND QUALIFIER.'
	EJECT
DCQ	SPACE	4,10
**	DCQ - DECODE COMMAND QUALIFIER.
*
*	DCQ READS AN OPTIONAL QUALIFICATION STRING FOLLOWING A
*	COMMAND
*
*	COMMAND'STRING'
*
*	ENTRY	NONE
*	EXIT	QUALS = STRING (NULL IF NONE)

DCQ	LXI	H,QUALS
	MVI	M,0		NULL IT
	CALL	ENC		CHECK NEXT CHARACTER
	CPI	QUOTE
	RNE			NO QUALIFIER
	JMP	RQS		READ QUOTED STRING AND RETURN
	STL	'DCO - DECODE COMMAND OPTIONS.'
	EJECT
DCO	SPACE	4,10
**	DCO - DECODE COMMAND OPTIONS.
*
*	DCO DECODES THE COMMAND OPTION SPECIFICATION.
*
*	COMMANDOPTION
*
*	WHERE OPT = A - PRINT LINE AFTER
*		      B - PRINT LINE BEFORE
*		      N - PRINT LINE NUMBERS

DCO	LXI	H,OPTS
	MVI	M,0		CLEAR OPTIONS
DCO1	CALL	ENC		CHECK NEXT CHARACTER
	CALL	$MCU		MAP CHARACTER TO UPPER CASE
	CPI	'A'
	JE	DCO2		IF 'A'
	CPI	'B'
	RNE			NOT OPTION
DCO2	ANI	OPT.A+OPT.B
	MOV	B,A		(B) = OPTION
	ANA	M
	JNZ	REFUSE		ALREADY SET
	MOV	A,B
	ORA	M		SET IN FLAGS
	MOV	M,A
	CALL	GNC		ACCEPT 'A' OR 'B'
	JMP	DCO1
	STL	'INSERT - PROCESS [X]INSERT COMMAND.'
	EJECT
INSERT	SPACE	4,10
**	INSERT - INSERT TEXT INTO BUFFER.
*
*	ISNERT RECOGNIZES TWO SPECIAL CASES:
*
*	1) IF NO TEXT EXISTS, INITIALIZE STRUCTURE
*	2) IF THE LINE NUMBER IS ' ', INSERT BEFORD THE 1ST LINE

INSERT	EQU	*
	CALL	RCR		REQUIRE CARRIAGE RETURN
	LHLD	WRKPTR
	MOV	A,H
	ORA	L
	JNZ	INS1		HAVE PRE-EXISTING TEXT

*	READ 1ST LINE INTO EMPTY STRUCTURE

	CALL	ATL		READ TEXT
	CALL	DCC		DISABLE CTL-C
	XCHG			(DE) = TEXT ADDRESS
	LXI	H,BUFFER
	CALL	SAP		SET ALL POINTERS
	PUSH	H
	MOV	C,A
	MVI	B,0		(BC) = LEN
	DAD	B
	SHLD	LALPTR
	POP	H
	JMP	INS3

INS1	CALL	PLB		PRINT LINE BEFORE
	LDA	LINE
	CPI	' '
INS2	CNZ	SNL		(HL) = ADDRESS TO INSERT TEXT
	CALL	ECC		RE-ENABLE CTL-C
	CALL	CBO		CHECK FOR BUFFER OVERFLOW

*	INSERT A NEW LINE

	SHLD	WRKPTR
	XCHG
	CALL	ATL		ACCEPT TEXT LINE
	CALL	DCC		DISABLE CTL-C
	XCHG
	MOV	C,A
	CALL	ITBK		INSERT TEXT BLOCK
	MVI	B,0
INS3	CALL	$MOVL		MOVE TEXT IN
	LHLD	WRKPTR
	ORA	H		CLEAR 'Z'
	JMP	INS2
	STL	'PRINT - [X]PRINT SOURCE LINES'
	EJECT
PRINT	SPACE	4,10
**	PRINT - PRINT TEXT LINES.
*

PRINT	CALL	RCR		REQUIRE CARRIAGE RETURN
PRI1	CALL	SEL		SCAN FOR ELIGIBLE LINE
	RZ			IF NO MORE
	CALL	TTX		TYPE SOURCE TEXT
PRIA	EQU	*-2		PROCESSOR ADDRESS
	CALL	ACL		ADVANCE COMMAND LINE
	JNZ	PRI1
	RET			DONE
	STL	'XPRINT	- PROCESS XPRINT COMMAND'
	EJECT
XPRINT	SPACE	4,10
**	XPRINT	-  PROCESS XPRINT COMMAND
*
*	XPRINT processes the XPRINT command which outputs
*	text to a specified alternate file.  The most
*	useful application of which, being a listing to
*	an alternate printer.
*

XPRINT	EQU	*
	CALL	RCR

	LDA	XOUTFB+FB.FLG
	ANI	FT.OW
	JZ	WRI4		REQUIRE AN OUTPUT FILE

XPR1	CALL	SEL
	JZ	XPR2		NO MORE LINES

*	OUTPUT THE SPECIFIED LINE TO THE XPRINT DEVICE

	CALL	XPR4		OUTPUT A LINE

	CALL	ACL		ADVANCE ONE LINE
	JNZ	XPR1

*	FLUSH THE OUPUT TO THE SPECIFIED DEVICE

XPR2	EQU	*

	LXI	H,XOUTFB	USE XOUT FILE BUFFER
	CALL	$FWBRK		BREAKOUTPUT

	RET
XPR4	SPACE	4,10
**	OUTPUT A LINE

XPR4	EQU	*
	PUSH	H
	XCHG			DE = ADDRESS OF LINE
	LXI	H,XOUTFB	HL = FILE BUFFER
	CALL	$FWRIL		WRITE LINE
	POP	H		RESTORE LINE ADDRESS
	RET

XPRA	DB	0		FLUSH CHARACTER
XPRAL	EQU	*-XPRA		LENGTH ( SHOULD BE ONE TO LEAVE BUFFER EMPTY )
	STL	'DELETE - PROCESS DELETE COMMAND'
	EJECT
DELETE	SPACE	4,10
**	DELETE - DELETE LINE RANGE.


DELETE	LDA	LINE
	CPI	' '
	JE	REFUSE		<BLANK>DELETE ILLEGAL
	CALL	RCR		REQUIRE CARRIAGE RETURN

*	ENTERED FROM *WRITE* HERE

DEL0	LDA	QUALS
	ANA	A
	JZ	DEL3		AM TO DELETE A BLOCK OF TEXT
DEL1	CALL	ECC		ENABLE CTL-C
	CALL	SEL		SCAN FOR ELIGIBLE LINE
	JZ	DEL2		DONE
	PUSH	H		SAVE ADDRESS
	LHLD	WRKPTR
	XCHG
	LHLD	CRLPTR		SEE IF AT LAST TEXT LINE
	MOV	A,E
	SUB	L
	MOV	A,D
	SBB	H
	POP	H		(HL) = TEXT POINTER
	PUSH	PSW		SAVE RESULT FOR LATER TEST
	CALL	PLB		PRINT LINE BEFORE
	CALL	DCC		DISABLE CTL-C
	CALL	$CLL		COMPUTE LINE LENGTH
	CALL	DTBK		DELETE TEXT BLOCK
	POP	PSW		RESTORE CONDITION AFTER TEST
	JC	DEL1		MORE TO GO

*	ALL DONE. CLEAR PREVIOUS COMMAND RANGE TO FORCE NEW RANGE

DEL2	EQU	*
	LHLD	LALPTR
	XCHG			DE = END OF LAST + 1
	LHLD	CRFPTR		HL = CURRENT FIRST POINTER
	CALL	CPDEHL		COMPARE
	JC	DEL2.5		HL < DE

	LHLD	LALPTR
	CALL	SLB		SCAN BACK ONE LINE

DEL2.5	SHLD	PCFPTR		SET PREVIOUS RANGE TO FIRST LINE
	SHLD	PCLPTR
	RET			EXIT

*	NO QUALIFIER STRING, WILL THEREFORE DELETE AN ENTIRE BLOCK.
*	LOCATE THAT BLOCK, AND DELETE ALL IN ONE SWOOP (RUNS A HECK OF A
*	LOT FASTER!)

DEL3	CALL	DCC		DISABLE CTL-C
	LHLD	WRKPTR
	SHLD	DELA		SAVE FWA OF BLOCK
	LXI	B,0		(BC) = BYTES TO DELETE

DEL4	LHLD	CRLPTR		SEE IF THE LAST LINE IN THE RANGE
	XCHG
	LHLD	WRKPTR
	MOV	A,L
	SUB	E
	MOV	A,H
	SBB	D
	PUSH	PSW		SAVE RESULT
	CALL	PLB		PRINT LINE BEFORE
	CALL	$CLL		COMPUTE LINE LENTH
	CALL	$DADA		(HL) = LINE LWA+1
	ADD	C
	MOV	C,A
	MOV	A,B
	ACI	0
	MOV	B,A		ADD LENGTH TO (BC)
	SHLD	WRKPTR		ADVANCE POINTER
	POP	PSW		(PSW) = RESULTS OF WRKPTR-CRLPTR
	JC	DEL4		IF NOT ALL DONE

*	DELETE (BC) BYTES AT (DELA)

	LHLD	DELA
	CALL	DTBK.		DELETE A TEXT BLOCK
	JMP	DEL2		FINISH UP

DELA	DW	0		FWA OF BLOCK TO DELETE
	STL	'REPLAC - PROCESS REPLACE COMMAND.'
	EJECT
REPLAC	SPACE	4,10
**	REPLACE - PROCESS REPLACE COMMAND.
*

REPLAC	CALL	RCR		REQUIRE CARRIAGE RETURN
REP1	CALL	SEL.		SCAN FOR ELIGIBLE LINE
	RZ			DONE
	CALL	PLB		PRINT LINE BEFORE
	CALL	ATL		ACCEPT TEXT LINE
	MOV	C,A
	CALL	RSL		REPLACE SINGLE LINE
	CALL	ACL		ADVANCE COMMAND LINE
	RZ
	JMP	REP1
	STL	'PURGE - PROCESS PURGE COMMAND.'
	EJECT
PURGE	SPACE	4,10
**	PURGE - PURGE TEXT BUFFER.
*
*	PURGE DELETES ALL TEXT, AND INITIALIZES THE DATA STRUCTURE.
*
*	THE NUMBER OF FREE BYTES REMAINING IS TYPED OUT.

PURGE	CALL	RCR		REQUIRE CARRIAGE RETURN
	CALL	AYS		ARE YOU SURE
	RC			NOT SURE
	RNE			NOT SURE

**	PURGE. - PURGE WITHOUT WARNING.
*

PURGE.	EQU	*
	LXI	H,0
	CALL	DCC		DISABLE CTL-C
SAP	SPACE	4,10
**	SAP - SET ALL POINERS.
*
*	SAP SETS THE FOLLOWING POINTERS TO A SINGLE VALUE:
*
*	FILPTR	FIRST LINE POINTER
*	LALPTR	LAST LINE POINTER
*	CRFPTR	COMMAND FIRST LINE POINTER
*	CRLPTR	COMMAND LAST LINE POINTER
*	WRKPTR	WROKING POINTER
*
*	ENTRY	(HL) = VALUE
*	EXIT	NONE
*	USES	NONE

SAP	SHLD	FILPTR
	SHLD	LALPTR
	SHLD	CRFPTR
	SHLD	CRLPTR
	SHLD	WRKPTR
	SHLD	PCFPTR
	SHLD	PCLPTR
	RET
	STL	'EDITC - PROCESS EDIT COMMAND.'
	EJECT
EDIT	SPACE	4,10
**	EDITC - PROCESS EDIT COMMAND.
*
*	EDIT/FROM/TO/COUNT

EDITC	EQU	*
	CALL	GTC		GET DELIMITER
	MOV	B,A		(B) = DELIMITER

*	READ /FROM/

	LXI	H,EDIA
	CALL	RDS		READ DELIMITED STRING
	MOV	A,C		(A) = LEN
	ANA	A
	JZ	REFUSE		NULL IS ILLEGAL

*	READ /TO/ STRING

	LXI	H,EDIB
	MOV	D,C		(D) = LENGTH OF /FROM/
	CALL	RDS		READ DELIMITED STRING
	MOV	B,D		(B) = LEN(FROM), (C) = LEN(TO)
	PUSH	B		SAVE
	LXI	B,0
	CALL	ENC
	CPI	'*'
	JNE	EDI0		TO PROCESS ALL OF THEM
	CALL	GNC
	JMP	EDI2

EDI0	INX	B		DEFAULT COUNT = 1
	CPI	NL
	CNE	DDN		DECODE IF DECIMAL
EDI2	CALL	RCR		REQUIRE CARRIAGE RETURN

*	GET NEXT LINE

EDI3	CALL	SEL.		SCAN FOR ELIGIBLE LIN
	JZ	EDI5		ALL DONE
	LHLD	WRKPTR
	CALL	$CLL		COMPUTE LINE LENGTH
	PUSH	B		SAVE REPEAT COUNT
	MOV	C,A
	MVI	B,0		(BC) = LINE LENGTH
	XCHG			(DE) = FROM
	LXI	H,WRKSTR
	PUSH	H		SAVE DEST ADDRESS
	CALL	$MOVL		MOVE INTO WRKSTR
	POP	H		(HL) = #WRKSTR
	POP	B		(BC) = REPEAT COUNT
	LXI	D,EDIA
	CALL	SFS		SEE IF SOURCE STRING IS PRESENT
	JNZ	EDI5		NOT FOUND
	XCHG			SAVE (HL) IN (DE)
	CALL	PLB		PRINT LINE BEFORE
	XCHG			RESTORE (HL)

*	REPLACE STRING

	POP	D		(D) = LEN(FROM), (E) = LEN(TO)
	PUSH	B		SAVE REPLACEMENT COUNTS
	PUSH	D		SAVE LENGTHS
	PUSH	H		SAVE ADDRESS OF MATCH

*	SOURCE LINE IS HEAD MATCH TAIL
*
*	MOVE TAIL TO ITS NEW POSITION TO MAKE ROOM FOR /TO/

	MOV	C,D		(BC) = LEN(FROM)
	MVI	B,0
	MOV	D,B		(DE) = LEN(TO)
	DAD	D		(HL) = NEW TIAL ADDRESS
	XCHG
	POP	H
	PUSH	H
	DAD	B		(HL) = CURRENT TAIL ADDRESS
	CALL	$CLL		COMPUTE LINE LENGTH
	MVI	B,0
	MOV	C,A		(BC) = LENGTH OF TAIL
	XCHG
	CALL	$MOVL		MOVE TAIL
	POP	H		(HL) = MATCH ADDRES
	POP	B		(BC) = LENGTHS
	PUSH	B
	MVI	B,0
	LXI	D,EDIB
	CALL	$MOVL		COPY INTO PLACE

*	COMPRESS STRING AND PUT BACK IN BUFFER

	LXI	H,WRKSTR
	CALL	$CLL		COMPUTE LINE LENGTH
	MOV	C,A		(C) = LENGTH
	CALL	RSL		REPLACE SINGLE LINE

*	DECREMENT REQUEST COUNT

	POP	D
	POP	B
	PUSH	D
	DCX	B

*	SEE IF MORE TO GO

	MOV	A,B
	ORA	C
	JZ	EDI6		NO MORE LINES TO CONSIDER

EDI5	CALL	ACL		ADVANCE COMMAND LINE
	JNZ	EDI3		MORE TO GO
EDI6	POP	B
	RET
RDS	SPACE	4,10
**	RDS - READ DELIMITED STRING.
*
*	ENTRY	(B) = DELIMITER
*		(HL) = ADDRESS FOR STRING
*	EXIT	(HL) UNCHANGED
*		(C) = LENGTH OF STRING
*	USES	A,F,C

RDS	MVI	C,377Q
	PUSH	H
	PUSH	D
	MVI	D,40		(D) = MAX COUNT
RDS1	DCR	D
	JZ	REFUSE		TOO MANY
	CALL	GTC		GET TEXT CHARACTER
	MOV	M,A
	INX	H
	INR	C
	CMP	B
	JNE	RDS1		NOT DELIMITER

*	OUT OF STRING

	DCX	H
	MVI	M,0		END IT
	POP	D		RESTORE (DE)
	POP	H
	RET
	STL	'FLUSH - PROCESS FLUSH COMMAND.'
	EJECT
FLUSH	SPACE	4,10
**	FLUSH - PROCESS FLUSH COMMAND.
*

FLUSH	EQU	*		ENTRY POINT
	CALL	RCR		REQUIRE CARRIAGE RETURN
FLUSH1	LDA	INFB+FB.FLG
	PUSH	PSW		SAVE FLAG
	CALL	NEXT.		MOVE DATA THROUGH
	POP	PSW
	ANI	FT.OR
	JNZ	FLUSH1		NOT AT EOF YET

*	HAVE READ EOF. WRITE ALL.

	LXI	H,OUTFB
	JMP	$FCLO		CLOSE AND EXIT
	STL	'BYE - EXIT EDITOR'
	EJECT
***	BYE - EXIT EDITOR.
*
*	BYE (CR)
*
*	BYE FLUSHES OUT THE EXISTING FILES, AND EXITS.

BYE	CALL	FLUSH
	LXI	H,XOUTFB	CLOSE  *XOUT*  FILE
	CALL	$FCLO
	XRA	A
	SCALL	.EXIT		EXIT
	STL	'NEWIN - PROCESS NEWIN COMMAND.'
	EJECT
NEWIN	SPACE	4,10
**	NEWIN - PROCESS NEWIN COMMAND.
*

NEWIN	EQU	*

*	SET NEW 'IN' FILE

	CALL	GTC		GET DELIMITER
	CPI	NL
	JE	REFUSE		NO NAME
	MOV	B,A
	LXI	H,EDIA
	CALL	RDS		READ DELIMITED STRING
	CALL	$MLU		MAP LINE TO UPPER CASE
	CALL	RCR		REQUIRE CARRIAGE RETURN
	CALL	MIM		REQUEST MINIMUM MEMORY
	MVI	A,FB.NAML
	CMP	C		SEE IF TOO LONG A NAME GIVEN
	JC	NEWIN4		TOO LONG
	LDA	INFB+FB.FLG
	ANI	FT.OR
	JZ	NEWIN1		NOT ALREADY OPEN
	CALL	$TYPTX
	DB	NL,'Old Input File Not Finished.',' '+200Q
	CALL	AYS		ARE YOU SURE?
	RC			NOT SURE
	RNE			NOT SURE
NEWIN1	LXI	H,INFB
	CALL	$FCLO		CLOSE OLD ONE
	PUSH	H
	CALL	$MOVLL
	DW	FB.NAML
	DW	EDIA
	DW	FB.NAM+INFB	SET NAME
	POP	H
	LXI	D,DEFALT
	JMP	$FOPER		OPEN FOR READ AND EXIT

*	ILLEGAL FILE NAME GIVEN

NEWIN4	CALL	$TYPTX
	DB	BELL,'Illegal File Name',' '+200Q
	JMP	EDIX
	STL	'NEWOUT - PROCESS NEWOUT COMMAND.'
	EJECT
NEWOUT	SPACE	4,10
**	NEWOUT,'NAME'
*

NEWOUT	EQU	*

*	SET NEW 'OUT' FILE

	CALL	GTC		GET DELIMITER
	MOV	B,A		(B) = DELIMITER
	CPI	NL
	JE	REFUSE		NO NEW FILE
	LXI	H,EDIA
	CALL	RDS		READ DELIMITED STRING
	CALL	$MLU		MAP LINE TO UPPER CASE
	CALL	RCR		REQUIRE CARRIAGE RETURN
	CALL	MIM		REQUEST MINIMUM MEMROY
	MVI	A,FB.NAML
	CMP	C
	JC	NEWIN4		TOO MANY CHARACTERS FOR FILE NAME
	LDA	OUTFB+FB.FLG
	ANI	FT.OW
	JZ	NEWO1		OUTPUT CLOSED
	CALL	$TYPTX
	DB	NL,'Old Output File Not Finished.',' '+200Q
	CALL	AYS		SURE?
	RC			NOT SURE
	RNE			NOT SURE
NEWO1	LXI	H,OUTFB
	CALL	$FCLO		CLOSE OLD STUFF
	PUSH	H
	CALL	$MOVLL
	DW	FB.NAML
	DW	EDIA
	DW	OUTFB+FB.NAM
	POP	H		(HL) = FB ADDRESS
	LXI	D,DEFALT
	JMP	$FOPEW		OPEN FOR WRITE AND EXIT
	STL	'XOUT	-  PROCESS XOUT COMMAND'
	EJECT
XOUT	SPACE	4,10
**	XOUT	-  PROCESS XOUT COMMAND
*
*	XOUT closes any currently specified XPRINT channel,
*	and opens the newly specified one.

XOUT	EQU	*

*	SET NEW 'OUT' FILE

	CALL	GTC
	MOV	B,A
	CPI	NL
	JE	REFUSE		NO NEW FILE

	LXI	H,EDIA
	CALL	RDS		READ DELIMITED STRING
	CALL	$MLU		MAP TO UPPER CASE
	CALL	RCR		GET NEWLINE
	CALL	MIM		MINIMUM MEMORY

	MVI	A,FB.NAML
	CMP	C
	JC	NEWIN4		TOO MANY CHARACTERS

	LDA	XOUTFB+FB.FLG
	ANI	FT.OW
	JZ	XOUT1		OUTPUT CLOSED

	CALL	$TYPTX
	DB	NL,'Old XOUT File is not finished.',' '+200Q
	CALL	AYS		SURE?
	RC			NOT SURE
	RNE			NOT SURE

XOUT1	LXI	H,XOUTFB
	CALL	$FCLO		CLOSE THE OLD ONES
	PUSH	H
	CALL	$MOVLL
	DW	FB.NAML
	DW	EDIA
	DW	XOUTFB+FB.NAM
	POP	H
	LXI	D,DEFALT
	JMP	$FOPEW		OPEN FOR WRITE AND EXIT
	STL	'NEXT - PROCESS NEXT COMMAND.'
	EJECT
NEXT	SPACE	4,10
**	NEXT - PROCESS "NEXT" COMMAND.
*

NEXT	EQU	*
	CALL	RCR		REQUIRE CARRIAGE RETURN
NEXT.	EQU	*
	LHLD	LALPTR
	MOV	A,H
	ORA	L
	JZ	READ.		NOTHING TO WRITE
	CALL	SLB		SCAN LINE BACKWARDS
	SHLD	CRLPTR
	SHLD	WRKPTR
	SHLD	CRFPTR
	CALL	WRITE.		WRITE ALL
	JMP	READ.		LOAD BACK UP
	STL	'READ - PROCESS READ COMMAND.'
	EJECT
READ	SPACE	4,10
**	READ - READ LINES FROM FILE.
*

READ	EQU	*
	CALL	RCR		REQUIRE CARRIAGE RETURN
	CALL	READ.
	JC	CBO1		NO ROOM
	RET

READ.	LDA	INFB+FB.FLG
	ANI	FT.OR
	JZ	READ2		AT EOF
READ0	LHLD	LALPTR		(HL) = LAST LINE POINTER
	MOV	A,H
	ORA	L
	JNZ	READ1		NOT EMPTY
	LXI	H,BUFFER
	CALL	SAP		SET ALL POINTERS IF NOT TEXT YET
READ1	LXI	D,512		(DE) = ROOM TO LEAVE IN BUFFER
	DAD	D
	XCHG			(DE) = PROPOSED NEW LALPTR
	LHLD	BUFMAX
	MOV	A,L		SEE IF WOULD EXCEDE MEMORY
	SUB	E
	MOV	A,H
	SBB	D
	RC			CBO1 => NO ROOM

*	HAVE ROOM. READ A LINE.

	LHLD	LALPTR
	XCHG
	LXI	B,128
	LXI	H,INFB
	CALL	$FREAL		READ LINE
	JC	READ2		EOF
	XCHG			(HL) = NEW LWA+1
	SHLD	LALPTR		UPDATE POINTER
	JMP	READ0		READ SOME MORE

*	AT EOF

READ2	CALL	$TYPTX
	DB	NL,'End of Fil','e'+200Q
	LXI	H,INFB
	CALL	$FCLO		CLOSE BUFFER: AM DONE
	STC
	CMC			CLEAR CARRY
	RET
	STL	'SEARCH - SEARCH COMMAND.'
	EJECT
SEARCH	SPACE	4,10
**	SEARCH - PROCESS SEARCH COMMAND.
*

SEARCH	EQU	*

*	DECODE SEARCH STRING

	CALL	GTC		GET DELIMITER
	MOV	B,A		(B) = DELIMITER
	LXI	H,EDIA
	CALL	RDS		READ DELIMITER STRING
	MOV	A,C
	ANA	A
	JZ	REFUSE		NULL STRING IS ILLEGAL
	CALL	RCR		REQUIRE CR

*	TRY TO FIND LINE.

SEA0	LHLD	LALPTR
	MOV	A,H
	ORA	L
	JZ	SEA2		NO DATA IN BUFFER
	CALL	SLB		SCAN LINE BACKWARDS
	SHLD	CRLPTR		SET COMMAND LIMIT
SEA1	CALL	SEL.		SCAN FOR ELIGIBLE LINE
	JZ	SEA2		NONE IN BUFFER
	LHLD	WRKPTR		(HL) = ADDRESS OF TEXT LINE
	LXI	D,EDIA
	CALL	SFS		SEE IF FOUND
	JZ	SEA3		FOUND IT
	CALL	ACL		ADVANCE LINE
	JNZ	SEA1		MORE GO TO

*	NOT FOUND IN THIS BUFFER.

SEA2	LDA	INFB+FB.FLG
	ANI	FT.OR
	JZ	SEA4		AT END OF FILE
	CALL	NEXT.		ADVANCE TEXT
	LHLD	FILPTR
	SHLD	CRFPTR
	SHLD	WRKPTR
	JMP	SEA0

*	FOUND IT

SEA3	DI			LOCK OUT CTL-C
	LHLD	WRKPTR
	SHLD	PCFPTR
	SHLD	PCLPTR		SET BOUNDS TO FOUND LINE
	EI			RE-ALLOW CTL-C
	JMP	PLA		PRINT LINE AFTER

*	NOT FOUND ANYWHERE.

SEA4	CALL	$TYPTX
	DB	NL,'Not Foun','d'+200Q
	RET
	STL	'USE - PROCESS USE COMMAND.'
	EJECT
USE	SPACE	4,10
**	USE - TYPE MEMORY STATISTICS.
*

USE	EQU	*
	CALL	RCR		REQUIRE CARRIAGE RETURN
	LXI	B,0		(BC) = LINE COUNT

USE1	CALL	SEL		SCAN FOR ELIGIBLE LINE
	JZ	USE2		NO MORE
	INX	B		COUNT LINE
	CALL	PLB		PRINT LINE BEFORE
	CALL	PLA		PRINT LINE AFTER
	CALL	ACL		ADVANCE COMMAND LINE
	JNZ	USE1		LOOP IF MORE IN RANGE

*	(BC) = COUNT OF LINES WITHIN RANGE

USE2	MVI	A,5
	LXI	H,USEB
	CALL	$UDD
	LHLD	FILPTR
	XCHG			(DE) = FIRST TEXT BYTE ADDRESS
	LHLD	LALPTR		(HL) = LAST TEXT BYTE ADDRESS
	PUSH	H		SAVE
	MOV	A,L
	SUB	E
	MOV	C,A
	MOV	A,H
	SBB	D
	MOV	B,A		(BC) = BYTES USED
	MVI	A,5
	LXI	H,USEC
	CALL	$UDD
	POP	D		(DE) = LAST
	MOV	A,D
	ORA	E
	JNZ	USE3		NON-ZERO
	LXI	D,BUFFER
USE3	EQU	*
	LHLD	BUFMAX		(HL) = MAX BUFFER SIZE
	MOV	A,L
	SUB	E
	MOV	C,A
	MOV	A,H
	SBB	D
	MOV	B,A		(BC) = AMOUNT UNUSED
	MVI	A,5
	LXI	H,USED
	CALL	$UDD		UNPACK COUNT
	CALL	$TYPTX
	DB	'Lines = '
USEB	DB	'XXXXX',NL,'Used  = '
USEC	DB	'XXXXX',NL,'Free  = '
USED	DB	'XXXXX',ENL
	RET
	STL	'WRITE - PROCESS WRITE COMMAND.'
	EJECT
WRITE	SPACE	4,10
**	WRITE - WRITE LINES TO OUTPUT FILE.
*
*	WRITE TEXT BLOCKS FROM THE TOP OF THE BUFFER UNTIL THE CURRENT
*	LINE

WRITE	EQU	*
	CALL	RCR
WRITE.	MVI	A,MI.NOP	DELETE TEXT AFTER WRITE
WRI..	STA	WRIA		SET FLAG
	LHLD	FILPTR
	SHLD	WRKPTR		START AT TOP OF TEXT
	LDA	OUTFB+FB.FLG
	ANI	FT.OW
	JZ	WRI4		REQUIRE NEWOUT

*	SEE IF MORE TEXT TO WRITE.

	LHLD	CRFPTR
	MOV	A,H
	ORA	L
	JZ	WRI3		NO DATA

*	WRITE ANOTHER LINE

	LHLD	WRKPTR
	XCHG			(DE) = CURRENT LINE
WRI1	LHLD	CRFPTR		(HL) = LIMIT
	CALL	$CDEHL		COMPARE
	PUSH	PSW		SAVE RESULTS
	LXI	H,OUTFB
	CALL	$FWRIL		WRITE LINE
	POP	PSW		(A) = RESULTS OF TEST
	JNE	WRI1		MORE TO TO

*	END OF WRITTING. DELETE LINES WRITTEN.

WRI3	EQU	*
WRIA	NOP			SET TO *RET* FOR SAVE
	LHLD	CRFPTR
	SHLD	CRLPTR		SET LINES WRITTEN AS COMMAND RANGE
	LHLD	FILPTR
	SHLD	CRFPTR
	SHLD	WRKPTR
	JMP	DEL0		DELETE

*	REQUIRE NEWOUT

WRI4	CALL	$TYPTX
	DB	NL,BELL,'No Output Fil','e'+200Q
	JMP	EDIX
	STL	'SUBROUTINES.'
	EJECT
ACL	SPACE	4,10
**	ACL - ADVANCE COMMAND LINE.
*
*	ACL ADVANCES WRKPTR TO THE NEXT COMMAND LINE.
*
*	EXIT	(WRKPTR) UPDATED
*		(HL) = (WRKPTR)
*		'Z' SET IF AT END OF RANGE
*	USES	A,F,H,L

ACL	PUSH	D
	LHLD	CRLPTR
	XCHG
	LHLD	WRKPTR
	CALL	$CDEHL		COMPARE
	POP	D
	RZ			IF AT END
	CALL	SNL		SCAN TO NEXT LINE
	SHLD	WRKPTR
	ORA	H		CLEAR 'Z'
	RET
ATL	SPACE	4,10
**	ATL - ACCEPT TEXT LINE
*
*	ATL READS A LINE OF TEXT FROM THE CONSOLE INTO *LINE*.
*
*	THE LINE IS TERMINATED BY A 00 BYTE
*
*	ENTRY	NONE
*	EXIT	(HL) = #LINE
*		(A) = BYTE COUNT
*	USES	A,F,H,L

ATL	LXI	H,LINE
	XRA	A
	STA	S.CSLMD		SET LINE-MODE INPUT
	CALL	$RTL		READ LINE
	RNC			NOT CTL-D
	JMP	EXIT		CTL-D STRUCK
AYS	SPACE	4,10
**	AYS - ASK ARE YOU SURE?
*
*	AYS PROMPTS THE USER, 'SURE?'
*	AND GETS HIS REPLY.
*
*	ENTRY	NONE
*	EXIT	'C' SET IF CTL-D
*		'C' CLEAR IF NOT CTL-D
*		 'Z' SET IF SURE
*	USES	ALL

AYS	CALL	$TYPTX
	DB	BELL,'Are You Sure?',' '+200Q
	CALL	$RCHAR
	CALL	$WCHAR		ECHO
	CALL	$MCU		MAP TO UPPER
	CPI	CTLD
	STC			ASSUME CTL-D
	RE			CTL-D
	SUI	'Y'		SEE IF 'Y'
	ANA	A		CLEAR CARRY
	RET			RETURN WITH CODES SET
CBE	SPACE	3,10
**	CBE - CHECK FOR BUFFER EMPTY.
*
*	IF FILPTR=LALPTR, ZERO POINTERS.

CBE	LHLD	FILPTR
	XCHG
	LHLD	LALPTR
	CALL	$CDEHL
	RNE			NOT EMPTY
	JMP	PURGE.		HAVE DELETED ALL.
CBO	SPACE	4,10
**	CBO - CHECK BUFFER OVERFLOW
*
*	CBO IS CALLED BY COMMANDS WHICH MAY INCREASE THE SIZE
*	OF THE BUFFER TEXT. IF THERE IS NOT ROOM ENOUGH FOR
*	THE MAXIMUM SIZE INCREASE (120 CHARACTERS), AN OVERFLOW
*	IS DECLARED.
*
*	ENTRY	NONE
*	EXIT	TO (RET) IF OK
*	USES	A,F

CBO	PUSH	H
	PUSH	D
	LHLD	LALPTR
	LXI	D,120
	DAD	D
	XCHG			(DE) = NEW LIMIT
	LHLD	BUFMAX
	MOV	A,L
	SUB	E
	MOV	A,H
	SBB	D
	POP	D
	POP	H
	RNC			IS OK
CBO1	CALL	$TYPTX
	DB	NL,BELL,'Not Enough RA','M'+200Q
	JMP	EDIX		ABORT COMMAND
CDV	SPACE	4,10
**	CDV - CHECK DECIMAL VALIDITY.
*
*	CDV EXAMINES THE NEXT CHARACTER TO SEE IF IT IS A DECIMAL
*	DIGIT.
*
*	ENTRY	NONE
*	EXIT	NEXT CHARACTER NOT READ
*		'C' SET IF OK
*		 (A) = DIGIT VALUE (0=9)
*		'C' SET IF NOT DECIMAL DIGIT

CDV	CALL	ENC		EXAMINE NEXT CHARACTER
	SUI	'0'
	RC
	CPI	9+1
	CMC
	RET
DCC	SPACE	4,10
**	DCC - DISABLE CTL-C PROCESSING.
*
*	DCC IS CALLED WHEN A PROCESSOR IS ABOUT TO ENTER SENSITIVE CODE.
*	CTL-C'S WILL BE HELD UNTIL A COMPANION CALL TO 'ECC' IS MADE.
*
*	ENTRY	NONE
*	EXIT	NONE
*	USES	NONE

DCC	PUSH	PSW
	MVI	A,1
	STA	CCFLG		FLAG DISABLED
	POP	PSW
	RET
DDN	SPACE	4,10
**	DDN - DEOCDE DECIMAL NUMBER.
*
*	ENTRY	NONE
*	EXIT	(BC) = VALUE (IF NON-NULL)
*		TO 'REFUSE' IF NULL
*	USES	A,B,C,F

DDN	PUSH	H
	PUSH	D
	CALL	CDV		CHECK DECIMAL VALUE
	JC	REFUSE		NOT DECIMAL DIGIT
	LXI	D,0		(DE) = ACCUMULATOR
DDN1	CALL	CDV		CHECK DECIMAL VALUE
	JC	DDN2		NO MORE DIGITS
	CALL	$MU10		(HL) = (DE)*10
	JC	REFUSE		OVERFLOW
	MOV	E,A
	MVI	D,0		(DE) = DIGIT VALUE
	DAD	D
	JC	REFUSE		NO GOOD
	XCHG			(DE) = VALUE
	CALL	GNC		READ DECIMAL VALUE
	JMP	DDN1		ACCEPT ANOTHER

*	NUMBER ACCUMULATED, RETURN.

DDN2	MOV	B,D
	MOV	C,E
	POP	D
	POP	H
	RET
DTBK	SPACE	4,10
**	DTBK	-  DELETE TEXT BLOCK
*
*	DTBK DELETES THE SPECIFIED TEXT BLOCK FROM THE TABLE
*
*
*	ENTRY:	A	=  COUNT
*		HL	=  ADDRESS IN BLOCK
*
*	EXIT:	NONE
*
*	USES:	PSW

DTBK	PUSH	B
	MOV	C,A
	MVI	B,0		BC = FULL WORD COUNT
	CALL	DTBK.
	POP	B
	RET
DTBK.	SPACE	4,10
**	BC	= FULL WORD COUNT
*

DTBK.	PUSH	H
	PUSH	D
	XCHG			DE = BUFFER ADDRESS

*	FIX POINTERS THAT WILL MOVE

	LHLD	CRLPTR		HL = CURRENT RANGE LAST POINTER
	CALL	CPDEHL
	JC	DTBK1		DELETION IS NOT IN RANGE
	JZ	DTBK1		DELETION IS NOT IN RANGE

	CALL	DTBK3		HL = HL - BC
	SHLD	CRLPTR
DTBK1	EQU	*

	LHLD	LALPTR
	PUSH	H
	CALL	DTBK3		HL = HL - BC
	SHLD	LALPTR
	POP	H

	XCHG			HL = ADDRESS IN BUFFER
	PUSH	H		SAVE DESTINATION
	DAD	B
	XCHG			DE = SOURCE ADDRESS
	CALL	DTBK4		BC = HL - DE
	POP	H		HL = DESTINATION ADDRESS

DTBK2	CALL	$MOVL

	POP	D
	POP	H
	RET
	SPACE	4,10
DTBK3	MOV	A,L
	SUB	C
	MOV	L,A
	MOV	A,H
	SBB	B
	MOV	H,A
	RET
	SPACE	4,10
DTBK4	MOV	A,L
	SUB	E
	MOV	C,A
	MOV	A,H
	SBB	D
	MOV	B,A
	RET
ECC	SPACE	4,10
**	ECC - ENABLE CTL-C.
*
*	ECC IS CALLED TO RESTORE CTL-C PROCESSING AFTER
*	A CALL TO *DCC*
*
*	IF A CTL-C WAS HIT IN THE INTERIM, IT WILL BE PROCESSED NOW.
*
*	ENTRY	NONE
*	EXIT	TO CTL-C PROCESSOR IF ONE WAS STRUCK
*	USES	NONE

ECC	PUSH	PSW
	DI			INTERLOCK
	XRA	A
	STA	CCFLG		CLEAR FLAG
	LDA	CCPEND
	EI
	ANA	A
	JNZ	INTRPT. 	PROCESS THAT NOW			/3.0a/
	POP	PSW
	RET
ENC	SPACE	4,10
**	ENC - EXAMINE NEXT CHARACTER.
*
*	ENC RETURNS A PREVIEW OF THE NEXT INPUT CHARACTER. THE CHARACTER
*	'POINTER' IS NOT UPDATED.
*
*	ENTRY	NONE
*	EXIT	(A) = CHARACTER
*	USES	A,F

ENC	LDA	ENCA
	ANA	A
	RNZ			HAVE CHARACTER

*	MUST READ ANOTHER CHARACTER FROM LINE OR TERMINAL.

	PUSH	H
	LHLD	LINPTR
	MOV	A,L
	INR	A
	PUSH	PSW		SAVE FOR LATER COMPARE
	MOV	A,M		(A) = CHARACTER
	INX	H
	ANA	A
	JNZ	ENC1		GOT CHARACTER IN LINE

*	MUST READ ANOTHER CHARACTER FROM TERMINAL

	LDA	PROCHA
	ANA	A
	CNZ	$WCHAR		ECHO PROBATION CHARACTER
	CALL	$INCHA		READ ANOTHER CHARACTER
	CPI	CTLD
	JE	EXIT		IS CTL-D
	LHLD	LINPTR
	MOV	M,A		STORE IN LINE
	STA	PROCHA		PUT ON 'PROBATION'
	INX	H
	MVI	M,0
ENC1	SHLD	LINPTR		UPDATE LINE POINTER
	STA	ENCA		SET PRE-READ CHARACTER
	MOV	H,A		SAVE CHARACTER
	POP	PSW		(A) = PREVIOUS *L* VALUE+1
	CMP	L
	JNE	EDI1		BACKSPACE OR RUBBOUT
	MOV	A,H		(A) = SAVED CHARACTER
	POP	H		RESTORE (HL)
	RET

ENCA	DB	0		HELD CHARACTER
ERROR	SPACE	4,10
**	ERROR - PROCESS ERROR MESSAGES.
*
*	ERROR IS CALLED WHEN A FILE ERROR OCCURS.
*	IT EXITS TO *RESTART*, WHICH CLEANS THE STACK.
*
*	ENTRY	(A) = ERROR CODE
*	EXIT	TO RESTART
*	USES	ALL

ERROR	PUSH	PSW		SAVE CODE
	CALL	$TYPTX
	DB	NL,BELL,'Error -',' '+200Q
	POP	PSW
	MVI	H,NL
	SCALL	.ERROR
	JMP	RESTART
GNC	SPACE	4,10
**	GNC - GET NEXT CHARACTER.
*
*	GNC READS THE NEXT CHARACTER, AND ADVANCES THE POINTER.
*
*	ENTRY	NONE
*	EXIT	(A) = CHARACTER
*	USES	A,F

GNC	CALL	ENC		EXAMINE NEXT
	PUSH	PSW		SAVE CHARACTER
	XRA	A
	STA	ENCA		CLEAR HELD CHARACTER
	POP	PSW
	RET
GTC	SPACE	4,10
**	GTC - GET TEXT CHARACTER.
*
*	GTC GETS A CHARACTER FROM THE INPUT STREAM, AND REQUIRES IT TO B
*	PRINTABLE CHARACTER.
*
*	ENTRY	NONE
*	EXIT	(A) = CHARACTER
*	USES	A,F

GTC	CALL	ENC
	CPI	TAB
	JE	GNC		ALLOW TABS
	CPI	FF
	JE	GNC		ALLOW FORM FEEDS
	CPI	20H
	JC	REFUSE		BAD
	JMP	GNC		GET IT AND RETURN
ITBK	SPACE	4,10
**	ITBK	-  INSERT TEXT BLOCK
*
*	ITBK INSERTS THE SPECIFIED NUMBER OF BYTES INTO
*	THE SPECIFIED TEXT BLOCK AT THE SPECIFIED ADDRESS.
*
*
*	ENTRY:	A	= COUNT
*		HL	= ADDRESS IN BUFFER
*
*	EXIT:	NONE
*
*	USES:	PSW

ITBK	PUSH	B
	MOV	C,A
	MVI	B,0		BC = FULL WORD COUNT
	CALL	ITBK.
	POP	B
	RET
ITBK.	SPACE	4,10
**	BC	= FULL WORD COUNT
*

ITBK.	PUSH	H
	PUSH	D
	XCHG			DE = ADDRESS IN BUFFER

*	FIX MOVING POINTERS

	LHLD	CRLPTR
	CALL	CPDEHL
	JC	ITBK1		DELETION IS NOT IN RANGE
	JZ	ITBK1		DELETION IS NOT IN RANGE

	DAD	B
	SHLD	CRLPTR		UPDATE CURRENT RANGE LAST POINTER
ITBK1	EQU	*

	LHLD	LALPTR
	PUSH	H
	DAD	B
	SHLD	LALPTR
	POP	H

	PUSH	B		SAVE COUNT
	CALL	DTBK4		BC = HL - DE
	POP	H		HL = COUNT
	DAD	D		HL = HL + DE = DESTINATION

	JMP	DTBK2		MOVE IT OUT
LQS	SPACE	4,10
**	LQS - LOCATE QUOTED STRING.
*
*	LQS FINDS A QUOTED STRING IN A TEXT LINE.
*
*	THE LINE IS EXPANDED INTO WRKSTR, AND THE SEARCH IS MADE.
*
*	ENTRY	(HL) = ADDRSS OF STRING
*	EXIT	'Z' SET IF FOUND
*		(DE) = ADDRESS IN LINWRK, IF FOUND
*		(HL) UNCHANGED
*	USES	A,F,D,E

LQS	XCHG
	LHLD	WRKPTR		POINT TO TEXT
	CALL	SFS		SEARCH FOR STRING
	XCHG
	RET
MAM	SPACE	4,10
**	MAM - REQUEST MAXIMUM MEMORY ALLOCATION.
*
*	MAM REQUESTS THE MAXIMUM MEMORY AVAILABLE SO THAT THE HDOS OVERLAY
*	CAN REMAIN RESIDENT.
*
*	THE SPACE IS GIVEN TO *BUFFER*.
*
*	* * NOTE * * - SOME OF THE MOVE AND MANAGEMENT ROUTINES
*	USED BY *EDIT* CANNOT HANDLE TRANSFERS OF >32768, THEREFORE
*	MAM REFUSES TO ALLOCATE MORE THAN 32000 TO THE BUFFER. 
*	DONT CHANGE THIS WITHOUT CAREFULLY CHECKING THINGS.
*
*	* * NOTE * * - THIS HOPEFULLY HAS BEEN FIXED AS OF  /80.02.GC/
*
*	ENTRY	NONE
*	EXIT	NONE
*	USES	NONE

MAM	CALL	$SAVALL
	LHLD	S.SYSM
	LXI	D,-10
	DAD	D
	JMP	MIM1		REQUEST AND STORE
MIM	SPACE	4,10
**	MIM - REQUEST MINIMUM MEMORY.
*
*	MIM SETS THE CURRENT PROGRAM SIZE TO THE MINIMUM POSSIBLE 
*	(IMMEDIATELY ABOVE THE LAST TEXT IN MEMORY)
*
*	ENTRY	NONE
*	EXIT	NONE
*	USES	NONE

MIM	CALL	$SAVALL
	LHLD	LALPTR
	MOV	A,H
	ORA	L
	JNZ	MIM0		HAVE TEXT

*	NO TEXT, JUST LOOK AT BUFFER SIZE

	LXI	H,BUFFER

MIM0	LXI	D,32
	DAD	D		ADD SOME SLOP
MIM1	SHLD	BUFMAX
	XCHG			(DE) = NEW LIMIT
	LHLD	S.USRM
	CALL	$CDEHL		SEE IF ALREADY HAVE THAT AMOUNT
	JE	$RSTALL		DONT ASK, WE HAVE IT!
	XCHG			(HL) = AMOUNT TO ASK FOR
	SCALL	.SETTP
	JNC	$RSTALL		IF OK, RESTORE AND EXIT
	JMP	ERROR
PLA	SPACE	4,10
**	PLA - PRINT LINE AFTER.
*
*	PLA PRINTES THE LINE IF THE *A* OPTION HAS BEEN SPECIFIED.
*
*	ENTRY	(WRKPTR) = LINE POINTER
*	EXIT	NONE
*	USES	A,F

PLA	LDA	OPTS
	ERRNZ	OPT.A-1
	RAR
	RNC			NOT SET
	JMP	TTX.		TYPE TEXT
PLB	SPACE	4,10
**	PLB - PRINT LINE BEFORE.
*
*	PLB PRINTS THE WORKING LINE IF TGE *BEFORE* OPTION IS
*	SELECTED.
*
*	ENTRY	(WRKPTR) = NEXT LINE TO CONSIDER
*	EXIT	(HL) = (WRKPTR)
*	USES	A,F,H,L

PLB	LDA	OPTS
	ANI	OPT.B
	RZ			NOT SET
	JMP	TTX.		TYPE TEXT
RCR	SPACE	4,10
**	RCR - REQUIRE CARRIAGE RETURN.
*
*	RCR IS CALLED BY THOSE COMMANDS WHICH END WITH A CARRIAGE
*	RETURN, TOO MAKE SURE THAT CARRIAGE RETURN WAS ENTERED.
*
*	ENTRY	NONE
*	EXIT	NONE
*	USES	A,F

RCR	CALL	GNC
	CPI	NL
	JNE	REFUSE		NO GOOD
	CALL	$CRLF		ECHO CRLF
	PUSH	H		SAVE (HL)
	LHLD	CRFPTR
	SHLD	PCFPTR		SAVE PREVIOUS COMMAND BOUNDS
	LHLD	CRLPTR
	SHLD	PCLPTR
	POP	H
	RET
RQS	SPACE	4,10
**	RQS - READ QUOTED STRING
*
*	RQS READS A QUOTED STRING FROM THE INPUT LINE, AND PLACES
*	IT IN MEMORY.
*
*	ENTRY	(HL) = ADDRESS FOR STRING
*	EXIT	(HL) = UNCHANGED
*		STRING IN MEMORY
*	USES	A,F

RQS	PUSH	H
	PUSH	D		SAVE (DE)
	CALL	GNC		READ INITIAL QUOTE
	MVI	D,40

*	READ ANOTHER CHARACTER

RQS1	DCR	D
	JZ	REFUSE		TOO MANY CHARACTERS
	CALL	GTC		GET TEXT CHARACTER
	CPI	QUOTE
	MOV	M,A		STORE IN MEMORY
	INX	H
	JNE	RQS1		NOT QUOTE

*	HAVE QUOTE

	CALL	ENC		EXAMINE NEXT
	CPI	QUOTE
	JNE	RQS2		SONGLE QUOTE - EXIT

*	HAVE DOUBLE QUOTE

	CALL	GTC		READ '
	JMP	RQS1

*	END OF STRING

RQS2	DCX	H
	MVI	M,0		END STRING
	POP	D
	POP	H
	RET
RSL	SPACE	4,10
**	RSL - REPLACE SINGLE LINE.
*
*	RSL REPLACES A SINGLE LINE IN THE TEXT BLOCK WITH A LINE
*	IN MEMORY.
*
*	ENTRY	(HL) = REPLACEMENT LINE ADDRESS
*		(C) = LENGTH
*		(WRKPTR) = ADDRESS IN BLOCK OF LINE TO REPLACE
*	EXIT	LINE REPLACED
*	USES

RSL	CALL	DCC		DISABLE CTL-C
	XCHG
	LHLD	WRKPTR
	CALL	$CLL		CHECK OLD LINE LENGTH
	SUB	C		OLD - NEW
	JC	RSL1		OLD < NEW

*	OLD >= NEW, DELETE EXTRA BYTES

	CALL	DTBK		DELETE BLOCK
	JMP	RSL2

*	OLD <  NEW, INSERT EXTRA BYTES

RSL1	CMA
	INR	A
	CALL	ITBK		INSERT BLOCK
	ERRNZ	*-RSL2

*	MOVE THE TEXT ACTUALLY IN

RSL2	EQU	*
	MVI	B,0
	CALL	$MOVL		ISNERT LINE
	CALL	ECC		RESTORE CTL-C PROCESSING
	JMP	PLA		PRINT LINE AFTER AND RETURN
R8N	SPACE	4,10
**	R8N - READ 8 BIT NUMBER.
*
*	R8N READS AN 8 BIT NUMBER FROM THE COMMAND STREAM.
*
*	ENTRY	NONE
*	EXIT	(A) = VALUE
*		TO 'REFUSE' IF BAD
*	USES	A,B,C,F

R8N	CALL	DDN		DECODE NUMBER
	MOV	A,B
	ANA	A
	JNZ	REFUSE		TOO LARGE
	MOV	A,C		(A) = VALUE
	RET
SEL	SPACE	4,10
**	SEL - SCAN FOR ELIGIBLE LINE.
*
*	SEL SCANS TO FIND THE NEXT LINE MEETING THE QUALIFIER STRING.
*
*	* * NOTE * *  'DELETE' ASSUMES THAT SEL ONLY CHECKS FOR
*		QUALIFIER STRINGS IN Q"QUALS", AND SKIPS
*		CALLING SEL IF "QUALS" IS 00. THIS MUST BE MODIFIED IF MORE
*		QUALIFIACTION SPECIFICATIONS ARE ALLOWED IN THE FUTURE.
*
*	ENTRY	(WRKPTR) = NEXT LINE TO CONSIDER
*	EXIT	(WRKPTR) = NEXT LINE TO PROCESS
*		(HL) = (WRKPTR)
*		'Z' SET IF NO MORE LINES
*	USES	A,F,H,L

SEL1	CALL	ACL		ADVANCE COMMAND LINE
	RZ			DONE

SEL.	CALL	CBO		CHECK FOR BUFFER OVERFLOW
SEL	LHLD	WRKPTR
	MOV	A,H
	ORA	L
	RZ			NO TEXT ESISTS
	LXI	H,QUALS
	MOV	A,M
	ANA	A
	JZ	SEL2		NO QUAL STRING

*	SEE IF MEET QUALIFIER STRING

	PUSH	D
	CALL	LQS		LOCATE QUOTED STRING
	POP	D
	JNZ	SEL1		DONT HAVE IT

*	HAVE QUALIFIED LINE.

SEL2	LHLD	WRKPTR
	ORA	H		CLEAR 'Z'
	RET
SFS	SPACE	4,10
**	SFS - SEARCH FOR STRING.
*
*	SFS SCANS AN EXPANDED CHARACTER STRING FOR A MATCH FOR
*	SOME PATTERN STRING
*
*	ENTRY	(DE) = STRING ADDRESS
*		(HL) = LINE ADDRESS
*	EXIT	(DE) UNCHANGED
*		(HL) = ADDRESS OF 1ST MATCH CHARACTER
*	USES	A,F,H,L

SFS	PUSH	D		SAVE STRING ADDRESS
	PUSH	H
	MOV	A,M
	ANA	A
	MVI	A,1
	JZ	SFS2		NOT FOUND - NO MORE TEXT

*	COMPARE STRINGS

SFS1	LDAX	D
	ANA	A
	JZ	SFS2		A MATCH
	CMP	M
	INX	D
	INX	H
	JE	SFS1		KEEP TRYING

*	A FAILURE

	POP	H
	POP	D
	INX	H
	JMP	SFS

SFS2	POP	H
	POP	D
	ANA	A		SET 'Z' IF FOUND
	RET
SLB	SPACE	4,10
**	SLB - SCAN LINE BACKWARDS.
*
*	SLB SCANS BACKWARDS OVER THE PREVIOUS LINE.
*
*	ENTRY	(HL) = 1ST BYTE OF CURRENT LINE
*	EXIT	(HL) = FIRST BYTE OF PREVIOUS LINE
*	USES	A,F,H,L

SLB	DCX	H
SLB1	DCX	H
	MOV	A,M
	ANA	A
	JNZ	SLB1
	INX	H
	RET
SNL	SPACE	4,10
**	SNL - SCAN TO NEXT LINE.
*
*	SNL SCANS THE TEXT BLOCK FOR THE NEXT LINE.
*
*	ENTRY	(HL) = START OF CURRENT LINE
*	EXIT	(HL) = START OF NEXT LINE
*	USES	A,F,H

SNL	MOV	A,M
	INX	H
	ANA	A
	JNZ	SNL
	RET
TTX	SPACE	4,10
**	TTX - TYPE TEXT LINE.
*
*	TTX TYPES THE TEXT FOR A LINE.
*
*	ENTRY	(HL) = FIRST BYTE
*	EXIT	(HL) UNCHANGED
*	USES	A,F

TTX.	LHLD	WRKPTR
TTX	CALL	$CLL		COMPUTE LENGTH
	PUSH	H		SAVE ADDRESS
	DCR	A		REMOVE COUNT OF '00'
	CALL	$TYPCC		TYPE IT
	POP	H
	JMP	$CRLF
	STL	'COMMON DECKS.'
	EJECT
	XTEXT	CLL
	XTEXT	CCO
	XTEXT	INCHA
	XTEXT	UDD
	XTEXT	MLU
	XTEXT	GNL
	XTEXT	MCU
	XTEXT	CHL
	XTEXT	CPDEHL
	XTEXT	SAVALL
	XTEXT	RTL
	XTEXT	MOVLL
	XTEXT	TYPCC
	XTEXT	TYPCH
	XTEXT	RCHAR
	XTEXT	INDL
	XTEXT	TBLS
	XTEXT	CDEHL
	XTEXT	CRLF
	XTEXT	DADA
	XTEXT	MOVL
	XTEXT	MU10
	XTEXT	TBRA
	XTEXT	FOPE
	XTEXT	FCLO
	XTEXT	FREAL
	XTEXT	FWRIL
	XTEXT	FWRIB
	XTEXT	FUTIL
	XTEXT	FERROR
	XTEXT	TJMP
	XTEXT	TYPTX
	STL	'CMDTAB - COMMAND TABLE.'
	EJECT
**	CMDTAB - COMMAND TABLE.
*

CMDTAB	EQU	*
	DB	0		DUMY FIRST COMMAND
	DB	'PRINT',0
	DB	'DELETE',0
	DB	'EDIT',0
	DB	'REPLACE',0
	DB	'WRITE',0
CMDTAB.	EQU	*		THESE COMMANDS ALLOWED WITH NO TEXT
	DB	'XPRINT',0	IS DUMMY COMMAND FOR 2ND GROUP, REAL COMMAND FOR 1ST
	DB	'INSERT',0
	DB	'READ',0
	DB	'BLITZ',0
	DB	'FLUSH',0
	DB	'NEXT',0
	DB	'SEARCH',0
	DB	'NEWIN',0
	DB	'NEWOUT',0
	DB	'XOUT',0
	DB	'USE',0
	DB	'BYE',0
	DB	0
	STL	'PATCH AREA'
	EJECT
PATCH	DC	64,#0AAH
	STL	'DATA STRUCTURES.'
	EJECT
	SPACE	3,10
**	LINE POINTERS INTO TEXT PAGE.

FILPTR	DW	0		ADDRESS OF 1ST LINE IN BUFFER
LALPTR	DW	0		ADDRESS OF END OFLAST LINE IN BUFFER +1
CRFPTR	DW	0		COMMAND RANGE 1ST LINE POINTER
CRLPTR	DW	0		COMMAND RANGE LAST LINE POINTER
WRKPTR	DW	0		COMMAND RANGE WORKING POINTER
PCFPTR	DW	0		PREVIOUS COMMAND 'FIRST' POINTER
PCLPTR	DW	0		PREVIOUS COMMAND 'LAST' POINTER

CCFLG	DB	0		<>0 IF CTL-C DISABLED
CCPEND	DB	0		<>0 IF CTL-C HIT DURING DISABLED PERIOD

BUFMAX	DW	0		MAX ADDRESS FOR *BUFFER*
	SPACE	3,10
**	CELLS AND POINTERS

LINPTR	DW	0		LINE POINTER
PROCHA	DB	0		PROBATION CHARACTER
SRCDIR	DB	0		SEARCH DIRECTON
OPTS	DB	0		OPTION FLAGS

*	FILE BUFFERS

DEFALT	DB	'SY0',0,0,0	DEFAULT DEVICE AND EXTENSION

INFB	DS	0		INPUT FILE BUFFER
	DB	1		CHANNEL NUMBER
	DB	0		FLAGS
	DW	INBUF
	DW	INBUF
	DW	INBUF
	DW	INBUFE
	DC	FB.NAML,#0	NAME

OUTFB	DS	0		OUTPUT FILE BUFFER
	DB	0
	DB	0		FLAGS
	DW	OUTBUF
	DW	OUTBUF
	DW	OUTBUF
	DW	OUTBUFE
	DC	FB.NAML,#0	NAME

XOUTFB	DS	0		XOUT FILE BUFFER
	DB	2
	DB	0		FLAGS
	DW	XOTBUF
	DW	XOTBUF
	DW	XOTBUF
	DW	XOTBUFE
	DC	FB.NAML,#0	NAME
	STL	'PRESET CODE (OVERLAID BY BUFFERS)'
	EJECT
PRS	SPACE	4,10
**	PRS - PERFORM PRESET PROCESSING.
*
*	THIS CODE IS ONLY USED UPON ENTRY, AND THEN IS OVERLAID BY BUFFERS.
*
*	IT	1) TYPES THE BANNER MESSAGE
*		2) DETERMINES THE MEMORY SIZE
*		3) PRESETS THE TEXT PAGE TO NULL
*
*	ENTRY	NONE
*	EXIT	DATA STRUCTURE INITIALIZED

ENTRY	EQU	*
	XRA	A
	STA	BUFFER-1	SET DUMY END-OF-LINE FOR BUFFER
	STA	LINE-1		SETUP 00 BYTE REQUIRED BEFORE *LINE*

*	CHECK VERSION

	SCALL	.VERS
	JC	PRSERR1		PROBABLY NO .VERS SYSTEM CALL
	CPI	VERS
	JNZ	PRSERR1		NOT THE CORRECT VERSION

*	SETUP HIGH MEMORY

	CALL	MAM		SET MAXIMUM MEMORY SIZE

*	SETUP CTL-C PROCESSING

	LXI	H,INTRPT
	MVI	A,CTLC
	SCALL	.CTLC

*	set default block

	LHLD	S.DFBLK
	LDA	S.DFBLK+2

	SHLD	DEFALT
	STA	DEFALT+2

*	signon and begin

	CALL	$TYPTX
	DB	'EDIT Issue #103.07.00',ENL			/WCZ080480/
	JMP	START		STARTUP

PRSERR1	MVI	A,EC.NCV	NOT THE CORRECT VERSION

ENTEXT	MVI	H,NL
	SCALL	.ERROR		THERE WAS AN ERROR UPON ENTRY
	XRA	A
	SCALL	.EXIT
	SPACE	4,8
**	"what" identification

	DB	'@(#)HDOS 3.0 Line Editor',NL
	DW	.DATE.
	DW	.TIME.
	SPACE	3
**	BUFFERS OVERLAYING PRS

MEML	EQU	*		END OF LOAD IMAGE

	NOTE	MEML

	ORG	ENTRY
TEXT	SPACE	3,10
**	STRING AND TEXT STORE AREAS

	DS	1		REQUIRED 0 BEFORE 'LINE'

LINE	DS	120		LINE BUFFER
FNRA	EQU	LINE		$FNR WORK AREA
WRKSTR	DS	120		EXPANDED STRING WORK AREA
EDIA	DS	41		EDIT WORK AREA
EDIB	DS	41		EDIT WORK AREA
QUALS	DS	41		QUALIFIER STRING
NXTCHA	DS	1		NEXT COMMAND CHARACTER
PATCNT	DS	1		INDEX OF CURRENT PATTERN
CMDGRP	DS	1		ZERO IF RESTRICTED COMMAND GROUP

$FOPWRK	DS	FB.NAML		USED BY $FOPEX

INBUF	DS	512
INBUFE	EQU	*

OUTBUF	DS	512
OUTBUFE	EQU	*

XOTBUF	DS	256
XOTBUFE	EQU	*
BUFFER	SPACE	4,10
**	TEXT BUFFER.

	DS	1		0 BYTE NEEDED FOR BACKWARDS SCAN OF 1ST LINE
BUFFER	DS	0
	SPACE	3,10
	ORG	MEML

	END	ENTRY
