	SPACE	4,10
**	$FST - FIND IN SERIAL TABLE
*
*	$FST SEARCHES A SERIAL TABLE FOR
*	A SPECIFIC KEY
*
*	ENTRY	(HL) = ADDR. OF TABLE
*		(DE) = ADDR. OF SEARCH KEY
*	EXIT	(DE) = UNCHANGED
*		'Z' CLEARED IF NO MATCH FOUND
*		  (HL) = ADDR. OF NEXT AVAILABLE BYTE
*		'Z' SET IF MATCH FOUND
*		  (HL) = ADDR. OF FIRST DATA BYTE
*	USES	A,F,H,L

$FST	PUSH	B		SAVE REGISTERS
	PUSH	D

*	SAVE TABLE LIMIT AND DATA BYTE COUNT

	MOV	E,M		GET AND SAVE TABLE LIMIT
	INX	H		(HL) = 2ND BYTE OF SIZE
	MOV	D,M
	XCHG
	SHLD	$FST.L		SAVE MAX. TABLE SIZE

	XCHG
	INX	H		(HL) = # OF BYTES OF DATA/ENTRY
	MOV	A,M
	STA	$FST.C
	INX	H		(HL) = BEGINNING OF DATA
FST1	POP	D		RESTORE ADDR. TO SEARCH KEY
	PUSH	D

* 	CHECK FOR END OF DATA

	MOV	A,M
	ORA	A		AT END OF DATA? ((A) = 0)
	JNZ	FST2		NO, START MATCHING
	INR	A		CLEAR 'Z'
	POP	D
	POP	B		RESTORE REGISTERS
	RET

FST2	LDAX	D		(A) = KEY CHAR.
	CMP	M		COMPARE TO TABLE
	JNE	FST3		NO MATCH, FIND NEXT KEY
	ANA	A		END OF KEY?
	JM	FST4		YES, SET UP FOR EXIT
	INX	H
	INX	D
	JMP	FST2

FST3	MOV	A,M		SEARCH FOR END OF KEY
	ANA	A		TEST CHAR.
	INX	H
	JP	FST3		CONTINUE SEARCH
	LDA	$FST.C		(A) = # OF BYTES OF DATA/ENTRY
	ADD	L
	MOV	L,A
	MVI	A,0
	ADC	H
	MOV	H,A		(HL) = HEAD OF NEXT KEY
	JMP	FST1		COMPARE NEXT KEY

FST4	XRA	A		SET'Z' FOR EXIT
	INX	H		(HL) = FIRST BYTE OF DATA
	POP	D		RESTORE REGISTERS
	POP	B
	RET			EXIT

$FST.L  DS	2
$FST.C	DS	1
