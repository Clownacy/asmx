	TITLE	'SYSGEN - GENERATE NEW SYSTEM'
***	SYSGEN IS A CUT-DOWN FROM PIP.
*

***	PIP - PERIHPERAL INTERCHANGE PROGRAM.
*
*	J.G. LETWIN, 11/1977 FOR *HEATH* COMPANY
*
*	COPYRIGHT 1977, 1979 BY HEATH COMPANY
*
*	G. Chandler, 9/78	Maintenence release
*			79/04	Issue --.04.--
*			79/11	Issue --.05.--
*			80/07	Issue --.06.--
*	B. Parrott, 8/86
*			86/08	Issue --.07.--
*
*	80.07.gc
*		Linked list structure modified to remove page boundary
*		requirements.
*		H17 dependency removed.
*		Multiple Unit
*		Multiple Device.
*		Command Line Switch Processing
*
	SPACE	4
***	USE:
*
*		Command Line File specification replacing default.
*		/Minimal Switch
*		Destination Device specification
*
	SPACE	4,10
**	Assembly Constants

FDNCNT	EQU	8		Number of File Descriptor Nodes


**	SYSTEM EQUIVALENCES

CN.SOU	EQU	0		SOURCE CHANNEL NUMBER
CN.DES	EQU	1		DESTINATION CHANNEL NUMBER
CN.DIR	EQU	2		DIRECTORY CHANNEL NUMBER


**	PROGRAM ERROR CODES	(Must not equal ENL)

PEC.DF	EQU	200Q		DEVICE FORMAT ERROR
PEC.DNC	EQU	201Q		DEVICES NOT CONSISTANT
PEC.RSE	EQU	202Q		RENAME SPECIFICATION ERROR
PEC.TFI	EQU	203Q		TARGET FILE ILLEGAL
PEC.CS	EQU	204Q		CONTRADICTORY SWITCHES
PEC.IUW	EQU	205Q		ILLEGAL USE OF WILDCARD
PEC.IDF	EQU	206Q		ILLEGAL DESTINATION FILE FORMAT
PEC.CO	EQU	207Q		Command Overflow

	EJECT
	XTEXT	DIRDEF
	XTEXT	DIFDEF
	XTEXT	DEVDEF
	XTEXT	IOCDEF
	XTEXT	DISDEF
	XTEXT	FBDEF
	XTEXT	ECDEF
	XTEXT	OVLDEF
	XTEXT	HOSEQU
	XTEXT	HOSDEF
	XTEXT	ASCII
	XTEXT	ESINT
	XTEXT	ESVAL
	XTEXT	DDDEF
	XTEXT	MTR
	XTEXT	DDFDEF
	XTEXT	LABDEF
	XTEXT	FILDEF
	XTEXT	ABSDEF
	STL	'Structures'
	EJECT
**	Structure Definitions

	ORG	0

DEFAULT	DS	6		Default device descriptor

DEVTAB	DS	2		Device Table Address Pointer

DRIVER	DS	3		Driver Entry Point

UNIT	DS	1		Unit Number

DEVICE	DS	IOC.DIR-IOC.DEV+2	Device Specifier

DVCLEN	EQU	*
	STL	'MAIN ROUTINE'
	EJECT

	ORG	USERFWA

*	COMMAND INTERPRETATION COMES HERE

START	LXI	SP,STACK	CLEAN STACK

	XRA	A
	STA	VOLFLAG 	Initialize Source Mounted
	CALL	MSD.		Mount Source Diskette
	LHLD	SRCLAB+LAB.SER
	MVI	H,0
	MVI	A,DC.MOU
	CALL	SRCDRVR 	Call source driver
	JC	ERROR

	LDA	DRIVES2
	ANA	A		'NZ' => 2-Drive Sysgen
	CNZ	MDD		Mount Destination Diskette

*	CLEAR CHANNELS AND FILE BUFFER

	SCALL	.CLEARA		CLEAR CHANNELS

	LXI	H,0
	SHLD	BUFSIZ		EMPTY BUFFER
	SHLD	NAMTLEN		CLEAR NAMTAB
	SHLD	NAMTMAX		CLEAR NAMTAB AREA
	LXI	H,BUFF
	SHLD	BUFPTR		SET BUFFER AGAINST END OF NAMTAB

*	Copy the files

	LDA	QUERY
	PUSH	PSW		Save Query Flag
	XRA	A
	STA	QUERY		Force NO Query on required files
	CALL	CRF		Copy Required Files
	CALL	CSD		Copy System Device Drivers
	POP	PSW
	STA	QUERY		Restore Query Flag
	CALL	SSL		Set the Sysgened flag in label
	CALL	COF		Copy Optional Files

*	Type File Count

	LDA	OCOPYC		(A) = FILE COUNT
	MVI	B,0		(BC) = COUNT OF FILES COPIED
	MOV	C,A

	MVI	A,3
	LXI	H,SYSA
	CALL	$UDDN		UNPACK COUNT INTO MESSAGE
	CALL	$TYPTX
	DB	NL
SYSA	DB	'XXX'
	DB	' Files Copied',ENL

*	Dismount all Disks

	LXI	H,DEST+DEVICE
	SCALL	.DMNMS
	LXI	H,SOURCE+DEVICE	Ignore any possible errors
	SCALL	.DMNMS

	XRA	A
	JMP	EXIT.		GRACEFUL EXIT

**	NO RESTARTING ALLOWED

RESTART	EQU	*

	JMP	EXIT		EXIT

*	CTL-D HIT

EXIT	MVI	A,1		FLAG ABORT
EXIT.	SCALL	.EXIT		EXIT TO  *HDOS*
CCHIT	SPACE	3,10
**	CCHIT - CTL-C HIT
*
*	ENTRY	FROM SYSTEM


CCHIT	CALL	$TYPTX
	DB	'^','C'+200Q
	JMP	EXIT		BOOT IT
	STL	'SYSGEN - COPY FILES BETWEEN VOLUMES.'
	EJECT
CRF	SPACE	4,10
***	CRF	- Copy Required Files
*
*	CRF copies the required HDOS files accross to the
*	destination device.  Once they are copied accross,
*	they must be flagged illegal for subsequent operations
*	since we want to use the *.SYS wild-card specification
*	later on.
*
*	NOTE:	The files listed in CRFA must also be
*		specified in CSFA.
*

CRF	LDA	CSFB
	PUSH	PSW
	XRA	A
	STA	CSFB		Flag these files valid for now

	MVI	A,1
	STA	OCOPYF		copy contiguous
	LXI	H,CRFA
	CALL	OCOPY		Copy required files

	XRA	A
	STA	OCOPYF		not contiguous
	LXI	H,CRFB
	CALL	OCOPY

	POP	PSW
	STA	CSFB		Flag the files not valid
	RET

CRFA	DB	'*.*=HDOS30.SYS,TT.DVD',0
CRFB	DB	'*.*=SYSCMD.SYS,PIP.ABS',0
CSD	SPACE	4,10
***	CSD	- Copy System Drivers
*
*	CSD copies the system device drivers across.  It
*	would be nice if this could be combined with the
*	previous required files, however, to avoid rename
*	difficulties, these files are handled individually.
*
*	IF destination device name == source device name
*	  THEN
*	    just copy SY.DVD
*	  ELSE
*	    DEST:SY.DVD=SOURCE:DEST.DVD
*	    DEST:DEST.DVD=SOURCE:SY.DVD
*

CSD	MVI	A,1
	STA	OCOPYF		copy contiguous

	LHLD	SOURCE+DEVICE
	XCHG			DE = Source Device
	LHLD	DEST+DEVICE	HL = Destination Device
	ERRNZ	IOC.UNI-IOC.DEV-2
	CALL	$CDEHL
	JNZ	CSD1		DE != HL

*	Devices are equal

	LDA	CSFC
	PUSH	PSW
	XRA	A
	STA	CSFC		Flag this device valid temporarily
	STA	CSFD		Only 1 driver copied

	LXI	H,CSDA
	CALL	OCOPY

	POP	PSW
	STA	CSFC		Re-Flag SY: Illegal
	RET

*	Devices are not equal

CSD1	SHLD	CSDC		Set Destination Device
	SHLD	CSDD
	SHLD	CSFD		Set Destination Driver Illegal for later
	LDA	CSFC
	PUSH	PSW
	XRA	A
	STA	CSFC		Flag these valid for now

	LXI	H,CSDB
	CALL	OCOPY

	XRA	A
	STA	OCOPYF		copy non-contiguous
	LXI	H,CSDD
	CALL	OCOPY

	POP	PSW
	STA	CSFC
	RET

CSDA	DB	'*.*=SY.DVD',0

CSDB	DB	'SY.DVD='		Copy System Device
CSDC	DB	'xx.DVD',0

CSDD	DB	'xx.DVD=SY.DVD',0	Copy destination device over
COF	SPACE	4,10
***	COF	- Copy Optional Files
*
*	COF copies the optional files accross to the
*	destination diskette.  If  *MINIMAL*  has been
*	specified, no additional files are copied.
*	Otherwise, the default command line is used unless
*	a command line was specified at run time.

COF	LDA	MINIMUM
	ANA	A
	RNZ			Minimum switch is set

	STA	OCOPYF		copy non-contiguous

	LDA	CMDLIN
	ANA	A
	JNZ	COF1		Command line specified

*	No command line specified

	LXI	H,COFA
	JMP	OCOPY		Normal extra files

*	Command Line specified

COF1	LXI	H,OFILES
	JMP	OCOPY		All files with query

COFA	DB	'*.*=*.SYS,SET.ABS,*.DVD,SYSHELP.DOC,HELP.',0
	DC	64,#0AAH
	EJECT
SYSGEN	SPACE	4,10
***	SYSGEN - COPY FILES BETWEEN TWO VOLUMES, WITH ONLY ONE
*	DRIVE.
*
*	(AND FOR MY NEXT TRICK...)
*
*	OCOPY COPIES FILES BETWEEN TWO VOLUMES BY ALTERNATING BETWEEN
*	TWO PHASES, THE READ PHASE AND THE WRITE PHASE. 
*
*	READ PHASE:
*
*	DURING THE READ PHASE, THE SOURCE DISK IS MOUNTED. SOURCE FILES ARE
*	OPENED IN THE ORDER OF THEIR APPEARANCE. FOR EACH OPENED
*	FILE, A 'FILE DESCRIPTOR NODE' *FDN* IS ADDED  TO  THE ACTIVE
*	CHAIN. THEN, AS MUCH AS THE FILE AS POSSIBLE IS READ INTO MEMORY.
*
*	THE PROCESS CONTINUES UNTIL
*		1) THERE IS NO MORE FREE RAM
*		2) OR, THERE ARE NO MORE FILE DESCRIPTOR NODES IN THE FREE CHAIN
*		3) OR, THERE ARE NO MORE FILES IN NAMTAB (INPUT FILE LIST)
*
*
*	WRITE PHASE
*
*	DURING THE WRITE PHASE, THE DESTINATION DISK IS MOUNTED. THE NODES
*	ARE TAKEN FROM THE ACTIVE CHAIN, AND PROCESSED. IF THE FILE HAD
*	BEEN PARTIALLY WRITTEN THE LAST PASS, IT IS  RE-OPENED AND POSITIONED.
*	IF THERE IS NOT MORE DATA TO READ FOR A PROCESSED
*	NODE, IT IS REMOVED, AND THE CORRESPONDING ENTRY IN NAMTAB IS DELETED.
*
*	WRITE PHASE CONTINUES UNTIL
*
*		1) THERE ARE NO MORE FILE NODES IN THE ACTIVE LIST
*		2) OR, THE FIRST (AND ONLY) ENTRY IN THE LIST HAS NO
*		   MORE DATA IN MEMORY, BUT HAS NOT BEEN COMPLETELY READ.
*
*	OCOPY EXITS WITH THE DESTINATION DISK MOUNTED.
*
*	ENTRY:	HL	= Line Pointer
*
*	EXIT:	OCOPYC	= Number of files copied
*

OCOPY	EQU	*
	SHLD	LINEP		Initialize Line Pointer
	CALL	IFL		INITIALIZE  FDN LISTS
	CALL	DDF		DECODE DESTINATION FILE
	JC	ERROR		ERROR
	STA	OCOPYA		SAVE DESTINATION TYPE

	CALL	MSD		Mount Source to build list

	XRA	A		ALLOW *.*
	CALL	BSL		BUILD SOURCE FILE LIST
	JC	ERROR
	CALL	$MOVEL
	DW	OCOPYDL
	DW	DESTFB+FB.NAM
	DW	OCOPYD		SAVE WILDCARD DESTINATION
	CALL	EBM		EXPAND BUFFER TO MAX

*	START READ PHASE

OCOPY1	LDA	BUFPTR+1	(A) = BUFFER FWA/256
	INR	A		ROUND UP TO NEXT PAGE
	STA	OBUFPTR		SET SECTOR BUFFER  FWA/256

	CALL	MSD		Mount Source Diskette
	CALL	RPH		Read Data
	CALL	MDD		Mount Destination Diskette
	CALL	WPH		Write Data

	LHLD	FDNHED
	MOV	A,H
	ORA	L
	JNZ	OCOPY1		Source files in List

	LHLD	NAMTLEN
	MOV	A,H
	ORA	L
	JNZ	OCOPY1		MORE NAMES IN LIST

*	ALL DONE

	RET

OCOPYA	DB	0		DESTINATION FILE WILDCARD FLAG (=0 IF WC)
OCOPYC	DB	0		FILES COPIED COUNT
OCOPYD	DC	FB.NAML,#0	HOLD AREA FOR WILDCARD DESTINATION
OCOPYDL	EQU	*-OCOPYD

OCOPYF	DB	0		NZ IF TO COPY CONTIGUOUS
	STL	'SYSGEN SUBROUTINES'
	EJECT
RPH	SPACE	4,10
**	RPH - READ PHASE.
*
*	RPH  HANDLES THE READ PHASE OF THE COPY PROCESS.
*
*	IT IS ENTERED WITH THE NAMTAB AND FDN TABLE SETUP, AND
*	WITH THE SOURCE DISK MOUNTED.
*
*	READ PHASE:
*
*	DURING THE READ PHASE, THE SOURCE DISK IS MOUNTED. SOURCE FILES ARE
*	OPENED IN THE ORDER OF THEIR APPEARANCE. FOR EACH OPENED
*	FILE, A 'FILE DESCRIPTOR NODE' *FDN* IS ADDED  TO  THE ACTIVE
*	CHAIN. THEN, AS MUCH AS THE FILE AS POSSIBLE IS READ INTO MEMORY.
*
*	THE PROCESS CONTINUES UNTIL
*		1) THERE IS NO MORE FREE RAM
*		2) OR, THERE ARE NO MORE FILE DESCRIPTOR NODES IN THE FREE CHAIN
*		3) OR, THERE ARE NO MORE FILES IN NAMTAB (INPUT FILE LIST)
*
*	ENTRY	NONE
*	EXIT	NONE
*	USES	ALL


RPH	EQU	*


*	SEE IF ANY MEMORY TO HAVE

	CALL	CBR		COMPUTE BUFFER ROOM
	RZ			NONE

*	SEE IF WE NEED TO READ SOME MORE INTO A PART-COPIED FILE

	LHLD	FDNHED		HL = Head of LIST
	MOV	A,H
	ORA	L
	JZ	RPH1		LIST is empty

	CALL	$INDLB		A  = status
	DW	FDN.STA
	ANI	ST.OPR
	LXI	D,NAMTAB
	JNZ	RPH2.5		FILE IS INCOMPLETELY READ

*	SEE IF ANY FREE FILE DESCRIPTOR NODES TO USE

RPH1	LHLD	FDNFREE 	HL = Head of FREE list
	MOV	A,H
	ORA	L
	RZ			free list is empty

*	SEE IF THERE IS A FILE IN NAMTAB WITHOUT AN ENTRY IN FNDLIST.
*	SINCE THE FIRST ENTRY IN FDNLIST CORRESPONDS TO THE FIRST IN
*	NAMTAB, ETC., WE'LL JUST RUN DOWN FDNLIST UNTIL THE END, AND
*	THE NEXT NAMTAB FILE WILL BE THE ONE WE WANT...

	LXI	B,FB.NAML	(BC) = ENTRY SIZE IN NAMTAB
	LXI	D,0		(DE) = POINTER INTO NAMTAB
	LXI	H,FDNHED	HL = head of FILE list

RPH2	PUSH	H
	CALL	$HLIHL		HL = next node
	ERRNZ	FDN.LNK
	MOV	A,H
	ORA	L
	POP	H
	JZ	RPH2.2		At the end of the list

	CALL	$HLIHL		HL = next node
	ERRNZ	FDN.LNK
	XCHG
	DAD	B		ADVANCE POINTER INTO NAMTAB
	XCHG
	JMP	RPH2

RPH2.2	PUSH	H		(HL) = ADDRESS OF LAST NODE
	LHLD	NAMTLEN
	CALL	$CDEHL		SEE IF HAVE ACCOUNTED FOR ALL NAMTAB ENTRYS
	POP	H
	RE			FILES ALL USED UP

*	HAVE ROOM FOR DATA, HAVE A NODE FOR THE FILE COUNTS, AND
*	HAVE A FILE NAME. ALL SET FOR BUSINESS..
*
*	(DE) = INDEX INTO NAMTAB FOR FILE
*	(HL) = NODE ADDRESS OF LAST ENTRY IN LIST
*

*	CHAIN THE FIRST FREE NODE ONTO THE END OF THE LIST

	PUSH	D
	PUSH	H
	LHLD	FDNFREE 	HL = FREE node

	PUSH	H
	CALL	$HLIHL		HL = address of next node
	ERRNZ	FDN.LNK
	SHLD	FDNFREE 	Update FREE list head
	POP	D		DE = address of new node

	POP	H		HL = address of TAIL of list
	CALL	$INDS		tail points to the new node
	DW	FDN.LNK
	XCHG			HL = address of new node
	POP	D		DE = address in name table

	MVI	B,FDNELEN
	PUSH	H		SAVE NODE ADDRESS
	CALL	$ZERO		ZERO ENTIRE NODE, INCLUDING CHAIN (NOW AT END)
	LXI	B,NAMTAB
	XCHG
	DAD	B		(HL) = ADDRESS OF NAMTAB ENTRY
	SHLD	NAMTPTR		POINTER TO CURRENT NAMTAB ENTRY
	XCHG
	POP	H

*	READY TO OPEN FILE
*
*	(DE) = NAMTAB ENTRY ADDRESS
*	(HL) = #FDN.LNK OF ENTRY

RPH2.5	INX	H
	INX	H		HL = &FDN.STA
	ERRNZ	FDN.STA-FDN.LNK-2
	PUSH	H		SAVE ADDRESS
	XCHG
	XRA	A
	ERRNZ	CN.SOU		(A) = SOURCE CHANNEL NUMBER
	SCALL	.OPENR		OPEN
	JC	NAMERR		ERROR
	POP	D
	LDAX	D		(A) = FDN.STA
	ANI	ST.OPR
	PUSH	D		SAVE ADDRESS
	JNZ	RPH3		ALREADY OPENED IN PREVIOUS PASSES

*	FIRST TIME THIS FILE HAS BEEN OPENED. GET FLAGS.

	LXI	H,OCOPYC
	INR	M
	LDAX	D
	ORI	ST.OPR		SET OPEN FOR READ
	STAX	D
	PUSH	D		SAVE #FDN.STA
	LHLD	S.CFWA		(HL) = CHANNEL 0 FWA
	ERRNZ	IOCCTD-1	MUST SKIP A CHANNEL FOR USER #0
	CALL	$HLIHL		(HL) = #USER CHANNEL 0
	ERRNZ	CN.SOU		ASSUME WE WANT CHANNEL 0
	CALL	$INDL
	DW	IOC.DIR+DIR.FLG
	MOV	A,E		(A) = DIR.FLG
	POP	D		(DE) = #FDN.STA
	ERRNZ	FDN.FLG-FDN.STA-1
	INX	D		(DE) = FDN.FLG
	ANI	~DIF.CNT	CLEAR 'C'
	STAX	D		SAVE FILE FLAGS

*	CHECK FOR CONTIGUOUS COPY. IF SO, GET FILE SIZE.

	LDA	OCOPYF
	ANA	A		COPY CONTIGUOUS?
	JZ	RPH3		NO.

	CALL	$INDL
	DW	IOC.GRT
	PUSH	D		SAVE GRT ADDRESS
	CALL	$INDLB		A  = Last Sector Index
	DW	IOC.DIR+DIR.LSI
	STA	RPHA		Save Sector Index
	CALL	$INDLB		A  = DIR.FGN
	DW	IOC.DIR+DIR.FGN
	POP	H		(HL) = GRT TABLE ADDRESS
	CALL	CFS.		COMPUTE BLOCK SIZE
	DCX	D		Don't count last block
	LDA	SRCSPG		A  = source volume SPG
	CALL	$MU86		HL = DE * A
	LDA	RPHA		A = Sector Index
	CALL	$DADA
	XCHG			DE = number of sectors
	POP	H		(HL) = ADDRESS OF FDN.STA
	PUSH	H

	MOV	A,M		(A) = FDN.STA
	ORI	ST.CNT		FLAG CONTIG
	MOV	M,A
	CALL	$INDS		FDN.SIZ = number of sectors
	DW	FDN.SIZ-FDN.STA

*	READY TO READ DATA. POSITION FILE (IN CASE SOME WAS READ IN
*	PREVIOUS PASSES) AND COMPUTE THE MAX POSSIBLE READ COUNT
*
*	((SP)) = ADDRESS OF FDN.STA FOR NODE

RPH3	POP	H		(HL) = ADDRESS OF FDN.STA
	PUSH	H
	CALL	$INDL
	DW	FDN.AMR-FDN.STA	(DE) = AMOUNT READ (IN SECTORS)
	MOV	B,D
	MOV	C,E		(BC) = AMOUNT READ
	MVI	A,CN.SOU
	SCALL	.POSIT		POSIT
	JC	IERR3		POSIT BLEW UP
	CALL	CBR		COMPUTE BUFFER ROOM
	XCHG			(D) = POINTER/256, (E) = LIMIT/256
	POP	H		(HL) = #FDN.STA
	LXI	B,FDN.ADR-FDN.STA
	DAD	B		(HL) = #FDN.ADR
	MOV	M,D		SET ADDRESS/256
	PUSH	H		SAVE #FDN.ADR
	MVI	E,0		(DE) = ADDRESS
	MOV	B,A		(B) = SECTORS OF RAM AVAILABLE
	MOV	C,E		(C) = 0
	PUSH	B		SAVE TRY COUNT
	MVI	A,CN.SOU
	SCALL	.READ		READ THE STUFF

*	COMPUTE THE AMOUNT READ (IN CASE OF EOF)

	POP	D		(DE) = TRY COUNT
	JNC	RPH4		GOT ALL WE TRIED
	CPI	EC.EOF
	JNE	NAMERR		NOT JUST EOF, GOT TROUBLES
	MOV	A,D
	SUB	B		REMOVE AMOUNT WE DIDNT GET
	MOV	D,A
	POP	H		(HL) = #FDN.ADR
	PUSH	H
	LXI	B,FDN.STA-FDN.ADR
	DAD	B
	MOV	A,M		(A) = FDN.STA
	ANI	377Q-ST.OPR	EOF, NOT OPEN FOR READ ANYMORE
	MOV	M,A		POST READ COMPLETE FOR THIS GUY

*	STORE RESULTS OF READ IN NODE
*
*	(D) = SECTORS READ
*	((SP)) = #FDN.ADR

RPH4	POP	H		(HL) = #FDN.ADR
	INX	H
	ERRNZ	FDN.AIM-FDN.ADR-1	(HL) = ADDRESS IF AMOUNT IN MEMORY BYTE
	MOV	M,D		STORE SECTORS IN MEMORY COUNT
	LXI	B,FDN.AMR-FDN.AIM
	DAD	B		(HL) = #FDN.AMR (AMOUNT READ)
	MOV	A,M		(A) = AMOUNT READ BEFORE
	ADD	D		ADD NEW AMOUNT
	MOV	M,A
	INX	H
	MOV	A,M
	ACI	0		PROPIGATE FOR VERY LARGE FILES
	MOV	M,A
	LXI	H,OBUFPTR
	MOV	A,M
	ADD	D		ADVANCE FREE RAM POINTER BY AMOUNT READ
	MOV	M,A
	MVI	A,CN.SOU
	SCALL	.CLOSE		CLOSE FILE
	JMP	RPH		SEE IF MORE TO READ

RPHA	DB	0		Saved Last Sector Index
WPH	SPACE	4,10
**	WPH - WRITE PHASE.
*
*	WPH HANDLES THE WRITE PHASE PROCESSING. IT IS ENTERED WITH
*	THE FDN CHAIN SETUP, THE NAMTAB SETUP, AND
*	THE DESTINATION DISK MOUNTED.
*
*
*	WRITE PHASE
*
*	DURING THE WRITE PHASE, THE DESTINATION DISK IS MOUNTED. THE NODES
*	ARE TAKEN FROM THE ACTIVE CHAIN, AND PROCESSED. IF THE FILE HAD
*	BEEN PARTIALLY WRITTEN THE LAST PASS, IT IS  RE-OPENED AND POSITIONED.
*	IF THERE IS NOT MORE DATA TO READ FOR A PROCESSED
*	NODE, IT IS REMOVED, AND THE CORRESPONDING ENTRY IN NAMTAB IS DELETED.
*
*	WRITE PHASE CONTINUES UNTIL
*
*		1) THERE ARE NO MORE FILE NODES IN THE ACTIVE LIST
*		2) OR, THE FIRST (AND ONLY) ENTRY IN THE LIST HAS NO
*		   MORE DATA IN MEMORY, BUT HAS NOT BEEN COMPLETELY READ.
*
*	ENTRY	NONE
*	EXIT	NONE
*	USES	ALL


WPH	EQU	*

*	SEE IF MORE TO WRITE

	LHLD	FDNHED		HL = FILE list head
	MOV	A,H
	ORA	L
	RZ			FILE list is empty

	CALL	$INDLB		A  = amount in memory for file
	DW	FDN.AIM
	ANA	A
	JNZ	WPH0		GOT DATA

*	NO DATA IN NODE. IF STILL READING, RETURN FOR MORE

	CALL	$INDLB		A  = FDN.STA
	DW	FDN.STA
	ANI	ST.OPR
	RNZ			STILL READING, GET MORE

	XCHG			(DE) = ADDRESS
	JMP	WPH4		REMOVE NODE, AM DONE WITH FILE

*	HAVE DATA TO WRITE. SEE IF WE HAVE OPENED THIS FILE BEFORE,
*	OR IF THIS IS THE FIRST TIME

WPH0	PUSH	H		SAVE NODE POINTER
	INX	H
	INX	H
	ERRNZ	FDN.STA-FDN.LNK-2
	MOV	A,M		(A) = FDN.STA
	ANI	ST.OPW
	JNZ	WPH2		OPENED BEFORE
	ERRNZ	ST.OPW-1
	INR	M		SET '1' BIT

*	BUILD NAME INTO DESTFB

	PUSH	H		SAVE NODE ADDRESS
	LXI	B,OCOPYD
	LXI	D,NAMTAB
	LXI	H,DESTFB+FB.NAM
	CALL	MWN		MERGE WILDCARD NAME
	POP	H

*	IS 1ST TIME FOR THIS FILE. IF CONTIGUOUS FLAG, OPEN THE FILE
*	FOR CONTIGUOUS

	MOV	A,M		(A) = FLAG BYTE
	ANI	ST.CNT
	JNZ	WPH1		IS CONTIG
	LXI	H,DESTFB+FB.NAM
	MVI	A,CN.DES
	SCALL	.OPENW		JUST OPEN FOR WRITE
	JC	DESTERR		ERROR
	JMP	WPH3		WRITE THE DATA

*	IS CONTIG FILE. OPEN IN CONTIG MODE

WPH1	CALL	$INDL
	DW	FDN.SIZ-FDN.STA
	MOV	B,D
	MOV	C,E		BC = Number of sectors required
	LXI	H,DESTFB+FB.NAM
	MVI	A,CN.DES
	PUSH	B		SAVE COUNT
	SCALL	.DELET		DELETE OLD ONE
	JNC	WPH1.5		DELETED
	CPI	EC.FNF
	JNE	ERROR		MUST BE WRITE PROTECTED, OR  SOMETHING...
WPH1.5	POP	B		(BC) = COUNT
	LXI	H,DESTFB+FB.NAM
	MVI	A,CN.DES
	SCALL	.OPENC		OPEN CONTIG
	JC	DESTERR
	JMP	WPH3

*	THIS FILE HAS ALREADY BEEN PARTIALLY WRITTEN. OPEN IN UPDATE MODE
*	SO WE CAN EXTEND IT.

WPH2	LXI	H,DESTFB+FB.NAM
	MVI	A,CN.DES
	SCALL	.OPENU		OPEN FOR UPDATE
	JC	DESTERR		PROBLEMS
	POP	H
	PUSH	H		(HL) = #FDN.STA
	CALL	$INDL
	DW	FDN.AMW		(DE) = AMOUNT WRITTEN
	MOV	B,D
	MOV	C,E		(BC) = SECTORS WRITTEN
	MVI	A,CN.DES
	SCALL	.POSIT		POSITION FOR EXTEND
	JC	IERR1		COULDNT GET THERE!

*	FILE OPEN AND POSITIONED. WRITE DATA

WPH3	POP	H
	PUSH	H		(HL) = #FDN.LNK
	CALL	$INDL
	DW	FDN.ADR		(E) = ADDR/256, (D) = CNT/256
	MOV	B,D
	MOV	D,E
	MVI	E,0		(DE) = ADDRESS
	MOV	C,E		(BC) = COUNT
	MVI	A,CN.DES
	PUSH	B		SAVE WRITE COUNT
	SCALL	.WRITE		WRITE IT
	JC	DESTERR		PROBABLY OUT OF ROOM
	MVI	A,CN.DES
	SCALL	.CLOSE		CLOSE IT
	JC	DESTERR
	POP	B		(B) = SECTORS WRITTEN
	POP	H
	PUSH	H		(HL) = #FDN.LNK
	LXI	D,FDN.AMW-FDN.LNK
	DAD	D		(HL) = FDN.AMW
	MOV	A,M
	ADD	B
	MOV	M,A
	INX	H
	MOV	A,M
	ACI	0		INCREMENT AMOUNT WRITTEN
	MOV	M,A

*	CLEAR 'IN MEMORY' COUNT IN NODE. IF THE FILE HAS NO MORE TO
*	READ, REMOVE IT FROM THE CHAIN AND NAMTAB

	POP	D		(DE) = FDN.LNK
WPH4	LXI	H,FDN.AIM
	DAD	D
	MVI	M,0		CLEAR AMOUNT IN MEMORY
	XCHG			(HL) = FDN.LNK
	INX	H
	INX	H
	ERRNZ	FDN.STA-FDN.LNK-2
	MOV	A,M		(A) = FDN.STA
	ANI	ST.OPR
	RNZ			STILL READING, AM DONE FOR THIS PHASE
	ERRNZ	FDN.FLG-FDN.STA-1
	INX	H		(HL) = #FDN.FLG
	MOV	B,M		(B) = FILE FLAGS
	PUSH	B		SAVE

*	UNLINK NODE FROM LIST

	DCX	H
	DCX	H
	DCX	H
	ERRNZ	FDN.LNK-FDN.FLG+3	(HL) = #FDN.LNK
	PUSH	H
	CALL	$HLIHL		HL = & next node
	ERRNZ	FDN.LNK
	SHLD	FDNHED		New FILE list head
	LHLD	FDNFREE
	XCHG			DE = current FREE list head
	POP	H		HL = current node
	CALL	$INDS		point to rest of free list
	DW	FDN.LNK
	SHLD	FDNFREE 	Link new at head of FREE list

	CALL	REN		REMOVE ENTRY FROM NAMTAB

*	FILE IS COMPLETED. NOW WE CAN
*	SET SPECIAL FLAGS: SWL

	POP	B		(B) = FLAGS
	MVI	C,377Q		SET AS MANY AS ALLOWED
	LXI	H,DESTFB+FB.NAM
	SCALL	.CHFLG		CHANGE FLAGS
	JC	DESTERR
	JMP	WPH		TRY TO WRITE THE NEXT GUY
CBR	SPACE	4,10
**	CBR - COMPUTE BUFFER ROOM.
*
*	CBR COMPUTES THE NUMBER OF SECTORS WORTH OF RAM
*	STILL FREE.
*
*	ENTRY	NONE
*	EXIT	(A) = SECTORS OF RAM FREE
*		'Z' SET IFF (A)  = 0
*		(H) = BUFPTR/256
*		(L) = OBUFLIM/256
*	USES	A,F

CBR	LHLD	OBUFLIM
	ERRNZ	OBUFPTR-OBUFLIM-1
	MOV	A,L
	SUB	H
	RET
DMD	SPACE	4,10
**	DMD	- Dismount Disk
*
*	DMD dismounts the source diskette
*
*	ENTRY:	NONE
*
*	EXIT:	To ERROR if problems
*
*	USES:	ALL

DMD	LXI	H,SOURCE+DEVICE

DMD.	SCALL	.DMNMS		Dismount without a message
	JC	ERROR

	RET
IFL	SPACE	4,10
**	IFL - INITIALIZE FDN LIST.
*
*	IFL CHAINS ALL THE FDN NODES TO THE FREE LIST. THIS
*	CLEANUP IS NECESSARY IN CASE A CTL-C OR SOMETHING
*	LEFT THE LIST GARBAGED.
*
*	ENTRY	NONE
*	EXIT	NONE
*	USES	ALL

IFL	LXI	H,FDN.1
	SHLD	FDNFREE

	MVI	B,FDNCNT-1
	LXI	D,FDN.1+FDNELEN

IFL1	CALL	$INDS		set link to next node
	DW	FDN.LNK
	PUSH	B
	MOV	H,D
	MOV	L,E		HL = DE
	LXI	B,FDNELEN
	DAD	B		Advance Next node pointer
	XCHG			HL = current ; DE = next
	POP	B
	DCR	B		Count node
	JNZ	IFL1

	LXI	D,0
	CALL	$INDS		last element links to NIL
	DW	FDN.LNK

	XCHG
	SHLD	FDNHED		FILE list is empty
	RET
MAD	SPACE	4,10
**	MAD - MOUNT ALTERNATE DISK.
*
*	MAD DISMOUNTES THE CURRENT DISK, HAS THE USER INSERT THE
*	OTHER DISK, AND MOUNTS IT.
*
*
*	ENTRY	(DE) = PROMPT PATTERNS FOR PANEL AND CONSOLE
*
*	EXIT	PSW	= 'C' set   if    ERROR	
*			= 'C' clear if NO ERROR
*
*	USES	ALL

MAD	EQU	*

*	DISMOUNT CURRENT DISK

	PUSH	D

	CALL	DMD		Dismount Source Diskette

	POP	H
	SCALL	.PRINT		CONSOLE PROMPT

MAD2	MVI	A,DC.RDY
	CALL	SRCDRVR
	JNC	MAD2		Wait for device NOT ready

MAD3	MVI	A,DC.RDY
	CALL	SRCDRVR
	JC	MAD3		Wait for device ready

	CALL	$CRLF		Output Newline to Console

	CALL	MND		MOUNT NEW DISK
	RET
MDD	SPACE	4,10
**	MDD	- Mount Destination Diskette
*
*	MDD insures that the destination diskette is mounted.
*
*	Since MSD requires a sysgened label, if the disk passes
*	the RDD test, we know that it is not the same diskette
*	as the source since the volume types must be differant.
*
*	ENTRY:	Source Label in SRCLAB
*
*	EXIT:	Destination Diskette mounted
*
*	USES:	ALL

MDD	LDA	VOLFLAG
	ANA	A
	RNZ			Destination is mounted

	CALL	MDD1

	LHLD	DSTLAB+LAB.SER
	MVI	H,0
	MVI	A,DC.MOU
	CALL	DSTDRVR		Insure Good volume number of label stuff
	JC	ERROR

	LDA	VOLFLAG
	CMA
	STA	VOLFLAG		Flag Destination mounted

	RET
MDD1	SPACE	4,10
**	MDD1
*

MDD1	LDA	DRIVES2
	ANA	A
	JNZ	MDD3		2-drive sysgen

*	Mount the Diskette

MDD2	LXI	D,MDDA
	CALL	MAD		Mount alternate disk

MDD3	LDA	MDDB
	ANA	A
	JZ	MDD4		Label not saved in DSTLAB

	LDA	DRIVES2
	ANA	A
	RNZ			2-drive sysgen means no change

	CALL	GETDLB		LABEL = Destination Label
	MVI	C,0		256-Byte Compare
	LXI	D,LABEL
	LXI	H,DSTLAB
	CALL	$COMP
	JNZ	MDD2		Destination Label does not match Original

	RET

*	Verify Diskette type and Save Label

MDD4	LXI	D,DSTLAB	DE = destination Label buffer
	CALL	GETDLB.		Read the label

	LDA	DRIVES2
	ANA	A
	JNZ	MDD5		2-drive sysgen don't care if labels match

	MVI	C,0
	LXI	D,DSTLAB
	LXI	H,SRCLAB
	CALL	$COMP		Compare Source Label to Destination Label
	JZ	MDD2		Source and Destination Labels Match

MDD5	CALL	RDD		Require Destination Data Diskette

	LDA	MDDB
	CMA
	STA	MDDB		Flag label saved and verified

	RET

MDDA	DB	NL,'Insert Destination:',BELL+200Q

MDDB	DB	0		!= 0  If label saved and type verified
MND	SPACE	4,10
**	MND - MOUNT SYSTEM DISK.
*
*	MND MOUNTS A NEW DISK INTO 'SY' UNIT 'UNIT'
*
*
*	THE LABEL MUST ALREADY HAVE BEEN READ INTO 'LABEL'
*
*	ENTRY	NONE
*
*	EXIT	To ERROR if bad problems
*
*	USES	ALL

MND	LXI	H,SOURCE+DEVICE

MND.	SCALL	.MONMS		Mount without message
	JC	ERROR		IF ERROR

	RET
MSD	SPACE	4,10
**	MSD	- Mount System Diskette
*
*	MSD insures that the system diskette is mounted
*
*	ENTRY:	NONE
*
*	EXIT:	System diskette mounted
*
*	USES:	ALL

MSD	LDA	VOLFLAG
	ANA	A
	RZ			System Diskette Mounted

	CALL	MSD1

	LHLD	SRCLAB+LAB.SER
	MVI	H,0
	MVI	A,DC.MOU
	CALL	SRCDRVR		Insure good volume number after label stuff
	JC	ERROR

	LDA	VOLFLAG
	CMA	A
	STA	VOLFLAG		Flag System Diskette Mounted

	RET
MSD1	SPACE	4,10
**	MSD1
*

MSD1	LDA	DRIVES2
	ANA	A
	JNZ	MSD3		2-drive sysgen

*	Mount the Diskette

MSD2	LXI	D,MSDA
	CALL	MAD		Mount the other diskette

MSD.	EQU	*		Used for Initial Mount

MSD3	LDA	MSDB
	ANA	A
	JZ	MSD4		Source Label is not saved yet

	LDA	DRIVES2
	ANA	A
	RNZ			2-drive sysgen => no change

	CALL	GETSLB		LABEL = Source Label
	MVI	C,0		256-Byte compare
	LXI	D,LABEL
	LXI	H,SRCLAB
	CALL	$COMP
	JNZ	MSD2		This Source Label does not match original

	RET

*	Verify Diskette type and Save Label

MSD4	CALL	RSD		Require Sysgened Source Diskette

	LDA	MSDB
	CMA
	STA	MSDB		Flag label saved and verified

	RET

MSDA	DB	NL,'Insert Source:',BELL+200Q

MSDB	DB	0		!= 0 If label saved and type verified
GETXLB	SPACE	4,10
**	GETXLB	- GET LABEL
*
*	GETXLB GETS THE LABEL FROM THE DISK
*
*	ENTRY	NONE
*
*	EXIT	(PSW)	= 'C' CLEAR IF NO ERROR
*			= 'C' SET   IF    ERROR
*
*	USES	ALL

GETDLB	LXI	D,LABEL		DE = buffer address

GETDLB.	PUSH	D
	LXI	H,0
	MVI	A,DC.MOU
	CALL	DSTDRVR		Mount as volume 0
	POP	D
	JC	ERROR

	LXI	H,DDF.LAB
	LXI	B,256
	MVI	A,DC.RER	READ REGARDLESS
	CALL	DSTDRVR
	JC	ERROR		Bad Error

	RET


GETSLB	LXI	D,LABEL		DE = buffer address

GETSLB.	PUSH	D
	LXI	H,0
	MVI	A,DC.MOU
	CALL	SRCDRVR		Mount as volume 0
	POP	D
	JC	ERROR

	LXI	H,DDF.LAB
	LXI	B,256
	MVI	A,DC.RER
	CALL	SRCDRVR		Read Source Label
	JC	ERROR		Bad Error

	RET
RDD	SPACE	4,10
**	RDD - REQUIRE Destination DATA DISK.
*
*	RDD CHECKS THE VOLUME TYPE TO MAKE SURE THAT IT IS A VALID
*	DATA DISK.
*
*	ENTRY	DSTLAB	= Destination Label
*
*	EXIT	TO CALLER IF OK
*		TO EXIT IF BAD
*
*	USES	ALL

RDD	LDA	DSTLAB+LAB.VER	A = Version of INIT to initialize disk
	CPI	VERS		Compare to SYSGEN Version
	JNZ	RDD2		Not Equal

	LDA	DSTLAB+LAB.VLT	(A) = VOLUME TYPE
	ERRNZ	LAB.DAT
	ANA	A
	RZ			IS DATA DISK, OK

	ERRNZ	LAB.SYS-1
	DCR	A		SEE IF SYSTEM DISK
	JNZ	RDD1		DISK NOT EVEN INITIALIZED
	CALL	$TYPTX
	DB	NL,BELL,'This Disk Has Already Been SYSGENed.',ENL
	JMP	EXIT

*	DISK IS NOT PROPERLY INITIALIZED.
*	(THIS CODE MAY BE ENTERED FROM OTHER ROUTINES)

RDD1	CALL	$TYPTX
	DB	NL,BELL,'This Disk Must be Re-Initialized Before It Can Be '
	DB	'SYSGENed.',ENL
	JMP	EXIT

*	Not Initialized by the correct version of HDOS

RDD2	CALL	$TYPTX
	DB	NL,BELL,'This disk has not been initialized by the correct '
	DB	'version of INIT.',ENL
	JMP	RDD1
RSD	SPACE	4,10
**	RSD - REQUIRE SYSGENED Source DISK.
*
*	RSD CHECKS TO SEE IF THE MOUNTED VOLUME HAS BEEN SYSGENED.
*
*	ENTRY	NONE
*	EXIT	TO CALLER IF OK
*		TO EXIT IF ERROR
*	USES	ALL

RSD	LXI	D,SRCLAB	HL = Source Label Save Area
	CALL	GETSLB.

	LDA	SRCLAB+LAB.VLT	(A) = VOLUME TYPE
	ERRNZ	LAB.SYS-1
	SUI	1
	RZ			IS OK

	JNC	RDD1		MUST BE INITIALIZED

	CALL	$TYPTX
	DB	NL,BELL,'This Disk Must be SYSGENed Before It Can be Used'
	DB	NL,'As Input For Another SYSGEN.',ENL
	JMP	EXIT
SSL	SPACE	4,10
**	SSL	- Set Sysgened Flag in Label
*
*	SSL sets the sysgened flag in the label
*
*	ENTRY:	Destination Diskette dismounted
*
*	EXIT:	To ERROR  if problems

SSL	CALL	MDD		Mount Destination Diskette
	LXI	H,DEST+DEVICE
	CALL	DMD.		Dismount Destination Diskette

	MVI	L,0
	MVI	A,DC.MOU
	CALL	DSTDRVR		Mount Diskette as volume 0

	MVI	A,LAB.SYS
	STA	DSTLAB+LAB.VLT	SET VOLUME TYPE

	LXI	D,DSTLAB
	LXI	H,DDF.LAB
	LXI	B,256
	MVI	A,DC.WRI
	CALL	DSTDRVR		Write Label Back
	JC	ERROR		BAD TROUBLE

	LXI	H,DEST+DEVICE
	JMP	MND.		Re-Mount the diskette
	STL	'ERROR PROCESSING'
	EJECT
**	ERROR PROCESSING ROUTINES
*
	SPACE	3,10
***	NAMERR - FILE TYPE ERROR, OCCOURED ON FILE WHOSE NAME
*	IS NEXT UP IN NAMTAB.
*
*	PROCESS VIA $FERROR

NAMERR	LHLD	NAMTPTR
	LXI	B,-FB.NAM
	DAD	B
	JMP	$FERROR
DESTERR	SPACE	4,10
**	ERROR ON FILE IN DESTFB

DESTERR	LXI	H,DESTFB
	JMP	$FERROR
INTERR	SPACE	4,10
**	INTERNAL ERRORS. SHOULD NOT OCCOUR.

IERR1	MVI	A,'1'
	JMP	INTERR

IERR2	MVI	A,'2'
	JMP	INTERR

IERR3	MVI	A,'3'
*	JMP	INTERR
	ERRNZ	*-INTERR

INTERR	STA	INTERRA 	SAVE CODE
	CALL	$TYPTX
	DB	BELL,NL,'SYSGEN Internal Error #'
INTERRA DB	'?',NL
	DB	NL
	DB	'This Error Should not Occur. Don''t contact HEATH Technical',NL
	DB	'Correspondence for Assistance.',ENL
	MVI	A,1
	SCALL	.EXIT		ABORT
ERROR	SPACE	4,10
**	ERROR - GENERAL AND SYNTAX ERRORS NOT DIRECTLY ASSOCIATED
*	WITH A VALID FILE NAME.

ERROR	PUSH	PSW		SAVE CODE
	CALL	$TYPTX
	DB	BELL,'Error -',' '+200Q
	POP	PSW
	ANA	A
	JM	ERROR1		IS PRODUCT ERROR
	MVI	H,NL		USE NL AS MESSAGE TRAIL CHAR
	SCALL	.ERROR		LOOK UP SYSTEM ERROR
	JMP	RESTART

*	IS PRODUCT ERROR

ERROR1	LXI	H,ERRORA
ERROR2	CMP	M
	INX	H
	JNE	ERROR2		FIND ERROR MESSAGE
	CALL	$TYPTX
	DB	BELL,'SYSGEN Error #',' '+200Q
	SCALL	.PRINT		PRINT MESSAGE
	JMP	RESTART

ERRORA	DS	0		ERROR MESSAGES
	DB	PEC.DF,'01',ENL
	DB	PEC.DNC,'02',ENL
	DB	PEC.RSE,'03',ENL
	DB	PEC.TFI,'04',ENL
	DB	PEC.CS,'05',ENL
	DB	PEC.IUW,'06',ENL
	DB	PEC.IDF,'07',ENL
	DB	PEC.CO,'08',ENL
	STL	'SUBROUTINES'
	EJECT
AEN	SPACE	4,10
**	AEN - ADD ENTRY TO 'NAMTAB'
*
*	AEN EXPANDS THE FILE INFO IN PIO.XXX INTO A FILE DESCRIPTOR
*	AND ENTERS IT IN THE NAMTAB TABLE.
*
*	If the QUERY flag is set, the user is interrogated
*	before the file is actually copied.  If a yes response
*	is given, then the file is actually added, otherwise,
*	the file is skipped.
*
*
*	ENTRY	NONE
*	EXIT	'C' SET IF WILDCARD
*	USES	ALL

AEN	LXI	H,AENA
	CALL	CDA		CONVERT DIRECTORY FORMAT TO ASCII FORMAT
	SUI	1		'C' SET IF WILDCARD
	PUSH	PSW		SAVE FLAG

	JC	AEN1		Ignore query for wild-carded files
	CALL	CQF		Check Query Flag
	JNZ	AEN2		Don't Copy this file

AEN1	LHLD	NAMTLEN
	LXI	B,FB.NAML
	DAD	B		INCREASE SIZE
	SHLD	NAMTLEN
	XCHG			(DE) = NEW LENGTH
	LHLD	NAMTMAX
	MOV	A,L		SEE IF WILL OVERFLOW
	SUB	E
	MOV	A,H
	SBB	D
	CC	INA		INCREASE NAMTAB ALLOCATION
	LXI	H,NAMTAB-FB.NAML
	DAD	D		(HL) = *TO* ADDRESS
	LXI	D,AENA		(DE) = *FROM* ADDRESS
	CALL	$MOVE		MOVE ENTRY IN

AEN2	POP	PSW		(PSW) = WILDCARD FLAG
	RET

AENA	DS	FB.NAML
BSL	SPACE	4,10
**	BSL - BUILD SOURCE FILE LIST.
*
*	BSL CRACKS THE LIST OF THE SOURCE FILES FROM THE COMMAND LINE AND
*	BUILDS THEM INTO THE NAMTAB MANAGED TABLE.
*	WILD CARDS ENCOUNTERED ARE EXPANDED.
*
*	ENTRY	(A) <> 0 IF TO ASK ABOUT '*.*' USE
*	EXIT	'C' CLEAR IF OK
*		'C' SET IF ERROR
*		 (A) = CODE
*	USES	ALL

BSL	STA	BSLA		SAVE ASK FLAG
	CALL	LSN		LOCATE SOURCE NAME

*	GO THROUGH SOURCE LIST CRACKING NAMES

BSL1	MOV	A,M
	ANA	A
	RZ			ALL DONE
	LXI	D,SOURCE+DEFAULT	Source default definition
	CALL	CAD		CONVERT ASCII NAME TO DIRECTORY FORMAT
	RC			ERROR
	CALL	SND		SET NEW DEFAULTS
	PUSH	H		SAVE LINE ADDRESS
	CALL	EWS		EXPAND WILDCARD SPECIFICATION
	JC	BSL2		IF ERROR
BSL2	POP	H		RESTORE LINE ADDRESS
	RC			USER REFUSED *.*
	CALL	SFS		SKIP FILE SEPERATOR (BLANKS AND/OR COMMA)
	JMP	BSL1		DO MORE

BSLA	DB	0		<>0 IF TO CHECK FOR *.*
CFS	SPACE	4,10
**	CFS - COMPUTE FILE SIZE
*
*	CFS COMPUTES THE SIZE OF A FILE. THE DEVICE'S GRT MUST BE IN
*	THE 'GRT' BUFFER.
*
*	ENTRY	(A) = FIRST GROUP NUMBER
*	EXIT	(DE) = SIZE
*	USES	ALL

CFS.	LXI	D,0
CFS1	ANA	A
	RZ			ALL DONE
	MOV	L,A
	MOV	A,M		(A) = NEXT GRT
	INX	D
	JMP	CFS1		TRY AGAIN
CQF	SPACE	4,10
**	CQF	- Check Query Flag
*
*	CQF checks the query flag, and if it is set, asks
*	the user if the file is to be transfered by typing
*	the filename followed by a question mark.  If the
*	response begins with a 'Y' the file is transfered,
*	else, it is to be ignored.
*
*	ENTRY:	PIO.xxx	= File specification
*
*	EXIT:	PSW	= 'Z'  if     to Copy
*			  'NZ' if NOT to Copy
*
*	USES:	ALL

CQF	LDA	QUERY
	ANA	A
	RZ			NO Query, so transfer file

	CALL	CQF.
	PUSH	PSW
	CALL	$CRLF
	POP	PSW
	RET

CQF.	LXI	H,PIO.DIR+DIR.NAM
	CALL	$TFN.		Type the File Name
	CALL	$TYPTX
	DB	'?',' '+200Q

	SCALL	.CLRCO		Clear the console
	CALL	$RCHAR
	CALL	$MCU
	CPI	'Y'
	RZ			Copy the file

	CPI	'N'
	JNZ	CQF1		Illegal
	ORI	1		'NZ' => DON'T copy the file
	RET

CQF1	CALL	$TYPTX
	DB	NL,BELL+200Q	Bell user for illegal character
	JMP	CQF.
CSF	SPACE	4,10
**	CSF - CHECK FOR SPECIAL FILE.
*
*	CSF CHECKS TO SEE IF THE FILE NAME (IN DIRECTORY FORMAT)
*	SUPPLIED MATCHES ONE OF A LIST OF 'NOT-TO-BE-PROCESSED'
*	FILES. THE LIST IS:
*
*	Since the table is terminated by a zero byte,
*	the files to be copied may be modified by
*	zeroing appropriately:
*
*		CSFB		No GRT.SYS, RGT.SYS, DIRECT.SYS
*		CSFC		or HDOS30.SYS, SYSCMD.SYS, PIP.ABS, TT.DVD
*		CSFD		or SY.DVD
*				or xx.DVD
*
*	ENTRY	(DE) = ADDRESS OF DIRECTORY BLOCK
*		CSFB	= 0 If not to search extra files
*			= CSFC if to search extra files
*
*	EXIT	'Z' SET IF MATCH
*		'Z' CLEAR OTHERSIZE
*
*	USES	A,F
*

CSF	PUSH	B
	PUSH	D
	PUSH	H		SAVE POINTERS

	LXI	H,CSFA		(A) = START OF LIST
CSF1	PUSH	D		SAVE NAME
	PUSH	H		SAVE LIST ADDRESS
	MVI	C,DIRIDL
	CALL	$COMP		SEE IF MATCH
	POP	H
	POP	D
	JE	CSF2		GOT MATCH
	MVI	A,DIRIDL
	CALL	$DADA.		POINT TO NEXT ENTRY
	MOV	A,M
	ANA	A
	JNZ	CSF1		MORE TO CHECK

*	NO MATCH

	INR	A		CLEAR 'Z'
CSF2	POP	H
	POP	D		RESTORE REGS
	POP	B
	RET

CSFA	DB	'GRT',0,0,0,0,0,'SYS'		GRT.SYS
	ERRNZ	*-CSFA-DIRIDL
	DB	'RGT',0,0,0,0,0,'SYS'		RGT.SYS
	ERRNZ	*-CSFA%DIRIDL
	DB	'DIRECT',0,0,'SYS'		DIRECT.SYS
	ERRNZ	*-CSFA%DIRIDL

CSFB	DB	'HDOS30',0,0,'SYS'		HDOS30.SYS
	ERRNZ	*-CSFA%DIRIDL
	DB	'SYSCMD',0,0,'SYS'		SYSCMD.SYS
	ERRNZ	*-CSFA%DIRIDL
	DB	'PIP',0,0,0,0,0,'ABS'		PIP.ABS
	ERRNZ	*-CSFA%DIRIDL
	DB	'TT',0,0,0,0,0,0,'DVD'		TT.DVD
	ERRNZ	*-CSFA%DIRIDL

CSFC	DB	'SY',0,0,0,0,0,0,'DVD'		SY.DVD
	ERRNZ	*-CSFA%DIRIDL

CSFD	DB	'xx',0,0,0,0,0,0,'DVD'		xx.DVD
	ERRNZ	*-CSFA%DIRIDL

	DB	0		New end of table
CWM	SPACE	4,10
**	CWM - CHECK WILDCARD MATCH.
*
*	CWM CHECKS TO SEE IF A WILDCARDED FIELD MATCHES A NON-WILDCARDED
*	FIELD.
*
*	ENTRY	(DE) = ADDRESS OF WC NAME
*		(HL) = ADDRESS OF NON/WC NAME
*		(B) = NUMBER OF CHARACTERS TO CHECK
*	EXIT	'Z' SET IF MATCH
*		 (HL) = (HL)+(B)
*		 (DE) = (DE) = (B)
*		'Z' CLEAR IF NO MATCH
*	USES	A,F,B,D,E,H,L

CWM	LDAX	D
	ANA	A
	JM	CWM1		IS MATCH
	CMP	M
	RNE			NO MATCH
CWM1	INX	D
	INX	H		ADVANCE ADDRESSES
	DCR	B
	JNZ	CWM		GO FOR MORE
	RET			GOT MATCH
DDF	SPACE	4,10
**	DDF - DECODE DESTINATION FILE.
*
*	DDF DECODES THE DESTINATION FILE NAME FROM THE COMMAND LINE.
*
*	Must have default specification.
*
*	ENTRY	NONE
*	EXIT	'C' CLEAR IF OK
*		 (A) = 0 IF NAME HAS WILDCARDS
*		 (A) = 1 IF NO WILDCARD USED
*		 DESTFB+FB.NAM CONTAINS A COMPLETE DESTINATION FILE NAME
*		 (HL) = COMMAND LINE POINTER UDPATED
*		'C' SET IF ERROR
*		 (A) = CODE
*	USES	ALL

DDF	LHLD	LINEP

*	(HL) = ADDRESS FOR NAME

DDF2	LXI	D,DEST+DEFAULT
	CALL	CAD		CONVERT ASCII NAME TO DIRECTORY FORMAT
	RC			ERROR

	MOV	A,M
	CPI	'='
	MVI	A,PEC.IDF	ASSUME ILLEGAL DESTINATION FORMAT
	STC
	RNE			MUST HAVE '='

*	HAVE NAME DECODED. EXPAND INTO DESTFB+FB.NAM

	LXI	H,DESTFB+FB.NAM
	JMP	CDA		CONVERT DIRECTORY FORMAT TO ASCII
DSTDRVR	SPACE	4,10
**	DSTDRVR	- Destination Driver
*
*	DSTDRVR invokes the DESTination device driver.
*
*	ENTRY:	NONE
*
*	EXIT:	NONE
*
*	USES:	NONE
*

DSTDRVR	PUSH	PSW
	LDA	DEST+UNIT
	STA	AIO.UNI
	POP	PSW
	JMP	DEST+DRIVER
CAD	SPACE	4,10
**	CAD - CONVERT ASCII FILE NAME INTO DIRECTORY FORMAT.
*
*	CAD CRACKS AN ALPHANUMERIC FILE DESCRIPTION, OF THE FORM
*
*	DEV:NAME.EXT
*
*	INTO THE PIO.XXX FIELDS.
*
*	THE DEFAULT BLOCK DETERMINES THE VALUES FOR THE DEVICE AND EXTENSION
*	FIELDS, IF THEY ARE UNSPECIFIED. IF *CAD* IS ENTERED
*	AT *CAD*, AN UNSPECIFIED NAME FIELD IS RETURNED AS ZERO BYTES.
*	IF ENTERED AT *CAD.*, AN UNSPECIFIED NAME FIELD IS
*	RETURNED AS 200Q (MATCH-ONE) BYTES.
*
*	ENTRY	(DE) = POINT TO DEFAULT BLOCK
*		(HL) = POINTER TO TEXT
*	EXIT	'C' SET IF ERROR
*		 (A) = ERROR CODE
*		'C' CLEAR IF OK
*		 (HL) = POINTS PAST FILE NAME
*		 'Z' SET IF NULL NAME
*		 'Z' CLEAR IF NON-NULL
*		  PIO.DIR.NAM = NAME
*		  PIO.DIR.EXT = EXTENSION
*		  PIO.DEV = DEVICE CODE
*		  PIO.UNI = UNIT NUMBER (ASCII DIGIT)
*	USES	ALL

CAD	XRA	A		SET TO NULLS
	JMP	CAD0

CAD.	MVI	A,200Q
CAD0	PUSH	H
	STA	CADA		SAVE DEFAULT VALUE

*	SET DEFAULTS IN PIO.xxx

	LXI	H,PIO.DEV
	LXI	B,3
	CALL	$MOVE		SET DEFALUT DEVICE
	LXI	B,3
	LXI	H,PIO.DIR+DIR.EXT
	CALL	$MOVE		SET DEFAULT EXTENSION
	POP	H
	CALL	$SOB		SKIP BLANKS
	MVI	B,0
	CPI	'?'
	JE	CAD1		IS '?'
	CPI	'*'
	JE	CAD1		IS '*'
	CPI	'.'
	JE	CAD1		IS '.'
	CPI	'A'
	JC	CAD4		NOT NAME
	CPI	'Z'+1
	JNC	CAD4		NOT NAME

*	HAVE ALPHA STRING. CRACK IT

CAD1	CALL	DNT		DECODE NEXT TOKEN
	JC	CAD5		ERROR
	CPI	':'
	JNE	CAD2		NOT DEVICE

*	HAVE EXPLICIT DEVICE

	INX	H		SKIP ':'
	MVI	A,3
	CMP	C
	JC	CAD5		TOO MANY CHARACTERS
	LXI	B,3
	PUSH	H		SAVE (HL)
	LXI	H,PIO.DEV
	CALL	$MOVE		SET EXPLICIT DEVICE
	POP	H
	CALL	DNT		DECODE NEXT TOKEN
	JC	CAD5		ERROR

*	DECODE NAME

CAD2	LXI	B,8		(BC) = COUNT
	PUSH	H		SAVE TEXT ADDR

*	SEE IF NAME IS  UNSPECIFIED

	LXI	H,PIO.DIR+DIR.NAM
	PUSH	H		SAVE ADDRESS OF DIR.NAM
	CALL	$MOVE		MOVE IN NAME
	POP	H		(HL) = #PIO.DIR+DIR.NAM
	MOV	A,M
	ANA	A
	JNZ	CAD2.6		IS SPECIFIED
	LDA	CADA		(A) = FILL CHARACTER
	MVI	C,8		(C) = COUNT
CAD2.4	MOV	M,A
	INX	H
	DCR	C
	JNZ	CAD2.4
CAD2.6	POP	H
	MOV	A,M		(A) = DELIMITER
	CPI	'.'
	JNE	CAD3		NOT EXTENSION

*	HAVE EXPLICIT EXTENSION

	INX	H
	CALL	DNT
	JC	CAD5		ERROR
	MVI	A,3
	CMP	C
	JC	CAD5		TOO LONG
	LXI	B,3
	PUSH	H		SAVE TEXT POINTER
	LXI	H,PIO.DIR+DIR.EXT
	CALL	$MOVE		MOVE EXTENSION
	POP	H

*	DONE WITH NAME. MUST HAVE LEGIT DELIMITER

CAD3	MVI	B,1		(B) = NAME PRESENT FLAG

*	END OF NAME. EXIT
*	(B) = 0 IF NULL, (B) <> 0 IF NON-NULL

CAD4	CALL	$SOB		SKIP BLANKS
	MOV	A,B
	ANA	A		SET 'Z' IF NULL
	RET

*	ERROR

CAD5	MVI	A,EC.IFN	ILLEGAL FILE NAME
	STC
	RET

CADA	DB	0		FILL CHARACTER FOR OMITTED NAME FIELD
DNT	SPACE	4,10
**	DNT - DECODE NEXT TOKEN.
*
*	DNT COPIES THE NEXT ALPHANUMERIC FIELD INTO A ZERO-FILLED WORK AREA.
*
*	ENTRY	(HL) = TEXT POINTER
*	EXIT	'C' SET IF ERROR
*		'C' CLEAR IF OK
*		(A) = DELIMTER CHARACTER
*		(HL) UPDATED TO DELIMITER CHARACTER
*		(DNTA) = STRING
*		(C) = LENGTH
*		(DE) = #DNTA
*	USES	ALL

DNT	LXI	D,DNTA
	MVI	C,9		(C) = SIZE OF DNTA
	MOV	B,C		(B) = MAX ALLOWED +1
	XRA	A
DNT1	STAX	D		ZERO BUFFER
	INX	D
	DCR	C
	JNZ	DNT1
	LXI	D,DNTA

*	COPY CHARACTERS

DNT2	MOV	A,M
	CPI	'?'
	MVI	A,200Q
	JE	DNT3		IS MATCHONE
	MOV	A,M
	CPI	'*'
	JE	DNT5		IS WILDCARD
	CPI	'0'
	JC	DNT4		NOT ALPHANUMERIC
	CPI	'9'+1
	JC	DNT3		NUMERIC
	CPI	'A'
	JC	DNT4		DELIMITER
	CPI	'Z'+1
	JNC	DNT4		DELIMITER

*	HAVE GOOD CHARACTER

DNT3	STAX	D		STORE CHAR
	INX	D
	INX	H
	INR	C		COUNT
	DCR	B		LIMIT DECREMENT
	JNZ	DNT2		NOT OVERFLOW

*	OVERFLOW

	STC			FLAG ERR
	RET

*	IS '*' WILDCARD

DNT5	MVI	A,200Q
	STAX	D
	INX	D
	DCR	B
	JNZ	DNT5		FILL WITH MATCH ONE
	INX	H		SKIP '*'

*	END OF STRING

DNT4	ANA	A		CLEAR 'C'
	LXI	D,DNTA		SET POINTER
	RET

DNTA	DS	9		WORK AREA
EBM	SPACE	4,10
**	EBM - EXPAND BUFFER TO MAXIMUM.
*
*	EBM IS CALLED TO EXPAND THE BUFFER 'BUF' TO THE MAXIMUM SIZE.
*	WHICH DOES NOT REQUIRE THE OVERLAYING OF THE SYSTEM.
*
*	ENTRY	NONE
*	EXIT	(BUFSIZ) = BUFFER SIZE (MULTIPLE OF 256)
*	USES	ALL

EBM	LHLD	S.SYSM
	LXI	D,-10
	DAD	D		THROW IN SOME SLOP
	SCALL	.SETTP
	JC	IERR1		NOT ENOUGH MEMORY
	LHLD	S.USRM

	MOV	A,H		(A) = LIMIT/256
	STA	OBUFLIM		SET LIMIT
	RET
CDA	SPACE	4,10
**	CDA - CONVERT DIRECTORY FORMAT TO ASCII.
*
*	CDA COPIES A DIRECTORY ENTRY FROM PIO.XXX TO A TARGET FIELD.
*	THE DEVICE SPECIFICATION (IN PIO.DEV AND PIO.UNI) IS ALSO ENCODED.
*	THE TARGET FIELD IS LEFT IN THE FORM:
*
*	DEV:NAME.XXX <00>
*
*	ENTRY	(HL) = FWA NAME FIELD
*	EXIT	(A) = 0, HAVE WILDCARD
*		    = 1, NO WILDCARDS USED
*		'C' CLEAR
*	USES	ALL

CDA	LXI	B,3*256		(B) = CHARACTER COUNT, (C) = WILDCARD FLAG
	LXI	D,PIO.DEV
	CALL	CDA5		COPY IT
	MVI	M,':'
	INX	H
	MVI	B,8
	LXI	D,PIO.DIR+DIR.NAM
	CALL	CDA5		COPY IT
	MVI	M,'.'
	INX	H
	MVI	B,3
	ERRNZ	DIR.EXT-DIR.NAM-8
	CALL	CDA5		COPY IT
	MVI	M,0		FLAG END OF NAME
	MOV	A,C		(A) (BIT 7) = 1 IF WILDCARDS
	RLC
	CMA
	ANI	1		=0 IF WILDCARD
	RET
CDA5	SPACE	2,10
**	CDA5 - CONVERT DIRECTORY FIELD TO ASCII.
*
*	ZEROS ARE IGNORED, 200Q WILDCARDS ARE MAPPED TO '?'
*
*	ENTRY	(DE) = FROM
*		(HL) = T0
*		(B) = COUNT
*		(C) = ORA ACCUMULATOR
*	EXIT	(DE) ADVANCED
* 		(HL) = (HL)+(B)
*		(C) = (C) .OR. (FROM CHARACTERS PROCESSED)
*	USES	ALL

CDA5	LDAX	D		(A) = CHARACTER
	ORA	C
	MOV	C,A
	LDAX	D
	INX	D
	ANA	A
	JZ	CDA7		IS 00
	JP	CDA6		NOT 200Q
	MVI	A,'?'
CDA6	MOV	M,A
	INX	H		INCREMENT TO
CDA7	DCR	B
	JNZ	CDA5		IF MORE TO GO
	RET
EWS	SPACE	4,10
**	EWS - EXPAND WILDCARD SPECIFICATION.
*
*	DWS ENTERS THE FILE NAME IN PIO.XXX INTO THE MANAGED TABLE
*	NAMTAB. IF THE FILE NAME CONTAINS WILDCARDS, THE DIRECTORY
*	IS READ FOR ELIGIBLE FILES.
*
*	ENTRY	PIO.XXX = FILE NAME
*	EXIT	'C' CLEAR IF OK
*		'C' SET IF ERROR
*	USES	ALL

EWS	CALL	AEN		TRY TO ENTER IT
	RNC			NO WILDCARDS, AM DONE

*	IS WILDCARD. LOOK UP DEVICE TYPE

	LHLD	NAMTLEN
	LXI	D,NAMTAB-FB.NAML
	DAD	D		(HL) = ADDRESS OF LAST ENTRY
	CALL	CAD		CONVERT ASCII NAME TO DIRECTORY FORMAT
	LHLD	NAMTLEN
	LXI	D,-FB.NAML
	DAD	D
	SHLD	NAMTLEN		REMOVE WILDCARD FROM TABLE
	CALL	$MOVEL
	DW	3,PIO.DEV,DIRNAM	SET DIRECTORY NAME IN XXX:DIRECT.SYS
	CALL	$MOVEL
	DW	8+3,PIO.DIR+DIR.NAM,EWSC	SAVE WILDCARD PATTERN
	LXI	B,EWSB
	LXI	H,DIRNAM
	SCALL	.DECODE 	GET INFORMATION ABOUT DEVICE
	RC			ERROR
	LDA	EWSB		SEE IF A DIRECTORY DEVICE
	ANI	DT.DD
	MVI	A,EC.DNS		ASSUME DEVICE NOT SUITABLE
	STC
	RZ			ERROR

*	IS DIRECTORY DEVICE. OPEN DIRECTORY

	LXI	H,DIRNAM
	MVI	A,CN.DIR
	SCALL	.OPENR
	MVI	A,PEC.DF
	RC			DEVICE FORMAT FAILURE

*	READ DIRECTORY ENTRYS FOR MATCH

EWS1	LHLD	DIRWRKP
	XCHG			DE = POINTER TO THE SCRATCH
	LXI	B,512
	MVI	A,CN.DIR
	PUSH	D		SAVE ADDRESS
	SCALL	.READ		READ BLOCK
	POP	H		(HL) = DIRECTORY ADDRESS
	JC	EWS7		ALL DONE

*	LOOK AT DIRECTORY BLOCK FOR MATCHES

	PUSH	H
	LHLD	DIRWRKP
	LXI	D,DIS.ENL
	DAD	D
	MOV	C,M		C  = LENGTH
	POP	H

*	CHECK NEXT ENTRY

EWS3	MOV	A,M		(A) = 1ST CHAR THIS ENTRY
	ANA	A
	JZ	EWS1		END OF BLOCK
	ERRNZ	DF.EMP-377Q
	INR	A
	JZ	EWS6		ENTRY EMPTY
	ERRNZ	DF.CLR-376Q
	INR	A
	JZ	EWS7		END OF LIST
	PUSH	H
	LXI	D,EWSC
	MVI	B,8+3
	CALL	CWM		CHECK WILDCARD MATCH
	JNZ	EWS4		NO MATCH

*	HAVE MATCH. ADD TO LSIT

	POP	D		(DE) = FROM
	PUSH	D
	CALL	CSF		CHECK FOR SPECIAL FILE
	JZ	EWS4		IS SPECIAL FILE, DONT ENTER
	PUSH	B		SAVE (C)
	LXI	B,8+3
	LXI	H,PIO.DIR+DIR.NAM
	CALL	$MOVE
	CALL	AEN		ADD TO TABLE
	POP	B		RESTORE (C)

*	LOOKUP NEXT ENTRY

EWS4	POP	H
EWS6	MVI	B,0
	DAD	B		POINT TO NEXT
	JMP	EWS3

*	ALL DONE. CLOSE DIRECTORY FILE

EWS7	MVI	A,CN.DIR
	SCALL	.CLOSE
	RET

EWSA	DB	'SY0',200Q,200Q,200Q

EWSB	DS	30

EWSC	DS	8+3		WILDCARD PATTERN FOR DIRECTORY SEARCH
INA	SPACE	4,10
**	INA - INCREASE NAMTAB ALLOCATION.
*
*	INA IS CALLED TO INCREASE THE NAMTAB ALLOCATION. THE
*	BUFFER AREA IS MOVED UP TO MAKE ROOM.
*
*	ENTRY	NONE
*	EXIT	NONE
*	USES	A,F,H,L

INA	LXI	H,NAMTMAX+1
	INR	M		INCREMENT LENGTH
	LXI	H,BUFPTR+1
	INR	M		MOVE BUFFER
	LHLD	BUFSIZ
	MOV	A,H
	ORA	L
	MVI	A,EC.NEM	FLAG OUT OF MEMORY IF BUFFER NOT EMPTY
	JNZ	ERROR
	PUSH	B
	PUSH	D
	CALL	SBE		NOTIFY SYSTEM
	POP	D
	POP	B
	RET
LSN	SPACE	4,10
**	LSN - LOCATE SOURCE NAME
*
*	LSN SCANS THE COMMAND LINE FOR THE FIRST SOURCE FILE NAME.
*
*	ENTRY	NONE
*	EXIT	(HL) = 1ST FILE NAME FWA
*	USES	A,F,H,L

LSN	LHLD	LINEP		HL = Line Pointer

LSN1	MOV	A,M
	INX	H
	CPI	'='
	RE			GOT IT

	ANA	A
	JNZ	LSN1		MORE LINE

	LHLD	LINEP		Is no '='
	RET
MWN	SPACE	4,10
**	MWN - MERGE WILDCARD NAMES.
*
*	MWN MERGES A COMPLETELY SPECIFIED FILENAME WITH A WILDCARDED COMPLETELY
*	SPECIFIED FILE NAME.
*
*	BOTH FILE NAMES SHOULD HAVE THE SAME DEVICE SPECIFICATION.
*
*	FILE NAME FORMAT:
*
*	DEV:NAMEXXXX.EXT 00
*
*	ENTRY	(BC) = ADDRESS OF WILDCARDED ASCII NAME
*		(DE) = ADDRESS OF NON-WC ASCII NAME
*		(HL) = ADDRESS FOR RESULTANT ASCII NAME
*	EXIT	NONE
*	USES	ALL

MWN	PUSH	H		SAVE TARGET ADDRESS
	PUSH	B		SAVE WC PATTERN
	XCHG			(HL) = MASTER NAME
	CALL	CAD		CONVERT TO DIRECTORY FORMAT
	CALL	$MOVEL
	DW	8+3,PIO.DIR,MWNA	(MWNA) = DECODED MASTER
	POP	H		(HL) = WC PATTERN
	CALL	CAD		(PIO.DIR) = WC PATTERN
	LXI	D,MWNA		(DE) = MASTER PATTERN
	LXI	H,PIO.DIR	(DE) = WC PATTERN ADDRESS
	MVI	C,8+3		MERGE NAME AND EXTENSION

*	MERGE NAMES

MWN1	MOV	A,M		(A) = WC PATTERN
	ANA	A
	JP	MWN2		USE THIS
	LDAX	D		IS MATCH CHARACTER, USE MASTER INSTEAD
MWN2	MOV	M,A		STORE CHARACTER
	INX	D
	INX	H
	DCR	C
	JNZ	MWN1		MERGE TILL DONE
	POP	H		(HL) = TARGET ADDRESS
	JMP	CDA		CONVERT DIRECTORY FORMAT TO ASCII
REN	SPACE	4,10
**	REN - REMOVE ENTRY FROM *NAMTAB*
*
*	REN REMOVES THE FIRST 'FB.NAML' BYTES FROM NAMTAB.
*
*	THE AMOUNT (FB.NAML) IS REMOVED FROM THE SIZE OF THE TABLE. THE
*	TABLE IS NOT CHECKED FOR UNDERFLOW, THE CALLER MUST GUARANTEE THE
*	PRESENSE OF AT LEAST FB.NAML BYTES IN NAMTAB.
*
*	ENTRY	NONE
*	EXIT	NONE
*	USES	ALL

REN	LHLD	NAMTLEN
	LXI	D,-FB.NAML
	DAD	D		REMOVE COUNT FROM LEN
	SHLD	NAMTLEN
	MOV	B,H
	MOV	C,L		(BC) = REMAINING LENGTH
	LXI	D,NAMTAB+FB.NAML	(DE) = START OF 2ND ENTRY
	LXI	H,NAMTAB
	JMP	$MOVE		MOVE DOWN AND RETURN
SBE	SPACE	4,10
**	SBE - SET BUFFER EMPTY.
*
*	THE SYSTEM IS NOTIFIED.
*
*	ENTRY	NONE
*	EXIT	NONE
*	USES	ALL

SBE	LXI	H,0
	SHLD	BUFSIZ
	LHLD	BUFPTR		(HL) = BUFFER FWA (AND LWA!)
	INX	H
	INX	H
	SCALL	.SETTP
	RNC			OK
	JMP	ERROR		NOT ENOUGH ROOM
SFS	SPACE	4,10
**	SFS - SKIP FILE SEPERATOR.
*
*	SFS IS CALLED TO SKIP OVER THE CHARACTERS SEPERATING ONE
*	FILE NAME FROM ANOTHER ON THE LINE. THE FILES MAY BE SEPERATED
*	BY BLANKS OR A COMMA ALONE, OR BY BLANKS WITH A COMMA. THE
*	SYNTAX IS
*
*	<BLANKS> <,> <BLANKS>
*
*	ONE, TWO OR ALL THREE FIELDS MAY BE PRESENT.
*
*	ENTRY	(HL) = POINT TO START OF SEP FIELD
*	EXIT	(HL) ADVANCED PAST SEPERATOR FIELD
*	USES	A,F,H,L

SFS	CALL	$SOB		SKIP BLANKS
	MOV	A,M
	CPI	','
	JNE	SFS1		NOT ,
	INX	H		SKIP ,
SFS1	JMP	$SOB		GET ANY MORE BLANKS AND EXIT
SND	SPACE	4,10
**	SND - SET NEW DEFAULTS.
*
*	SND IS CALLED TO SET A NEW DEFAULT DEVICE AND EXTENSION
*	IN THE 'DEFALT' AREA.
*
*	ENTRY	PIO.DEV = DEVICE CODE
*		PIO.UNI = UNIT #
*		PIO.DIR+DIR.EXT = EXTENSION
*	EXIT	NONE
*	USES	NONE

SND	CALL	$SAVALL		SAVE REGS
	ERRNZ	PIO.UNI-PIO.DEV-2
	CALL	$MOVEL
	DW	3
	DW	PIO.DEV
	DW	SOURCE+DEFAULT

	CALL	$MOVEL
	DW	3
	DW	PIO.DIR+DIR.EXT
	DW	SOURCE+DEFAULT+3
	JMP	$RSTALL		RETURN
SRCDRVR	SPACE	4,10
**	SRCDRVR	- Source Device Driver
*
*	SRCDRVR invokes the Source device Driver
*
*	ENTRY:	NONE
*
*	EXIT:	NONE
*
*	USES:	NONE

SRCDRVR	PUSH	PSW
	LDA	SOURCE+UNIT
	STA	AIO.UNI
	POP	PSW
	JMP	SOURCE+DRIVER
	STL	'COMMON DECKS'
	EJECT
	XTEXT	CDEHL
	XTEXT	CHL
	XTEXT	COMP
	XTEXT	CRLF
	XTEXT	DADA
	XTEXT	DADA2
	XTEXT	DTB
	XTEXT	DU66
	XTEXT	FERROR
	XTEXT	HLIHL
	XTEXT	ILDEHL
	XTEXT	INDL
	XTEXT	INDXX
	XTEXT	ISDEHL
	XTEXT	MCU
	XTEXT	MOVE
	XTEXT	MOVEL
	XTEXT	MU86
	XTEXT	RCHAR
	XTEXT	SAVALL
	XTEXT	SOB
	XTEXT	TFN
	XTEXT	TJMP
	XTEXT	TYPCC
	XTEXT	TYPCH
$CMP$	EQU	1
	XTEXT	TYPLN
	XTEXT	TYPT2
	XTEXT	UDD
	XTEXT	UDDN
	XTEXT	XCHGBC
	XTEXT	ZERO
	STL	'SYSGEN SPECIAL DATA STRUCTURES'
	EJECT
**	FDN - FILE DESCRIPTOR NODES.
*
*	THESE NODES ARE USED TO KEEP TRACK OF FILES WHICH ARE BEING
*	HELD IN MEMORY WHILE TRANSFERING.

FDN	DS	0		START OF TYPICAL NODE

FDN.LNK	EQU	*-FDN		LINK TO NEXT NODE IN CHAIN
	DS	2		Full word link

FDN.STA	EQU	*-FDN		STATUS BYTE
ST.CNT	EQU	DIF.CNT		IS CONTIGUOUS
ST.OPR	EQU	00000010B	IS BEING READ
ST.OPW	EQU	00000001B	OPEN FOR WRITE
	DS	1

FDN.FLG	EQU	*-FDN		FLAG BITS SET ON SOURCE FILE
	DS	1

FDN.SIZ	EQU	*-FDN		TOTAL SIZE OF FILE (IF ST.CNT SET)
	DS	2		  In Sectors

FDN.AMR	EQU	*-FDN		AMOUNT ALREADY READ
	DS	2		 IN SECTORS

FDN.AMW	EQU	*-FDN		AMOUNT ALREADY WRITTEN
	DS	2		 IN SECTORS

FDN.ADR	EQU	*-FDN		ADDRESS IN BUFFER
	DS	1		 ADDRESS/256 (MUST BE EVEN PAGE)

FDN.AIM	EQU	*-FDN		AMOUNT IN MEMORY
	DS	1		  IN SECTORS

FDNELEN	EQU	*-FDN		ENTRY  LENGTH

	ORG	FDN		ORG BACK OVER DEFINITION AREA
	SPACE	4,10
**	TABLE. A LINK OF 0 IS A NULL LINK.
*

FDNFREE DW	0		HEAD of FREE List
FDNHED	DW	0		HEAD of FILE List

FDN.1	DS	0
	DC	FDNCNT*FDNELEN,#0AAH	Reserve space for nodes

OBUFLIM	DB	0		BUFFER LIMIT/256
OBUFPTR	DB	0		NEXT FREE PAGE IN BUFFER/256
	STL	'DATA AND FILE BUFFERS'
	EJECT
BUFPTR	DW	BUFF		POINTER TO START  OF BUFFER
BUFSIZ	DW	0		BUFFER LENGTH
CMDLIN	DB	0		!= 0  =>  Command Line specified
DRIVES2 DB	0		!= 0  =>  Two-Drive system
LINEP	DW	0		Line Pointer
MINIMUM DB	0		!= 0  =>  Minimal Sysgen
QUERY	DB	0		!= 0  =>  Query extra files
SRCSPG	DB	0		Source volume Sectors per Group
VOLFLAG DB	0		== 0  =>  System Vol. Mounted
*				== 377Q => Dest. Vol. Mounted

DIRNAM	DB	'XXX:DIRECT.SYS',0	DIRECTORY FILE NAME


DEST	EQU	*

	ERRNZ	*-DEFAULT-DEST
	DB	'SY1',0,0,0

	ERRNZ	*-DEVTAB-DEST
	DW	0

	ERRNZ	*-DRIVER-DEST
	JMP	0

	ERRNZ	*-UNIT-DEST
	DB	1

	ERRNZ	*-DEVICE-DEST
	DB	'SY1:',0

	ERRNZ	*-DVCLEN-DEST


SOURCE	EQU	*

	ERRNZ	*-DEFAULT-SOURCE
	DB	'SY0',0,0,0

	ERRNZ	*-DEVTAB-SOURCE
	DW	0

	ERRNZ	*-DRIVER-SOURCE
	JMP	0

	ERRNZ	*-UNIT-SOURCE
	DB	0

	ERRNZ	*-DEVICE-SOURCE
	DB	'SY0:',0

	ERRNZ	*-DVCLEN-SOURCE
	SPACE	3,10
**	FILE BLOCKS

DESTFB	DS	0		DUMMY BUFFER
	DB	200		ILLEGAL CHANNEL NUMBER
	DB	0		FLAGS
	DW	0
	DW	0
	DW	0
	DW	0		END OF BLOCK
	DS	FB.NAML		NAME AREA
	SPACE	3,10
NAMTLEN	DW	0		NAME TABLE POINTER
NAMTMAX	DW	0		MAXIMUM SIZE OF NAME TABLE
NAMTPTR	DW	0		POINTER TO ACTIVE ELEMENT IN NAMTAB

OFILES	DB	'*.*='
OFILESA DC	80,#0AAH	Optional File List
OFILESL EQU	*-OFILES
	DB	0
	SPACE	3,5
PATCH	DC	32,#0AAH
	STL	'PRS - PRESET PROGRAM (OVERLAID BY BUFFERS).'
	EJECT
PCL	SPACE	4,10
**	PCL	- Parse Command Line
*
*	PCL parses the command line.  Valid switches are:
*
*		M[INIMUM]	Minimal Sysgen
*		Q[UERY]		Query user for optional files
*		File list specifying files other than internal default
*
*	ENTRY:	Command line pushed on the stack, followed by return address
*
*	EXIT:	Command line parsed
*
*	USES:	ALL
*

PCL	LXI	H,2
	DAD	SP		PRS must directly call this routine
	LXI	D,STACK
	CALL	$CDEHL
	RZ			Nothing on Stack other than RET address

	PUSH	H
	LXI	D,SWTFWA
	CALL	$DRS
	POP	H		Restore pointer
	JC	ERROR		Bad error

	LDA	MINIMUM
	MOV	B,A
	LDA	QUERY
	ANA	B		/min and /query together are illegal
	MVI	A,PEC.CS
	JNZ	ERROR

	CALL	$SOB
	MOV	A,M
	ANA	A
	RZ

*	Process File List

	STA	CMDLIN		Flag Command Line specified

	LDA	MINIMUM
	ANA	A
	MVI	A,PEC.CS
	JNZ	ERROR		/min and command list together are illegal

	MVI	C,OFILESL
	LXI	D,OFILESA
PCL1	MOV	A,M		Copy the file list to the optional table
	STAX	D
	INX	D
	INX	H
	ANA	A
	RZ			End of List

	DCR	C
	JNZ	PCL1

	MVI	A,PEC.CO
	JMP	ERROR		COMMAND OVERFLOW
PDN	SPACE	4,10
**	PDN	- Parse Device Name
*
*	PDN parses a device name, assuming a default of SY0:.
*
*	ENTRY:	NONE
*
*	EXIT:	To EXIT if CTL-D was hit
*		DEST and SOURCE initialized
*		DRIVES2	= 0 iff 1-drive sysgen
*			= 1 iff 2-drive sysgen
*
*	USES:	ALL

PDN	CALL	$CCO
	CALL	$TYPTX
	DB	NL
	DB	'Destination Device <SY0:>?',' '+200Q

	CALL	$ITL.
	JC	EXIT		Exit if CTL-D is hit

	LXI	H,ITLA		HL = Address of device specification
PDN.	LXI	B,PDNA		Decode Area
	LXI	D,PDNC		Default Device
	CALL	DDS
	JNC	PDN1		No Problems with Device Specification

*	Illegal Device Specification

	CALL	$TYPTX
	DB	NL
	DB	'Illegal Device Specification',ENL

	JMP	PDN

*	Set up Flags and Pointers

PDN1	XRA	A
	STA	DRIVES2		Default to 1-Drive Sysgen
	MVI	C,PDNAL
	LXI	D,PDNA
	LXI	H,PDND
	CALL	$COMP		Compare Destination to Source
	JZ	PDN2		Source == Destination

*	Source != Destination, Initialize Source

	MVI	A,1
	STA	DRIVES2		Flag 2-drive sysgen

	LHLD	PDNA
	SHLD	DEST+DEFAULT	Initialize Name
	SHLD	DEST+DEVICE
	LDA	PDNB
	STA	DEST+UNIT	Initialize Binary Unit
	ADI	'0'		Convert to ASCII
	STA	DEST+DEFAULT+IOC.UNI-IOC.DEV
	STA	DEST+DEVICE+IOC.UNI-IOC.DEV

*	Initialize Source

PDN2	LHLD	PDND
	SHLD	SOURCE+DEFAULT	Initialize Device Name
	SHLD	SOURCE+DEVICE
	LDA	PDND+IOC.UNI-IOC.DEV
	STA	SOURCE+UNIT
	ADI	'0'		Convert to ASCII
	STA	SOURCE+DEFAULT+IOC.UNI-IOC.DEV
	STA	SOURCE+DEVICE+IOC.UNI-IOC.DEV

	RET

PDNA	DB	'xx'
PDNB	DB	0
PDNAL	EQU	*-PDNA

	ERRNZ	IOC.UNI-IOC.DEV-2	2-Byte Device
	ERRNZ	IOC.DIR-IOC.UNI-1	1-Byte Unit

PDNC	DB	'SY0',0,0,0		Default Destination Device

PDND	DB	'SY'			Source Device Specification
	DB	0
PRS	SPACE	4,10
***	PRS - PRESET PROGRAM.
*
*	PRS IS CALLED TO PERFORM ONE-TIME-ONLY PRESETTING OF
*	THE PROGRAM ENVIRONMENT.
*
*	THE CODE IS OVERLAID BY BUFFERS AND WORK AREAS.
*
*	ENTRY	NONE
*	EXIT	NONE
*	USES	ALL

ENTRY	EQU	*		INITIAL ENTRY POINT

PRS	SCALL	.VERS
	JC	PRSERR		NO .VERS SYSTEM CALL
	CPI	VERS
	JNZ	PRSERR

	MVI	A,377Q
	SCALL	.CLOSE		CLOSE THE CHANNEL THAT WE CAME IN ON
	LXI	H,RMEML		(HL) = RUN-TIME HIGH MEMORY
	SCALL	.SETTP		SET HI MEMORY
	JC	ERROR

	XRA	A
	STA	CMDLIN		Initialize to NO command line
	STA	MINIMUM 	Initialize to Normal Sysgen
	STA	QUERY		Initialize to no query

	LXI	H,CCHIT
	MVI	A,CTLC
	SCALL	.CTLC		SET CTL/C PROCESSING

	CALL	$TYPTX
	DB	NL,TAB,TAB,TAB,'   ','SYSGEN'
	DB	NL,TAB,TAB,TAB,'Version:  ',VERS/16+'0','.',VERS&0FH+'0'
	DB	NL,TAB,TAB,'      ','Issue:  #50.07.00'
	DB	NL
	DB	ENL

	CALL	PCL		Parse Command Line
	CALL	PDN		Parse Device Name

	LXI	H,SOURCE+DEVICE
	SCALL	.LOADD		Load Source Device Driver
	JC	ERROR
	SHLD	SOURCE+DEVTAB	Save Table Address
	LXI	D,DEV.JMP
	DAD	D		HL = driver jump address
	SHLD	SOURCE+DRIVER+1

	LDA	DRIVES2
	ANA	A
	JZ	PRS1		1-Drive Sysgen

	LXI	H,DEST+DEVICE
	SCALL	.LOADD		Load Device Driver for Destination
	JC	ERROR
	SHLD	DEST+DEVTAB	Save Device Table Address
	LXI	D,DEV.JMP
	DAD	D		HL = Device Jump Address
	SHLD	DEST+DRIVER+1

PRS1	CALL	$DOS		DISMOUNT OPERATING SYSTEM
	JC	ERROR

*	Mount the Source Diskette

	CALL	$MOVEL		Stuff Source specification
	ERRNZ	IOC.DIR-IOC.DEV-3
	DW	3
	DW	SOURCE+DEVICE
	DW	PRSA

	CALL	$TYPTX
	DB	NL
	DB	'Insert the Source Diskette in '
PRSA	DB	'xxn:.  Hit Return when Ready:',' '+200Q

PRS2	CALL	$RCHAR
	CPI	NL
	JNZ	PRS2		Wait for Newline

	LXI	H,SOURCE+DEVICE
	CALL	MND.

	LHLD	SOURCE+DEVTAB
	LXI	D,DEV.UNT
	DAD	D		HL = Address of Unit Pointer
	XRA	A		Use unit 0
	CALL	S.GUP		HL = Base address of SY0: Unit Table
	CALL	$INDLB		A  = Sectors Per Group
	DW	UNT.SPG
	STA	SRCSPG		Save Source SPG for later

	LDA	DRIVES2
	ANA	A
	JNZ	PRS3		2-Drive Sysgen

*	1-Drive Sysgen

	CALL	$MOVEL
	DW	DVCLEN		Count
	DW	SOURCE		From
	DW	DEST		To

	JMP	PRS5

*	2-Drive Sysgen, Mount Destination

PRS3	CALL	$MOVEL		Stuff Device Specification into message
	ERRNZ	IOC.DIR-IOC.DEV-3
	DW	3
	DW	DEST+DEVICE
	DW	PRSB

	CALL	$TYPTX
	DB	NL
	DB	'Insert the Destination Diskette in '
PRSB	DB	'xxn:.  Hit Return when Ready:',' '+200Q

PRS4	CALL	$RCHAR
	CPI	NL
	JNZ	PRS4		Wait for NL

	LXI	H,DEST+DEVICE
	CALL	MND.		Mount a new Diskette

	ERRNZ	*-PRS5

PRS5	MVI	A,I.CSLMD
	MVI	B,CSL.CHR
	MVI	C,CSL.CHR	Character Mode
	SCALL	.CONSL
	JC	ERROR

	JMP	START

PRSERR	MVI	A,EC.NCV	NOT CORRECT VERSION
	STC
	JMP	ERROR
	STL	'Switch Processors'
	EJECT
P.MIN	SPACE	4,10
**	P.MIN	- Process Minimum
*
*	P.MIN processes the minimum switch
*
*	This switch will transfer the minimal set
*	of HDOS working files.
*

P.MIN	MVI	A,1
	STA	MINIMUM
	ANA	A		Clear 'C'
	RET
P.QUE	SPACE	4,10
**	P.QUE	- Process Query
*
*	P.QUE processes the query switch
*
*	This switch will query the user as to whether
*	each non-essential file is to be transfered.
*

P.QUE	MVI	A,1
	STA	QUERY
	ANA	A		Clear 'C'
	RET
	STL	'Overlaid Common Decks'
	EJECT
	XTEXT	CCO
	XTEXT	DDS
	XTEXT	DOS
	XTEXT	DRS
	XTEXT	ITL
	XTEXT	MLU
	XTEXT	RTL
	STL	'Overlaid Buffers and Data'
	EJECT
**	Overlaid Buffers and Data
*

SWTFWA	DS	0		Switch Table FWA

	DB	'M'		/M[INIMAL]
	DB	'I'+200Q,'N'+200Q,'I'+200Q,'M'+200Q,'A'+200Q,'L'+200Q,200Q
	DW	P.MIN

	DB	'Q'		/Q[UERY]
	DB	'U'+200Q,'E'+200Q,'R'+200Q,'Y'+200Q,200Q
	DW	P.QUE

	DB	0

ITLA	EQU	*		Line buffer
	SPACE	4,8
**	"what" identification

	DB	'@(#)HDOS 3.0 System Generation Utility',NL
	DW	.DATE.
	DW	.TIME.

	DS	80-(*-ITLA)		; make up to 80 character line buffer

MEML	EQU	*		MEMORY LENGTH
	STL	'RUN-TIME WORK AREAS'
	EJECT
**	THE FOLLOWING BUFFERS AND AREAS OVERLAY THE PRS CODE.

	ORG	PRS

DSTLAB	DS	256		Saved Destination Label
SRCLAB	DS	256		Saved Source Label
LABEL	DS	256		Transient Label

MWNA	DS	FB.NAML		MWN WORK AREA


**	* * NOTE * *
*
*	DIRWORK  USES THE SYSTEM SCRATCH AREA, SECSCR. DIRWORK WILL NOT
*	BE PRESERVED DURING A SYSCALL !!

DIRWRKP	EQU	S.SCR		POINTER TO THE SCRATCH AREA
PIO.	SPACE	3,10
**	PIO.XXX - IMAGE OF SYSTEM AIO.XXX AREA
*
*	THESE CELLS MIRROR THE SYSTEM AIO.XXX AREA


PIO.DEV	DS	2		DEVICE CODE
PIO.UNI	DS	1		UNIT NUMBER (0-9)

PIO.DIR	DS	DIRELEN		DIRECTORY ENTRY


NAMTAB	DS	0		NAME TABLE


BUFMINL	EQU	512		MINIMUM SIZE FOR BUFFER (WHEN IN USE)
BUFF	EQU	*		BUFFER AREA STARTS AFTER NAMTAB

RMEML	EQU	*		INITIAL RUNNING MEMORY LENGTH

	ORG	MEML		; back to last code

	END	ENTRY
