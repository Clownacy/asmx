$MOVL	SPACE	4,10
**	$MOVL - MOVE DATA
*
*	$MOVL MOVES A BLOCK OF BYTES TO A NEW MEMORY ADDRESS.
*
*	THIS MOVE ROUTINE WILL MOVE 0 TO 65535 BYTES.  IT SHOULD BE
*	USED IN PLACE OF THE H17 ROM ROUTINE WHICH ONLY MOVES
*	0 TO 32767 BYTES.
*
*	IF THE MOVE IS TO A LOWER ADDRESS, THE BYTES ARE MOVED FROM
*	FIRST TO LAST.
*
*	IF THE MOVE IS TO A HIGHER ADDRESS, THE BYTES ARE MOVED FROM
*	LAST TO FIRST.
*
*	THIS IS DONE SO THAT AN OVERLAPED MOVE WILL NOT 'RIPPLE'.
*
*	ENTRY	(BC) = COUNT
*		(DE) = FROM
*		(HL) = TO
*	EXIT	MOVED
*		(DE) = ADDRESS OF NEXT FROM BYTE
*		(HL) = ADDRESS OF NEXT *TO* BYTE
*		'C' CLEAR
*	USES	ALL

$MOVL	EQU	*

*	IF COUNT IS EQUAL TO 0, THEN RETURN IMMEDIATELY.

	MOV	A,B
	ORA	C
	RZ

*	DETERMINE IF WE ARE MOVING TO LOWER OR HIGHER ADDRESS.

	MOV	A,L
	SUB	E
	MOV	A,H
	SBB	D
	JC	$MOVL2		MOVE IS TO A LOWER ADDRESS

*	MOVE IS TO HIGHER ADDRESS, THEREFORE MOVE LAST TO FIRST.

	XCHG			ADJUST *FROM*
	DAD	B		  ADDRESS TO
	XCHG			    LAST BYTE + 1
	PUSH	D		SAVE IT

	DAD	B		ADJUST *TO* ADDRESS TO LAST BYTE + 1
	PUSH	H		SAVE IT

$MOVL1	EQU	*
	DCX	D		DECREMENT POINTERS
	DCX	H
	LDAX	D		MOVE BYTE
	MOV	M,A
	DCX	B		DECREMENT COUNT
	MOV	A,B		Q. HAS COUNT
	ORA	C		    GONE TO ZERO
	JNZ	$MOVL1		     BR IF NOT

	POP	H		RETRIEVE *TO* LWA+1
	POP	D		RETRIEVE *FROM* LWA+1
	RET

*	MOVE IS TO A LOWER ADDRESS, THEREFORE MOVE FIRST TO LAST.

$MOVL2	EQU	*
	LDAX	D		MOVE BYTE
	MOV	M,A
	INX	D		INCREMENT POINTERS
	INX	H
	DCX	B		DECREMENT COUNT
	MOV	A,B		Q. HAS COUNT
	ORA	C		    GONE TO ZERO
	JNZ	$MOVL2		     BR IF NOT

	RET
