	SPACE	4,10
**	$FWRIB - WRITE BYTES FROM FILE BUFFER.
*
*	$FWRIB IS CALLED TO WRITE A NUMBER OF BYTES FROM A FILE BUFFER.
*
*	ENTRY	(BC) = BYTE COUNT
*		(DE) = FWA FOR BYTES
*		(HL) = ADDRESS OF FILE BUFFER
*	EXIT	TO *FERROR* IF ERROR
*		TO CALLER IF OK
*		 (DE) = ADDRESS OF FIRST UNWRITTEN BYTE
*	USES	A,F,B,C,D,E

$FWRIB	CALL	$FWRIB.
	RNC				; RETURN IF OK
	JMP	$FERROR 		; ERROR


$FWRIB.	PUSH	H
	CALL	CBT			; COPY BUFFER POINTERS TO TEMP CELLS

*	COPY DATA FROM USER AREA TO BUFFER

$WRIB2	PUSH	D			; SAVE AREA ADDRESS
	LDA	T.FLG
	ANI	FT.OW			; SEE IF OPEN FOR WRITE
	JZ	$WRIB8			; FILE NOT OPEN FOR WRITE
	MOV	A,B
	ORA	C
	JZ	$WRIB8			; ALL DONE

*	COMPUTE MIN( ROOM IN BUFFER, WRITE COUNT REQUESTED)

$WRIB3	LHLD	T.PTR
	XCHG				; (DE) = (FB.PTR) = ADDRESS OF ROOM
	LHLD	T.LWA			; (HL) = LIMIT ADDRESS
	MOV	A,L
	SUB	E
	MOV	L,A
	MOV	A,H
	SBB	D
	MOV	H,A			; (HL) = BYTES OF ROOM IN BUFFER
	MOV	A,C			; COMPARE REQUESTED COUNT TO BUFFER ROOM
	SUB	L
	MOV	A,B
	SBB	H
	JNC	$WRIB4			; MORE REQUESTED THEN ROOM
	MOV	H,B
	MOV	L,C			; USE REQUESTED COUNT
$WRIB4	MOV	A,H
	ORA	L
	JNZ	$WRIB6			; SOME ROOM IN BUFFER

*	BUFFER IS FULL. EMPTY IT

	PUSH	B			; SAVE COUNT
	LHLD	T.FWA
	SHLD	T.PTR			; CLEAR REMOVAL POINTER
	XCHG
	LHLD	T.LWA
	MOV	A,L
	SUB	E
	MOV	C,A
	MOV	A,H
	SBB	D
	MOV	B,A			; (BC) = DATA IN BUFFER
	LDA	T.CHA
	SCALL	.WRITE			; WRITE BUFFER
	POP	B			; (BC) = DESIRED COUNT
	JNC	$WRIB3			; GOT THE DATA

*	ERROR ON WRITE.

	JMP	$WRIB8			; HAVE ERROR

*	GOT THE DATA. MOVE IT FROM BUFFER TO TARGET
*
*	(BC) = REQUEST COUNT
*	(DE) = TO
*	(HL) = COUNT
*	((SP)) = FROM

$WRIB6	MOV	A,C
	SUB	L
	MOV	C,A
	MOV	A,B
	SBB	H
	MOV	B,A			; REMOVE BYTES FROM REQUEST COUNT
	PUSH	B
	XTHL				; (HL) = REMAINING REQUEST COUNT
	POP	B			; (BC) = COUNT FOR THIS COPY
	XTHL				; (HL) = TARGET ADDR, ((SP)) = REMAINING
$WRIB7	MOV	A,M
	STAX	D
	INX	D
	INX	H
	DCX	B
	MOV	A,B
	ORA	C
	JNZ	$WRIB7			; MORE TO GO
	XCHG
	SHLD	T.PTR			; UPDATE POINTER
	POP	B			; (BC) = REMAINING COUNT
	JMP	$WRIB2			; SEE IF MORE IN BUFFER

*	WRITE COMPLETE.
*
*	(PSW) = COMPLETION FLAGS

$WRIB8	POP	D			; RESTORE TARGET ADDRESS
	POP	H
	JMP	CTB			; COPY TEMP POINTERS BACK TO BLOCK, EXIT
	SPACE	4,10
**	$FWBRK	-  BREAKOUTPUT
*
*	$FWBRK empties the specified buffer by filling it with NULLs
*	and then writing it.  Note this is used to insure that block
*	mode I/O is output if it is not really a serial device (eg.
*	writing to AT: from  *EDIT*.
*
*
*	ENTRY:	HL = FILE BLOCK POINTER
*	EXIT:	HL = FILE BLOCK POINTER
*		 to $FERROR IF ERROR
*	USES:	A,F,B,C,D,E

$FWBRK	CALL	$FWBRK.
	RNC				; NO ERROR

	JMP	$FERROR

$FWBRK.	PUSH	H
	CALL	CBT			; COPY BUFFER TO TEMPORARY
	CALL	$FWBRK1
	POP	H
	CALL	CTB			; COPY TEMPORARY TO BUFFER
	RET

$FWBRK1	LHLD	T.LWA
	XCHG				; DE = BUFFER LWA
	LHLD	T.PTR			; HL = BUFFER PTR
	MOV	A,E
	SUB	L
	MOV	C,A
	MOV	A,D
	SBB	H
	MOV	B,A			; BC = DE - HL
	ORA	C
	RZ				; THE BUFFER IS ALREADY FLUSHED
	
*	FILL THE BUFFER WITH NULLS

FWBRK2	MOV	A,B
	ORA	C
	JZ	FWBRK3			; NO MORE LEFT TO FILL

	MVI	M,0
	INX	H
	DCX	B
	JMP	FWBRK2

FWBRK3	LHLD	T.FWA
	SHLD	T.PTR
	XCHG				; DE = BUFFER FWA
	LHLD	T.LWA			; HL = BUFFER LWA
	MOV	A,L
	SUB	E
	MOV	C,A
	MOV	A,H
	SBB	D
	MOV	B,A			; BC = HL - DE	( BC = COUNT )
	LDA	T.CHA
	SCALL	.WRITE
	RET
