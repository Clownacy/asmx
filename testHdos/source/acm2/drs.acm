**	$DRS - DECODE AND REMOVE SWITCHES.
*
*	$DRS IS CALLED TO DECODE COMMAND SWITCHES FROM A LINE
*	OF TEXT. SWITCHES TAKE THE FORM:
*
*	/XXXXX
*
*	AFTER A SWITCH HAS BEEN LOCATED, IT (AND THE PRECEDING '/')
*	ARE REPLACED WITH BLANKS.
*
*	VALID SWITCH DESCRIPTIONS ARE ENCODED INTO A TABLE
*	SUPPLIED BY THE CALLER, IN THE FORMAT:
*
*	DB	'X...X'		REQUIRED SWITCH CHARACTERS
*	DB	'C'+200Q,...,'C'+200Q	OPTIONAL CHARACTERS
*	DB	200Q		END OF CHARACTERS
*	DW	ADDR		PROCESSOR ADDRESS (CALLED WHEN SWITCH DETECTED)
*
*	DB	'Y...Y'		NEXT SWITCH
*	.	.
*	.	.
*	.	.
*
*	DB	0		FLAGS END OF TABLE
*
*	SWITCHES MUST BE FOLLOWED BY A ':', A '/' (ANOTHER SWITCH)
*	A ',', OR A 00 BYTE.
*
*	UPON DETECTION OF A VALID SWITCH, $DRS CALLS THE USER PROCESS
*	ROUTINE, UPON ENTRY,
*	(HL) = ADDRESS OF THE FIRST BYTE FOLLOWING THE SWITCH
*	'Z' CLEAR IF CHARACTER = '/', ',', OR 00
*	'Z' SET IF CHARACTER = ':'
*
*	THE USER ROUTINE CAN DECODE SWITCH SUB-OPTIONS, IF DESIRED.
*	THE USER ROUTINE MAY USE ALL REGISTERS.
*
*	ENTRY	(DE) = SWWITCH TABLE FWA
*		(HL) = LINE FWA
*	EXIT	'C' CLEAR IF OK
*		'C' SET IF ERROR
*		(HL) = ADDRESS OF START OF BAD SWITCH
*		(A) = ERROR CODE
*	USES	ALL

$DRS	EQU	*

*	LOOK FOR SWITCHES
$DRS1	MOV	A,M
	ANA	A
	RZ			END OF LINE
	INX 	H
	CPI	'/'
	JNE	$DRS1		NOT A SWITCH
	SHLD	$DRSB		($SRSB) = SWITCH FWA (AFTER '/')
	
*	GOT A SWITCH. LOOK FOR A MATCH IN THE CALLER'S TABLE

	PUSH	D		SAVE TABLE FWA
$DRS2	LHLD	$DRSB		(HL) = SWITCH FWA
$DRS3	LDAX	D		(A) = TABLE ENTRY
	ANI	177Q
	JZ	$DRS6		GOT A MATCH
	CMP	M
	JNE	$DRS4		NO MATCH
	INX	D
	INX	H
	JMP	$DRS3		SEE IF MORE MATCH
	
*	HAVE MIS-MATCH. SEE IF THE MISSING CHARACTER IS SIGNIFICANT

$DRS4	MOV	A,M		(A) - LINE CHARACTER WE COULDNT MATCH
	CALL	$DRS15		SEE IF OK TERMINATOR
	JNE	$DRS4.5		NO MATCH ON THIS SWITCH
	LDAX	D		(A) = NEXT CHARACTER IN SWITCH PATTERN
	ANA	A
	JM	$DRS6		HAVE SUFFICIENT MATCH
$DRS4.5	CALL	$DRS20		SKIP TABLE ENTRY
	LDAX	D
	ANA	A
	JNZ	$DRS2		MORE SWITCHES IN TABLE TO CHECK

*	BAD SWITCH

$DRS5	POP	D		RESTORE STACK
	LHLD	$DRSB		POINT TO BAD SWITCH
	STC
	MVI	A,EC.IS		ILLEGAL SWITCH
	RET

*	HAVE SWITCH. CHECK IT'S FOLLOWING CHARACTER

$DRS6	CALL	$SOB		SKIP OVER BLANKS
	MOV	A,M
	CALL	$DRS15		CHECK CHARACTER
	JNE	$DRS5		IN ERROR
	CALL	$DRS20		GET PROCESSOR ADDRESS
	LXI	D,$DRS7
	PUSH	H		SAVE (HL)
	PUSH	D		SET RETURN ADDRESS FOR TABLE CODE
	PUSH	B		SAVE PROCESSOR ADDRESS
	MOV	A,M		(A) = NEXT CHARACTER
	CPI	':'		SET CONDITION CODES
	RET			CALL USER PROCESS
	
*	USER PROCESS RETURNS HERE

$DRS7	POP	D		(DE) = LAST CHARACTER OF SWITCH+1
	LHLD	$DRSB		(HL) = FIRST CHARACTER OF SWITCH AFTER /
	DCX	H		(HL) = ADDRESS OF '/'
	
*	REPLACE SWITCH WITH BLANKS

$DRS8	MVI	M,' '
	INX	H
	CALL	$CDEHL
	JNE	$DRS8		NOT THERE YET
	POP	D		(DE) = SWTICH TABLE FWA
	JMP	$DRS1		LOOK FOR MORE SWITCHES
	SPACE	2,10
**	$DRS15 - CHECK FOR VALID DELIMITER CHARACTER.
*
*	$DRS15 CHECKS THE NEXT TEXT CHARACTER TO SEE IF IT IS
*
*	00, '/', ',', ':'
*
*	ENTRY	(A) = CHARACTER
*	EXIT	'Z' SET IFF CHARACTER IS ONE OF THE ABOVE
*	USES	F

$DRS15	ANA	A
	RZ			IS 00
	CPI	'/'
	RE
	CPI	','
	RE
	CPI	':'
	RET
	SPACE	2,10
**	$DRS20 - GET PROCESSOR ADDRESS.
*
*	$DRS20 IS CALLED TO GET THE PROCESSOR ADDRESS FIELD OUT OF
*	AN ENTRY IN THE SWITCH TABLE. THE CALLER SUPPLIES A POINTER
*	TO SOMEWHERE IN THE TEXT PART OF THE SWITCH DESCRIPTION:
*	$DRS20 ADVANCES THE POINTER TO THE PROCESSOR ADDRESS.
*
*	ENTRY	(DE) = POINTER TO TEXT PART OF SWITCH ENTRY
*	EXIT	(DE) = POINTER TO 1ST BYTE OF NEXT SWITCH TABLE ENTRY
*		(BC) = PROCESSOR ADDRESS FROM TABLE
*	USES	A,F,B,C,D,E


$DRS20	LDAX	D
	INX	D
	CPI	200Q
	JNE	$DRS20
	LDAX	D		(A) - LOW BYTE OF PROCESSOR ADDRESS
	MOV	C,A
	INX	D
	LDAX	D
	MOV	B,A		(BC) = PROCESSOR ADDRESS
	INX	D
	RET
	
$DRSB	DW	0		POINTER TO SWITCH BEING PROCESSED
	
